2,4c2,8
< Player 0: Bought Silver
< Player 0: 4
< Player 1: 1
---
> Player 0: 3
> Player 1: 2
> Player 2: 0
> Player 3: 0
> Player 1: Bought Silver
> Player 0: 3
> Player 1: 4
5a10,13
> Player 3: 0
> Player 0: 3
> Player 1: 4
> Player 2: 3
7,8c15,46
< Player 0: 4
< Player 1: 2
---
> Player 3: Bought Treasure Map
> Player 0: 5
> Player 1: 4
> Player 2: 3
> Player 3: 3
> Player 0: Bought Silver
> Player 0: 5
> Player 1: 5
> Player 2: 3
> Player 3: 3
> Player 1: Bought Gardens
> Player 0: 5
> Player 1: 4
> Player 2: 5
> Player 3: 3
> Player 2: Bought Silver
> Player 0: 5
> Player 1: 4
> Player 2: 5
> Player 3: 5
> Player 0: 1
> Player 1: 4
> Player 2: 5
> Player 3: 5
> Player 0: Bought Treasure Map
> Player 0: 3
> Player 1: 0
> Player 2: 5
> Player 3: 5
> Player 1: Bought Adventurer
> Player 0: 3
> Player 1: 3
9a48,52
> Player 3: 5
> Player 2: Bought Sea Hag
> Player 0: 3
> Player 1: 3
> Player 2: 3
11,12c54,88
< Player 2: Bought Silver
< Player 0: 4
---
> Player 3: Bought Silver
> Player 0: 5
> Player 1: 3
> Player 2: 3
> Player 3: 3
> Player 0: 6
> Player 1: 5
> Player 2: 3
> Player 3: 3
> Player 1: Bought Silver
> Player 0: 6
> Player 1: 5
> Player 2: 3
> Player 3: 3
> Player 0: 6
> Player 1: 5
> Player 2: 5
> Player 3: 5
> Player 3: Bought Silver
> Player 0: 1
> Player 1: 5
> Player 2: 5
> Player 3: 5
> Player 0: Bought Duchy
> Player 0: 6
> Player 1: 1
> Player 2: 5
> Player 3: 5
> Player 1: Bought Silver
> Player 0: 6
> Player 1: 2
> Player 2: 2
> Player 3: 5
> Player 2: Bought Feast
> Player 0: 6
14c90
< Player 2: 4
---
> Player 2: 3
16,17c92,93
< Player 3: Bought Steward
< Player 0: 2
---
> Player 3: Bought Silver
> Player 0: 8
19,20c95,114
< Player 2: 4
< Player 3: 4
---
> Player 2: 3
> Player 3: 3
> Player 0: 9
> Player 1: 3
> Player 2: 3
> Player 3: 3
> Player 0: 9
> Player 1: 4
> Player 2: 3
> Player 3: 3
> ***Played Sea Hag***
> Player 2: Bought Salvager
> Player 0: 8
> Player 1: 3
> Player 2: 3
> Player 3: 3
> Player 0: 3
> Player 1: 3
> Player 2: 3
> Player 3: 5
23,25c117,118
< Player 2: 4
< Player 3: 4
< Player 1: Bought Gardens
---
> Player 2: 3
> Player 3: 5
27,30c120,123
< Player 1: 3
< Player 2: 1
< Player 3: 4
< Player 2: Bought Duchy
---
> Player 1: 2
> Player 2: 2
> Player 3: 5
> ***Played Feast***
32c125
< Player 1: 3
---
> Player 1: 2
35,50c128,130
< ***Played Stewrd***
< Player 0: 1
< Player 1: 3
< Player 2: 6
< Player 3: 4
< Player 0: Bought Minion
< Player 0: 3
< Player 1: 1
< Player 2: 6
< Player 3: 4
< Player 0: 3
< Player 1: 1
< Player 2: 2
< Player 3: 4
< Player 0: 3
< Player 1: 1
---
> Player 3: Bought Minion
> Player 0: 7
> Player 1: 2
52,55c132,134
< Player 3: 2
< Player 3: Bought Silver
< Player 0: 2
< Player 1: 1
---
> Player 3: 3
> Player 0: 11
> Player 1: 2
57,59c136,140
< Player 3: 4
< Player 0: 3
< Player 1: 1
---
> Player 3: 3
> ***Played Adventurer***
> Player 1: Bought Gold
> Player 0: 11
> Player 1: 2
61,62c142,144
< Player 3: 4
< Player 0: 3
---
> Player 3: 3
> Player 2: Bought Silver
> Player 0: 11
64,65c146,148
< Player 2: 4
< Player 3: 4
---
> Player 2: 7
> Player 3: 3
> Player 3: Bought Duchy
67a151,164
> Player 2: 7
> Player 3: 7
> Player 0: Bought Silver
> Player 0: 7
> Player 1: 0
> Player 2: 7
> Player 3: 7
> Player 1: Bought Province
> Player 0: 7
> Player 1: 9
> Player 2: 2
> Player 3: 7
> Player 0: 7
> Player 1: 9
69,72c166,169
< Player 3: 1
< Player 3: Bought Duchy
< Player 0: 2
< Player 1: 2
---
> Player 3: 5
> Player 3: Bought Silver
> Player 0: 11
> Player 1: 9
76,77c173,174
< Player 0: 4
< Player 1: 1
---
> Player 0: 15
> Player 1: 10
80,83c177,180
< Player 1: Bought Silver
< Player 0: 4
< Player 1: 3
< Player 2: 5
---
> Player 1: Bought Treasure Map
> Player 0: 15
> Player 1: 10
> Player 2: 6
85,96c182,184
< Player 2: Bought Silver
< Player 0: 4
< Player 1: 3
< Player 2: 9
< Player 3: 2
< Player 0: 0
< Player 1: 3
< Player 2: 9
< Player 3: 5
< Player 0: Bought Duchy
< Player 0: 5
< Player 1: 1
---
> ***Played Feast***
> Player 0: 15
> Player 1: 10
98,107c186,187
< Player 3: 5
< Player 0: 5
< Player 1: 1
< Player 2: 3
< Player 3: 5
< Player 2: Bought Duchy
< Player 0: 5
< Player 1: 1
< Player 2: 11
< Player 3: 4
---
> Player 3: 6
> ***Played Minion***
109,130c189,191
< Player 0: 2
< Player 1: 1
< Player 2: 11
< Player 3: 7
< Player 0: 5
< Player 1: 0
< Player 2: 11
< Player 3: 7
< Player 1: Bought Duchy
< Player 0: 5
< Player 1: 5
< Player 2: 2
< Player 3: 7
< Player 2: Bought Duchy
< Player 0: 5
< Player 1: 5
< Player 2: 11
< Player 3: 2
< Player 3: Bought Duchy
< Player 0: 4
< Player 1: 5
< Player 2: 11
---
> Player 0: 1
> Player 1: 10
> Player 2: 9
132,133c193,194
< ***Played Minion***
< Player 0: Bought Silver
---
> ***Played Treasure Mp***
> Player 0: Bought Gardens
135,136c196,197
< Player 1: 4
< Player 2: 11
---
> Player 1: 12
> Player 2: 9
138d198
< Player 1: Bought Silver
140,141c200,201
< Player 1: 7
< Player 2: 6
---
> Player 1: 10
> Player 2: 10
143,145c203,211
< Player 0: 6
< Player 1: 7
< Player 2: 11
---
> ***Played Sea Hag***
> Player 2: Bought Silver
> Player 0: 7
> Player 1: 10
> Player 2: 6
> Player 3: 1
> Player 0: 11
> Player 1: 10
> Player 2: 6
147,148c213
< Player 3: Bought Duchy
< Player 0: 1
---
> Player 0: 12
150,152c215,226
< Player 2: 11
< Player 3: 11
< Player 0: Bought Gold
---
> Player 2: 6
> Player 3: 3
> Player 0: 12
> Player 1: 8
> Player 2: 6
> Player 3: 3
> Player 2: Bought Silver
> Player 0: 12
> Player 1: 8
> Player 2: 7
> Player 3: 6
> Player 3: Bought Gold
154,156c228,253
< Player 1: 0
< Player 2: 11
< Player 3: 11
---
> Player 1: 8
> Player 2: 7
> Player 3: 9
> Player 0: Bought Silver
> Player 0: 6
> Player 1: 9
> Player 2: 7
> Player 3: 9
> Player 1: Bought Gold
> Player 0: 6
> Player 1: 10
> Player 2: 8
> Player 3: 9
> ***Played Salvager***
> Player 0: 6
> Player 1: 10
> Player 2: 9
> Player 3: 5
> Player 0: 8
> Player 1: 10
> Player 2: 9
> Player 3: 6
> Player 0: 13
> Player 1: 11
> Player 2: 9
> Player 3: 6
158,161c255,276
< Player 0: 5
< Player 1: 7
< Player 2: 16
< Player 3: 11
---
> Player 0: 13
> Player 1: 22
> Player 2: 11
> Player 3: 6
> Player 0: 13
> Player 1: 22
> Player 2: 12
> Player 3: 6
> Player 3: Bought Province
> Player 0: 2
> Player 1: 22
> Player 2: 12
> Player 3: 15
> ***Played Treasure Mp***
> Player 0: 6
> Player 1: 1
> Player 2: 12
> Player 3: 15
> Player 0: 6
> Player 1: 5
> Player 2: 6
> Player 3: 15
162a278,306
> Player 0: 6
> Player 1: 5
> Player 2: 7
> Player 3: 2
> Player 0: 8
> Player 1: 5
> Player 2: 7
> Player 3: 12
> Player 0: Bought Steward
> Player 0: 11
> Player 1: 6
> Player 2: 7
> Player 3: 12
> ***Played Adventurer***
> Player 1: Bought Province
> Player 0: 11
> Player 1: 32
> Player 2: 9
> Player 3: 12
> Player 0: 11
> Player 1: 32
> Player 2: 10
> Player 3: 12
> Player 3: Bought Province
> Player 0: 3
> Player 1: 32
> Player 2: 10
> Player 3: 19
> Player 0: Bought Adventurer
164,170c308,311
< Player 1: 7
< Player 2: 16
< Player 3: 8
< Player 0: 4
< Player 1: 7
< Player 2: 16
< Player 3: 11
---
> Player 1: 36
> Player 2: 10
> Player 3: 19
> Player 1: Bought Gold
172,174c313,317
< Player 1: 7
< Player 2: 16
< Player 3: 11
---
> Player 1: 33
> Player 2: 11
> Player 3: 19
> ***Played Sea Hag***
> ***Played Feast***
176,178c319,337
< Player 1: 7
< Player 2: 6
< Player 3: 11
---
> Player 1: 34
> Player 2: 18
> Player 3: 6
> Player 3: Bought Province
> Player 0: 6
> Player 1: 34
> Player 2: 18
> Player 3: 13
> ***Played Stewrd***
> Player 0: Bought Silver
> Player 0: 6
> Player 1: 1
> Player 2: 18
> Player 3: 13
> Player 1: Bought Province
> Player 0: 6
> Player 1: 28
> Player 2: 3
> Player 3: 13
180,184d338
< Player 0: 5
< Player 1: 7
< Player 2: 14
< Player 3: 14
< Player 3: Bought Minion
186,188c340,347
< Player 1: 7
< Player 2: 14
< Player 3: 17
---
> Player 1: 28
> Player 2: 9
> Player 3: 15
> Player 0: 3
> Player 1: 28
> Player 2: 9
> Player 3: 22
> ***Played Adventurer***
191,194c350,353
< Player 1: 7
< Player 2: 14
< Player 3: 17
< Player 1: Bought Minion
---
> Player 1: 30
> Player 2: 9
> Player 3: 22
> Player 1: Bought Silver
196,198c355,358
< Player 1: 10
< Player 2: 19
< Player 3: 17
---
> Player 1: 33
> Player 2: 10
> Player 3: 22
> Player 2: Bought Duchy
200,208c360,368
< Player 1: 10
< Player 2: 25
< Player 3: 6
< ***Played Minion***
< Player 0: 2
< Player 1: 10
< Player 2: 25
< Player 3: 10
< Player 0: Bought Duchy
---
> Player 1: 33
> Player 2: 16
> Player 3: 0
> Player 3: Bought Province
> Player 0: 6
> Player 1: 33
> Player 2: 16
> Player 3: 20
> Player 0: Bought Gold
210,212c370,373
< Player 1: 4
< Player 2: 25
< Player 3: 10
---
> Player 1: 36
> Player 2: 16
> Player 3: 20
> Player 1: Bought Gold
214,216c375,378
< Player 1: 4
< Player 2: 4
< Player 3: 10
---
> Player 1: 38
> Player 2: 21
> Player 3: 20
> ***Played Feast***
218c380,402
< Player 1: 4
---
> Player 1: 38
> Player 2: 29
> Player 3: 26
> Player 3: Bought Duchy
> Player 0: 1
> Player 1: 38
> Player 2: 29
> Player 3: 29
> Player 0: Bought Province
> Player 0: 8
> Player 1: 47
> Player 2: 29
> Player 3: 29
> ***Played Adventurer***
> Player 1: Bought Gold
> Player 0: 10
> Player 1: 42
> Player 2: 0
> Player 3: 29
> ***Played Feast***
> Player 2: Bought Duchy
> Player 0: 10
> Player 1: 42
220c404,405
< Player 3: 12
---
> Player 3: 37
> Player 3: Bought Silver
222c407
< Player 1: 4
---
> Player 1: 42
224c409,410
< Player 3: 16
---
> Player 3: 31
> ***Played Adventurer***
227c413
< Player 1: 7
---
> Player 1: 45
229,235c415,416
< Player 3: 16
< Player 1: Bought Duchy
< Player 0: 12
< Player 1: 17
< Player 2: 18
< Player 3: 16
< Player 2: Bought Duchy
---
> Player 3: 31
> Player 1: Bought Province
237,238c418,425
< Player 1: 17
< Player 2: 22
---
> Player 1: 54
> Player 2: 20
> Player 3: 31
> ***Played Sea Hag***
> Player 2: Bought Silver
> Player 0: 11
> Player 1: 53
> Player 2: 30
240,261c427,430
< Player 0: 3
< Player 1: 17
< Player 2: 22
< Player 3: 11
< Player 0: Bought Province
< Player 0: 14
< Player 1: 7
< Player 2: 22
< Player 3: 11
< Player 0: 14
< Player 1: 10
< Player 2: 8
< Player 3: 11
< Player 0: 14
< Player 1: 10
< Player 2: 11
< Player 3: 14
< Player 3: Bought Adventurer
< Player 0: 16
< Player 1: 10
< Player 2: 11
< Player 3: 22
---
> Player 0: 0
> Player 1: 53
> Player 2: 30
> Player 3: 12
263,298c432,450
< Player 0: 19
< Player 1: 10
< Player 2: 11
< Player 3: 22
< Player 0: 19
< Player 1: 14
< Player 2: 14
< Player 3: 22
< Player 2: Bought Gold
< Player 0: 19
< Player 1: 14
< Player 2: 19
< Player 3: 6
< ***Played Adventurer***
< Player 0: 4
< Player 1: 14
< Player 2: 19
< Player 3: 15
< Player 0: Bought Adventurer
< Player 0: 7
< Player 1: 6
< Player 2: 19
< Player 3: 15
< Player 0: 7
< Player 1: 10
< Player 2: 4
< Player 3: 15
< Player 2: Bought Treasure Map
< Player 0: 7
< Player 1: 10
< Player 2: 13
< Player 3: 8
< Player 0: 14
< Player 1: 10
< Player 2: 13
< Player 3: 11
---
> Player 0: 10
> Player 1: 54
> Player 2: 30
> Player 3: 12
> ***Played Treasure Mp***
> Player 1: Bought Duchy
> Player 0: 10
> Player 1: 53
> Player 2: 37
> Player 3: 12
> Player 2: Bought Silver
> Player 0: 10
> Player 1: 53
> Player 2: 36
> Player 3: 24
> Player 0: 11
> Player 1: 53
> Player 2: 36
> Player 3: 24
300,317c452,469
< Player 0: 22
< Player 1: 13
< Player 2: 13
< Player 3: 11
< Player 1: Bought Silver
< Player 0: 22
< Player 1: 19
< Player 2: 14
< Player 3: 11
< Player 2: Bought Province
< Player 0: 22
< Player 1: 19
< Player 2: 21
< Player 3: 14
< Player 0: 3
< Player 1: 19
< Player 2: 21
< Player 3: 21
---
> Player 0: 12
> Player 1: 14
> Player 2: 36
> Player 3: 24
> Player 0: 12
> Player 1: 20
> Player 2: 41
> Player 3: 24
> Player 2: Bought Silver
> Player 0: 12
> Player 1: 20
> Player 2: 35
> Player 3: 24
> Player 3: Bought Gold
> Player 0: 13
> Player 1: 20
> Player 2: 35
> Player 3: 37
320,323c472,476
< Player 1: 4
< Player 2: 21
< Player 3: 21
< Player 1: Bought Silver
---
> Player 1: 20
> Player 2: 35
> Player 3: 37
> ***Played Treasure Mp***
> Player 1: Bought Duchy
325,327c478,481
< Player 1: 10
< Player 2: 12
< Player 3: 21
---
> Player 1: 36
> Player 2: 3
> Player 3: 37
> Player 2: Bought Silver
329c483
< Player 1: 10
---
> Player 1: 36
332,333c486,488
< Player 0: 20
< Player 1: 10
---
> Player 3: Bought Feast
> Player 0: 12
> Player 1: 36
335,339c490,492
< Player 3: 10
< ***Played Adventurer***
< Player 0: Bought Adventurer
< Player 0: 22
< Player 1: 13
---
> Player 3: 16
> Player 0: 13
> Player 1: 39
341,357c494,508
< Player 3: 10
< Player 1: Bought Duchy
< Player 0: 22
< Player 1: 16
< Player 2: 20
< Player 3: 10
< Player 2: Bought Duchy
< Player 0: 22
< Player 1: 16
< Player 2: 27
< Player 3: 14
< Player 3: Bought Duchy
< Player 0: 9
< Player 1: 16
< Player 2: 27
< Player 3: 19
< ***Played Adventurer***
---
> Player 3: 16
> Player 1: Bought Gold
> Player 0: 13
> Player 1: 54
> Player 2: 15
> Player 3: 16
> Player 0: 13
> Player 1: 54
> Player 2: 21
> Player 3: 18
> Player 3: Bought Treasure Map
> Player 0: 14
> Player 1: 54
> Player 2: 21
> Player 3: 24
359,364c510,520
< Player 0: 26
< Player 1: 3
< Player 2: 27
< Player 3: 19
< Player 0: 26
< Player 1: 7
---
> Player 0: 23
> Player 1: 79
> Player 2: 21
> Player 3: 24
> Player 0: 23
> Player 1: 79
> Player 2: 24
> Player 3: 24
> Player 2: Bought Gold
> Player 0: 23
> Player 1: 79
366,413c522
< Player 3: 19
< Player 2: Bought Adventurer
< Player 0: 26
< Player 1: 7
< Player 2: 27
< Player 3: 9
< Player 3: Bought Silver
< Player 0: 35
< Player 1: 7
< Player 2: 27
< Player 3: 11
< Player 0: 39
< Player 1: 11
< Player 2: 27
< Player 3: 11
< Player 1: Bought Duchy
< Player 0: 39
< Player 1: 14
< Player 2: 3
< Player 3: 11
< ***Played Adventurer***
< Player 2: Bought Province
< Player 0: 39
< Player 1: 14
< Player 2: 35
< Player 3: 13
< ***Played Adventurer***
< Player 3: Bought Minion
< Player 0: 7
< Player 1: 14
< Player 2: 35
< Player 3: 23
< Player 0: 17
< Player 1: 3
< Player 2: 35
< Player 3: 23
< ***Played Minion***
< Player 1: Bought Silver
< Player 0: 17
< Player 1: 10
< Player 2: 40
< Player 3: 23
< Player 2: Bought Silver
< Player 0: 17
< Player 1: 10
< Player 2: 42
< Player 3: 3
< ***Played Adventurer***
---
> Player 3: 30
415,495c524,527
< Player 0: 20
< Player 1: 10
< Player 2: 42
< Player 3: 20
< ***Played Adventurer***
< Player 0: Bought Province
< Player 0: 35
< Player 1: 13
< Player 2: 42
< Player 3: 20
< Player 1: Bought Gold
< Player 0: 35
< Player 1: 13
< Player 2: 10
< Player 3: 20
< ***Played Adventurer***
< Player 0: 35
< Player 1: 13
< Player 2: 26
< Player 3: 5
< Player 0: 50
< Player 1: 13
< Player 2: 26
< Player 3: 11
< ***Played Adventurer***
< Player 0: Bought Feast
< Player 0: 32
< Player 1: 4
< Player 2: 26
< Player 3: 11
< Player 1: Bought Feast
< Player 0: 32
< Player 1: 10
< Player 2: 32
< Player 3: 11
< Player 2: Bought Province
< Player 0: 32
< Player 1: 10
< Player 2: 48
< Player 3: 17
< ***Played Adventurer***
< Player 3: Bought Province
< Player 0: 35
< Player 1: 10
< Player 2: 48
< Player 3: 29
< ***Played Adventurer***
< Player 0: Bought Province
< Player 0: 49
< Player 1: 10
< Player 2: 48
< Player 3: 29
< Player 1: Bought Province
< Player 0: 49
< Player 1: 15
< Player 2: 4
< Player 3: 29
< Player 0: 49
< Player 1: 15
< Player 2: 16
< Player 3: 4
< ***Played Minion***
< Player 0: 7
< Player 1: 15
< Player 2: 16
< Player 3: 16
< Player 0: 19
< Player 1: 21
< Player 2: 16
< Player 3: 16
< Player 1: Bought Duchy
< Player 0: 19
< Player 1: 16
< Player 2: 22
< Player 3: 16
< ***Played Adventurer***
< Player 2: Bought Province
< Player 0: 19
< Player 1: 16
< Player 2: 54
< Player 3: 23
---
> Player 0: 26
> Player 1: 79
> Player 2: 28
> Player 3: 45
497,500c529,532
< Player 0: 19
< Player 1: 16
< Player 2: 54
< Player 3: 23
---
> Player 0: 26
> Player 1: 79
> Player 2: 28
> Player 3: 45
502c534
< Lines executed:47.60% of 584
---
> Lines executed:54.17% of 576
517,522c549,554
<      1297:    8:int compare(const void* a, const void* b) {
<      1297:    9:  if (*(int*)a > *(int*)b)
<       635:   10:    return 1;
<       662:   11:  if (*(int*)a < *(int*)b)
<       301:   12:    return -1;
<       361:   13:  return 0;
---
>      1632:    8:int compare(const void* a, const void* b) {
>      1632:    9:  if (*(int*)a > *(int*)b)
>       739:   10:    return 1;
>       893:   11:  if (*(int*)a < *(int*)b)
>       345:   12:    return -1;
>       548:   13:  return 0;
525,527c557,559
<     #####:   16:struct gameState* newGame() {
<     #####:   17:  struct gameState* g = malloc(sizeof(struct gameState));
<     #####:   18:  return g;
---
>     #####:   16:struct gameState* newGame(){
>     #####:   17:	struct gameState* g = malloc(sizeof(struct gameState));
>     #####:   18:	return g;
530,560c562,592
<     #####:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
<         -:   22:		  int k8, int k9, int k10) {
<     #####:   23:  int* k = malloc(10 * sizeof(int));
<     #####:   24:  k[0] = k1;
<     #####:   25:  k[1] = k2;
<     #####:   26:  k[2] = k3;
<     #####:   27:  k[3] = k4;
<     #####:   28:  k[4] = k5;
<     #####:   29:  k[5] = k6;
<     #####:   30:  k[6] = k7;
<     #####:   31:  k[7] = k8;
<     #####:   32:  k[8] = k9;
<     #####:   33:  k[9] = k10;
<     #####:   34:  return k;
<         -:   35:}
<         -:   36:
<         1:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
<         -:   38:		   struct gameState *state) {
<         -:   39:
<         -:   40:  int i;
<         -:   41:  int j;
<         -:   42:  int it;			
<         -:   43:  //set up random number generator
<         1:   44:  SelectStream(1);
<         1:   45:  PutSeed((long)randomSeed);
<         -:   46:  
<         -:   47:  //check number of players
<         1:   48:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
<         -:   49:    {
<     #####:   50:      return -1;
<         -:   51:    }
---
>     #####:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7, int k8, int k9, int k10) {
>     #####:   22:	int* k = malloc(10 * sizeof(int));
>     #####:   23:	k[0] = k1;
>     #####:   24:	k[1] = k2;
>     #####:   25:	k[2] = k3;
>     #####:   26:	k[3] = k4;
>     #####:   27:	k[4] = k5;
>     #####:   28:	k[5] = k6;
>     #####:   29:	k[6] = k7;
>     #####:   30:	k[7] = k8;
>     #####:   31:	k[8] = k9;
>     #####:   32:	k[9] = k10;
>     #####:   33:	return k;
>         -:   34:}
>         -:   35:
>         1:   36:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed, struct gameState *state){
>         -:   37:
>         -:   38:	int i;
>         -:   39:	int j;
>         -:   40:	int it;			
>         -:   41:	//set up random number generator
>         1:   42:	SelectStream(1);
>         1:   43:	PutSeed((long)randomSeed);
>         -:   44:  
>         -:   45:	//check number of players
>         1:   46:	if (numPlayers > MAX_PLAYERS || numPlayers < 2){
>     #####:   47:		return -1;
>         -:   48:    }
>         -:   49:
>         -:   50:	//set number of players
>         1:   51:	state->numPlayers = numPlayers;
562,658c594,690
<         -:   53:  //set number of players
<         1:   54:  state->numPlayers = numPlayers;
<         -:   55:
<         -:   56:  //check selected kingdom cards are different
<        11:   57:  for (i = 0; i < 10; i++)
<         -:   58:    {
<       110:   59:      for (j = 0; j < 10; j++)
<         -:   60:        {
<       100:   61:	  if (j != i && kingdomCards[j] == kingdomCards[i])
<         -:   62:	    {
<     #####:   63:	      return -1;
<         -:   64:	    }
<         -:   65:        }
<         -:   66:    }
<         -:   67:
<         -:   68:
<         -:   69:  //initialize supply
<         -:   70:  ///////////////////////////////
<         -:   71:
<         -:   72:  //set number of Curse cards
<         1:   73:  if (numPlayers == 2)
<         -:   74:    {
<     #####:   75:      state->supplyCount[curse] = 10;
<         -:   76:    }
<         1:   77:  else if (numPlayers == 3)
<         -:   78:    {
<     #####:   79:      state->supplyCount[curse] = 20;
<         -:   80:    }
<         -:   81:  else
<         -:   82:    {
<         1:   83:      state->supplyCount[curse] = 30;
<         -:   84:    }
<         -:   85:
<         -:   86:  //set number of Victory cards
<         1:   87:  if (numPlayers == 2)
<         -:   88:    {
<     #####:   89:      state->supplyCount[estate] = 8;
<     #####:   90:      state->supplyCount[duchy] = 8;
<     #####:   91:      state->supplyCount[province] = 8;
<         -:   92:    }
<         -:   93:  else
<         -:   94:    {
<         1:   95:      state->supplyCount[estate] = 12;
<         1:   96:      state->supplyCount[duchy] = 12;
<         1:   97:      state->supplyCount[province] = 12;
<         -:   98:    }
<         -:   99:
<         -:  100:  //set number of Treasure cards
<         1:  101:  state->supplyCount[copper] = 60 - (7 * numPlayers);
<         1:  102:  state->supplyCount[silver] = 40;
<         1:  103:  state->supplyCount[gold] = 30;
<         -:  104:
<         -:  105:  //set number of Kingdom cards
<        21:  106:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
<         -:  107:    {
<       165:  108:      for (j = 0; j < 10; j++)           		//loop chosen cards
<         -:  109:	{
<       155:  110:	  if (kingdomCards[j] == i)
<         -:  111:	    {
<         -:  112:	      //check if card is a 'Victory' Kingdom card
<        11:  113:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
<         -:  114:		{
<         1:  115:		  if (numPlayers == 2){ 
<     #####:  116:		    state->supplyCount[i] = 8; 
<         -:  117:		  }
<         1:  118:		  else{ state->supplyCount[i] = 12; }
<         -:  119:		}
<         -:  120:	      else
<         -:  121:		{
<         9:  122:		  state->supplyCount[i] = 10;
<         -:  123:		}
<        10:  124:	      break;
<         -:  125:	    }
<         -:  126:	  else    //card is not in the set choosen for the game
<         -:  127:	    {
<       145:  128:	      state->supplyCount[i] = -1;
<         -:  129:	    }
<         -:  130:	}
<         -:  131:
<         -:  132:    }
<         -:  133:
<         -:  134:  ////////////////////////
<         -:  135:  //supply intilization complete
<         -:  136:
<         -:  137:  //set player decks
<         5:  138:  for (i = 0; i < numPlayers; i++)
<         -:  139:    {
<         4:  140:      state->deckCount[i] = 0;
<        16:  141:      for (j = 0; j < 3; j++)
<         -:  142:	{
<        12:  143:	  state->deck[i][j] = estate;
<        12:  144:	  state->deckCount[i]++;
<         -:  145:	}
<        32:  146:      for (j = 3; j < 10; j++)
<         -:  147:	{
<        28:  148:	  state->deck[i][j] = copper;
<        28:  149:	  state->deckCount[i]++;		
---
>         -:   53:	//check selected kingdom cards are different
>        11:   54:	for (i = 0; i < 10; i++){
>       110:   55:		for (j = 0; j < 10; j++){
>       100:   56:			if (j != i && kingdomCards[j] == kingdomCards[i]){
>     #####:   57:				return -1;
>         -:   58:			}
>         -:   59:        }
>         -:   60:	}
>         -:   61:
>         -:   62:
>         -:   63:	//initialize supply
>         -:   64:	///////////////////////////////
>         -:   65:
>         -:   66:	//set number of Curse cards
>         1:   67:	if (numPlayers == 2){
>     #####:   68:		state->supplyCount[curse] = 10;
>         -:   69:    }
>         1:   70:	else if (numPlayers == 3){
>     #####:   71:		state->supplyCount[curse] = 20;
>         -:   72:    }
>         -:   73:	else{
>         1:   74:		state->supplyCount[curse] = 30;
>         -:   75:    }
>         -:   76:
>         -:   77:	//set number of Victory cards
>         1:   78:	if (numPlayers == 2){
>     #####:   79:		state->supplyCount[estate] = 8;
>     #####:   80:		state->supplyCount[duchy] = 8;
>     #####:   81:		state->supplyCount[province] = 8;
>         -:   82:    }
>         -:   83:	else{
>         1:   84:		state->supplyCount[estate] = 12;
>         1:   85:		state->supplyCount[duchy] = 12;
>         1:   86:		state->supplyCount[province] = 12;
>         -:   87:    }
>         -:   88:
>         -:   89:	//set number of Treasure cards
>         1:   90:	state->supplyCount[copper] = 60 - (7 * numPlayers);
>         1:   91:	state->supplyCount[silver] = 40;
>         1:   92:	state->supplyCount[gold] = 30;
>         -:   93:
>         -:   94:	//set number of Kingdom cards
>        21:   95:	for (i = adventurer; i <= treasure_map; i++){       	//loop all cards
>       165:   96:		for (j = 0; j < 10; j++){           		//loop chosen cards
>       155:   97:			if (kingdomCards[j] == i){				//check if card is a 'Victory' Kingdom card
>        11:   98:				if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens){
>         1:   99:					if (numPlayers == 2){ 
>     #####:  100:						state->supplyCount[i] = 8; 
>         -:  101:					}
>         -:  102:					else{ 
>         1:  103:						state->supplyCount[i] = 12; 
>         -:  104:					}
>         -:  105:				}
>         -:  106:				else{
>         9:  107:					state->supplyCount[i] = 10;
>         -:  108:				}
>        10:  109:				break;
>         -:  110:			}
>         -:  111:			else{    //card is not in the set choosen for the game
>       145:  112:				state->supplyCount[i] = -1;
>         -:  113:			}
>         -:  114:		}
>         -:  115:	}
>         -:  116:
>         -:  117:	////////////////////////
>         -:  118:	//supply intilization complete
>         -:  119:
>         -:  120:	//set player decks
>         5:  121:	for (i = 0; i < numPlayers; i++){
>         4:  122:		state->deckCount[i] = 0;
>        16:  123:		for (j = 0; j < 3; j++){
>        12:  124:			state->deck[i][j] = estate;
>        12:  125:			state->deckCount[i]++;
>         -:  126:		}
>        32:  127:		for (j = 3; j < 10; j++){
>        28:  128:			state->deck[i][j] = copper;
>        28:  129:			state->deckCount[i]++;		
>         -:  130:		}
>         -:  131:	}
>         -:  132:
>         -:  133:	//shuffle player decks
>         5:  134:	for (i = 0; i < numPlayers; i++){
>         4:  135:		if ( shuffle(i, state) < 0 ){
>     #####:  136:			return -1;
>         -:  137:		}
>         -:  138:	}
>         -:  139:
>         -:  140:	//draw player hands
>         5:  141:	for (i = 0; i < numPlayers; i++){  
>         -:  142:		//initialize hand size to zero
>         4:  143:		state->handCount[i] = 0;
>         4:  144:		state->discardCount[i] = 0;
>         -:  145:		//draw 5 cards
>         -:  146:		// for (j = 0; j < 5; j++)
>         -:  147:		//	{
>         -:  148:		//	  drawCard(i, state);
>         -:  149:		//	}
660,714c692,746
<         -:  151:    }
<         -:  152:
<         -:  153:  //shuffle player decks
<         5:  154:  for (i = 0; i < numPlayers; i++)
<         -:  155:    {
<         4:  156:      if ( shuffle(i, state) < 0 )
<         -:  157:	{
<     #####:  158:	  return -1;
<         -:  159:	}
<         -:  160:    }
<         -:  161:
<         -:  162:  //draw player hands
<         5:  163:  for (i = 0; i < numPlayers; i++)
<         -:  164:    {  
<         -:  165:      //initialize hand size to zero
<         4:  166:      state->handCount[i] = 0;
<         4:  167:      state->discardCount[i] = 0;
<         -:  168:      //draw 5 cards
<        24:  169:      for (j = 0; j < 5; j++)
<         -:  170:      	{
<        20:  171:      	  drawCard(i, state);
<         -:  172:      	}
<         -:  173:    }
<         -:  174:  
<         -:  175:  //set embargo tokens to 0 for all supply piles
<        28:  176:  for (i = 0; i <= treasure_map; i++)
<         -:  177:    {
<        27:  178:      state->embargoTokens[i] = 0;
<         -:  179:    }
<         -:  180:
<         -:  181:  //initialize first player's turn
<         1:  182:  state->outpostPlayed = 0;
<         1:  183:  state->phase = 0;
<         1:  184:  state->numActions = 1;
<         1:  185:  state->numBuys = 1;
<         1:  186:  state->playedCardCount = 0;
<         1:  187:  state->whoseTurn = 0;
<         1:  188:  state->handCount[state->whoseTurn] = 0;
<         -:  189:  //int it; move to top
<         -:  190:
<         -:  191:  //Moved draw cards to here, only drawing at the start of a turn
<         6:  192:  for (it = 0; it < 5; it++){
<         5:  193:    drawCard(state->whoseTurn, state);
<         -:  194:  }
<         -:  195:
<         1:  196:  updateCoins(state->whoseTurn, state, 0);
<         -:  197:
<         1:  198:  return 0;
<         -:  199:}
<         -:  200:
<        75:  201:int shuffle(int player, struct gameState *state) {
<         -:  202: 
<         -:  203:
<         -:  204:  int newDeck[MAX_DECK];
<        75:  205:  int newDeckPos = 0;
---
>         -:  151:  
>         -:  152:	//set embargo tokens to 0 for all supply piles
>        28:  153:	for (i = 0; i <= treasure_map; i++){
>        27:  154:		state->embargoTokens[i] = 0;
>         -:  155:    }
>         -:  156:
>         -:  157:	//initialize first player's turn
>         1:  158:	state->outpostPlayed = 0;
>         1:  159:	state->phase = 0;
>         1:  160:	state->numActions = 1;
>         1:  161:	state->numBuys = 1;
>         1:  162:	state->playedCardCount = 0;
>         1:  163:	state->whoseTurn = 0;
>         1:  164:	state->handCount[state->whoseTurn] = 0;
>         -:  165:	//int it; move to top
>         -:  166:
>         -:  167:	//Moved draw cards to here, only drawing at the start of a turn
>         6:  168:	for (it = 0; it < 5; it++){
>         5:  169:		drawCard(state->whoseTurn, state);
>         -:  170:	}
>         -:  171:
>         1:  172:	updateCoins(state->whoseTurn, state, 0);
>         -:  173:
>         1:  174:	return 0;
>         -:  175:}
>         -:  176:
>        46:  177:int shuffle(int player, struct gameState *state) {
>         -:  178: 
>         -:  179:	int newDeck[MAX_DECK];
>        46:  180:	int newDeckPos = 0;
>         -:  181:	int card;
>         -:  182:	int i;
>         -:  183:	
>        46:  184:	if (state->deckCount[player] < 1)
>     #####:  185:		return -1;
>        46:  186:	qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
>         -:  187:	/* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
>         -:  188:
>       720:  189:	while (state->deckCount[player] > 0) {
>       628:  190:		card = floor(Random() * state->deckCount[player]);
>       628:  191:		newDeck[newDeckPos] = state->deck[player][card];
>       628:  192:		newDeckPos++;
>      2884:  193:		for (i = card; i < state->deckCount[player]-1; i++) {
>      2256:  194:			state->deck[player][i] = state->deck[player][i+1];
>         -:  195:		}
>       628:  196:		state->deckCount[player]--;
>         -:  197:	}
>       674:  198:	for (i = 0; i < newDeckPos; i++) {
>       628:  199:		state->deck[player][i] = newDeck[i];
>       628:  200:		state->deckCount[player]++;
>         -:  201:	}
>        46:  202:return 0;
>         -:  203:}
>         -:  204:
>       369:  205:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) {	
716c748
<         -:  207:  int i;
---
>       369:  207:  int coin_bonus = 0; 		//tracks coins gain from actions
718,749c750,781
<        75:  209:  if (state->deckCount[player] < 1)
<         4:  210:    return -1;
<        71:  211:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
<         -:  212:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
<         -:  213:
<       756:  214:  while (state->deckCount[player] > 0) {
<       614:  215:    card = floor(Random() * state->deckCount[player]);
<       614:  216:    newDeck[newDeckPos] = state->deck[player][card];
<       614:  217:    newDeckPos++;
<      2083:  218:    for (i = card; i < state->deckCount[player]-1; i++) {
<      1469:  219:      state->deck[player][i] = state->deck[player][i+1];
<         -:  220:    }
<       614:  221:    state->deckCount[player]--;
<         -:  222:  }
<       685:  223:  for (i = 0; i < newDeckPos; i++) {
<       614:  224:    state->deck[player][i] = newDeck[i];
<       614:  225:    state->deckCount[player]++;
<         -:  226:  }
<         -:  227:
<        71:  228:  return 0;
<         -:  229:}
<         -:  230:
<       333:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
<         -:  232:{	
<         -:  233:  int card;
<       333:  234:  int coin_bonus = 0; 		//tracks coins gain from actions
<         -:  235:
<         -:  236:  //check if it is the right phase
<       333:  237:  if (state->phase != 0)
<         -:  238:    {
<     #####:  239:      return -1;
<         -:  240:    }
---
>         -:  209:  //check if it is the right phase
>       369:  210:  if (state->phase != 0)
>         -:  211:    {
>     #####:  212:      return -1;
>         -:  213:    }
>         -:  214:	
>         -:  215:  //check if player has enough actions
>       369:  216:  if ( state->numActions < 1 )
>         -:  217:    {
>        27:  218:      return -1;
>         -:  219:    }
>         -:  220:	
>         -:  221:  //get card played
>       342:  222:  card = handCard(handPos, state);
>         -:  223:	
>         -:  224:  //check if selected card is an action
>       342:  225:  if ( card < adventurer || card > treasure_map )
>         -:  226:    {
>       322:  227:      return -1;
>         -:  228:    }
>         -:  229:	
>         -:  230:  //play card
>        20:  231:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
>         -:  232:    {
>         4:  233:      return -1;
>         -:  234:    }
>         -:  235:	
>         -:  236:  //reduce number of actions
>        16:  237:  state->numActions--;
>         -:  238:
>         -:  239:  //update coins (Treasure cards may be added with card draws)
>        16:  240:  updateCoins(state->whoseTurn, state, coin_bonus);
751,784c783,816
<         -:  242:  //check if player has enough actions
<       333:  243:  if ( state->numActions < 1 )
<         -:  244:    {
<        36:  245:      return -1;
<         -:  246:    }
<         -:  247:	
<         -:  248:  //get card played
<       297:  249:  card = handCard(handPos, state);
<         -:  250:	
<         -:  251:  //check if selected card is an action
<       297:  252:  if ( card < adventurer || card > treasure_map )
<         -:  253:    {
<       280:  254:      return -1;
<         -:  255:    }
<         -:  256:	
<         -:  257:  //play card
<        17:  258:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
<         -:  259:    {
<     #####:  260:      return -1;
<         -:  261:    }
<         -:  262:	
<         -:  263:  //reduce number of actions
<        17:  264:  state->numActions--;
<         -:  265:
<         -:  266:  //update coins (Treasure cards may be added with card draws)
<        17:  267:  updateCoins(state->whoseTurn, state, coin_bonus);
<         -:  268:	
<        17:  269:  return 0;
<         -:  270:}
<         -:  271:
<        65:  272:int buyCard(int supplyPos, struct gameState *state) {
<         -:  273:  int who;
<        65:  274:  if (DEBUG){
<         -:  275:    printf("Entering buyCard...\n");
---
>        16:  242:  return 0;
>         -:  243:}
>         -:  244:
>        73:  245:int buyCard(int supplyPos, struct gameState *state) {
>         -:  246:  int who;
>        73:  247:  if (DEBUG){
>         -:  248:    printf("Entering buyCard...\n");
>         -:  249:  }
>         -:  250:
>         -:  251:  // I don't know what to do about the phase thing.
>         -:  252:
>        73:  253:  who = state->whoseTurn;
>         -:  254:
>        73:  255:  if (state->numBuys < 1){
>     #####:  256:    if (DEBUG)
>         -:  257:      printf("You do not have any buys left\n");
>     #####:  258:    return -1;
>        73:  259:  } else if (supplyCount(supplyPos, state) <1){
>         2:  260:    if (DEBUG)
>         -:  261:      printf("There are not any of that type of card left\n");
>         2:  262:    return -1;
>        71:  263:  } else if (state->coins < getCost(supplyPos)){
>     #####:  264:    if (DEBUG) 
>         -:  265:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
>     #####:  266:    return -1;
>         -:  267:  } else {
>        71:  268:    state->phase=1;
>         -:  269:    //state->supplyCount[supplyPos]--;
>        71:  270:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
>         -:  271:  
>        71:  272:    state->coins = (state->coins) - (getCost(supplyPos));
>        71:  273:    state->numBuys--;
>        71:  274:    if (DEBUG)
>         -:  275:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
787,818c819,850
<         -:  278:  // I don't know what to do about the phase thing.
<         -:  279:
<        65:  280:  who = state->whoseTurn;
<         -:  281:
<        65:  282:  if (state->numBuys < 1){
<     #####:  283:    if (DEBUG)
<         -:  284:      printf("You do not have any buys left\n");
<     #####:  285:    return -1;
<        65:  286:  } else if (supplyCount(supplyPos, state) <1){
<         7:  287:    if (DEBUG)
<         -:  288:      printf("There are not any of that type of card left\n");
<         7:  289:    return -1;
<        58:  290:  } else if (state->coins < getCost(supplyPos)){
<     #####:  291:    if (DEBUG) 
<         -:  292:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
<     #####:  293:    return -1;
<         -:  294:  } else {
<        58:  295:    state->phase=1;
<         -:  296:    //state->supplyCount[supplyPos]--;
<        58:  297:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
<         -:  298:  
<        58:  299:    state->coins = (state->coins) - (getCost(supplyPos));
<        58:  300:    state->numBuys--;
<        58:  301:    if (DEBUG)
<         -:  302:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
<         -:  303:  }
<         -:  304:
<         -:  305:  //state->discard[who][state->discardCount[who]] = supplyPos;
<         -:  306:  //state->discardCount[who]++;
<         -:  307:    
<        58:  308:  return 0;
<         -:  309:}
---
>         -:  278:  //state->discard[who][state->discardCount[who]] = supplyPos;
>         -:  279:  //state->discardCount[who]++;
>         -:  280:    
>        71:  281:  return 0;
>         -:  282:}
>         -:  283:
>      1308:  284:int numHandCards(struct gameState *state) {
>      1308:  285:  return state->handCount[ whoseTurn(state) ];
>         -:  286:}
>         -:  287:
>      7657:  288:int handCard(int handPos, struct gameState *state) {
>      7657:  289:  int currentPlayer = whoseTurn(state);
>      7657:  290:  return state->hand[currentPlayer][handPos];
>         -:  291:}
>         -:  292:
>       152:  293:int supplyCount(int card, struct gameState *state) {
>       152:  294:  return state->supplyCount[card];
>         -:  295:}
>         -:  296:
>       136:  297:int fullDeckCount(int player, int card, struct gameState *state) {
>         -:  298:  int i;
>       136:  299:  int count = 0;
>         -:  300:
>       741:  301:  for (i = 0; i < state->deckCount[player]; i++)
>         -:  302:    {
>       605:  303:      if (state->deck[player][i] == card) count++;
>         -:  304:    }
>         -:  305:
>       266:  306:  for (i = 0; i < state->handCount[player]; i++)
>         -:  307:    {
>       130:  308:      if (state->hand[player][i] == card) count++;
>         -:  309:    }
820,833c852,865
<      1257:  311:int numHandCards(struct gameState *state) {
<      1257:  312:  return state->handCount[ whoseTurn(state) ];
<         -:  313:}
<         -:  314:
<      7284:  315:int handCard(int handPos, struct gameState *state) {
<      7284:  316:  int currentPlayer = whoseTurn(state);
<      7284:  317:  return state->hand[currentPlayer][handPos];
<         -:  318:}
<         -:  319:
<       123:  320:int supplyCount(int card, struct gameState *state) {
<       123:  321:  return state->supplyCount[card];
<         -:  322:}
<         -:  323:
<       120:  324:int fullDeckCount(int player, int card, struct gameState *state) {
---
>      1635:  311:  for (i = 0; i < state->discardCount[player]; i++)
>         -:  312:    {
>      1499:  313:      if (state->discard[player][i] == card) count++;
>         -:  314:    }
>         -:  315:
>       136:  316:  return count;
>         -:  317:}
>         -:  318:
>      9166:  319:int whoseTurn(struct gameState *state) {
>      9166:  320:  return state->whoseTurn;
>         -:  321:}
>         -:  322:
>       108:  323:int endTurn(struct gameState *state) {
>         -:  324:  int k;
835,850c867,882
<       120:  326:  int count = 0;
<         -:  327:
<       501:  328:  for (i = 0; i < state->deckCount[player]; i++)
<         -:  329:    {
<       381:  330:      if (state->deck[player][i] == card) count++;
<         -:  331:    }
<         -:  332:
<       225:  333:  for (i = 0; i < state->handCount[player]; i++)
<         -:  334:    {
<       105:  335:      if (state->hand[player][i] == card) count++;
<         -:  336:    }
<         -:  337:
<      1006:  338:  for (i = 0; i < state->discardCount[player]; i++)
<         -:  339:    {
<       886:  340:      if (state->discard[player][i] == card) count++;
<         -:  341:    }
---
>       108:  326:  int currentPlayer = whoseTurn(state);
>         -:  327:  
>         -:  328:  //Discard hand
>       660:  329:  for (i = 0; i < state->handCount[currentPlayer]; i++){
>       552:  330:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
>       552:  331:    state->hand[currentPlayer][i] = -1;//Set card to -1
>         -:  332:  }
>       108:  333:  state->handCount[currentPlayer] = 0;//Reset hand count
>         -:  334:    
>         -:  335:  //Code for determining the player
>       108:  336:  if (currentPlayer < (state->numPlayers - 1)){ 
>        81:  337:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
>         -:  338:  }
>         -:  339:  else{
>        27:  340:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
>         -:  341:  }
852,911c884,943
<       120:  343:  return count;
<         -:  344:}
<         -:  345:
<      8726:  346:int whoseTurn(struct gameState *state) {
<      8726:  347:  return state->whoseTurn;
<         -:  348:}
<         -:  349:
<       103:  350:int endTurn(struct gameState *state) {
<         -:  351:  int k;
<         -:  352:  int i;
<       103:  353:  int currentPlayer = whoseTurn(state);
<         -:  354:  
<         -:  355:  //Discard hand
<       638:  356:  for (i = 0; i < state->handCount[currentPlayer]; i++){
<       535:  357:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
<       535:  358:    state->hand[currentPlayer][i] = -1;//Set card to -1
<         -:  359:  }
<       103:  360:  state->handCount[currentPlayer] = 0;//Reset hand count
<         -:  361:    
<         -:  362:  //Code for determining the player
<       103:  363:  if (currentPlayer < (state->numPlayers - 1)){ 
<        78:  364:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
<         -:  365:  }
<         -:  366:  else{
<        25:  367:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
<         -:  368:  }
<         -:  369:
<       103:  370:  state->outpostPlayed = 0;
<       103:  371:  state->phase = 0;
<       103:  372:  state->numActions = 1;
<       103:  373:  state->coins = 0;
<       103:  374:  state->numBuys = 1;
<       103:  375:  state->playedCardCount = 0;
<       103:  376:  state->handCount[state->whoseTurn] = 0;
<         -:  377:
<         -:  378:  //int k; move to top
<         -:  379:  //Next player draws hand
<       618:  380:  for (k = 0; k < 5; k++){
<       515:  381:    drawCard(state->whoseTurn, state);//Draw a card
<         -:  382:  }
<         -:  383:
<         -:  384:  //Update money
<       103:  385:  updateCoins(state->whoseTurn, state , 0);
<         -:  386:
<       103:  387:  return 0;
<         -:  388:}
<         -:  389:
<       104:  390:int isGameOver(struct gameState *state) {
<         -:  391:  int i;
<         -:  392:  int j;
<         -:  393:	
<         -:  394:  //if stack of Province cards is empty, the game ends
<       104:  395:  if (state->supplyCount[province] == 0)
<         -:  396:    {
<         1:  397:      return 1;
<         -:  398:    }
<         -:  399:
<         -:  400:  //if three supply pile are at 0, the game ends
<       103:  401:  j = 0;
<      2678:  402:  for (i = 0; i < 25; i++)
---
>       108:  343:  state->outpostPlayed = 0;
>       108:  344:  state->phase = 0;
>       108:  345:  state->numActions = 1;
>       108:  346:  state->coins = 0;
>       108:  347:  state->numBuys = 1;
>       108:  348:  state->playedCardCount = 0;
>       108:  349:  state->handCount[state->whoseTurn] = 0;
>         -:  350:
>         -:  351:  //int k; move to top
>         -:  352:  //Next player draws hand
>       648:  353:  for (k = 0; k < 5; k++){
>       540:  354:    drawCard(state->whoseTurn, state);//Draw a card
>         -:  355:  }
>         -:  356:
>         -:  357:  //Update money
>       108:  358:  updateCoins(state->whoseTurn, state , 0);
>         -:  359:
>       108:  360:  return 0;
>         -:  361:}
>         -:  362:
>       109:  363:int isGameOver(struct gameState *state) {
>         -:  364:	int i;
>         -:  365:	int j;
>         -:  366:	
>         -:  367:	//if stack of Province cards is empty, the game ends
>       109:  368:	if (state->supplyCount[province] == 0){
>         1:  369:		return 1;
>         -:  370:    }
>         -:  371:
>         -:  372:	//if three supply pile are at 0, the game ends
>       108:  373:	j = 0;
>      2808:  374:	for (i = 0; i < 25; i++){
>      2700:  375:		if (state->supplyCount[i] == 0){
>        19:  376:			j++;
>         -:  377:		}
>         -:  378:    }
>       108:  379:	if ( j >= 3){
>     #####:  380:		return 1;
>         -:  381:    }
>         -:  382:
>       108:  383:	return 0;
>         -:  384:}
>         -:  385:
>       436:  386:int scoreFor (int player, struct gameState *state) {
>         -:  387:
>         -:  388:  int i;
>       436:  389:  int score = 0;
>         -:  390:  //score from hand
>       981:  391:  for (i = 0; i < state->handCount[player]; i++)
>         -:  392:    {
>       545:  393:      if (state->hand[player][i] == curse) { score = score - 1; };
>       545:  394:      if (state->hand[player][i] == estate) { score = score + 1; };
>       545:  395:      if (state->hand[player][i] == duchy) { score = score + 3; };
>       545:  396:      if (state->hand[player][i] == province) { score = score + 6; };
>       545:  397:      if (state->hand[player][i] == great_hall) { score = score + 1; };
>       545:  398:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
>         -:  399:    }
>         -:  400:
>         -:  401:  //score from discard
>      4371:  402:  for (i = 0; i < state->discardCount[player]; i++)
913,939c945,971
<      2575:  404:      if (state->supplyCount[i] == 0)
<         -:  405:	{
<        53:  406:	  j++;
<         -:  407:	}
<         -:  408:    }
<       103:  409:  if ( j >= 3)
<         -:  410:    {
<     #####:  411:      return 1;
<         -:  412:    }
<         -:  413:
<       103:  414:  return 0;
<         -:  415:}
<         -:  416:
<       416:  417:int scoreFor (int player, struct gameState *state) {
<         -:  418:
<         -:  419:  int i;
<       416:  420:  int score = 0;
<         -:  421:  //score from hand
<       951:  422:  for (i = 0; i < state->handCount[player]; i++)
<         -:  423:    {
<       535:  424:      if (state->hand[player][i] == curse) { score = score - 1; };
<       535:  425:      if (state->hand[player][i] == estate) { score = score + 1; };
<       535:  426:      if (state->hand[player][i] == duchy) { score = score + 3; };
<       535:  427:      if (state->hand[player][i] == province) { score = score + 6; };
<       535:  428:      if (state->hand[player][i] == great_hall) { score = score + 1; };
<       535:  429:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
<         -:  430:    }
---
>      3935:  404:      if (state->discard[player][i] == curse) { score = score - 1; };
>      3935:  405:      if (state->discard[player][i] == estate) { score = score + 1; };
>      3935:  406:      if (state->discard[player][i] == duchy) { score = score + 3; };
>      3935:  407:      if (state->discard[player][i] == province) { score = score + 6; };
>      3935:  408:      if (state->discard[player][i] == great_hall) { score = score + 1; };
>      3935:  409:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
>         -:  410:    }
>         -:  411:
>         -:  412:  //score from deck
>      4371:  413:  for (i = 0; i < state->discardCount[player]; i++)
>         -:  414:    {
>      3935:  415:      if (state->deck[player][i] == curse) { score = score - 1; };
>      3935:  416:      if (state->deck[player][i] == estate) { score = score + 1; };
>      3935:  417:      if (state->deck[player][i] == duchy) { score = score + 3; };
>      3935:  418:      if (state->deck[player][i] == province) { score = score + 6; };
>      3935:  419:      if (state->deck[player][i] == great_hall) { score = score + 1; };
>      3935:  420:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
>         -:  421:    }
>         -:  422:
>       436:  423:  return score;
>         -:  424:}
>         -:  425:
>     #####:  426:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
>         -:  427:  int i;	
>         -:  428:  int j;
>         -:  429:  int highScore;
>         -:  430:  int currentPlayer;
941,942c973,974
<         -:  432:  //score from discard
<      3081:  433:  for (i = 0; i < state->discardCount[player]; i++)
---
>         -:  432:  //get score for each player
>     #####:  433:  for (i = 0; i < MAX_PLAYERS; i++)
944,964c976,996
<      2665:  435:      if (state->discard[player][i] == curse) { score = score - 1; };
<      2665:  436:      if (state->discard[player][i] == estate) { score = score + 1; };
<      2665:  437:      if (state->discard[player][i] == duchy) { score = score + 3; };
<      2665:  438:      if (state->discard[player][i] == province) { score = score + 6; };
<      2665:  439:      if (state->discard[player][i] == great_hall) { score = score + 1; };
<      2665:  440:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
<         -:  441:    }
<         -:  442:
<         -:  443:  //score from deck
<      3081:  444:  for (i = 0; i < state->discardCount[player]; i++)
<         -:  445:    {
<      2665:  446:      if (state->deck[player][i] == curse) { score = score - 1; };
<      2665:  447:      if (state->deck[player][i] == estate) { score = score + 1; };
<      2665:  448:      if (state->deck[player][i] == duchy) { score = score + 3; };
<      2665:  449:      if (state->deck[player][i] == province) { score = score + 6; };
<      2665:  450:      if (state->deck[player][i] == great_hall) { score = score + 1; };
<      2665:  451:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
<         -:  452:    }
<         -:  453:
<       416:  454:  return score;
<         -:  455:}
---
>         -:  435:      //set unused player scores to -9999
>     #####:  436:      if (i >= state->numPlayers)
>         -:  437:	{
>     #####:  438:	  players[i] = -9999;
>         -:  439:	}
>         -:  440:      else
>         -:  441:	{
>     #####:  442:	  players[i] = scoreFor (i, state);
>         -:  443:	}
>         -:  444:    }
>         -:  445:
>         -:  446:  //find highest score
>     #####:  447:  j = 0;
>     #####:  448:  for (i = 0; i < MAX_PLAYERS; i++)
>         -:  449:    {
>     #####:  450:      if (players[i] > players[j])
>         -:  451:	{
>     #####:  452:	  j = i;
>         -:  453:	}
>         -:  454:    }
>     #####:  455:  highScore = players[j];
966,980c998,1012
<     #####:  457:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
<         -:  458:  int i;	
<         -:  459:  int j;
<         -:  460:  int highScore;
<         -:  461:  int currentPlayer;
<         -:  462:
<         -:  463:  //get score for each player
<     #####:  464:  for (i = 0; i < MAX_PLAYERS; i++)
<         -:  465:    {
<         -:  466:      //set unused player scores to -9999
<     #####:  467:      if (i >= state->numPlayers)
<         -:  468:	{
<     #####:  469:	  players[i] = -9999;
<         -:  470:	}
<         -:  471:      else
---
>         -:  457:  //add 1 to players who had less turns
>     #####:  458:  currentPlayer = whoseTurn(state);
>     #####:  459:  for (i = 0; i < MAX_PLAYERS; i++)
>         -:  460:    {
>     #####:  461:      if ( players[i] == highScore && i > currentPlayer )
>         -:  462:	{
>     #####:  463:	  players[i]++;
>         -:  464:	}
>         -:  465:    }
>         -:  466:
>         -:  467:  //find new highest score
>     #####:  468:  j = 0;
>     #####:  469:  for (i = 0; i < MAX_PLAYERS; i++)
>         -:  470:    {
>     #####:  471:      if ( players[i] > players[j] )
982c1014
<     #####:  473:	  players[i] = scoreFor (i, state);
---
>     #####:  473:	  j = i;
985,987c1017,1019
<         -:  476:
<         -:  477:  //find highest score
<     #####:  478:  j = 0;
---
>     #####:  476:  highScore = players[j];
>         -:  477:
>         -:  478:  //set winners in array to 1 and rest to 0
990c1022
<     #####:  481:      if (players[i] > players[j])
---
>     #####:  481:      if ( players[i] == highScore )
992c1024
<     #####:  483:	  j = i;
---
>     #####:  483:	  players[i] = 1;
994,1250c1026,1282
<         -:  485:    }
<     #####:  486:  highScore = players[j];
<         -:  487:
<         -:  488:  //add 1 to players who had less turns
<     #####:  489:  currentPlayer = whoseTurn(state);
<     #####:  490:  for (i = 0; i < MAX_PLAYERS; i++)
<         -:  491:    {
<     #####:  492:      if ( players[i] == highScore && i > currentPlayer )
<         -:  493:	{
<     #####:  494:	  players[i]++;
<         -:  495:	}
<         -:  496:    }
<         -:  497:
<         -:  498:  //find new highest score
<     #####:  499:  j = 0;
<     #####:  500:  for (i = 0; i < MAX_PLAYERS; i++)
<         -:  501:    {
<     #####:  502:      if ( players[i] > players[j] )
<         -:  503:	{
<     #####:  504:	  j = i;
<         -:  505:	}
<         -:  506:    }
<     #####:  507:  highScore = players[j];
<         -:  508:
<         -:  509:  //set winners in array to 1 and rest to 0
<     #####:  510:  for (i = 0; i < MAX_PLAYERS; i++)
<         -:  511:    {
<     #####:  512:      if ( players[i] == highScore )
<         -:  513:	{
<     #####:  514:	  players[i] = 1;
<         -:  515:	}
<         -:  516:      else
<         -:  517:	{
<     #####:  518:	  players[i] = 0;
<         -:  519:	}
<         -:  520:    }
<         -:  521:
<     #####:  522:  return 0;
<         -:  523:}
<         -:  524:
<       589:  525:int drawCard(int player, struct gameState *state)
<         -:  526:{	int count;
<         -:  527:  int deckCounter;
<       589:  528:  if (state->deckCount[player] <= 0){//Deck is empty
<         -:  529:    
<         -:  530:    //Step 1 Shuffle the discard pile back into a deck
<         -:  531:    int i;
<         -:  532:    //Move discard to deck
<       642:  533:    for (i = 0; i < state->discardCount[player];i++){
<       574:  534:      state->deck[player][i] = state->discard[player][i];
<       574:  535:      state->discard[player][i] = -1;
<         -:  536:    }
<         -:  537:
<        68:  538:    state->deckCount[player] = state->discardCount[player];
<        68:  539:    state->discardCount[player] = 0;//Reset discard
<         -:  540:
<         -:  541:    //Shufffle the deck
<        68:  542:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
<         -:  543:   
<        68:  544:    if (DEBUG){//Debug statements
<         -:  545:      printf("Deck count now: %d\n", state->deckCount[player]);
<         -:  546:    }
<         -:  547:    
<        68:  548:    state->discardCount[player] = 0;
<         -:  549:
<         -:  550:    //Step 2 Draw Card
<        68:  551:    count = state->handCount[player];//Get current player's hand count
<         -:  552:    
<        68:  553:    if (DEBUG){//Debug statements
<         -:  554:      printf("Current hand count: %d\n", count);
<         -:  555:    }
<         -:  556:    
<        68:  557:    deckCounter = state->deckCount[player];//Create a holder for the deck count
<         -:  558:
<        68:  559:    if (deckCounter == 0)
<         1:  560:      return -1;
<         -:  561:
<        67:  562:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
<        67:  563:    state->deckCount[player]--;
<        67:  564:    state->handCount[player]++;//Increment hand count
<         -:  565:  }
<         -:  566:
<         -:  567:  else{
<       521:  568:    int count = state->handCount[player];//Get current hand count for player
<         -:  569:    int deckCounter;
<       521:  570:    if (DEBUG){//Debug statements
<         -:  571:      printf("Current hand count: %d\n", count);
<         -:  572:    }
<         -:  573:
<       521:  574:    deckCounter = state->deckCount[player];//Create holder for the deck count
<       521:  575:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
<       521:  576:    state->deckCount[player]--;
<       521:  577:    state->handCount[player]++;//Increment hand count
<         -:  578:  }
<         -:  579:
<       588:  580:  return 0;
<         -:  581:}
<         -:  582:
<       116:  583:int getCost(int cardNumber)
<         -:  584:{
<       116:  585:  switch( cardNumber ) 
<         -:  586:    {
<         -:  587:    case curse:
<     #####:  588:      return 0;
<         -:  589:    case estate:
<     #####:  590:      return 2;
<         -:  591:    case duchy:
<        24:  592:      return 5;
<         -:  593:    case province:
<        24:  594:      return 8;
<         -:  595:    case copper:
<     #####:  596:      return 0;
<         -:  597:    case silver:
<        30:  598:      return 3;
<         -:  599:    case gold:
<        10:  600:      return 6;
<         -:  601:    case adventurer:
<        10:  602:      return 6;
<         -:  603:    case council_room:
<     #####:  604:      return 5;
<         -:  605:    case feast:
<         4:  606:      return 4;
<         -:  607:    case gardens:
<         2:  608:      return 4;
<         -:  609:    case mine:
<     #####:  610:      return 5;
<         -:  611:    case remodel:
<     #####:  612:      return 4;
<         -:  613:    case smithy:
<     #####:  614:      return 4;
<         -:  615:    case village:
<     #####:  616:      return 3;
<         -:  617:    case baron:
<     #####:  618:      return 4;
<         -:  619:    case great_hall:
<     #####:  620:      return 3;
<         -:  621:    case minion:
<         8:  622:      return 5;
<         -:  623:    case steward:
<         2:  624:      return 3;
<         -:  625:    case tribute:
<     #####:  626:      return 5;
<         -:  627:    case ambassador:
<     #####:  628:      return 3;
<         -:  629:    case cutpurse:
<     #####:  630:      return 4;
<         -:  631:    case embargo: 
<     #####:  632:      return 2;
<         -:  633:    case outpost:
<     #####:  634:      return 5;
<         -:  635:    case salvager:
<     #####:  636:      return 4;
<         -:  637:    case sea_hag:
<     #####:  638:      return 4;
<         -:  639:    case treasure_map:
<         2:  640:      return 4;
<         -:  641:    }
<         -:  642:	
<     #####:  643:  return -1;
<         -:  644:}
<        12:  645:int adventurerCard(struct gameState *state, int currentPlayer,int cardDrawn,int drawntreasure,int temphand[MAX_HAND],int z){
<        71:  646:  while (drawntreasure < 2){
<        47:  647:    if (state->deckCount[currentPlayer] < 1){//if the deck is empty we need to shuffle discard and add to deck
<         3:  648:      shuffle(currentPlayer,state);
<         -:  649:    }
<        47:  650:    drawCard(currentPlayer, state);
<        47:  651:    cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer] - 1];//top card of hand is most recently drawn card.
<        71:  652:    if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
<        24:  653:      drawntreasure++;
<         -:  654:    else{
<        23:  655:      temphand[z] = cardDrawn;
<        23:  656:      state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
<        23:  657:      z++;
<         -:  658:    }
<         -:  659:  }
<        47:  660:  while (z - 1 >= 0){
<        23:  661:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; // discard all cards in play that have been drawn
<        23:  662:    z = z - 1;
<         -:  663:	}
<        12:  664:  return 0;
<         -:  665:}
<     #####:  666:int council_roomCard(struct gameState *state, int currentPlayer, int handPos)
<         -:  667:{
<         -:  668:  int i;
<         -:  669:  //+4 Cards
<     #####:  670:  for (i = 0; i < 4; i++){
<     #####:  671:    drawCard(currentPlayer, state);
<         -:  672:  }		
<         -:  673:  //+1 Buy
<     #####:  674:  state->numBuys++;  
<         -:  675:  //Each other player draws a card
<     #####:  676:  for ( i = 0; i < state->numPlayers; i++){
<     #####:  677:    if ( i != currentPlayer ){
<     #####:  678:      drawCard(i, state);
<         -:  679:    }
<         -:  680:  }
<         -:  681:  
<         -:  682:  //put played card in played card pile
<     #####:  683:  discardCard(handPos, currentPlayer, state, 0);
<         -:  684:  
<     #####:  685:  return 0;
<         -:  686:}
<     #####:  687:int feastCard(struct gameState *state, int currentPlayer, int choice1, 
<         -:  688:	      int temphand[MAX_HAND])
<         -:  689:{
<         -:  690:  int i, x;
<         -:  691:  //gain card with cost up to 5
<         -:  692:  //Backup hand
<     #####:  693:  for (i = 0; i <= state->handCount[currentPlayer]; i++){
<     #####:  694:    temphand[i] = state->hand[currentPlayer][i];//Backup card
<     #####:  695:    state->hand[currentPlayer][i] = -1;//Set to nothing
<         -:  696:  }
<         -:  697:  //Backup hand
<         -:  698:    
<         -:  699:  //Update Coins for Buy
<     #####:  700:  updateCoins(currentPlayer, state, 5);
<     #####:  701:  x = 1;//Condition to loop on
<     #####:  702:  while( x == 1) {//Buy one card
<     #####:  703:    if (supplyCount(choice1, state) <= 0){
<     #####:  704:      if (DEBUG)
<         -:  705:	printf("None of that card left, sorry!\n");
<         -:  706:      
<     #####:  707:      if (DEBUG){
<         -:  708:	printf("Cards Left: %d\n", supplyCount(choice1, state));
<         -:  709:      }
<         -:  710:      }
<     #####:  711:      else if (state->coins < getCost(choice1)){
<     #####:  712:	printf("That card is too expensive!\n");
<         -:  713:	
<     #####:  714:	if (DEBUG){
<         -:  715:	  printf("Coins: %d < %d\n", state->coins, getCost(choice1));
<         -:  716:	}
<         -:  717:      }
<         -:  718:      else{
<         -:  719:	
<     #####:  720:	if (DEBUG){
<         -:  721:	  printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
<         -:  722:	}
<         -:  723:	
<     #####:  724:	gainCard(choice1, state, 0, currentPlayer);//Gain the card
<     #####:  725:	x = 0;//No more buying cards
<         -:  726:	
<     #####:  727:	if (DEBUG){
<         -:  728:	  printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
<         -:  729:	}
<         -:  730:	
<         -:  731:      }
<         -:  732:    }     
<         -:  733:    
<         -:  734:    //Reset Hand
<     #####:  735:    for (i = 0; i <= state->handCount[currentPlayer]; i++){
<     #####:  736:      state->hand[currentPlayer][i] = temphand[i];
<     #####:  737:      temphand[i] = -1;
<         -:  738:    }
<         -:  739:    //Reset Hand
<         -:  740:    
<     #####:  741:    return 0;
---
>         -:  485:      else
>         -:  486:	{
>     #####:  487:	  players[i] = 0;
>         -:  488:	}
>         -:  489:    }
>         -:  490:
>     #####:  491:  return 0;
>         -:  492:}
>         -:  493:
>       562:  494:int drawCard(int player, struct gameState *state)
>         -:  495:{	int count;
>         -:  496:  int deckCounter;
>       562:  497:  if (state->deckCount[player] <= 0){//Deck is empty
>         -:  498:    
>         -:  499:    //Step 1 Shuffle the discard pile back into a deck
>         -:  500:    int i;
>         -:  501:    //Move discard to deck
>       618:  502:    for (i = 0; i < state->discardCount[player];i++){
>       577:  503:      state->deck[player][i] = state->discard[player][i];
>       577:  504:      state->discard[player][i] = -1;
>         -:  505:    }
>         -:  506:
>        41:  507:    state->deckCount[player] = state->discardCount[player];
>        41:  508:    state->discardCount[player] = 0;//Reset discard
>         -:  509:
>         -:  510:    //Shufffle the deck
>        41:  511:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
>         -:  512:   
>        41:  513:    if (DEBUG){//Debug statements
>         -:  514:      printf("Deck count now: %d\n", state->deckCount[player]);
>         -:  515:    }
>         -:  516:    
>        41:  517:    state->discardCount[player] = 0;
>         -:  518:
>         -:  519:    //Step 2 Draw Card
>        41:  520:    count = state->handCount[player];//Get current player's hand count
>         -:  521:    
>        41:  522:    if (DEBUG){//Debug statements
>         -:  523:      printf("Current hand count: %d\n", count);
>         -:  524:    }
>         -:  525:    
>        41:  526:    deckCounter = state->deckCount[player];//Create a holder for the deck count
>         -:  527:
>        41:  528:    if (deckCounter == 0)
>     #####:  529:      return -1;
>         -:  530:
>        41:  531:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
>        41:  532:    state->deckCount[player]--;
>        41:  533:    state->handCount[player]++;//Increment hand count
>         -:  534:  }
>         -:  535:
>         -:  536:  else{
>       521:  537:    int count = state->handCount[player];//Get current hand count for player
>         -:  538:    int deckCounter;
>       521:  539:    if (DEBUG){//Debug statements
>         -:  540:      printf("Current hand count: %d\n", count);
>         -:  541:    }
>         -:  542:
>       521:  543:    deckCounter = state->deckCount[player];//Create holder for the deck count
>       521:  544:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
>       521:  545:    state->deckCount[player]--;
>       521:  546:    state->handCount[player]++;//Increment hand count
>         -:  547:  }
>         -:  548:
>       562:  549:  return 0;
>         -:  550:}
>         -:  551:
>       147:  552:int getCost(int cardNumber)
>         -:  553:{
>       147:  554:  switch( cardNumber ) 
>         -:  555:    {
>         -:  556:    case curse:
>     #####:  557:      return 0;
>         -:  558:    case estate:
>     #####:  559:      return 2;
>         -:  560:    case duchy:
>        20:  561:      return 5;
>         -:  562:    case province:
>        24:  563:      return 8;
>         -:  564:    case copper:
>     #####:  565:      return 0;
>         -:  566:    case silver:
>        49:  567:      return 3;
>         -:  568:    case gold:
>        24:  569:      return 6;
>         -:  570:    case adventurer:
>         6:  571:      return 6;
>         -:  572:    case council_room:
>     #####:  573:      return 5;
>         -:  574:    case feast:
>         4:  575:      return 4;
>         -:  576:    case gardens:
>         4:  577:      return 4;
>         -:  578:    case mine:
>     #####:  579:      return 5;
>         -:  580:    case remodel:
>     #####:  581:      return 4;
>         -:  582:    case smithy:
>     #####:  583:      return 4;
>         -:  584:    case village:
>     #####:  585:      return 3;
>         -:  586:    case baron:
>     #####:  587:      return 4;
>         -:  588:    case great_hall:
>     #####:  589:      return 3;
>         -:  590:    case minion:
>         2:  591:      return 5;
>         -:  592:    case steward:
>         2:  593:      return 3;
>         -:  594:    case tribute:
>     #####:  595:      return 5;
>         -:  596:    case ambassador:
>     #####:  597:      return 3;
>         -:  598:    case cutpurse:
>     #####:  599:      return 4;
>         -:  600:    case embargo: 
>     #####:  601:      return 2;
>         -:  602:    case outpost:
>     #####:  603:      return 5;
>         -:  604:    case salvager:
>         2:  605:      return 4;
>         -:  606:    case sea_hag:
>         2:  607:      return 4;
>         -:  608:    case treasure_map:
>         8:  609:      return 4;
>         -:  610:    }
>         -:  611:	
>     #####:  612:  return -1;
>         -:  613:}
>         -:  614:
>         5:  615:int adventurerEffect(int temphand[MAX_HAND], struct gameState *state, int currentPlayer){	
>         -:  616:
>         5:  617:	int currentplayer = 0;
>         5:  618:	int drawntreasure = 0;
>         5:  619:	int z = 0;// this is the counter for the temp hand
>         -:  620:	int cardDrawn;
>        25:  621:	while(drawntreasure < 2){
>        15:  622:		if (state->deckCount[currentPlayer] < 1){	//if the deck is empty we need to shuffle discard and add to deck
>         1:  623:			shuffle(currentplayer, state);
>         -:  624:		}
>        15:  625:		drawCard(currentPlayer, state);
>        15:  626:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];	//top card of hand is most recently drawn card.
>        25:  627:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
>        10:  628:			drawntreasure++;
>         -:  629:		else{
>         5:  630:			temphand[z] = cardDrawn;
>         5:  631:			state->handCount[currentplayer]--;	//this should just remove the top card (the most recently drawn one).
>         5:  632:			z++;
>         -:  633:		}
>         -:  634:	}
>        15:  635:	while(z - 1 >= 0){
>         5:  636:		state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1];	// discard all cards in play that have been drawn
>         5:  637:		z = z - 1;
>         -:  638:	}
>         5:  639:	return 0;
>         -:  640:}
>         -:  641:
>     #####:  642:int councilRoomEffect(int currentPlayer, struct gameState *state, int handPos){
>         -:  643:	int i;
>     #####:  644:	for (i = 0; i < 4; i++){	//+4 Cards
>     #####:  645:		drawCard(currentPlayer, state);
>         -:  646:	}
>         -:  647:	
>     #####:  648:	state->numBuys++;	//+1 Buy
>     #####:  649:	for (i = 0; i < state->numPlayers; i++){	 //Each other player draws a card
>     #####:  650:		if ( i != currentPlayer ){
>     #####:  651:			drawCard(i, state);
>         -:  652:		}
>         -:  653:	}
>         -:  654:	
>     #####:  655:	discardCard(handPos, currentPlayer, state, 0);	//put played card in played card pile
>     #####:  656:	return 0;
>         -:  657:}
>         -:  658:
>         4:  659:int feastEffect(int currentPlayer, struct gameState *state, int temphand[MAX_HAND], int choice1){
>         -:  660:	//gain card with cost up to 5
>         -:  661:	//Backup hand
>         -:  662:	int x;
>         -:  663:	int i;
>        28:  664:	for (i = 0; i <= state->handCount[currentPlayer]; i++){
>        24:  665:		temphand[i] = state->hand[currentPlayer][i];	//Backup card
>        24:  666:		state->hand[currentPlayer][i] = -1;		//Set to nothing
>         -:  667:	}
>         -:  668:    //Backup hand
>         -:  669:
>         -:  670:    //Update Coins for Buy
>         4:  671:    updateCoins(currentPlayer, state, 5);
>         4:  672:    x = 1;//Condition to loop on
>        12:  673:    while (x == 1) {//Buy one card
>         4:  674:		if (supplyCount(choice1, state) <= 0){
>     #####:  675:			if (DEBUG){
>         -:  676:				printf("None of that card left, sorry!\n");
>         -:  677:			}
>     #####:  678:			if (DEBUG){
>         -:  679:				printf("Cards Left: %d\n", supplyCount(choice1, state));
>         -:  680:			}
>         -:  681:		}	
>         4:  682:		else if (state->coins < getCost(choice1)){
>     #####:  683:			printf("That card is too expensive!\n");
>         -:  684:
>     #####:  685:			if (DEBUG){
>         -:  686:				printf("Coins: %d < %d\n", state->coins, getCost(choice1));
>         -:  687:			}
>         -:  688:		}
>         -:  689:		else{
>         -:  690:
>         4:  691:			if (DEBUG){
>         -:  692:				printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
>         -:  693:			}
>         -:  694:
>         4:  695:			gainCard(choice1, state, 0, currentPlayer);		//Gain the card
>         4:  696:			x = 0;	//No more buying cards
>         -:  697:
>         4:  698:			if (DEBUG){
>         -:  699:				printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
>         -:  700:			}
>         -:  701:		}
>         -:  702:	}     
>         -:  703:
>         -:  704:      //Reset Hand
>        28:  705:	for (i = 0; i <= state->handCount[currentPlayer]; i++){
>        24:  706:		state->hand[currentPlayer][i] = temphand[i];
>        24:  707:		temphand[i] = -1;
>         -:  708:    }
>         -:  709:    //Reset Hand
>         4:  710:    return 0;  			
>         -:  711:}
>         -:  712:
>     #####:  713:int mineEffect(int currentPlayer, struct gameState *state, int oldTreasurePos, int newTreasure, int handPos, int j){
>         -:  714:	int i;
>     #####:  715:	j = state->hand[currentPlayer][oldTreasurePos];  //store treasure card we will trash
>         -:  716:	
>     #####:  717:	if (state->hand[currentPlayer][oldTreasurePos] < copper || state->hand[currentPlayer][oldTreasurePos] >= gold){ 
>     #####:  718:		return -1;
>         -:  719:	}
>         -:  720:	
>     #####:  721:    if (newTreasure > treasure_map || newTreasure < curse){
>     #####:  722:		return -1;
>         -:  723:	}
>         -:  724:	
>     #####:  725:    if ( (getCost(state->hand[currentPlayer][oldTreasurePos]) + 3) > getCost(newTreasure) ){
>     #####:  726:		return -1;
>         -:  727:	}
>         -:  728:	
>     #####:  729:    gainCard(newTreasure, state, 2, currentPlayer);
>         -:  730:
>         -:  731:    //discard mine card from hand
>     #####:  732:    discardCard(handPos, currentPlayer, state, 0);
>         -:  733:
>         -:  734:    //discard trashed treasure card
>     #####:  735:    for (i = 0; i < state->handCount[currentPlayer]; i++){
>     #####:  736:		if (state->hand[currentPlayer][i] == j){
>     #####:  737:			discardCard(i, currentPlayer, state, 0);			
>     #####:  738:			break;
>         -:  739:	    }
>         -:  740:	}
>     #####:  741:	return 0;
1252,1264c1284,1296
<     #####:  743:int mineCard(struct gameState *state, int currentPlayer, int choice1, 
<         -:  744:	     int choice2, int handPos)
<         -:  745:{
<         -:  746:  int i, j;
<     #####:  747:  j = state->hand[currentPlayer][choice1];  //store card we will trash
<         -:  748:  
<     #####:  749:  if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold){
<     #####:  750:    return -1;
<         -:  751:  }
<         -:  752:  
<     #####:  753:  if (choice2 > treasure_map || choice2 < curse){
<     #####:  754:    return -1;
<         -:  755:  }
---
>         -:  743:
>     #####:  744:remodelEffect(int currentPlayer, struct gameState *state, int choice1, int choice2, int handPos, int j){
>         -:  745:	int i;
>     #####:  746:	j = state->hand[currentPlayer][choice1];  //store card we will trash
>         -:  747:
>     #####:  748:    if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) ){
>     #####:  749:		return -1;
>         -:  750:	}
>         -:  751:
>     #####:  752:    gainCard(choice2, state, 0, currentPlayer);
>         -:  753:
>         -:  754:    //discard card from hand
>     #####:  755:    discardCard(handPos, currentPlayer, state, 0);
1266,1518c1298,1550
<     #####:  757:  if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) ){
<     #####:  758:    return -1;
<         -:  759:  }
<         -:  760:  
<     #####:  761:  gainCard(choice2, state, 1, currentPlayer);
<         -:  762:  
<         -:  763:  //discard card from hand
<     #####:  764:  discardCard(handPos, currentPlayer, state, 0);
<         -:  765:  
<         -:  766:  //discard trashed card
<     #####:  767:  for (i = 0; i < state->handCount[currentPlayer]; i++){
<     #####:  768:    if (state->hand[currentPlayer][i] == j){
<     #####:  769:      discardCard(i, currentPlayer, state, 0);			
<     #####:  770:      break;
<         -:  771:    }
<         -:  772:  }
<     #####:  773:  return 0;
<         -:  774:}
<     #####:  775:int smithyCard(struct gameState *state, int currentPlayer, int handPos)
<         -:  776:{
<         -:  777:  int i;
<         -:  778:  //+3 Cards
<     #####:  779:  for (i = 0; i < 3; i++){
<     #####:  780:    drawCard(currentPlayer, state);
<         -:  781:  }
<         -:  782:  
<         -:  783:  //discard card from hand
<     #####:  784:  discardCard(handPos, currentPlayer, state, 1);
<     #####:  785:  return 0;
<         -:  786:}
<        17:  787:int cardEffect(int card, int choice1, int choice2, int choice3, 
<         -:  788:	       struct gameState *state, int handPos, int *bonus)
<         -:  789:{
<         -:  790:  int i;
<         -:  791:  int j;
<         -:  792:  int k;
<         -:  793:  int index;
<        17:  794:  int currentPlayer = whoseTurn(state);
<        17:  795:  int nextPlayer = currentPlayer + 1;
<         -:  796:
<        17:  797:  int tributeRevealedCards[2] = {-1, -1};
<         -:  798:  int temphand[MAX_HAND];// moved above the if statement
<        17:  799:  int drawntreasure=0;
<         -:  800:  int cardDrawn;
<        17:  801:  int z = 0;// this is the counter for the temp hand
<        17:  802:  if (nextPlayer > (state->numPlayers - 1)){
<         7:  803:    nextPlayer = 0;
<         -:  804:  }
<         -:  805:  //uses switch to select card and perform actions
<        17:  806:  switch( card ){
<         -:  807:  case adventurer:
<        12:  808:    adventurerCard(state, currentPlayer, cardDrawn, drawntreasure, temphand, z);
<        12:  809:    return 0;
<         -:  810:    
<         -:  811:  case council_room:
<     #####:  812:    council_roomCard(state, currentPlayer, handPos);
<     #####:  813:    return 0;
<         -:  814:    
<         -:  815:  case feast:
<     #####:  816:    feastCard(state, currentPlayer, choice1, temphand);
<     #####:  817:    return 0;
<         -:  818:    
<         -:  819:  case gardens:
<     #####:  820:    return -1;
<         -:  821:			
<         -:  822:  case mine:
<     #####:  823:    mineCard(state, currentPlayer, choice1, choice2, handPos);
<     #####:  824:    return 0;
<         -:  825:    
<         -:  826:  case remodel:
<     #####:  827:    j = state->hand[currentPlayer][choice1];  //store card we will trash
<     #####:  828:    printf("Cost of choice1 is:%d\n", getCost(state->hand[currentPlayer][choice1]));
<     #####:  829:    printf("Cost of choice2 is:%d\n", getCost(choice2));
<     #####:  830:    if ( (getCost(state->hand[currentPlayer][choice1]) + 2) < getCost(choice2) ){
<     #####:  831:      return -1;
<         -:  832:    }
<         -:  833:    
<     #####:  834:    gainCard(choice2, state, 0, currentPlayer);
<         -:  835:    
<         -:  836:    //discard card from hand
<     #####:  837:    discardCard(handPos, currentPlayer, state, 0);
<         -:  838:    
<         -:  839:    //discard trashed card
<     #####:  840:    for (i = 0; i < state->handCount[currentPlayer]; i++){
<     #####:  841:      if (state->hand[currentPlayer][i] == j){
<     #####:  842:	discardCard(i, currentPlayer, state, 0);			
<     #####:  843:	  break;
<         -:  844:      }
<         -:  845:    }
<         -:  846:    
<         -:  847:    
<     #####:  848:    return 0;
<         -:  849:    
<         -:  850:    case smithy:
<     #####:  851:      smithyCard(state, currentPlayer, handPos);
<     #####:  852:      return 0;
<         -:  853:		
<         -:  854:    case village:
<         -:  855:      //+1 Card
<     #####:  856:      drawCard(currentPlayer, state);
<         -:  857:			
<         -:  858:      //+2 Actions
<     #####:  859:      state->numActions = state->numActions + 2;
<         -:  860:			
<         -:  861:      //discard played card from hand
<     #####:  862:      discardCard(handPos, currentPlayer, state, 0);
<     #####:  863:      return 0;
<         -:  864:		
<         -:  865:    case baron:
<     #####:  866:      state->numBuys++;//Increase buys by 1!
<     #####:  867:      if (choice1 > 0){//Boolean true or going to discard an estate
<     #####:  868:	int p = 0;//Iterator for hand!
<     #####:  869:	int card_not_discarded = 1;//Flag for discard set!
<     #####:  870:	while(card_not_discarded){
<     #####:  871:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
<     #####:  872:	    state->coins += 4;//Add 4 coins to the amount of coins
<     #####:  873:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
<     #####:  874:	    state->discardCount[currentPlayer]++;
<     #####:  875:	    for (;p < state->handCount[currentPlayer]; p++){
<     #####:  876:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
<         -:  877:	    }
<     #####:  878:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
<     #####:  879:	    state->handCount[currentPlayer]--;
<     #####:  880:	    card_not_discarded = 0;//Exit the loop
<         -:  881:	  }
<     #####:  882:	  else if (p > state->handCount[currentPlayer]){
<     #####:  883:	    if(DEBUG) {
<         -:  884:	      printf("No estate cards in your hand, invalid choice\n");
<         -:  885:	      printf("Must gain an estate if there are any\n");
<         -:  886:	    }
<     #####:  887:	    if (supplyCount(estate, state) > 0){
<     #####:  888:	      gainCard(estate, state, 0, currentPlayer);
<     #####:  889:	      state->supplyCount[estate]--;//Decrement estates
<     #####:  890:	      if (supplyCount(estate, state) == 0){
<     #####:  891:		isGameOver(state);
<         -:  892:	      }
<         -:  893:	    }
<     #####:  894:	    card_not_discarded = 0;//Exit the loop
<         -:  895:	  }
<         -:  896:			    
<         -:  897:	  else{
<     #####:  898:	    p++;//Next card
<         -:  899:	  }
<         -:  900:	}
<         -:  901:      }
<         -:  902:			    
<         -:  903:      else{
<     #####:  904:	if (supplyCount(estate, state) > 0){
<     #####:  905:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
<     #####:  906:	  state->supplyCount[estate]--;//Decrement Estates
<     #####:  907:	  if (supplyCount(estate, state) == 0){
<     #####:  908:	    isGameOver(state);
<         -:  909:	  }
<         -:  910:	}
<         -:  911:      }
<         -:  912:	    
<         -:  913:      
<     #####:  914:      return 0;
<         -:  915:		
<         -:  916:    case great_hall:
<         -:  917:      //+1 Card
<     #####:  918:      drawCard(currentPlayer, state);
<         -:  919:			
<         -:  920:      //+1 Actions
<     #####:  921:      state->numActions++;
<         -:  922:			
<         -:  923:      //discard card from hand
<     #####:  924:      discardCard(handPos, currentPlayer, state, 0);
<     #####:  925:      return 0;
<         -:  926:		
<         -:  927:    case minion:
<         -:  928:      //+1 action
<         4:  929:      state->numActions++;
<         -:  930:			
<         -:  931:      //discard card from hand
<         4:  932:      discardCard(handPos, currentPlayer, state, 0);
<         -:  933:			
<         4:  934:      if (choice1)		//+2 coins
<         -:  935:	{
<         4:  936:	  state->coins = state->coins + 2;
<         -:  937:	}
<         -:  938:			
<     #####:  939:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
<         -:  940:	{
<         -:  941:	  //discard hand
<     #####:  942:	  while(numHandCards(state) > 0)
<         -:  943:	    {
<     #####:  944:	      discardCard(handPos, currentPlayer, state, 0);
<         -:  945:	    }
<         -:  946:				
<         -:  947:	  //draw 4
<     #####:  948:	  for (i = 0; i < 4; i++)
<         -:  949:	    {
<     #####:  950:	      drawCard(currentPlayer, state);
<         -:  951:	    }
<         -:  952:				
<         -:  953:	  //other players discard hand and redraw if hand size > 4
<     #####:  954:	  for (i = 0; i < state->numPlayers; i++)
<         -:  955:	    {
<     #####:  956:	      if (i != currentPlayer)
<         -:  957:		{
<     #####:  958:		  if ( state->handCount[i] > 4 )
<         -:  959:		    {
<         -:  960:		      //discard hand
<     #####:  961:		      while( state->handCount[i] > 0 )
<         -:  962:			{
<     #####:  963:			  discardCard(handPos, i, state, 0);
<         -:  964:			}
<         -:  965:							
<         -:  966:		      //draw 4
<     #####:  967:		      for (j = 0; j < 4; j++)
<         -:  968:			{
<     #####:  969:			  drawCard(i, state);
<         -:  970:			}
<         -:  971:		    }
<         -:  972:		}
<         -:  973:	    }
<         -:  974:				
<         -:  975:	}
<         4:  976:      return 0;
<         -:  977:		
<         -:  978:    case steward:
<         1:  979:      if (choice1 == 1)
<         -:  980:	{
<         -:  981:	  //+2 cards
<         1:  982:	  drawCard(currentPlayer, state);
<         1:  983:	  drawCard(currentPlayer, state);
<         -:  984:	}
<     #####:  985:      else if (choice1 == 2)
<         -:  986:	{
<         -:  987:	  //+2 coins
<     #####:  988:	  state->coins = state->coins + 2;
<         -:  989:	}
<         -:  990:      else
<         -:  991:	{
<         -:  992:	  //trash 2 cards in hand
<     #####:  993:	  discardCard(choice2, currentPlayer, state, 1);
<     #####:  994:	  discardCard(choice3, currentPlayer, state, 1);
<         -:  995:	}
<         -:  996:			
<         -:  997:      //discard card from hand
<         1:  998:      discardCard(handPos, currentPlayer, state, 0);
<         1:  999:      return 0;
<         -: 1000:		
<         -: 1001:    case tribute:
<     #####: 1002:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
<     #####: 1003:	if (state->deckCount[nextPlayer] > 0){
<     #####: 1004:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
<     #####: 1005:	  state->deckCount[nextPlayer]--;
<         -: 1006:	}
<     #####: 1007:	else if (state->discardCount[nextPlayer] > 0){
<     #####: 1008:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
<     #####: 1009:	  state->discardCount[nextPlayer]--;
---
>         -:  757:    //discard trashed card
>     #####:  758:    for (i = 0; i < state->handCount[currentPlayer]; i++){
>     #####:  759:		if (state->hand[currentPlayer][i] == j){
>     #####:  760:			discardCard(i, currentPlayer, state, 0);			
>     #####:  761:			break;
>         -:  762:	    }
>         -:  763:	}
>     #####:  764:	return 0;
>         -:  765:}
>         -:  766:
>        20:  767:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus){
>         -:  768:	int i;
>         -:  769:	int j;
>         -:  770:	int k;
>         -:  771:	int index;
>        20:  772:	int currentPlayer = whoseTurn(state);
>        20:  773:	int nextPlayer = currentPlayer + 1;
>        20:  774:	int tributeRevealedCards[2] = {-1, -1};
>         -:  775:	int temphand[MAX_HAND];
>         -:  776:
>        20:  777:	if (nextPlayer > (state->numPlayers - 1)){
>         1:  778:		nextPlayer = 0;
>         -:  779:	}
>         -:  780:  
>         -:  781:	
>         -:  782:  //uses switch to select card and perform actions
>        20:  783:	switch( card ){
>         -:  784:		case adventurer:
>         5:  785:			return adventurerEffect(temphand, state, currentPlayer);
>         -:  786:			
>         -:  787:		case council_room:
>     #####:  788:			return councilRoomEffect(currentPlayer, state, handPos);
>         -:  789:			
>         -:  790:		case feast:
>         4:  791:			return feastEffect(currentPlayer, state, temphand, choice1);
>         -:  792:      
>         -:  793:		case gardens:
>     #####:  794:			return -1;
>         -:  795:			
>         -:  796:		case mine:
>     #####:  797:			return mineEffect(currentPlayer, state, choice1, choice2, handPos, j);
>         -:  798:			
>         -:  799:		case remodel:
>     #####:  800:			return remodelEffect(currentPlayer, state, choice1, choice2, handPos, j);
>         -:  801:		
>         -:  802:		case smithy:
>         -:  803:			//+3 Cards
>     #####:  804:			for (i = 0; i < 3; i++){
>     #####:  805:				drawCard(currentPlayer, state);
>         -:  806:			}
>         -:  807:			
>         -:  808:			//discard card from hand
>     #####:  809:			discardCard(handPos, currentPlayer, state, 0);
>     #####:  810:			return 0;
>         -:  811:		
>         -:  812:    case village:
>         -:  813:      //+1 Card
>     #####:  814:      drawCard(currentPlayer, state);
>         -:  815:			
>         -:  816:      //+2 Actions
>     #####:  817:      state->numActions = state->numActions + 2;
>         -:  818:			
>         -:  819:      //discard played card from hand
>     #####:  820:      discardCard(handPos, currentPlayer, state, 0);
>     #####:  821:      return 0;
>         -:  822:		
>         -:  823:    case baron:
>     #####:  824:      state->numBuys++;//Increase buys by 1!
>     #####:  825:      if (choice1 > 0){//Boolean true or going to discard an estate
>     #####:  826:	int p = 0;//Iterator for hand!
>     #####:  827:	int card_not_discarded = 1;//Flag for discard set!
>     #####:  828:	while(card_not_discarded){
>     #####:  829:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
>     #####:  830:	    state->coins += 4;//Add 4 coins to the amount of coins
>     #####:  831:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
>     #####:  832:	    state->discardCount[currentPlayer]++;
>     #####:  833:	    for (;p < state->handCount[currentPlayer]; p++){
>     #####:  834:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
>         -:  835:	    }
>     #####:  836:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
>     #####:  837:	    state->handCount[currentPlayer]--;
>     #####:  838:	    card_not_discarded = 0;//Exit the loop
>         -:  839:	  }
>     #####:  840:	  else if (p > state->handCount[currentPlayer]){
>     #####:  841:	    if(DEBUG) {
>         -:  842:	      printf("No estate cards in your hand, invalid choice\n");
>         -:  843:	      printf("Must gain an estate if there are any\n");
>         -:  844:	    }
>     #####:  845:	    if (supplyCount(estate, state) > 0){
>     #####:  846:	      gainCard(estate, state, 0, currentPlayer);
>     #####:  847:	      state->supplyCount[estate]--;//Decrement estates
>     #####:  848:	      if (supplyCount(estate, state) == 0){
>     #####:  849:		isGameOver(state);
>         -:  850:	      }
>         -:  851:	    }
>     #####:  852:	    card_not_discarded = 0;//Exit the loop
>         -:  853:	  }
>         -:  854:			    
>         -:  855:	  else{
>     #####:  856:	    p++;//Next card
>         -:  857:	  }
>         -:  858:	}
>         -:  859:      }
>         -:  860:			    
>         -:  861:      else{
>     #####:  862:	if (supplyCount(estate, state) > 0){
>     #####:  863:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
>     #####:  864:	  state->supplyCount[estate]--;//Decrement Estates
>     #####:  865:	  if (supplyCount(estate, state) == 0){
>     #####:  866:	    isGameOver(state);
>         -:  867:	  }
>         -:  868:	}
>         -:  869:      }
>         -:  870:	    
>         -:  871:      
>     #####:  872:      return 0;
>         -:  873:		
>         -:  874:    case great_hall:
>         -:  875:      //+1 Card
>     #####:  876:      drawCard(currentPlayer, state);
>         -:  877:			
>         -:  878:      //+1 Actions
>     #####:  879:      state->numActions++;
>         -:  880:			
>         -:  881:      //discard card from hand
>     #####:  882:      discardCard(handPos, currentPlayer, state, 0);
>     #####:  883:      return 0;
>         -:  884:		
>         -:  885:    case minion:
>         -:  886:      //+1 action
>         1:  887:      state->numActions++;
>         -:  888:			
>         -:  889:      //discard card from hand
>         1:  890:      discardCard(handPos, currentPlayer, state, 0);
>         -:  891:			
>         1:  892:      if (choice1)		//+2 coins
>         -:  893:	{
>         1:  894:	  state->coins = state->coins + 2;
>         -:  895:	}
>         -:  896:			
>     #####:  897:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
>         -:  898:	{
>         -:  899:	  //discard hand
>     #####:  900:	  while(numHandCards(state) > 0)
>         -:  901:	    {
>     #####:  902:	      discardCard(handPos, currentPlayer, state, 0);
>         -:  903:	    }
>         -:  904:				
>         -:  905:	  //draw 4
>     #####:  906:	  for (i = 0; i < 4; i++)
>         -:  907:	    {
>     #####:  908:	      drawCard(currentPlayer, state);
>         -:  909:	    }
>         -:  910:				
>         -:  911:	  //other players discard hand and redraw if hand size > 4
>     #####:  912:	  for (i = 0; i < state->numPlayers; i++)
>         -:  913:	    {
>     #####:  914:	      if (i != currentPlayer)
>         -:  915:		{
>     #####:  916:		  if ( state->handCount[i] > 4 )
>         -:  917:		    {
>         -:  918:		      //discard hand
>     #####:  919:		      while( state->handCount[i] > 0 )
>         -:  920:			{
>     #####:  921:			  discardCard(handPos, i, state, 0);
>         -:  922:			}
>         -:  923:							
>         -:  924:		      //draw 4
>     #####:  925:		      for (j = 0; j < 4; j++)
>         -:  926:			{
>     #####:  927:			  drawCard(i, state);
>         -:  928:			}
>         -:  929:		    }
>         -:  930:		}
>         -:  931:	    }
>         -:  932:				
>         -:  933:	}
>         1:  934:      return 0;
>         -:  935:		
>         -:  936:    case steward:
>         1:  937:      if (choice1 == 1)
>         -:  938:	{
>         -:  939:	  //+2 cards
>         1:  940:	  drawCard(currentPlayer, state);
>         1:  941:	  drawCard(currentPlayer, state);
>         -:  942:	}
>     #####:  943:      else if (choice1 == 2)
>         -:  944:	{
>         -:  945:	  //+2 coins
>     #####:  946:	  state->coins = state->coins + 2;
>         -:  947:	}
>         -:  948:      else
>         -:  949:	{
>         -:  950:	  //trash 2 cards in hand
>     #####:  951:	  discardCard(choice2, currentPlayer, state, 1);
>     #####:  952:	  discardCard(choice3, currentPlayer, state, 1);
>         -:  953:	}
>         -:  954:			
>         -:  955:      //discard card from hand
>         1:  956:      discardCard(handPos, currentPlayer, state, 0);
>         1:  957:      return 0;
>         -:  958:		
>         -:  959:    case tribute:
>     #####:  960:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
>     #####:  961:	if (state->deckCount[nextPlayer] > 0){
>     #####:  962:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
>     #####:  963:	  state->deckCount[nextPlayer]--;
>         -:  964:	}
>     #####:  965:	else if (state->discardCount[nextPlayer] > 0){
>     #####:  966:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
>     #####:  967:	  state->discardCount[nextPlayer]--;
>         -:  968:	}
>         -:  969:	else{
>         -:  970:	  //No Card to Reveal
>     #####:  971:	  if (DEBUG){
>         -:  972:	    printf("No cards to reveal\n");
>         -:  973:	  }
>         -:  974:	}
>         -:  975:      }
>         -:  976:	    
>         -:  977:      else{
>     #####:  978:	if (state->deckCount[nextPlayer] == 0){
>     #####:  979:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
>     #####:  980:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
>     #####:  981:	    state->deckCount[nextPlayer]++;
>     #####:  982:	    state->discard[nextPlayer][i] = -1;
>     #####:  983:	    state->discardCount[nextPlayer]--;
>         -:  984:	  }
>         -:  985:			    
>     #####:  986:	  shuffle(nextPlayer,state);//Shuffle the deck
>         -:  987:	} 
>     #####:  988:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
>     #####:  989:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
>     #####:  990:	state->deckCount[nextPlayer]--;
>     #####:  991:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
>     #####:  992:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
>     #####:  993:	state->deckCount[nextPlayer]--;
>         -:  994:      }    
>         -:  995:		       
>     #####:  996:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
>     #####:  997:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
>     #####:  998:	state->playedCardCount++;
>     #####:  999:	tributeRevealedCards[1] = -1;
>         -: 1000:      }
>         -: 1001:
>     #####: 1002:      for (i = 0; i <= 2; i ++){
>     #####: 1003:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
>     #####: 1004:	  state->coins += 2;
>         -: 1005:	}
>         -: 1006:		    
>     #####: 1007:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
>     #####: 1008:	  drawCard(currentPlayer, state);
>     #####: 1009:	  drawCard(currentPlayer, state);
1520,1854c1552,1844
<         -: 1011:	else{
<         -: 1012:	  //No Card to Reveal
<     #####: 1013:	  if (DEBUG){
<         -: 1014:	    printf("No cards to reveal\n");
<         -: 1015:	  }
<         -: 1016:	}
<         -: 1017:      }
<         -: 1018:	    
<         -: 1019:      else{
<     #####: 1020:	if (state->deckCount[nextPlayer] == 0){
<     #####: 1021:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
<     #####: 1022:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
<     #####: 1023:	    state->deckCount[nextPlayer]++;
<     #####: 1024:	    state->discard[nextPlayer][i] = -1;
<     #####: 1025:	    state->discardCount[nextPlayer]--;
<         -: 1026:	  }
<         -: 1027:			    
<     #####: 1028:	  shuffle(nextPlayer,state);//Shuffle the deck
<         -: 1029:	} 
<     #####: 1030:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
<     #####: 1031:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
<     #####: 1032:	state->deckCount[nextPlayer]--;
<     #####: 1033:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
<     #####: 1034:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
<     #####: 1035:	state->deckCount[nextPlayer]--;
<         -: 1036:      }    
<         -: 1037:		       
<     #####: 1038:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
<     #####: 1039:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
<     #####: 1040:	state->playedCardCount++;
<     #####: 1041:	tributeRevealedCards[1] = -1;
<         -: 1042:      }
<         -: 1043:
<     #####: 1044:      for (i = 0; i <= 2; i ++){
<     #####: 1045:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
<     #####: 1046:	  state->coins += 2;
<         -: 1047:	}
<         -: 1048:		    
<     #####: 1049:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
<     #####: 1050:	  drawCard(currentPlayer, state);
<     #####: 1051:	  drawCard(currentPlayer, state);
<         -: 1052:	}
<         -: 1053:	else{//Action Card
<     #####: 1054:	  state->numActions = state->numActions + 2;
<         -: 1055:	}
<         -: 1056:      }
<         -: 1057:	    
<     #####: 1058:      return 0;
<         -: 1059:		
<         -: 1060:    case ambassador:
<     #####: 1061:      j = 0;		//used to check if player has enough cards to discard
<         -: 1062:
<     #####: 1063:      if (choice2 > 2 || choice2 < 0)
<         -: 1064:	{
<     #####: 1065:	  return -1;				
<         -: 1066:	}
<         -: 1067:
<     #####: 1068:      if (choice1 == handPos)
<         -: 1069:	{
<     #####: 1070:	  return -1;
<         -: 1071:	}
<         -: 1072:
<     #####: 1073:      for (i = 0; i < state->handCount[currentPlayer]; i++)
<         -: 1074:	{
<     #####: 1075:	  if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
<         -: 1076:	    {
<     #####: 1077:	      j++;
<         -: 1078:	    }
<         -: 1079:	}
<     #####: 1080:      if (j < choice2)
<         -: 1081:	{
<     #####: 1082:	  return -1;				
<         -: 1083:	}
<         -: 1084:
<     #####: 1085:      if (DEBUG) 
<         -: 1086:	printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
<         -: 1087:
<         -: 1088:      //increase supply count for choosen card by amount being discarded
<     #####: 1089:      state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
<         -: 1090:			
<         -: 1091:      //each other player gains a copy of revealed card
<     #####: 1092:      for (i = 0; i < state->numPlayers; i++)
<         -: 1093:	{
<     #####: 1094:	  if (i != currentPlayer)
<         -: 1095:	    {
<     #####: 1096:	      gainCard(state->hand[currentPlayer][choice1], state, 0, i);
<         -: 1097:	    }
<         -: 1098:	}
<         -: 1099:
<         -: 1100:      //discard played card from hand
<     #####: 1101:      discardCard(handPos, currentPlayer, state, 0);			
<         -: 1102:
<         -: 1103:      //trash copies of cards returned to supply
<     #####: 1104:      for (j = 0; j < choice2; j++)
<         -: 1105:	{
<     #####: 1106:	  for (i = 0; i < state->handCount[currentPlayer]; i++)
<         -: 1107:	    {
<     #####: 1108:	      if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
<         -: 1109:		{
<     #####: 1110:		  discardCard(i, currentPlayer, state, 1);
<     #####: 1111:		  break;
<         -: 1112:		}
<         -: 1113:	    }
<         -: 1114:	}			
<         -: 1115:
<     #####: 1116:      return 0;
<         -: 1117:		
<         -: 1118:    case cutpurse:
<         -: 1119:
<     #####: 1120:      updateCoins(currentPlayer, state, 2);
<     #####: 1121:      for (i = 0; i < state->numPlayers; i++)
<         -: 1122:	{
<     #####: 1123:	  if (i != currentPlayer)
<         -: 1124:	    {
<     #####: 1125:	      for (j = 0; j < state->handCount[i]; j++)
<         -: 1126:		{
<     #####: 1127:		  if (state->hand[i][j] == copper)
<         -: 1128:		    {
<     #####: 1129:		      discardCard(j, i, state, 0);
<     #####: 1130:		      break;
<         -: 1131:		    }
<     #####: 1132:		  if (j == state->handCount[i])
<         -: 1133:		    {
<     #####: 1134:		      for (k = 0; k < state->handCount[i]; k++)
<         -: 1135:			{
<     #####: 1136:			  if (DEBUG)
<         -: 1137:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
<         -: 1138:			}	
<     #####: 1139:		      break;
<         -: 1140:		    }		
<         -: 1141:		}
<         -: 1142:					
<         -: 1143:	    }
<         -: 1144:				
<         -: 1145:	}				
<         -: 1146:
<         -: 1147:      //discard played card from hand
<     #####: 1148:      discardCard(handPos, currentPlayer, state, 0);			
<         -: 1149:
<     #####: 1150:      return 0;
<         -: 1151:
<         -: 1152:		
<         -: 1153:    case embargo: 
<         -: 1154:      //+2 Coins
<     #####: 1155:      state->coins = state->coins + 2;
<         -: 1156:			
<         -: 1157:      //see if selected pile is in play
<     #####: 1158:      if ( state->supplyCount[choice1] == -1 )
<         -: 1159:	{
<     #####: 1160:	  return -1;
<         -: 1161:	}
<         -: 1162:			
<         -: 1163:      //add embargo token to selected supply pile
<     #####: 1164:      state->embargoTokens[choice1]++;
<         -: 1165:			
<         -: 1166:      //trash card
<     #####: 1167:      discardCard(handPos, currentPlayer, state, 1);		
<     #####: 1168:      return 0;
<         -: 1169:		
<         -: 1170:    case outpost:
<         -: 1171:      //set outpost flag
<     #####: 1172:      state->outpostPlayed++;
<         -: 1173:			
<         -: 1174:      //discard card
<     #####: 1175:      discardCard(handPos, currentPlayer, state, 0);
<     #####: 1176:      return 0;
<         -: 1177:		
<         -: 1178:    case salvager:
<         -: 1179:      //+1 buy
<     #####: 1180:      state->numBuys++;
<         -: 1181:			
<     #####: 1182:      if (choice1)
<         -: 1183:	{
<         -: 1184:	  //gain coins equal to trashed card
<     #####: 1185:	  state->coins = state->coins + getCost( handCard(choice1, state) );
<         -: 1186:	  //trash card
<     #####: 1187:	  discardCard(choice1, currentPlayer, state, 1);	
<         -: 1188:	}
<         -: 1189:			
<         -: 1190:      //discard card
<     #####: 1191:      discardCard(handPos, currentPlayer, state, 0);
<     #####: 1192:      return 0;
<         -: 1193:		
<         -: 1194:    case sea_hag:
<     #####: 1195:      for (i = 0; i < state->numPlayers; i++){
<     #####: 1196:	if (i != currentPlayer){
<     #####: 1197:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
<     #####: 1198:	  state->discardCount[i]++;
<     #####: 1199:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
<         -: 1200:	}
<         -: 1201:      }
<     #####: 1202:      return 0;
<         -: 1203:		
<         -: 1204:    case treasure_map:
<         -: 1205:      //search hand for another treasure_map
<     #####: 1206:      index = -1;
<     #####: 1207:      for (i = 0; i < state->handCount[currentPlayer]; i++)
<         -: 1208:	{
<     #####: 1209:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
<         -: 1210:	    {
<     #####: 1211:	      index = i;
<     #####: 1212:	      break;
<         -: 1213:	    }
<         -: 1214:	}
<     #####: 1215:      if (index > -1)
<         -: 1216:	{
<         -: 1217:	  //trash both treasure cards
<     #####: 1218:	  discardCard(handPos, currentPlayer, state, 1);
<     #####: 1219:	  discardCard(index, currentPlayer, state, 1);
<         -: 1220:
<         -: 1221:	  //gain 4 Gold cards
<     #####: 1222:	  for (i = 0; i < 4; i++)
<         -: 1223:	    {
<     #####: 1224:	      gainCard(gold, state, 1, currentPlayer);
<         -: 1225:	    }
<         -: 1226:				
<         -: 1227:	  //return success
<     #####: 1228:	  return 1;
<         -: 1229:	}
<         -: 1230:			
<         -: 1231:      //no second treasure_map found in hand
<     #####: 1232:      return -1;
<         -: 1233:    }
<         -: 1234:	
<     #####: 1235:  return -1;
<         -: 1236:}
<         -: 1237:
<         5: 1238:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
<         -: 1239:{
<         -: 1240:	
<         -: 1241:  //if card is not trashed, added to Played pile 
<         5: 1242:  if (trashFlag < 1)
<         -: 1243:    {
<         -: 1244:      //add card to played pile
<         5: 1245:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
<         5: 1246:      state->playedCardCount++;
<         -: 1247:    }
<         -: 1248:	
<         -: 1249:  //set played card to -1
<         5: 1250:  state->hand[currentPlayer][handPos] = -1;
<         -: 1251:	
<         -: 1252:  //remove card from player's hand
<         5: 1253:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
<         -: 1254:    {
<         -: 1255:      //reduce number of cards in hand
<         1: 1256:      state->handCount[currentPlayer]--;
<         -: 1257:    }
<         4: 1258:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
<         -: 1259:    {
<         -: 1260:      //reduce number of cards in hand
<     #####: 1261:      state->handCount[currentPlayer]--;
<         -: 1262:    }
<         -: 1263:  else 	
<         -: 1264:    {
<         -: 1265:      //replace discarded card with last card in hand
<         4: 1266:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
<         -: 1267:      //set last card to -1
<         4: 1268:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
<         -: 1269:      //reduce number of cards in hand
<         4: 1270:      state->handCount[currentPlayer]--;
<         -: 1271:    }
<         -: 1272:	
<         5: 1273:  return 0;
<         -: 1274:}
<         -: 1275:
<        58: 1276:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
<         -: 1277:{
<         -: 1278:  //Note: supplyPos is enum of choosen card
<         -: 1279:	
<         -: 1280:  //check if supply pile is empty (0) or card is not used in game (-1)
<        58: 1281:  if ( supplyCount(supplyPos, state) < 1 )
<         -: 1282:    {
<     #####: 1283:      return -1;
<         -: 1284:    }
<         -: 1285:	
<         -: 1286:  //added card for [whoseTurn] current player:
<         -: 1287:  // toFlag = 0 : add to discard
<         -: 1288:  // toFlag = 1 : add to deck
<         -: 1289:  // toFlag = 2 : add to hand
<         -: 1290:
<        58: 1291:  if (toFlag == 1)
<         -: 1292:    {
<     #####: 1293:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
<     #####: 1294:      state->deckCount[player]++;
<         -: 1295:    }
<        58: 1296:  else if (toFlag == 2)
<         -: 1297:    {
<     #####: 1298:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
<     #####: 1299:      state->handCount[player]++;
<         -: 1300:    }
<         -: 1301:  else
<         -: 1302:    {
<        58: 1303:      state->discard[player][ state->discardCount[player] ] = supplyPos;
<        58: 1304:      state->discardCount[player]++;
<         -: 1305:    }
<         -: 1306:	
<         -: 1307:  //decrease number in supply pile
<        58: 1308:  state->supplyCount[supplyPos]--;
<         -: 1309:	 
<        58: 1310:  return 0;
<         -: 1311:}
<         -: 1312:
<       121: 1313:int updateCoins(int player, struct gameState *state, int bonus)
<         -: 1314:{
<         -: 1315:  int i;
<         -: 1316:	
<         -: 1317:  //reset coin count
<       121: 1318:  state->coins = 0;
<         -: 1319:
<         -: 1320:  //add coins for each Treasure card in player's hand
<       746: 1321:  for (i = 0; i < state->handCount[player]; i++)
<         -: 1322:    {
<       625: 1323:      if (state->hand[player][i] == copper)
<         -: 1324:	{
<       196: 1325:	  state->coins += 1;
<         -: 1326:	}
<       429: 1327:      else if (state->hand[player][i] == silver)
<         -: 1328:	{
<       133: 1329:	  state->coins += 2;
<         -: 1330:	}
<       296: 1331:      else if (state->hand[player][i] == gold)
<         -: 1332:	{
<        29: 1333:	  state->coins += 3;
<         -: 1334:	}	
<         -: 1335:    }	
<         -: 1336:
<         -: 1337:  //add bonus
<       121: 1338:  state->coins += bonus;
<         -: 1339:
<       121: 1340:  return 0;
<         -: 1341:}
<         -: 1342:
<         -: 1343:
<         -: 1344://end of dominion.c
<         -: 1345:
---
>         -: 1011:	else{//Action Card
>     #####: 1012:	  state->numActions = state->numActions + 2;
>         -: 1013:	}
>         -: 1014:      }
>         -: 1015:	    
>     #####: 1016:      return 0;
>         -: 1017:		
>         -: 1018:    case ambassador:
>     #####: 1019:      j = 0;		//used to check if player has enough cards to discard
>         -: 1020:
>     #####: 1021:      if (choice2 > 2 || choice2 < 0)
>         -: 1022:	{
>     #####: 1023:	  return -1;				
>         -: 1024:	}
>         -: 1025:
>     #####: 1026:      if (choice1 == handPos)
>         -: 1027:	{
>     #####: 1028:	  return -1;
>         -: 1029:	}
>         -: 1030:
>     #####: 1031:      for (i = 0; i < state->handCount[currentPlayer]; i++)
>         -: 1032:	{
>     #####: 1033:	  if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
>         -: 1034:	    {
>     #####: 1035:	      j++;
>         -: 1036:	    }
>         -: 1037:	}
>     #####: 1038:      if (j < choice2)
>         -: 1039:	{
>     #####: 1040:	  return -1;				
>         -: 1041:	}
>         -: 1042:
>     #####: 1043:      if (DEBUG) 
>         -: 1044:	printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
>         -: 1045:
>         -: 1046:      //increase supply count for choosen card by amount being discarded
>     #####: 1047:      state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
>         -: 1048:			
>         -: 1049:      //each other player gains a copy of revealed card
>     #####: 1050:      for (i = 0; i < state->numPlayers; i++)
>         -: 1051:	{
>     #####: 1052:	  if (i != currentPlayer)
>         -: 1053:	    {
>     #####: 1054:	      gainCard(state->hand[currentPlayer][choice1], state, 0, i);
>         -: 1055:	    }
>         -: 1056:	}
>         -: 1057:
>         -: 1058:      //discard played card from hand
>     #####: 1059:      discardCard(handPos, currentPlayer, state, 0);			
>         -: 1060:
>         -: 1061:      //trash copies of cards returned to supply
>     #####: 1062:      for (j = 0; j < choice2; j++)
>         -: 1063:	{
>     #####: 1064:	  for (i = 0; i < state->handCount[currentPlayer]; i++)
>         -: 1065:	    {
>     #####: 1066:	      if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
>         -: 1067:		{
>     #####: 1068:		  discardCard(i, currentPlayer, state, 1);
>     #####: 1069:		  break;
>         -: 1070:		}
>         -: 1071:	    }
>         -: 1072:	}			
>         -: 1073:
>     #####: 1074:      return 0;
>         -: 1075:		
>         -: 1076:    case cutpurse:
>         -: 1077:
>     #####: 1078:      updateCoins(currentPlayer, state, 2);
>     #####: 1079:      for (i = 0; i < state->numPlayers; i++)
>         -: 1080:	{
>     #####: 1081:	  if (i != currentPlayer)
>         -: 1082:	    {
>     #####: 1083:	      for (j = 0; j < state->handCount[i]; j++)
>         -: 1084:		{
>     #####: 1085:		  if (state->hand[i][j] == copper)
>         -: 1086:		    {
>     #####: 1087:		      discardCard(j, i, state, 0);
>     #####: 1088:		      break;
>         -: 1089:		    }
>     #####: 1090:		  if (j == state->handCount[i])
>         -: 1091:		    {
>     #####: 1092:		      for (k = 0; k < state->handCount[i]; k++)
>         -: 1093:			{
>     #####: 1094:			  if (DEBUG)
>         -: 1095:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
>         -: 1096:			}	
>     #####: 1097:		      break;
>         -: 1098:		    }		
>         -: 1099:		}
>         -: 1100:					
>         -: 1101:	    }
>         -: 1102:				
>         -: 1103:	}				
>         -: 1104:
>         -: 1105:      //discard played card from hand
>     #####: 1106:      discardCard(handPos, currentPlayer, state, 0);			
>         -: 1107:
>     #####: 1108:      return 0;
>         -: 1109:
>         -: 1110:		
>         -: 1111:    case embargo: 
>         -: 1112:      //+2 Coins
>     #####: 1113:      state->coins = state->coins + 2;
>         -: 1114:			
>         -: 1115:      //see if selected pile is in play
>     #####: 1116:      if ( state->supplyCount[choice1] == -1 )
>         -: 1117:	{
>     #####: 1118:	  return -1;
>         -: 1119:	}
>         -: 1120:			
>         -: 1121:      //add embargo token to selected supply pile
>     #####: 1122:      state->embargoTokens[choice1]++;
>         -: 1123:			
>         -: 1124:      //trash card
>     #####: 1125:      discardCard(handPos, currentPlayer, state, 1);		
>     #####: 1126:      return 0;
>         -: 1127:		
>         -: 1128:    case outpost:
>         -: 1129:      //set outpost flag
>     #####: 1130:      state->outpostPlayed++;
>         -: 1131:			
>         -: 1132:      //discard card
>     #####: 1133:      discardCard(handPos, currentPlayer, state, 0);
>     #####: 1134:      return 0;
>         -: 1135:		
>         -: 1136:    case salvager:
>         -: 1137:      //+1 buy
>         1: 1138:      state->numBuys++;
>         -: 1139:			
>         1: 1140:      if (choice1)
>         -: 1141:	{
>         -: 1142:	  //gain coins equal to trashed card
>         1: 1143:	  state->coins = state->coins + getCost( handCard(choice1, state) );
>         -: 1144:	  //trash card
>         1: 1145:	  discardCard(choice1, currentPlayer, state, 1);	
>         -: 1146:	}
>         -: 1147:			
>         -: 1148:      //discard card
>         1: 1149:      discardCard(handPos, currentPlayer, state, 0);
>         1: 1150:      return 0;
>         -: 1151:		
>         -: 1152:    case sea_hag:
>        20: 1153:      for (i = 0; i < state->numPlayers; i++){
>        16: 1154:	if (i != currentPlayer){
>        12: 1155:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
>        12: 1156:	  state->discardCount[i]++;
>        12: 1157:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
>         -: 1158:	}
>         -: 1159:      }
>         4: 1160:      return 0;
>         -: 1161:		
>         -: 1162:    case treasure_map:
>         -: 1163:      //search hand for another treasure_map
>         4: 1164:      index = -1;
>        24: 1165:      for (i = 0; i < state->handCount[currentPlayer]; i++)
>         -: 1166:	{
>        20: 1167:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
>         -: 1168:	    {
>     #####: 1169:	      index = i;
>     #####: 1170:	      break;
>         -: 1171:	    }
>         -: 1172:	}
>         4: 1173:      if (index > -1)
>         -: 1174:	{
>         -: 1175:	  //trash both treasure cards
>     #####: 1176:	  discardCard(handPos, currentPlayer, state, 1);
>     #####: 1177:	  discardCard(index, currentPlayer, state, 1);
>         -: 1178:
>         -: 1179:	  //gain 4 Gold cards
>     #####: 1180:	  for (i = 0; i < 4; i++)
>         -: 1181:	    {
>     #####: 1182:	      gainCard(gold, state, 1, currentPlayer);
>         -: 1183:	    }
>         -: 1184:				
>         -: 1185:	  //return success
>     #####: 1186:	  return 1;
>         -: 1187:	}
>         -: 1188:			
>         -: 1189:      //no second treasure_map found in hand
>         4: 1190:      return -1;
>         -: 1191:    }
>         -: 1192:	
>     #####: 1193:  return -1;
>         -: 1194:}
>         -: 1195:
>         4: 1196:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
>         -: 1197:{
>         -: 1198:	
>         -: 1199:  //if card is not trashed, added to Played pile 
>         4: 1200:  if (trashFlag < 1)
>         -: 1201:    {
>         -: 1202:      //add card to played pile
>         3: 1203:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
>         3: 1204:      state->playedCardCount++;
>         -: 1205:    }
>         -: 1206:	
>         -: 1207:  //set played card to -1
>         4: 1208:  state->hand[currentPlayer][handPos] = -1;
>         -: 1209:	
>         -: 1210:  //remove card from player's hand
>         4: 1211:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
>         -: 1212:    {
>         -: 1213:      //reduce number of cards in hand
>         1: 1214:      state->handCount[currentPlayer]--;
>         -: 1215:    }
>         3: 1216:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
>         -: 1217:    {
>         -: 1218:      //reduce number of cards in hand
>     #####: 1219:      state->handCount[currentPlayer]--;
>         -: 1220:    }
>         -: 1221:  else 	
>         -: 1222:    {
>         -: 1223:      //replace discarded card with last card in hand
>         3: 1224:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
>         -: 1225:      //set last card to -1
>         3: 1226:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
>         -: 1227:      //reduce number of cards in hand
>         3: 1228:      state->handCount[currentPlayer]--;
>         -: 1229:    }
>         -: 1230:	
>         4: 1231:  return 0;
>         -: 1232:}
>         -: 1233:
>        75: 1234:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
>         -: 1235:{
>         -: 1236:  //Note: supplyPos is enum of choosen card
>         -: 1237:	
>         -: 1238:  //check if supply pile is empty (0) or card is not used in game (-1)
>        75: 1239:  if ( supplyCount(supplyPos, state) < 1 )
>         -: 1240:    {
>     #####: 1241:      return -1;
>         -: 1242:    }
>         -: 1243:	
>         -: 1244:  //added card for [whoseTurn] current player:
>         -: 1245:  // toFlag = 0 : add to discard
>         -: 1246:  // toFlag = 1 : add to deck
>         -: 1247:  // toFlag = 2 : add to hand
>         -: 1248:
>        75: 1249:  if (toFlag == 1)
>         -: 1250:    {
>     #####: 1251:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
>     #####: 1252:      state->deckCount[player]++;
>         -: 1253:    }
>        75: 1254:  else if (toFlag == 2)
>         -: 1255:    {
>     #####: 1256:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
>     #####: 1257:      state->handCount[player]++;
>         -: 1258:    }
>         -: 1259:  else
>         -: 1260:    {
>        75: 1261:      state->discard[player][ state->discardCount[player] ] = supplyPos;
>        75: 1262:      state->discardCount[player]++;
>         -: 1263:    }
>         -: 1264:	
>         -: 1265:  //decrease number in supply pile
>        75: 1266:  state->supplyCount[supplyPos]--;
>         -: 1267:	 
>        75: 1268:  return 0;
>         -: 1269:}
>         -: 1270:
>       129: 1271:int updateCoins(int player, struct gameState *state, int bonus)
>         -: 1272:{
>         -: 1273:  int i;
>         -: 1274:	
>         -: 1275:  //reset coin count
>       129: 1276:  state->coins = 0;
>         -: 1277:
>         -: 1278:  //add coins for each Treasure card in player's hand
>       786: 1279:  for (i = 0; i < state->handCount[player]; i++)
>         -: 1280:    {
>       657: 1281:      if (state->hand[player][i] == copper)
>         -: 1282:	{
>       279: 1283:	  state->coins += 1;
>         -: 1284:	}
>       378: 1285:      else if (state->hand[player][i] == silver)
>         -: 1286:	{
>        92: 1287:	  state->coins += 2;
>         -: 1288:	}
>       286: 1289:      else if (state->hand[player][i] == gold)
>         -: 1290:	{
>        24: 1291:	  state->coins += 3;
>         -: 1292:	}	
>         -: 1293:    }	
>         -: 1294:
>         -: 1295:  //add bonus
>       129: 1296:  state->coins += bonus;
>         -: 1297:
>       129: 1298:  return 0;
>         -: 1299:}
>         -: 1300:
>         -: 1301:
>         -: 1302://end of dominion.c
>         -: 1303:
