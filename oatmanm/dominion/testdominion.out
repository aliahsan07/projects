File 'dominion.c'
Lines executed:54.95% of 586
dominion.c:creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:2
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
     3491:    8:int compare(const void* a, const void* b) {
     3491:    9:  if (*(int*)a > *(int*)b)
     1644:   10:    return 1;
     1847:   11:  if (*(int*)a < *(int*)b)
      521:   12:    return -1;
     1326:   13:  return 0;
        -:   14:}
        -:   15:
    #####:   16:struct gameState* newGame() {
    #####:   17:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:  return g;
        -:   19:}
        -:   20:
    #####:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:		  int k8, int k9, int k10) {
    #####:   23:  int* k = malloc(10 * sizeof(int));
    #####:   24:  k[0] = k1;
    #####:   25:  k[1] = k2;
    #####:   26:  k[2] = k3;
    #####:   27:  k[3] = k4;
    #####:   28:  k[4] = k5;
    #####:   29:  k[5] = k6;
    #####:   30:  k[6] = k7;
    #####:   31:  k[7] = k8;
    #####:   32:  k[8] = k9;
    #####:   33:  k[9] = k10;
    #####:   34:  return k;
        -:   35:}
        -:   36:
        2:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		   struct gameState *state) {
        -:   39:
        -:   40:  int i;
        -:   41:  int j;
        -:   42:  int it;			
        -:   43:  //set up random number generator
        2:   44:  SelectStream(1);
        2:   45:  PutSeed((long)randomSeed);
        -:   46:  
        -:   47:  //check number of players
        2:   48:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:    {
    #####:   50:      return -1;
        -:   51:    }
        -:   52:
        -:   53:  //set number of players
        2:   54:  state->numPlayers = numPlayers;
        -:   55:
        -:   56:  //check selected kingdom cards are different
       22:   57:  for (i = 0; i < 10; i++)
        -:   58:    {
      220:   59:      for (j = 0; j < 10; j++)
        -:   60:        {
      200:   61:	  if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:	    {
    #####:   63:	      return -1;
        -:   64:	    }
        -:   65:        }
        -:   66:    }
        -:   67:
        -:   68:
        -:   69:  //initialize supply
        -:   70:  ///////////////////////////////
        -:   71:
        -:   72:  //set number of Curse cards
        2:   73:  if (numPlayers == 2)
        -:   74:    {
        2:   75:      state->supplyCount[curse] = 10;
        -:   76:    }
    #####:   77:  else if (numPlayers == 3)
        -:   78:    {
    #####:   79:      state->supplyCount[curse] = 20;
        -:   80:    }
        -:   81:  else
        -:   82:    {
    #####:   83:      state->supplyCount[curse] = 30;
        -:   84:    }
        -:   85:
        -:   86:  //set number of Victory cards
        2:   87:  if (numPlayers == 2)
        -:   88:    {
        2:   89:      state->supplyCount[estate] = 8;
        2:   90:      state->supplyCount[duchy] = 8;
        2:   91:      state->supplyCount[province] = 8;
        -:   92:    }
        -:   93:  else
        -:   94:    {
    #####:   95:      state->supplyCount[estate] = 12;
    #####:   96:      state->supplyCount[duchy] = 12;
    #####:   97:      state->supplyCount[province] = 12;
        -:   98:    }
        -:   99:
        -:  100:  //set number of Treasure cards
        2:  101:  state->supplyCount[copper] = 60 - (7 * numPlayers);
        2:  102:  state->supplyCount[silver] = 40;
        2:  103:  state->supplyCount[gold] = 30;
        -:  104:
        -:  105:  //set number of Kingdom cards
       42:  106:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:    {
      330:  108:      for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:	{
      310:  110:	  if (kingdomCards[j] == i)
        -:  111:	    {
        -:  112:	      //check if card is a 'Victory' Kingdom card
       23:  113:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:		{
        3:  115:		  if (numPlayers == 2){ 
        3:  116:		    state->supplyCount[i] = 8; 
        -:  117:		  }
    #####:  118:		  else{ state->supplyCount[i] = 12; }
        -:  119:		}
        -:  120:	      else
        -:  121:		{
       17:  122:		  state->supplyCount[i] = 10;
        -:  123:		}
       20:  124:	      break;
        -:  125:	    }
        -:  126:	  else    //card is not in the set choosen for the game
        -:  127:	    {
      290:  128:	      state->supplyCount[i] = -1;
        -:  129:	    }
        -:  130:	}
        -:  131:
        -:  132:    }
        -:  133:
        -:  134:  ////////////////////////
        -:  135:  //supply intilization complete
        -:  136:
        -:  137:  //set player decks
        6:  138:  for (i = 0; i < numPlayers; i++)
        -:  139:    {
        4:  140:      state->deckCount[i] = 0;
       16:  141:      for (j = 0; j < 3; j++)
        -:  142:	{
       12:  143:	  state->deck[i][j] = estate;
       12:  144:	  state->deckCount[i]++;
        -:  145:	}
       32:  146:      for (j = 3; j < 10; j++)
        -:  147:	{
       28:  148:	  state->deck[i][j] = copper;
       28:  149:	  state->deckCount[i]++;		
        -:  150:	}
        -:  151:    }
        -:  152:
        -:  153:  //shuffle player decks
        6:  154:  for (i = 0; i < numPlayers; i++)
        -:  155:    {
        4:  156:      if ( shuffle(i, state) < 0 )
        -:  157:	{
    #####:  158:	  return -1;
        -:  159:	}
        -:  160:    }
        -:  161:
        -:  162:  //draw player hands
        6:  163:  for (i = 0; i < numPlayers; i++)
        -:  164:    {  
        -:  165:      //initialize hand size to zero
        4:  166:      state->handCount[i] = 0;
        4:  167:      state->discardCount[i] = 0;
        -:  168:      //draw 5 cards
        -:  169:      // for (j = 0; j < 5; j++)
        -:  170:      //	{
        -:  171:      //	  drawCard(i, state);
        -:  172:      //	}
        -:  173:    }
        -:  174:  
        -:  175:  //set embargo tokens to 0 for all supply piles
       56:  176:  for (i = 0; i <= treasure_map; i++)
        -:  177:    {
       54:  178:      state->embargoTokens[i] = 0;
        -:  179:    }
        -:  180:
        -:  181:  //initialize first player's turn
        2:  182:  state->outpostPlayed = 0;
        2:  183:  state->phase = 0;
        2:  184:  state->numActions = 1;
        2:  185:  state->numBuys = 1;
        2:  186:  state->playedCardCount = 0;
        2:  187:  state->whoseTurn = 0;
        2:  188:  state->handCount[state->whoseTurn] = 0;
        -:  189:  //int it; move to top
        -:  190:
        -:  191:  //Moved draw cards to here, only drawing at the start of a turn
       12:  192:  for (it = 0; it < 5; it++){
       10:  193:    drawCard(state->whoseTurn, state);
        -:  194:  }
        -:  195:
        2:  196:  updateCoins(state->whoseTurn, state, 0);
        -:  197:
        2:  198:  return 0;
        -:  199:}
        -:  200:
       61:  201:int shuffle(int player, struct gameState *state) {
        -:  202: 
        -:  203:
        -:  204:  int newDeck[MAX_DECK];
       61:  205:  int newDeckPos = 0;
        -:  206:  int card;
        -:  207:  int i;
        -:  208:
       61:  209:  if (state->deckCount[player] < 1)
    #####:  210:    return -1;
       61:  211:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
        -:  212:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
     1249:  214:  while (state->deckCount[player] > 0) {
     1127:  215:    card = floor(Random() * state->deckCount[player]);
     1127:  216:    newDeck[newDeckPos] = state->deck[player][card];
     1127:  217:    newDeckPos++;
     6859:  218:    for (i = card; i < state->deckCount[player]-1; i++) {
     5732:  219:      state->deck[player][i] = state->deck[player][i+1];
        -:  220:    }
     1127:  221:    state->deckCount[player]--;
        -:  222:  }
     1188:  223:  for (i = 0; i < newDeckPos; i++) {
     1127:  224:    state->deck[player][i] = newDeck[i];
     1127:  225:    state->deckCount[player]++;
        -:  226:  }
        -:  227:
       61:  228:  return 0;
        -:  229:}
        -:  230:
       93:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  232:{	
        -:  233:  int card;
       93:  234:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:  //check if it is the right phase
       93:  237:  if (state->phase != 0)
        -:  238:    {
    #####:  239:      return -1;
        -:  240:    }
        -:  241:	
        -:  242:  //check if player has enough actions
       93:  243:  if ( state->numActions < 1 )
        -:  244:    {
    #####:  245:      return -1;
        -:  246:    }
        -:  247:	
        -:  248:  //get card played
       93:  249:  card = handCard(handPos, state);
        -:  250:	
        -:  251:  //check if selected card is an action
       93:  252:  if ( card < adventurer || card > treasure_map )
        -:  253:    {
    #####:  254:      return -1;
        -:  255:    }
        -:  256:	
        -:  257:  //play card
       93:  258:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
        -:  259:    {
       41:  260:      return -1;
        -:  261:    }
        -:  262:	
        -:  263:  //reduce number of actions
        -:  264:
       52:  265:  state->numActions--;
        -:  266:
        -:  267:  //update coins (Treasure cards may be added with card draws)
       52:  268:  updateCoins(state->whoseTurn, state, coin_bonus);
        -:  269:	
       52:  270:  return 0;
        -:  271:}
        -:  272:
      122:  273:int buyCard(int supplyPos, struct gameState *state) {
        -:  274:  int who;
      122:  275:  if (DEBUG){
        -:  276:    printf("Entering buyCard...\n");
        -:  277:  }
        -:  278:
        -:  279:  // I don't know what to do about the phase thing.
        -:  280:
      122:  281:  who = state->whoseTurn;
        -:  282:
      122:  283:  if (state->numBuys < 1){
    #####:  284:    if (DEBUG)
        -:  285:      printf("You do not have any buys left\n");
    #####:  286:    return -1;
      122:  287:  } else if (supplyCount(supplyPos, state) <1){
    #####:  288:    if (DEBUG)
        -:  289:      printf("There are not any of that type of card left\n");
    #####:  290:    return -1;
      122:  291:  } else if (state->coins < getCost(supplyPos)){
       30:  292:    if (DEBUG) 
        -:  293:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
       30:  294:    return -1;
        -:  295:  } else {
       92:  296:    state->phase=1;
        -:  297:    //state->supplyCount[supplyPos]--;
       92:  298:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  299:  
       92:  300:    state->coins = (state->coins) - (getCost(supplyPos));
       92:  301:    state->numBuys--;
       92:  302:    if (DEBUG)
        -:  303:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  304:  }
        -:  305:
        -:  306:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  307:  //state->discardCount[who]++;
        -:  308:    
       92:  309:  return 0;
        -:  310:}
        -:  311:
    #####:  312:int numHandCards(struct gameState *state) {
    #####:  313:  return state->handCount[ whoseTurn(state) ];
        -:  314:}
        -:  315:
       93:  316:int handCard(int handPos, struct gameState *state) {
       93:  317:  int currentPlayer = whoseTurn(state);
       93:  318:  return state->hand[currentPlayer][handPos];
        -:  319:}
        -:  320:
      234:  321:int supplyCount(int card, struct gameState *state) {
      234:  322:  return state->supplyCount[card];
        -:  323:}
        -:  324:
    #####:  325:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  326:  int i;
    #####:  327:  int count = 0;
        -:  328:
    #####:  329:  for (i = 0; i < state->deckCount[player]; i++)
        -:  330:    {
    #####:  331:      if (state->deck[player][i] == card) count++;
        -:  332:    }
        -:  333:
    #####:  334:  for (i = 0; i < state->handCount[player]; i++)
        -:  335:    {
    #####:  336:      if (state->hand[player][i] == card) count++;
        -:  337:    }
        -:  338:
    #####:  339:  for (i = 0; i < state->discardCount[player]; i++)
        -:  340:    {
    #####:  341:      if (state->discard[player][i] == card) count++;
        -:  342:    }
        -:  343:
    #####:  344:  return count;
        -:  345:}
        -:  346:
      393:  347:int whoseTurn(struct gameState *state) {
      393:  348:  return state->whoseTurn;
        -:  349:}
        -:  350:
      207:  351:int endTurn(struct gameState *state) {
        -:  352:  int k;
        -:  353:  int i;
      207:  354:  int currentPlayer = whoseTurn(state);
        -:  355:  
        -:  356:  //Discard hand
     1198:  357:  for (i = 0; i < state->handCount[currentPlayer]; i++){
      991:  358:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
      991:  359:    state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  360:  }
      207:  361:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  362:    
        -:  363:  //Code for determining the player
      207:  364:  if (currentPlayer < (state->numPlayers - 1)){ 
       82:  365:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  366:  }
        -:  367:  else{
      125:  368:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  369:  }
        -:  370:
      207:  371:  state->outpostPlayed = 0;
      207:  372:  state->phase = 0;
      207:  373:  state->numActions = 1;
      207:  374:  state->coins = 0;
      207:  375:  state->numBuys = 1;
      207:  376:  state->playedCardCount = 0;
      207:  377:  state->handCount[state->whoseTurn] = 0;
        -:  378:
        -:  379:  //int k; move to top
        -:  380:  //Next player draws hand
     1242:  381:  for (k = 0; k < 5; k++){
     1035:  382:    drawCard(state->whoseTurn, state);//Draw a card
        -:  383:  }
        -:  384:
        -:  385:  //Update money
      207:  386:  updateCoins(state->whoseTurn, state , 0);
        -:  387:
      207:  388:  return 0;
        -:  389:}
        -:  390:
      209:  391:int isGameOver(struct gameState *state) {
        -:  392:  int i;
        -:  393:  int j;
        -:  394:	
        -:  395:  //if stack of Province cards is empty, the game ends
      209:  396:  if (state->supplyCount[province] == 0)
        -:  397:    {
    #####:  398:      return 1;
        -:  399:    }
        -:  400:
        -:  401:  //if three supply pile are at 0, the game ends
      209:  402:  j = 0;
     5434:  403:  for (i = 0; i < 25; i++)
        -:  404:    {
     5225:  405:      if (state->supplyCount[i] == 0)
        -:  406:	{
      296:  407:	  j++;
        -:  408:	}
        -:  409:    }
      209:  410:  if ( j >= 3)
        -:  411:    {
        2:  412:      return 1;
        -:  413:    }
        -:  414:
      207:  415:  return 0;
        -:  416:}
        -:  417:
        3:  418:int scoreFor (int player, struct gameState *state) {
        -:  419:
        -:  420:  int i;
        3:  421:  int score = 0;
        -:  422:  //score from hand
       13:  423:  for (i = 0; i < state->handCount[player]; i++)
        -:  424:    {
       10:  425:      if (state->hand[player][i] == curse) { score = score - 1; };
       10:  426:      if (state->hand[player][i] == estate) { score = score + 1; };
       10:  427:      if (state->hand[player][i] == duchy) { score = score + 3; };
       10:  428:      if (state->hand[player][i] == province) { score = score + 6; };
       10:  429:      if (state->hand[player][i] == great_hall) { score = score + 1; };
       10:  430:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
        -:  431:    }
        -:  432:
        -:  433:  //score from discard
       46:  434:  for (i = 0; i < state->discardCount[player]; i++)
        -:  435:    {
       43:  436:      if (state->discard[player][i] == curse) { score = score - 1; };
       43:  437:      if (state->discard[player][i] == estate) { score = score + 1; };
       43:  438:      if (state->discard[player][i] == duchy) { score = score + 3; };
       43:  439:      if (state->discard[player][i] == province) { score = score + 6; };
       43:  440:      if (state->discard[player][i] == great_hall) { score = score + 1; };
       43:  441:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
        -:  442:    }
        -:  443:
        -:  444:  //score from deck
       46:  445:  for (i = 0; i < state->discardCount[player]; i++)
        -:  446:    {
       43:  447:      if (state->deck[player][i] == curse) { score = score - 1; };
       43:  448:      if (state->deck[player][i] == estate) { score = score + 1; };
       43:  449:      if (state->deck[player][i] == duchy) { score = score + 3; };
       43:  450:      if (state->deck[player][i] == province) { score = score + 6; };
       43:  451:      if (state->deck[player][i] == great_hall) { score = score + 1; };
       43:  452:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
        -:  453:    }
        -:  454:
        3:  455:  return score;
        -:  456:}
        -:  457:
    #####:  458:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  459:  int i;	
        -:  460:  int j;
        -:  461:  int highScore;
        -:  462:  int currentPlayer;
        -:  463:
        -:  464:  //get score for each player
    #####:  465:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  466:    {
        -:  467:      //set unused player scores to -9999
    #####:  468:      if (i >= state->numPlayers)
        -:  469:	{
    #####:  470:	  players[i] = -9999;
        -:  471:	}
        -:  472:      else
        -:  473:	{
    #####:  474:	  players[i] = scoreFor (i, state);
        -:  475:	}
        -:  476:    }
        -:  477:
        -:  478:  //find highest score
    #####:  479:  j = 0;
    #####:  480:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  481:    {
    #####:  482:      if (players[i] > players[j])
        -:  483:	{
    #####:  484:	  j = i;
        -:  485:	}
        -:  486:    }
    #####:  487:  highScore = players[j];
        -:  488:
        -:  489:  //add 1 to players who had less turns
    #####:  490:  currentPlayer = whoseTurn(state);
    #####:  491:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  492:    {
    #####:  493:      if ( players[i] == highScore && i > currentPlayer )
        -:  494:	{
    #####:  495:	  players[i]++;
        -:  496:	}
        -:  497:    }
        -:  498:
        -:  499:  //find new highest score
    #####:  500:  j = 0;
    #####:  501:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  502:    {
    #####:  503:      if ( players[i] > players[j] )
        -:  504:	{
    #####:  505:	  j = i;
        -:  506:	}
        -:  507:    }
    #####:  508:  highScore = players[j];
        -:  509:
        -:  510:  //set winners in array to 1 and rest to 0
    #####:  511:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  512:    {
    #####:  513:      if ( players[i] == highScore )
        -:  514:	{
    #####:  515:	  players[i] = 1;
        -:  516:	}
        -:  517:      else
        -:  518:	{
    #####:  519:	  players[i] = 0;
        -:  520:	}
        -:  521:    }
        -:  522:
    #####:  523:  return 0;
        -:  524:}
        -:  525:
     1045:  526:int drawCard(int player, struct gameState *state)
        -:  527:{	int count;
        -:  528:  int deckCounter;
     1045:  529:  if (state->deckCount[player] <= 0){//Deck is empty
        -:  530:    
        -:  531:    //Step 1 Shuffle the discard pile back into a deck
        -:  532:    int i;
        -:  533:    //Move discard to deck
     1144:  534:    for (i = 0; i < state->discardCount[player];i++){
     1087:  535:      state->deck[player][i] = state->discard[player][i];
     1087:  536:      state->discard[player][i] = -1;
        -:  537:    }
        -:  538:
       57:  539:    state->deckCount[player] = state->discardCount[player];
       57:  540:    state->discardCount[player] = 0;//Reset discard
        -:  541:
        -:  542:    //Shufffle the deck
       57:  543:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  544:   
       57:  545:    if (DEBUG){//Debug statements
        -:  546:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  547:    }
        -:  548:    
       57:  549:    state->discardCount[player] = 0;
        -:  550:
        -:  551:    //Step 2 Draw Card
       57:  552:    count = state->handCount[player];//Get current player's hand count
        -:  553:    
       57:  554:    if (DEBUG){//Debug statements
        -:  555:      printf("Current hand count: %d\n", count);
        -:  556:    }
        -:  557:    
       57:  558:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  559:
       57:  560:    if (deckCounter == 0)
    #####:  561:      return -1;
        -:  562:
       57:  563:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
       57:  564:    state->deckCount[player]--;
       57:  565:    state->handCount[player]++;//Increment hand count
        -:  566:  }
        -:  567:
        -:  568:  else{
      988:  569:    int count = state->handCount[player];//Get current hand count for player
        -:  570:    int deckCounter;
      988:  571:    if (DEBUG){//Debug statements
        -:  572:      printf("Current hand count: %d\n", count);
        -:  573:    }
        -:  574:
      988:  575:    deckCounter = state->deckCount[player];//Create holder for the deck count
      988:  576:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
      988:  577:    state->deckCount[player]--;
      988:  578:    state->handCount[player]++;//Increment hand count
        -:  579:  }
        -:  580:
     1045:  581:  return 0;
        -:  582:}
        -:  583:
     3952:  584:int getCost(int cardNumber)
        -:  585:{
     3952:  586:  switch( cardNumber ) 
        -:  587:    {
        -:  588:    case curse:
    #####:  589:      return 0;
        -:  590:    case estate:
      306:  591:      return 2;
        -:  592:    case duchy:
      215:  593:      return 5;
        -:  594:    case province:
      210:  595:      return 8;
        -:  596:    case copper:
      452:  597:      return 0;
        -:  598:    case silver:
      317:  599:      return 3;
        -:  600:    case gold:
      211:  601:      return 6;
        -:  602:    case adventurer:
       85:  603:      return 6;
        -:  604:    case council_room:
    #####:  605:      return 5;
        -:  606:    case feast:
    #####:  607:      return 4;
        -:  608:    case gardens:
      214:  609:      return 4;
        -:  610:    case mine:
      212:  611:      return 5;
        -:  612:    case remodel:
      216:  613:      return 4;
        -:  614:    case smithy:
    #####:  615:      return 4;
        -:  616:    case village:
    #####:  617:      return 3;
        -:  618:    case baron:
       89:  619:      return 4;
        -:  620:    case great_hall:
      139:  621:      return 3;
        -:  622:    case minion:
      210:  623:      return 5;
        -:  624:    case steward:
    #####:  625:      return 3;
        -:  626:    case tribute:
    #####:  627:      return 5;
        -:  628:    case ambassador:
      266:  629:      return 3;
        -:  630:    case cutpurse:
      216:  631:      return 4;
        -:  632:    case embargo: 
      250:  633:      return 2;
        -:  634:    case outpost:
      125:  635:      return 5;
        -:  636:    case salvager:
    #####:  637:      return 4;
        -:  638:    case sea_hag:
      131:  639:      return 4;
        -:  640:    case treasure_map:
       88:  641:      return 4;
        -:  642:    }
        -:  643:	
    #####:  644:  return -1;
        -:  645:}
        -:  646:
    #####:  647:int adventurerCard(int drawntreasure, struct gameState *state, int currentPlayer, int cardDrawn, int temphand [], int handPos, int z, int i){
    #####:  648:  int count = 0;
        -:  649:
    #####:  650:  while(drawntreasure<2){
    #####:  651:    count++;
    #####:  652:    if (state->deckCount[currentPlayer] <1)//if the deck is empty we need to shuffle discard and add to deck
    #####:  653:      shuffle(currentPlayer, state);
    #####:  654:    drawCard(currentPlayer, state);
    #####:  655:    cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
    #####:  656:    if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
    #####:  657:      drawntreasure++;
        -:  658:    else{
    #####:  659:      temphand[z]=cardDrawn;
    #####:  660:      state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####:  661:      z++;
        -:  662:    }
        -:  663:  }
        -:  664:
    #####:  665:  while(z-1>=0){
    #####:  666:    state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
    #####:  667:    z=z-1;
        -:  668:  }
        -:  669:
    #####:  670:  discardCard(handPos, currentPlayer, state, 0);
        -:  671:  //printf("count = %d\n", count);
        -:  672:
    #####:  673:  return 0;
        -:  674:}
        -:  675:
    #####:  676:int councilRoomCard(struct gameState *state, int currentPlayer, int handPos, int i){
    #####:  677:  for (i = 0; i < 4; i++)
    #####:  678:    drawCard(currentPlayer, state);
    #####:  679:  state->numBuys++;
    #####:  680:  for (i = 0; i < state->numPlayers; i++){  //Each other player draws a card
    #####:  681:    if ( i != currentPlayer )
    #####:  682:      drawCard(i, state);
        -:  683:  }
    #####:  684:  discardCard(handPos, currentPlayer, state, 0); //put played card in played card pile
        -:  685:      
    #####:  686:  return 0;
        -:  687:}
        -:  688:
    #####:  689:int feastCard(struct gameState *state, int temphand [], int currentPlayer, int choice1, int i, int x){
    #####:  690:  for (i = 0; i <= state->handCount[currentPlayer]; i++){  
    #####:  691:    temphand[i] = state->hand[currentPlayer][i];
    #####:  692:    state->hand[currentPlayer][i] = -1;
        -:  693:  }
    #####:  694:  updateCoins(currentPlayer, state, 5);
    #####:  695:  x = 1;
    #####:  696:  while( x == 1) {
    #####:  697:    if (supplyCount(choice1, state) <= 0){
    #####:  698:      if (DEBUG)
        -:  699:        printf("None of that card left, sorry!\n");
        -:  700:
    #####:  701:      if (DEBUG)
        -:  702:        printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  703:    }
    #####:  704:    else if (state->coins < getCost(choice1)){
    #####:  705:      printf("That card is too expensive!\n");
    #####:  706:      if (DEBUG)
        -:  707:        printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  708:    }
        -:  709:    else{
    #####:  710:      if (DEBUG)
        -:  711:        printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
    #####:  712:      gainCard(choice1, state, 0, currentPlayer);
    #####:  713:      x = 0;
    #####:  714:      if (DEBUG)
        -:  715:        printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  716:    }
        -:  717:  }
        -:  718:
    #####:  719:  for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  720:    state->hand[currentPlayer][i] = temphand[i];
    #####:  721:    temphand[i] = -1;
        -:  722:  }
        -:  723:            
    #####:  724:      return 0;
        -:  725:}
        -:  726:
    #####:  727:int mineCard(struct gameState *state, int currentPlayer, int choice1, int choice2, int handPos, int i, int j){
    #####:  728:  j = state->hand[currentPlayer][choice1];  //store card we will trash
    #####:  729:  if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
    #####:  730:    return -1;  
    #####:  731:  if (choice2 > treasure_map || choice2 < curse)
    #####:  732:    return -1;
    #####:  733:  if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
    #####:  734:    return -1;
    #####:  735:  gainCard(choice2, state, 2, currentPlayer);
    #####:  736:  discardCard(handPos, currentPlayer, state, 0);
    #####:  737:  for (i = 0; i < state->handCount[currentPlayer]; i++){
    #####:  738:    if (state->hand[currentPlayer][i] == j){
    #####:  739:      discardCard(i, currentPlayer, state, 0);      
    #####:  740:      break;
        -:  741:    }
        -:  742:  }
        -:  743:      
    #####:  744:      return 0;
        -:  745:}
        -:  746:
        3:  747:int remodelCard(struct gameState *state, int currentPlayer, int choice1, int choice2, int handPos, int i, int j){
        3:  748:  j = state->hand[currentPlayer][choice1];  //store card we will trash
        3:  749:  if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
        1:  750:    return -1;
        2:  751:  gainCard(choice2, state, 0, currentPlayer);
        2:  752:  discardCard(handPos, currentPlayer, state, 0);
        3:  753:  for (i = 0; i < state->handCount[currentPlayer]; i++){
        3:  754:    if (state->hand[currentPlayer][i] == j){
        2:  755:        discardCard(i, currentPlayer, state, 0);      
        2:  756:        break;
        -:  757:    }
        -:  758:  }
        2:  759:      return 0;
        -:  760:}
        -:  761:
       93:  762:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  763:{
        -:  764:  int i;
        -:  765:  int j;
        -:  766:  int k;
        -:  767:  int x;
        -:  768:  int index;
       93:  769:  int currentPlayer = whoseTurn(state);
       93:  770:  int nextPlayer = currentPlayer + 1;
        -:  771:
       93:  772:  int tributeRevealedCards[2] = {-1, -1};
        -:  773:  int temphand[MAX_HAND];// moved above the if statement
       93:  774:  int drawntreasure=0;
        -:  775:  int cardDrawn;
       93:  776:  int z = 0;// this is the counter for the temp hand
       93:  777:  if (nextPlayer > (state->numPlayers - 1)){
       56:  778:    nextPlayer = 0;
        -:  779:  }
        -:  780:  
        -:  781:	
        -:  782:  //uses switch to select card and perform actions
       93:  783:  switch( card ) 
        -:  784:    {
        -:  785:    case adventurer:
    #####:  786:      adventurerCard(drawntreasure, state, currentPlayer, cardDrawn, temphand, handPos, z, i);
    #####:  787:      break;
        -:  788:      
        -:  789:    case council_room:
    #####:  790:      councilRoomCard(state, currentPlayer, handPos, i);
    #####:  791:      break;
        -:  792:			
        -:  793:    case feast:
    #####:  794:      feastCard(state, temphand, currentPlayer, choice1, i, x);
    #####:  795:      break;
        -:  796:
        -:  797:    case gardens:
    #####:  798:      return -1;
        -:  799:			
        -:  800:    case mine:
    #####:  801:      mineCard(state, currentPlayer, choice1, choice2, handPos, i, j);
    #####:  802:      break;
        -:  803:			
        -:  804:    case remodel:
        3:  805:      remodelCard(state, currentPlayer, choice1, choice2, handPos, i, j);
        3:  806:      break;
        -:  807:		
        -:  808:    case smithy:
        -:  809:      //+3 Cards
    #####:  810:      for (i = 0; i < 3; i++)
        -:  811:	{
    #####:  812:	  drawCard(currentPlayer, state);
        -:  813:	}
        -:  814:			
        -:  815:      //discard card from hand
    #####:  816:      discardCard(handPos, currentPlayer, state, 0);
    #####:  817:      return 0;
        -:  818:		
        -:  819:    case village:
        -:  820:      //+1 Card
    #####:  821:      drawCard(currentPlayer, state);
        -:  822:			
        -:  823:      //+2 Actions
    #####:  824:      state->numActions = state->numActions + 2;
        -:  825:			
        -:  826:      //discard played card from hand
    #####:  827:      discardCard(handPos, currentPlayer, state, 0);
    #####:  828:      return 0;
        -:  829:		
        -:  830:    case baron:
        7:  831:      state->numBuys++;//Increase buys by 1!
        7:  832:      if (choice1 > 0){//Boolean true or going to discard an estate
        3:  833:	int p = 0;//Iterator for hand!
        3:  834:	int card_not_discarded = 1;//Flag for discard set!
       22:  835:	while(card_not_discarded){
       16:  836:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
        1:  837:	    state->coins += 4;//Add 4 coins to the amount of coins
        1:  838:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
        1:  839:	    state->discardCount[currentPlayer]++;
        5:  840:	    for (;p < state->handCount[currentPlayer]; p++){
        4:  841:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
        -:  842:	    }
        1:  843:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
        1:  844:	    state->handCount[currentPlayer]--;
        1:  845:	    card_not_discarded = 0;//Exit the loop
        -:  846:	  }
       15:  847:	  else if (p > state->handCount[currentPlayer]){
        2:  848:	    if(DEBUG) {
        -:  849:	      printf("No estate cards in your hand, invalid choice\n");
        -:  850:	      printf("Must gain an estate if there are any\n");
        -:  851:	    }
        2:  852:	    if (supplyCount(estate, state) > 0){
    #####:  853:	      gainCard(estate, state, 0, currentPlayer);
    #####:  854:	      state->supplyCount[estate]--;//Decrement estates
    #####:  855:	      if (supplyCount(estate, state) == 0){
    #####:  856:		isGameOver(state);
        -:  857:	      }
        -:  858:	    }
        2:  859:	    card_not_discarded = 0;//Exit the loop
        -:  860:	  }
        -:  861:			    
        -:  862:	  else{
       13:  863:	    p++;//Next card
        -:  864:	  }
        -:  865:	}
        -:  866:      }
        -:  867:			    
        -:  868:      else{
        4:  869:	if (supplyCount(estate, state) > 0){
    #####:  870:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  871:	  state->supplyCount[estate]--;//Decrement Estates
    #####:  872:	  if (supplyCount(estate, state) == 0){
    #####:  873:	    isGameOver(state);
        -:  874:	  }
        -:  875:	}
        -:  876:      }
        -:  877:	    
        -:  878:      
        7:  879:      return 0;
        -:  880:		
        -:  881:    case great_hall:
        -:  882:      //+1 Card
    #####:  883:      drawCard(currentPlayer, state);
        -:  884:			
        -:  885:      //+1 Actions
    #####:  886:      state->numActions++;
        -:  887:			
        -:  888:      //discard card from hand
    #####:  889:      discardCard(handPos, currentPlayer, state, 0);
    #####:  890:      return 0;
        -:  891:		
        -:  892:    case minion:
        -:  893:      //+1 action
    #####:  894:      state->numActions++;
        -:  895:			
        -:  896:      //discard card from hand
    #####:  897:      discardCard(handPos, currentPlayer, state, 0);
        -:  898:			
    #####:  899:      if (choice1)		//+2 coins
        -:  900:	{
    #####:  901:	  state->coins = state->coins + 2;
        -:  902:	}
        -:  903:			
    #####:  904:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  905:	{
        -:  906:	  //discard hand
    #####:  907:	  while(numHandCards(state) > 0)
        -:  908:	    {
    #####:  909:	      discardCard(handPos, currentPlayer, state, 0);
        -:  910:	    }
        -:  911:				
        -:  912:	  //draw 4
    #####:  913:	  for (i = 0; i < 4; i++)
        -:  914:	    {
    #####:  915:	      drawCard(currentPlayer, state);
        -:  916:	    }
        -:  917:				
        -:  918:	  //other players discard hand and redraw if hand size > 4
    #####:  919:	  for (i = 0; i < state->numPlayers; i++)
        -:  920:	    {
    #####:  921:	      if (i != currentPlayer)
        -:  922:		{
    #####:  923:		  if ( state->handCount[i] > 4 )
        -:  924:		    {
        -:  925:		      //discard hand
    #####:  926:		      while( state->handCount[i] > 0 )
        -:  927:			{
    #####:  928:			  discardCard(handPos, i, state, 0);
        -:  929:			}
        -:  930:							
        -:  931:		      //draw 4
    #####:  932:		      for (j = 0; j < 4; j++)
        -:  933:			{
    #####:  934:			  drawCard(i, state);
        -:  935:			}
        -:  936:		    }
        -:  937:		}
        -:  938:	    }
        -:  939:				
        -:  940:	}
    #####:  941:      return 0;
        -:  942:		
        -:  943:    case steward:
        -:  944:     //discard card from hand
    #####:  945:      discardCard(handPos, currentPlayer, state, 0);
    #####:  946:      if (choice1 == 1)
        -:  947:	{
        -:  948:	  //+2 cards
    #####:  949:	  drawCard(currentPlayer, state);
    #####:  950:	  drawCard(currentPlayer, state);
        -:  951:	}
    #####:  952:      else if (choice1 == 2)
        -:  953:	{
        -:  954:	  //+2 coins
    #####:  955:	  state->coins = state->coins + 2;
        -:  956:	}
        -:  957:      else
        -:  958:	{
        -:  959:	  //trash 2 cards in hand
    #####:  960:	  discardCard(choice2, currentPlayer, state, 1);
    #####:  961:	  discardCard(choice3, currentPlayer, state, 1);
        -:  962:	}
        -:  963:			
    #####:  964:      return 0;
        -:  965:		
        -:  966:    case tribute:
    #####:  967:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####:  968:	if (state->deckCount[nextPlayer] > 0){
    #####:  969:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  970:	  state->deckCount[nextPlayer]--;
        -:  971:	}
    #####:  972:	else if (state->discardCount[nextPlayer] > 0){
    #####:  973:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####:  974:	  state->discardCount[nextPlayer]--;
        -:  975:	}
        -:  976:	else{
        -:  977:	  //No Card to Reveal
    #####:  978:	  if (DEBUG){
        -:  979:	    printf("No cards to reveal\n");
        -:  980:	  }
        -:  981:	}
        -:  982:      }
        -:  983:	    
        -:  984:      else{
    #####:  985:	if (state->deckCount[nextPlayer] == 0){
    #####:  986:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####:  987:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####:  988:	    state->deckCount[nextPlayer]++;
    #####:  989:	    state->discard[nextPlayer][i] = -1;
    #####:  990:	    state->discardCount[nextPlayer]--;
        -:  991:	  }
        -:  992:			    
    #####:  993:	  shuffle(nextPlayer,state);//Shuffle the deck
        -:  994:	} 
    #####:  995:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  996:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  997:	state->deckCount[nextPlayer]--;
    #####:  998:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  999:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1000:	state->deckCount[nextPlayer]--;
        -: 1001:      }    
        -: 1002:		       
    #####: 1003:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
    #####: 1004:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1005:	state->playedCardCount++;
    #####: 1006:	tributeRevealedCards[1] = -1;
        -: 1007:      }
        -: 1008:
    #####: 1009:      for (i = 0; i <= 2; i ++){
    #####: 1010:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
    #####: 1011:	  state->coins += 2;
        -: 1012:	}
        -: 1013:		    
    #####: 1014:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
    #####: 1015:	  drawCard(currentPlayer, state);
    #####: 1016:	  drawCard(currentPlayer, state);
        -: 1017:	}
        -: 1018:	else{//Action Card
    #####: 1019:	  state->numActions = state->numActions + 2;
        -: 1020:	}
        -: 1021:      }
        -: 1022:	    
    #####: 1023:      return 0;
        -: 1024:		
        -: 1025:    case ambassador:
        -: 1026:
       27: 1027:      j = 0;		//used to check if player has enough cards to discard
        -: 1028:
       27: 1029:      if (choice2 > 2 || choice2 < 0)
        -: 1030:	{
    #####: 1031:	  return -1;				
        -: 1032:	}
        -: 1033:
       27: 1034:      if (choice1 == handPos)
        -: 1035:	{
    #####: 1036:	  return -1;
        -: 1037:	}
        -: 1038:
      162: 1039:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1040:	{
      135: 1041:	  if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1042:	    {
        6: 1043:	      j++;
        -: 1044:	    }
        -: 1045:	}
       27: 1046:      if (j < choice2)
        -: 1047:	{
       13: 1048:	  return -1;				
        -: 1049:	}
        -: 1050:
       14: 1051:      if (DEBUG) 
        -: 1052:	printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1053:
        -: 1054:      //increase supply count for choosen card by amount being discarded
       14: 1055:      state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1056:			
        -: 1057:      //each other player gains a copy of revealed card
       40: 1058:      for (i = 0; i < state->numPlayers; i++)
        -: 1059:	{
       26: 1060:	  if (i != currentPlayer)
        -: 1061:	    {
       12: 1062:	      gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1063:	    }
        -: 1064:	}
        -: 1065:
        -: 1066:      //discard played card from hand
       14: 1067:      discardCard(handPos, currentPlayer, state, 0);			
        -: 1068:
        -: 1069:      //trash copies of cards returned to supply
       18: 1070:      for (j = 0; j < choice2; j++)
        -: 1071:	{
       10: 1072:	  for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1073:	    {
       10: 1074:	      if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1075:		{
        4: 1076:		  discardCard(i, currentPlayer, state, 1);
        4: 1077:		  break;
        -: 1078:		}
        -: 1079:	    }
        -: 1080:	}			
        -: 1081:
       14: 1082:      return 0;
        -: 1083:		
        -: 1084:    case cutpurse:
        -: 1085:
        3: 1086:      updateCoins(currentPlayer, state, 2);
        9: 1087:      for (i = 0; i < state->numPlayers; i++)
        -: 1088:	{
        6: 1089:	  if (i != currentPlayer)
        -: 1090:	    {
        3: 1091:	      for (j = 0; j < state->handCount[i]; j++)
        -: 1092:		{
    #####: 1093:		  if (state->hand[i][j] == copper)
        -: 1094:		    {
    #####: 1095:		      discardCard(j, i, state, 0);
    #####: 1096:		      break;
        -: 1097:		    }
    #####: 1098:		  if (j == state->handCount[i])
        -: 1099:		    {
    #####: 1100:		      for (k = 0; k < state->handCount[i]; k++)
        -: 1101:			{
    #####: 1102:			  if (DEBUG)
        -: 1103:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1104:			}	
    #####: 1105:		      break;
        -: 1106:		    }		
        -: 1107:		}
        -: 1108:					
        -: 1109:	    }
        -: 1110:				
        -: 1111:	}				
        -: 1112:
        -: 1113:      //discard played card from hand
        3: 1114:      discardCard(handPos, currentPlayer, state, 0);			
        -: 1115:
        3: 1116:      return 0;
        -: 1117:
        -: 1118:		
        -: 1119:    case embargo: 
        -: 1120:      //+2 Coins
       18: 1121:      state->coins = state->coins + 2;
        -: 1122:			
        -: 1123:      //see if selected pile is in play
       18: 1124:      if ( state->supplyCount[choice1] == -1 )
        -: 1125:	{
    #####: 1126:	  return -1;
        -: 1127:	}
        -: 1128:			
        -: 1129:      //add embargo token to selected supply pile
       18: 1130:      state->embargoTokens[choice1]++;
        -: 1131:			
        -: 1132:      //trash card
       18: 1133:      discardCard(handPos, currentPlayer, state, 1);		
       18: 1134:      return 0;
        -: 1135:		
        -: 1136:    case outpost:
        -: 1137:      //set outpost flag
    #####: 1138:      state->outpostPlayed++;
        -: 1139:			
        -: 1140:      //discard card
    #####: 1141:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1142:      return 0;
        -: 1143:		
        -: 1144:    case salvager:
        -: 1145:      //+1 buy
    #####: 1146:      state->numBuys++;
        -: 1147:			
    #####: 1148:      if (choice1)
        -: 1149:	{
        -: 1150:	  //gain coins equal to trashed card
    #####: 1151:	  state->coins = state->coins + getCost( handCard(choice1, state) );
        -: 1152:	  //trash card
    #####: 1153:	  discardCard(choice1, currentPlayer, state, 1);	
        -: 1154:	}
        -: 1155:			
        -: 1156:      //discard card
    #####: 1157:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1158:      return 0;
        -: 1159:		
        -: 1160:    case sea_hag:
       30: 1161:      for (i = 0; i < state->numPlayers; i++){
       20: 1162:	if (i != currentPlayer){
       10: 1163:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
       10: 1164:	  state->discardCount[i]++;
       10: 1165:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1166:	}
        -: 1167:      }
       10: 1168:      return 0;
        -: 1169:		
        -: 1170:    case treasure_map:
        -: 1171:      //search hand for another treasure_map
       25: 1172:      index = -1;
      150: 1173:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1174:	{
      125: 1175:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -: 1176:	    {
    #####: 1177:	      index = i;
    #####: 1178:	      break;
        -: 1179:	    }
        -: 1180:	}
       25: 1181:      if (index > -1)
        -: 1182:	{
        -: 1183:	  //trash both treasure cards
    #####: 1184:	  discardCard(handPos, currentPlayer, state, 1);
    #####: 1185:	  discardCard(index, currentPlayer, state, 1);
        -: 1186:
        -: 1187:	  //gain 4 Gold cards
    #####: 1188:	  for (i = 0; i < 4; i++)
        -: 1189:	    {
    #####: 1190:	      gainCard(gold, state, 1, currentPlayer);
        -: 1191:	    }
        -: 1192:				
        -: 1193:	  //return success
    #####: 1194:	  return 1;
        -: 1195:	}
        -: 1196:			
        -: 1197:      //no second treasure_map found in hand
       25: 1198:      return -1;
        -: 1199:    }
        -: 1200:
        3: 1201:  return -1;
        -: 1202:}
        -: 1203:
       43: 1204:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1205:{
        -: 1206:	
        -: 1207:  //if card is not trashed, added to Played pile 
       43: 1208:  if (trashFlag < 1)
        -: 1209:    {
        -: 1210:      //add card to played pile
       21: 1211:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
       21: 1212:      state->playedCardCount++;
        -: 1213:    }
        -: 1214:	
        -: 1215:  //set played card to -1
       43: 1216:  state->hand[currentPlayer][handPos] = -1;
        -: 1217:	
        -: 1218:  //remove card from player's hand
       43: 1219:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
        -: 1220:    {
        -: 1221:      //reduce number of cards in hand
        6: 1222:      state->handCount[currentPlayer]--;
        6: 1223:      state->discardCount[currentPlayer]++;
        -: 1224:    }
       37: 1225:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
        -: 1226:    {
        -: 1227:      //reduce number of cards in hand
    #####: 1228:      state->handCount[currentPlayer]--;
    #####: 1229:      state->discardCount[currentPlayer]++;
        -: 1230:    }
        -: 1231:  else 	
        -: 1232:    {
        -: 1233:      //replace discarded card with last card in hand
       37: 1234:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1235:      //set last card to -1
       37: 1236:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1237:      //reduce number of cards in hand
       37: 1238:      state->handCount[currentPlayer]--;
       37: 1239:      state->discardCount[currentPlayer]++;
        -: 1240:    }
        -: 1241:	
       43: 1242:  return 0;
        -: 1243:}
        -: 1244:
      106: 1245:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1246:{
        -: 1247:  //Note: supplyPos is enum of choosen card
        -: 1248:	
        -: 1249:  //check if supply pile is empty (0) or card is not used in game (-1)
      106: 1250:  if ( supplyCount(supplyPos, state) < 1 )
        -: 1251:    {
        2: 1252:      return -1;
        -: 1253:    }
        -: 1254:	
        -: 1255:  //added card for [whoseTurn] current player:
        -: 1256:  // toFlag = 0 : add to discard
        -: 1257:  // toFlag = 1 : add to deck
        -: 1258:  // toFlag = 2 : add to hand
        -: 1259:
      104: 1260:  if (toFlag == 1)
        -: 1261:    {
    #####: 1262:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
    #####: 1263:      state->deckCount[player]++;
        -: 1264:    }
      104: 1265:  else if (toFlag == 2)
        -: 1266:    {
    #####: 1267:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
    #####: 1268:      state->handCount[player]++;
        -: 1269:    }
        -: 1270:  else
        -: 1271:    {
      104: 1272:      state->discard[player][ state->discardCount[player] ] = supplyPos;
      104: 1273:      state->discardCount[player]++;
        -: 1274:    }
        -: 1275:	
        -: 1276:  //decrease number in supply pile
      104: 1277:  state->supplyCount[supplyPos]--;
        -: 1278:	 
      104: 1279:  return 0;
        -: 1280:}
        -: 1281:
      264: 1282:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1283:{
        -: 1284:  int i;
        -: 1285:	
        -: 1286:  //reset coin count
      264: 1287:  state->coins = 0;
        -: 1288:
        -: 1289:  //add coins for each Treasure card in player's hand
     1542: 1290:  for (i = 0; i < state->handCount[player]; i++)
        -: 1291:    {
     1278: 1292:      if (state->hand[player][i] == copper)
        -: 1293:	{
      436: 1294:	  state->coins += 1;
        -: 1295:	}
      842: 1296:      else if (state->hand[player][i] == silver)
        -: 1297:	{
       45: 1298:	  state->coins += 2;
        -: 1299:	}
      797: 1300:      else if (state->hand[player][i] == gold)
        -: 1301:	{
    #####: 1302:	  state->coins += 3;
        -: 1303:	}	
        -: 1304:    }	
        -: 1305:
        -: 1306:  //add bonus
      264: 1307:  state->coins += bonus;
        -: 1308:
      264: 1309:  return 0;
        -: 1310:}
        -: 1311:
        -: 1312://end of dominion.c
        -: 1313:
File 'dominion.c'
Lines executed:59.56% of 586
dominion.c:creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:3
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
     5254:    8:int compare(const void* a, const void* b) {
     5254:    9:  if (*(int*)a > *(int*)b)
     2478:   10:    return 1;
     2776:   11:  if (*(int*)a < *(int*)b)
      846:   12:    return -1;
     1930:   13:  return 0;
        -:   14:}
        -:   15:
    #####:   16:struct gameState* newGame() {
    #####:   17:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:  return g;
        -:   19:}
        -:   20:
    #####:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:		  int k8, int k9, int k10) {
    #####:   23:  int* k = malloc(10 * sizeof(int));
    #####:   24:  k[0] = k1;
    #####:   25:  k[1] = k2;
    #####:   26:  k[2] = k3;
    #####:   27:  k[3] = k4;
    #####:   28:  k[4] = k5;
    #####:   29:  k[5] = k6;
    #####:   30:  k[6] = k7;
    #####:   31:  k[7] = k8;
    #####:   32:  k[8] = k9;
    #####:   33:  k[9] = k10;
    #####:   34:  return k;
        -:   35:}
        -:   36:
        3:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		   struct gameState *state) {
        -:   39:
        -:   40:  int i;
        -:   41:  int j;
        -:   42:  int it;			
        -:   43:  //set up random number generator
        3:   44:  SelectStream(1);
        3:   45:  PutSeed((long)randomSeed);
        -:   46:  
        -:   47:  //check number of players
        3:   48:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:    {
    #####:   50:      return -1;
        -:   51:    }
        -:   52:
        -:   53:  //set number of players
        3:   54:  state->numPlayers = numPlayers;
        -:   55:
        -:   56:  //check selected kingdom cards are different
       33:   57:  for (i = 0; i < 10; i++)
        -:   58:    {
      330:   59:      for (j = 0; j < 10; j++)
        -:   60:        {
      300:   61:	  if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:	    {
    #####:   63:	      return -1;
        -:   64:	    }
        -:   65:        }
        -:   66:    }
        -:   67:
        -:   68:
        -:   69:  //initialize supply
        -:   70:  ///////////////////////////////
        -:   71:
        -:   72:  //set number of Curse cards
        3:   73:  if (numPlayers == 2)
        -:   74:    {
        3:   75:      state->supplyCount[curse] = 10;
        -:   76:    }
    #####:   77:  else if (numPlayers == 3)
        -:   78:    {
    #####:   79:      state->supplyCount[curse] = 20;
        -:   80:    }
        -:   81:  else
        -:   82:    {
    #####:   83:      state->supplyCount[curse] = 30;
        -:   84:    }
        -:   85:
        -:   86:  //set number of Victory cards
        3:   87:  if (numPlayers == 2)
        -:   88:    {
        3:   89:      state->supplyCount[estate] = 8;
        3:   90:      state->supplyCount[duchy] = 8;
        3:   91:      state->supplyCount[province] = 8;
        -:   92:    }
        -:   93:  else
        -:   94:    {
    #####:   95:      state->supplyCount[estate] = 12;
    #####:   96:      state->supplyCount[duchy] = 12;
    #####:   97:      state->supplyCount[province] = 12;
        -:   98:    }
        -:   99:
        -:  100:  //set number of Treasure cards
        3:  101:  state->supplyCount[copper] = 60 - (7 * numPlayers);
        3:  102:  state->supplyCount[silver] = 40;
        3:  103:  state->supplyCount[gold] = 30;
        -:  104:
        -:  105:  //set number of Kingdom cards
       63:  106:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:    {
      495:  108:      for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:	{
      465:  110:	  if (kingdomCards[j] == i)
        -:  111:	    {
        -:  112:	      //check if card is a 'Victory' Kingdom card
       34:  113:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:		{
        4:  115:		  if (numPlayers == 2){ 
        4:  116:		    state->supplyCount[i] = 8; 
        -:  117:		  }
    #####:  118:		  else{ state->supplyCount[i] = 12; }
        -:  119:		}
        -:  120:	      else
        -:  121:		{
       26:  122:		  state->supplyCount[i] = 10;
        -:  123:		}
       30:  124:	      break;
        -:  125:	    }
        -:  126:	  else    //card is not in the set choosen for the game
        -:  127:	    {
      435:  128:	      state->supplyCount[i] = -1;
        -:  129:	    }
        -:  130:	}
        -:  131:
        -:  132:    }
        -:  133:
        -:  134:  ////////////////////////
        -:  135:  //supply intilization complete
        -:  136:
        -:  137:  //set player decks
        9:  138:  for (i = 0; i < numPlayers; i++)
        -:  139:    {
        6:  140:      state->deckCount[i] = 0;
       24:  141:      for (j = 0; j < 3; j++)
        -:  142:	{
       18:  143:	  state->deck[i][j] = estate;
       18:  144:	  state->deckCount[i]++;
        -:  145:	}
       48:  146:      for (j = 3; j < 10; j++)
        -:  147:	{
       42:  148:	  state->deck[i][j] = copper;
       42:  149:	  state->deckCount[i]++;		
        -:  150:	}
        -:  151:    }
        -:  152:
        -:  153:  //shuffle player decks
        9:  154:  for (i = 0; i < numPlayers; i++)
        -:  155:    {
        6:  156:      if ( shuffle(i, state) < 0 )
        -:  157:	{
    #####:  158:	  return -1;
        -:  159:	}
        -:  160:    }
        -:  161:
        -:  162:  //draw player hands
        9:  163:  for (i = 0; i < numPlayers; i++)
        -:  164:    {  
        -:  165:      //initialize hand size to zero
        6:  166:      state->handCount[i] = 0;
        6:  167:      state->discardCount[i] = 0;
        -:  168:      //draw 5 cards
        -:  169:      // for (j = 0; j < 5; j++)
        -:  170:      //	{
        -:  171:      //	  drawCard(i, state);
        -:  172:      //	}
        -:  173:    }
        -:  174:  
        -:  175:  //set embargo tokens to 0 for all supply piles
       84:  176:  for (i = 0; i <= treasure_map; i++)
        -:  177:    {
       81:  178:      state->embargoTokens[i] = 0;
        -:  179:    }
        -:  180:
        -:  181:  //initialize first player's turn
        3:  182:  state->outpostPlayed = 0;
        3:  183:  state->phase = 0;
        3:  184:  state->numActions = 1;
        3:  185:  state->numBuys = 1;
        3:  186:  state->playedCardCount = 0;
        3:  187:  state->whoseTurn = 0;
        3:  188:  state->handCount[state->whoseTurn] = 0;
        -:  189:  //int it; move to top
        -:  190:
        -:  191:  //Moved draw cards to here, only drawing at the start of a turn
       18:  192:  for (it = 0; it < 5; it++){
       15:  193:    drawCard(state->whoseTurn, state);
        -:  194:  }
        -:  195:
        3:  196:  updateCoins(state->whoseTurn, state, 0);
        -:  197:
        3:  198:  return 0;
        -:  199:}
        -:  200:
       90:  201:int shuffle(int player, struct gameState *state) {
        -:  202: 
        -:  203:
        -:  204:  int newDeck[MAX_DECK];
       90:  205:  int newDeckPos = 0;
        -:  206:  int card;
        -:  207:  int i;
        -:  208:
       90:  209:  if (state->deckCount[player] < 1)
    #####:  210:    return -1;
       90:  211:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
        -:  212:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
     1869:  214:  while (state->deckCount[player] > 0) {
     1689:  215:    card = floor(Random() * state->deckCount[player]);
     1689:  216:    newDeck[newDeckPos] = state->deck[player][card];
     1689:  217:    newDeckPos++;
    10395:  218:    for (i = card; i < state->deckCount[player]-1; i++) {
     8706:  219:      state->deck[player][i] = state->deck[player][i+1];
        -:  220:    }
     1689:  221:    state->deckCount[player]--;
        -:  222:  }
     1779:  223:  for (i = 0; i < newDeckPos; i++) {
     1689:  224:    state->deck[player][i] = newDeck[i];
     1689:  225:    state->deckCount[player]++;
        -:  226:  }
        -:  227:
       90:  228:  return 0;
        -:  229:}
        -:  230:
      158:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  232:{	
        -:  233:  int card;
      158:  234:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:  //check if it is the right phase
      158:  237:  if (state->phase != 0)
        -:  238:    {
    #####:  239:      return -1;
        -:  240:    }
        -:  241:	
        -:  242:  //check if player has enough actions
      158:  243:  if ( state->numActions < 1 )
        -:  244:    {
    #####:  245:      return -1;
        -:  246:    }
        -:  247:	
        -:  248:  //get card played
      158:  249:  card = handCard(handPos, state);
        -:  250:	
        -:  251:  //check if selected card is an action
      158:  252:  if ( card < adventurer || card > treasure_map )
        -:  253:    {
    #####:  254:      return -1;
        -:  255:    }
        -:  256:	
        -:  257:  //play card
      158:  258:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
        -:  259:    {
       51:  260:      return -1;
        -:  261:    }
        -:  262:	
        -:  263:  //reduce number of actions
        -:  264:
      107:  265:  state->numActions--;
        -:  266:
        -:  267:  //update coins (Treasure cards may be added with card draws)
      107:  268:  updateCoins(state->whoseTurn, state, coin_bonus);
        -:  269:	
      107:  270:  return 0;
        -:  271:}
        -:  272:
      216:  273:int buyCard(int supplyPos, struct gameState *state) {
        -:  274:  int who;
      216:  275:  if (DEBUG){
        -:  276:    printf("Entering buyCard...\n");
        -:  277:  }
        -:  278:
        -:  279:  // I don't know what to do about the phase thing.
        -:  280:
      216:  281:  who = state->whoseTurn;
        -:  282:
      216:  283:  if (state->numBuys < 1){
    #####:  284:    if (DEBUG)
        -:  285:      printf("You do not have any buys left\n");
    #####:  286:    return -1;
      216:  287:  } else if (supplyCount(supplyPos, state) <1){
    #####:  288:    if (DEBUG)
        -:  289:      printf("There are not any of that type of card left\n");
    #####:  290:    return -1;
      216:  291:  } else if (state->coins < getCost(supplyPos)){
       60:  292:    if (DEBUG) 
        -:  293:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
       60:  294:    return -1;
        -:  295:  } else {
      156:  296:    state->phase=1;
        -:  297:    //state->supplyCount[supplyPos]--;
      156:  298:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  299:  
      156:  300:    state->coins = (state->coins) - (getCost(supplyPos));
      156:  301:    state->numBuys--;
      156:  302:    if (DEBUG)
        -:  303:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  304:  }
        -:  305:
        -:  306:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  307:  //state->discardCount[who]++;
        -:  308:    
      156:  309:  return 0;
        -:  310:}
        -:  311:
    #####:  312:int numHandCards(struct gameState *state) {
    #####:  313:  return state->handCount[ whoseTurn(state) ];
        -:  314:}
        -:  315:
      158:  316:int handCard(int handPos, struct gameState *state) {
      158:  317:  int currentPlayer = whoseTurn(state);
      158:  318:  return state->hand[currentPlayer][handPos];
        -:  319:}
        -:  320:
      398:  321:int supplyCount(int card, struct gameState *state) {
      398:  322:  return state->supplyCount[card];
        -:  323:}
        -:  324:
    #####:  325:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  326:  int i;
    #####:  327:  int count = 0;
        -:  328:
    #####:  329:  for (i = 0; i < state->deckCount[player]; i++)
        -:  330:    {
    #####:  331:      if (state->deck[player][i] == card) count++;
        -:  332:    }
        -:  333:
    #####:  334:  for (i = 0; i < state->handCount[player]; i++)
        -:  335:    {
    #####:  336:      if (state->hand[player][i] == card) count++;
        -:  337:    }
        -:  338:
    #####:  339:  for (i = 0; i < state->discardCount[player]; i++)
        -:  340:    {
    #####:  341:      if (state->discard[player][i] == card) count++;
        -:  342:    }
        -:  343:
    #####:  344:  return count;
        -:  345:}
        -:  346:
      613:  347:int whoseTurn(struct gameState *state) {
      613:  348:  return state->whoseTurn;
        -:  349:}
        -:  350:
      297:  351:int endTurn(struct gameState *state) {
        -:  352:  int k;
        -:  353:  int i;
      297:  354:  int currentPlayer = whoseTurn(state);
        -:  355:  
        -:  356:  //Discard hand
     1736:  357:  for (i = 0; i < state->handCount[currentPlayer]; i++){
     1439:  358:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
     1439:  359:    state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  360:  }
      297:  361:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  362:    
        -:  363:  //Code for determining the player
      297:  364:  if (currentPlayer < (state->numPlayers - 1)){ 
      108:  365:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  366:  }
        -:  367:  else{
      189:  368:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  369:  }
        -:  370:
      297:  371:  state->outpostPlayed = 0;
      297:  372:  state->phase = 0;
      297:  373:  state->numActions = 1;
      297:  374:  state->coins = 0;
      297:  375:  state->numBuys = 1;
      297:  376:  state->playedCardCount = 0;
      297:  377:  state->handCount[state->whoseTurn] = 0;
        -:  378:
        -:  379:  //int k; move to top
        -:  380:  //Next player draws hand
     1782:  381:  for (k = 0; k < 5; k++){
     1485:  382:    drawCard(state->whoseTurn, state);//Draw a card
        -:  383:  }
        -:  384:
        -:  385:  //Update money
      297:  386:  updateCoins(state->whoseTurn, state , 0);
        -:  387:
      297:  388:  return 0;
        -:  389:}
        -:  390:
      300:  391:int isGameOver(struct gameState *state) {
        -:  392:  int i;
        -:  393:  int j;
        -:  394:	
        -:  395:  //if stack of Province cards is empty, the game ends
      300:  396:  if (state->supplyCount[province] == 0)
        -:  397:    {
    #####:  398:      return 1;
        -:  399:    }
        -:  400:
        -:  401:  //if three supply pile are at 0, the game ends
      300:  402:  j = 0;
     7800:  403:  for (i = 0; i < 25; i++)
        -:  404:    {
     7500:  405:      if (state->supplyCount[i] == 0)
        -:  406:	{
      383:  407:	  j++;
        -:  408:	}
        -:  409:    }
      300:  410:  if ( j >= 3)
        -:  411:    {
        3:  412:      return 1;
        -:  413:    }
        -:  414:
      297:  415:  return 0;
        -:  416:}
        -:  417:
        4:  418:int scoreFor (int player, struct gameState *state) {
        -:  419:
        -:  420:  int i;
        4:  421:  int score = 0;
        -:  422:  //score from hand
       19:  423:  for (i = 0; i < state->handCount[player]; i++)
        -:  424:    {
       15:  425:      if (state->hand[player][i] == curse) { score = score - 1; };
       15:  426:      if (state->hand[player][i] == estate) { score = score + 1; };
       15:  427:      if (state->hand[player][i] == duchy) { score = score + 3; };
       15:  428:      if (state->hand[player][i] == province) { score = score + 6; };
       15:  429:      if (state->hand[player][i] == great_hall) { score = score + 1; };
       15:  430:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
        -:  431:    }
        -:  432:
        -:  433:  //score from discard
       61:  434:  for (i = 0; i < state->discardCount[player]; i++)
        -:  435:    {
       57:  436:      if (state->discard[player][i] == curse) { score = score - 1; };
       57:  437:      if (state->discard[player][i] == estate) { score = score + 1; };
       57:  438:      if (state->discard[player][i] == duchy) { score = score + 3; };
       57:  439:      if (state->discard[player][i] == province) { score = score + 6; };
       57:  440:      if (state->discard[player][i] == great_hall) { score = score + 1; };
       57:  441:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
        -:  442:    }
        -:  443:
        -:  444:  //score from deck
       61:  445:  for (i = 0; i < state->discardCount[player]; i++)
        -:  446:    {
       57:  447:      if (state->deck[player][i] == curse) { score = score - 1; };
       57:  448:      if (state->deck[player][i] == estate) { score = score + 1; };
       57:  449:      if (state->deck[player][i] == duchy) { score = score + 3; };
       57:  450:      if (state->deck[player][i] == province) { score = score + 6; };
       57:  451:      if (state->deck[player][i] == great_hall) { score = score + 1; };
       57:  452:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
        -:  453:    }
        -:  454:
        4:  455:  return score;
        -:  456:}
        -:  457:
    #####:  458:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  459:  int i;	
        -:  460:  int j;
        -:  461:  int highScore;
        -:  462:  int currentPlayer;
        -:  463:
        -:  464:  //get score for each player
    #####:  465:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  466:    {
        -:  467:      //set unused player scores to -9999
    #####:  468:      if (i >= state->numPlayers)
        -:  469:	{
    #####:  470:	  players[i] = -9999;
        -:  471:	}
        -:  472:      else
        -:  473:	{
    #####:  474:	  players[i] = scoreFor (i, state);
        -:  475:	}
        -:  476:    }
        -:  477:
        -:  478:  //find highest score
    #####:  479:  j = 0;
    #####:  480:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  481:    {
    #####:  482:      if (players[i] > players[j])
        -:  483:	{
    #####:  484:	  j = i;
        -:  485:	}
        -:  486:    }
    #####:  487:  highScore = players[j];
        -:  488:
        -:  489:  //add 1 to players who had less turns
    #####:  490:  currentPlayer = whoseTurn(state);
    #####:  491:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  492:    {
    #####:  493:      if ( players[i] == highScore && i > currentPlayer )
        -:  494:	{
    #####:  495:	  players[i]++;
        -:  496:	}
        -:  497:    }
        -:  498:
        -:  499:  //find new highest score
    #####:  500:  j = 0;
    #####:  501:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  502:    {
    #####:  503:      if ( players[i] > players[j] )
        -:  504:	{
    #####:  505:	  j = i;
        -:  506:	}
        -:  507:    }
    #####:  508:  highScore = players[j];
        -:  509:
        -:  510:  //set winners in array to 1 and rest to 0
    #####:  511:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  512:    {
    #####:  513:      if ( players[i] == highScore )
        -:  514:	{
    #####:  515:	  players[i] = 1;
        -:  516:	}
        -:  517:      else
        -:  518:	{
    #####:  519:	  players[i] = 0;
        -:  520:	}
        -:  521:    }
        -:  522:
    #####:  523:  return 0;
        -:  524:}
        -:  525:
     1536:  526:int drawCard(int player, struct gameState *state)
        -:  527:{	int count;
        -:  528:  int deckCounter;
     1536:  529:  if (state->deckCount[player] <= 0){//Deck is empty
        -:  530:    
        -:  531:    //Step 1 Shuffle the discard pile back into a deck
        -:  532:    int i;
        -:  533:    //Move discard to deck
     1713:  534:    for (i = 0; i < state->discardCount[player];i++){
     1629:  535:      state->deck[player][i] = state->discard[player][i];
     1629:  536:      state->discard[player][i] = -1;
        -:  537:    }
        -:  538:
       84:  539:    state->deckCount[player] = state->discardCount[player];
       84:  540:    state->discardCount[player] = 0;//Reset discard
        -:  541:
        -:  542:    //Shufffle the deck
       84:  543:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  544:   
       84:  545:    if (DEBUG){//Debug statements
        -:  546:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  547:    }
        -:  548:    
       84:  549:    state->discardCount[player] = 0;
        -:  550:
        -:  551:    //Step 2 Draw Card
       84:  552:    count = state->handCount[player];//Get current player's hand count
        -:  553:    
       84:  554:    if (DEBUG){//Debug statements
        -:  555:      printf("Current hand count: %d\n", count);
        -:  556:    }
        -:  557:    
       84:  558:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  559:
       84:  560:    if (deckCounter == 0)
    #####:  561:      return -1;
        -:  562:
       84:  563:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
       84:  564:    state->deckCount[player]--;
       84:  565:    state->handCount[player]++;//Increment hand count
        -:  566:  }
        -:  567:
        -:  568:  else{
     1452:  569:    int count = state->handCount[player];//Get current hand count for player
        -:  570:    int deckCounter;
     1452:  571:    if (DEBUG){//Debug statements
        -:  572:      printf("Current hand count: %d\n", count);
        -:  573:    }
        -:  574:
     1452:  575:    deckCounter = state->deckCount[player];//Create holder for the deck count
     1452:  576:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
     1452:  577:    state->deckCount[player]--;
     1452:  578:    state->handCount[player]++;//Increment hand count
        -:  579:  }
        -:  580:
     1536:  581:  return 0;
        -:  582:}
        -:  583:
     5742:  584:int getCost(int cardNumber)
        -:  585:{
     5742:  586:  switch( cardNumber ) 
        -:  587:    {
        -:  588:    case curse:
    #####:  589:      return 0;
        -:  590:    case estate:
      451:  591:      return 2;
        -:  592:    case duchy:
      315:  593:      return 5;
        -:  594:    case province:
      300:  595:      return 8;
        -:  596:    case copper:
      632:  597:      return 0;
        -:  598:    case silver:
      484:  599:      return 3;
        -:  600:    case gold:
      305:  601:      return 6;
        -:  602:    case adventurer:
      175:  603:      return 6;
        -:  604:    case council_room:
       94:  605:      return 5;
        -:  606:    case feast:
    #####:  607:      return 4;
        -:  608:    case gardens:
      317:  609:      return 4;
        -:  610:    case mine:
      302:  611:      return 5;
        -:  612:    case remodel:
      216:  613:      return 4;
        -:  614:    case smithy:
      103:  615:      return 4;
        -:  616:    case village:
    #####:  617:      return 3;
        -:  618:    case baron:
      183:  619:      return 4;
        -:  620:    case great_hall:
      139:  621:      return 3;
        -:  622:    case minion:
      210:  623:      return 5;
        -:  624:    case steward:
      116:  625:      return 3;
        -:  626:    case tribute:
    #####:  627:      return 5;
        -:  628:    case ambassador:
      379:  629:      return 3;
        -:  630:    case cutpurse:
      216:  631:      return 4;
        -:  632:    case embargo: 
      362:  633:      return 2;
        -:  634:    case outpost:
      125:  635:      return 5;
        -:  636:    case salvager:
    #####:  637:      return 4;
        -:  638:    case sea_hag:
      230:  639:      return 4;
        -:  640:    case treasure_map:
       88:  641:      return 4;
        -:  642:    }
        -:  643:	
    #####:  644:  return -1;
        -:  645:}
        -:  646:
    #####:  647:int adventurerCard(int drawntreasure, struct gameState *state, int currentPlayer, int cardDrawn, int temphand [], int handPos, int z, int i){
    #####:  648:  int count = 0;
        -:  649:
    #####:  650:  while(drawntreasure<2){
    #####:  651:    count++;
    #####:  652:    if (state->deckCount[currentPlayer] <1)//if the deck is empty we need to shuffle discard and add to deck
    #####:  653:      shuffle(currentPlayer, state);
    #####:  654:    drawCard(currentPlayer, state);
    #####:  655:    cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
    #####:  656:    if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
    #####:  657:      drawntreasure++;
        -:  658:    else{
    #####:  659:      temphand[z]=cardDrawn;
    #####:  660:      state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####:  661:      z++;
        -:  662:    }
        -:  663:  }
        -:  664:
    #####:  665:  while(z-1>=0){
    #####:  666:    state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
    #####:  667:    z=z-1;
        -:  668:  }
        -:  669:
    #####:  670:  discardCard(handPos, currentPlayer, state, 0);
        -:  671:  //printf("count = %d\n", count);
        -:  672:
    #####:  673:  return 0;
        -:  674:}
        -:  675:
        2:  676:int councilRoomCard(struct gameState *state, int currentPlayer, int handPos, int i){
       10:  677:  for (i = 0; i < 4; i++)
        8:  678:    drawCard(currentPlayer, state);
        2:  679:  state->numBuys++;
        6:  680:  for (i = 0; i < state->numPlayers; i++){  //Each other player draws a card
        4:  681:    if ( i != currentPlayer )
        2:  682:      drawCard(i, state);
        -:  683:  }
        2:  684:  discardCard(handPos, currentPlayer, state, 0); //put played card in played card pile
        -:  685:      
        2:  686:  return 0;
        -:  687:}
        -:  688:
    #####:  689:int feastCard(struct gameState *state, int temphand [], int currentPlayer, int choice1, int i, int x){
    #####:  690:  for (i = 0; i <= state->handCount[currentPlayer]; i++){  
    #####:  691:    temphand[i] = state->hand[currentPlayer][i];
    #####:  692:    state->hand[currentPlayer][i] = -1;
        -:  693:  }
    #####:  694:  updateCoins(currentPlayer, state, 5);
    #####:  695:  x = 1;
    #####:  696:  while( x == 1) {
    #####:  697:    if (supplyCount(choice1, state) <= 0){
    #####:  698:      if (DEBUG)
        -:  699:        printf("None of that card left, sorry!\n");
        -:  700:
    #####:  701:      if (DEBUG)
        -:  702:        printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  703:    }
    #####:  704:    else if (state->coins < getCost(choice1)){
    #####:  705:      printf("That card is too expensive!\n");
    #####:  706:      if (DEBUG)
        -:  707:        printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  708:    }
        -:  709:    else{
    #####:  710:      if (DEBUG)
        -:  711:        printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
    #####:  712:      gainCard(choice1, state, 0, currentPlayer);
    #####:  713:      x = 0;
    #####:  714:      if (DEBUG)
        -:  715:        printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  716:    }
        -:  717:  }
        -:  718:
    #####:  719:  for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  720:    state->hand[currentPlayer][i] = temphand[i];
    #####:  721:    temphand[i] = -1;
        -:  722:  }
        -:  723:            
    #####:  724:      return 0;
        -:  725:}
        -:  726:
    #####:  727:int mineCard(struct gameState *state, int currentPlayer, int choice1, int choice2, int handPos, int i, int j){
    #####:  728:  j = state->hand[currentPlayer][choice1];  //store card we will trash
    #####:  729:  if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
    #####:  730:    return -1;  
    #####:  731:  if (choice2 > treasure_map || choice2 < curse)
    #####:  732:    return -1;
    #####:  733:  if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
    #####:  734:    return -1;
    #####:  735:  gainCard(choice2, state, 2, currentPlayer);
    #####:  736:  discardCard(handPos, currentPlayer, state, 0);
    #####:  737:  for (i = 0; i < state->handCount[currentPlayer]; i++){
    #####:  738:    if (state->hand[currentPlayer][i] == j){
    #####:  739:      discardCard(i, currentPlayer, state, 0);      
    #####:  740:      break;
        -:  741:    }
        -:  742:  }
        -:  743:      
    #####:  744:      return 0;
        -:  745:}
        -:  746:
        3:  747:int remodelCard(struct gameState *state, int currentPlayer, int choice1, int choice2, int handPos, int i, int j){
        3:  748:  j = state->hand[currentPlayer][choice1];  //store card we will trash
        3:  749:  if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
        1:  750:    return -1;
        2:  751:  gainCard(choice2, state, 0, currentPlayer);
        2:  752:  discardCard(handPos, currentPlayer, state, 0);
        3:  753:  for (i = 0; i < state->handCount[currentPlayer]; i++){
        3:  754:    if (state->hand[currentPlayer][i] == j){
        2:  755:        discardCard(i, currentPlayer, state, 0);      
        2:  756:        break;
        -:  757:    }
        -:  758:  }
        2:  759:      return 0;
        -:  760:}
        -:  761:
      158:  762:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  763:{
        -:  764:  int i;
        -:  765:  int j;
        -:  766:  int k;
        -:  767:  int x;
        -:  768:  int index;
      158:  769:  int currentPlayer = whoseTurn(state);
      158:  770:  int nextPlayer = currentPlayer + 1;
        -:  771:
      158:  772:  int tributeRevealedCards[2] = {-1, -1};
        -:  773:  int temphand[MAX_HAND];// moved above the if statement
      158:  774:  int drawntreasure=0;
        -:  775:  int cardDrawn;
      158:  776:  int z = 0;// this is the counter for the temp hand
      158:  777:  if (nextPlayer > (state->numPlayers - 1)){
      104:  778:    nextPlayer = 0;
        -:  779:  }
        -:  780:  
        -:  781:	
        -:  782:  //uses switch to select card and perform actions
      158:  783:  switch( card ) 
        -:  784:    {
        -:  785:    case adventurer:
    #####:  786:      adventurerCard(drawntreasure, state, currentPlayer, cardDrawn, temphand, handPos, z, i);
    #####:  787:      break;
        -:  788:      
        -:  789:    case council_room:
        2:  790:      councilRoomCard(state, currentPlayer, handPos, i);
        2:  791:      break;
        -:  792:			
        -:  793:    case feast:
    #####:  794:      feastCard(state, temphand, currentPlayer, choice1, i, x);
    #####:  795:      break;
        -:  796:
        -:  797:    case gardens:
    #####:  798:      return -1;
        -:  799:			
        -:  800:    case mine:
    #####:  801:      mineCard(state, currentPlayer, choice1, choice2, handPos, i, j);
    #####:  802:      break;
        -:  803:			
        -:  804:    case remodel:
        3:  805:      remodelCard(state, currentPlayer, choice1, choice2, handPos, i, j);
        3:  806:      break;
        -:  807:		
        -:  808:    case smithy:
        -:  809:      //+3 Cards
       24:  810:      for (i = 0; i < 3; i++)
        -:  811:	{
       18:  812:	  drawCard(currentPlayer, state);
        -:  813:	}
        -:  814:			
        -:  815:      //discard card from hand
        6:  816:      discardCard(handPos, currentPlayer, state, 0);
        6:  817:      return 0;
        -:  818:		
        -:  819:    case village:
        -:  820:      //+1 Card
    #####:  821:      drawCard(currentPlayer, state);
        -:  822:			
        -:  823:      //+2 Actions
    #####:  824:      state->numActions = state->numActions + 2;
        -:  825:			
        -:  826:      //discard played card from hand
    #####:  827:      discardCard(handPos, currentPlayer, state, 0);
    #####:  828:      return 0;
        -:  829:		
        -:  830:    case baron:
       11:  831:      state->numBuys++;//Increase buys by 1!
       11:  832:      if (choice1 > 0){//Boolean true or going to discard an estate
        5:  833:	int p = 0;//Iterator for hand!
        5:  834:	int card_not_discarded = 1;//Flag for discard set!
       40:  835:	while(card_not_discarded){
       30:  836:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
        1:  837:	    state->coins += 4;//Add 4 coins to the amount of coins
        1:  838:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
        1:  839:	    state->discardCount[currentPlayer]++;
        5:  840:	    for (;p < state->handCount[currentPlayer]; p++){
        4:  841:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
        -:  842:	    }
        1:  843:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
        1:  844:	    state->handCount[currentPlayer]--;
        1:  845:	    card_not_discarded = 0;//Exit the loop
        -:  846:	  }
       29:  847:	  else if (p > state->handCount[currentPlayer]){
        4:  848:	    if(DEBUG) {
        -:  849:	      printf("No estate cards in your hand, invalid choice\n");
        -:  850:	      printf("Must gain an estate if there are any\n");
        -:  851:	    }
        4:  852:	    if (supplyCount(estate, state) > 0){
    #####:  853:	      gainCard(estate, state, 0, currentPlayer);
    #####:  854:	      state->supplyCount[estate]--;//Decrement estates
    #####:  855:	      if (supplyCount(estate, state) == 0){
    #####:  856:		isGameOver(state);
        -:  857:	      }
        -:  858:	    }
        4:  859:	    card_not_discarded = 0;//Exit the loop
        -:  860:	  }
        -:  861:			    
        -:  862:	  else{
       25:  863:	    p++;//Next card
        -:  864:	  }
        -:  865:	}
        -:  866:      }
        -:  867:			    
        -:  868:      else{
        6:  869:	if (supplyCount(estate, state) > 0){
    #####:  870:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  871:	  state->supplyCount[estate]--;//Decrement Estates
    #####:  872:	  if (supplyCount(estate, state) == 0){
    #####:  873:	    isGameOver(state);
        -:  874:	  }
        -:  875:	}
        -:  876:      }
        -:  877:	    
        -:  878:      
       11:  879:      return 0;
        -:  880:		
        -:  881:    case great_hall:
        -:  882:      //+1 Card
    #####:  883:      drawCard(currentPlayer, state);
        -:  884:			
        -:  885:      //+1 Actions
    #####:  886:      state->numActions++;
        -:  887:			
        -:  888:      //discard card from hand
    #####:  889:      discardCard(handPos, currentPlayer, state, 0);
    #####:  890:      return 0;
        -:  891:		
        -:  892:    case minion:
        -:  893:      //+1 action
    #####:  894:      state->numActions++;
        -:  895:			
        -:  896:      //discard card from hand
    #####:  897:      discardCard(handPos, currentPlayer, state, 0);
        -:  898:			
    #####:  899:      if (choice1)		//+2 coins
        -:  900:	{
    #####:  901:	  state->coins = state->coins + 2;
        -:  902:	}
        -:  903:			
    #####:  904:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  905:	{
        -:  906:	  //discard hand
    #####:  907:	  while(numHandCards(state) > 0)
        -:  908:	    {
    #####:  909:	      discardCard(handPos, currentPlayer, state, 0);
        -:  910:	    }
        -:  911:				
        -:  912:	  //draw 4
    #####:  913:	  for (i = 0; i < 4; i++)
        -:  914:	    {
    #####:  915:	      drawCard(currentPlayer, state);
        -:  916:	    }
        -:  917:				
        -:  918:	  //other players discard hand and redraw if hand size > 4
    #####:  919:	  for (i = 0; i < state->numPlayers; i++)
        -:  920:	    {
    #####:  921:	      if (i != currentPlayer)
        -:  922:		{
    #####:  923:		  if ( state->handCount[i] > 4 )
        -:  924:		    {
        -:  925:		      //discard hand
    #####:  926:		      while( state->handCount[i] > 0 )
        -:  927:			{
    #####:  928:			  discardCard(handPos, i, state, 0);
        -:  929:			}
        -:  930:							
        -:  931:		      //draw 4
    #####:  932:		      for (j = 0; j < 4; j++)
        -:  933:			{
    #####:  934:			  drawCard(i, state);
        -:  935:			}
        -:  936:		    }
        -:  937:		}
        -:  938:	    }
        -:  939:				
        -:  940:	}
    #####:  941:      return 0;
        -:  942:		
        -:  943:    case steward:
        -:  944:     //discard card from hand
        9:  945:      discardCard(handPos, currentPlayer, state, 0);
        9:  946:      if (choice1 == 1)
        -:  947:	{
        -:  948:	  //+2 cards
        4:  949:	  drawCard(currentPlayer, state);
        4:  950:	  drawCard(currentPlayer, state);
        -:  951:	}
        5:  952:      else if (choice1 == 2)
        -:  953:	{
        -:  954:	  //+2 coins
        2:  955:	  state->coins = state->coins + 2;
        -:  956:	}
        -:  957:      else
        -:  958:	{
        -:  959:	  //trash 2 cards in hand
        3:  960:	  discardCard(choice2, currentPlayer, state, 1);
        3:  961:	  discardCard(choice3, currentPlayer, state, 1);
        -:  962:	}
        -:  963:			
        9:  964:      return 0;
        -:  965:		
        -:  966:    case tribute:
    #####:  967:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####:  968:	if (state->deckCount[nextPlayer] > 0){
    #####:  969:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  970:	  state->deckCount[nextPlayer]--;
        -:  971:	}
    #####:  972:	else if (state->discardCount[nextPlayer] > 0){
    #####:  973:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####:  974:	  state->discardCount[nextPlayer]--;
        -:  975:	}
        -:  976:	else{
        -:  977:	  //No Card to Reveal
    #####:  978:	  if (DEBUG){
        -:  979:	    printf("No cards to reveal\n");
        -:  980:	  }
        -:  981:	}
        -:  982:      }
        -:  983:	    
        -:  984:      else{
    #####:  985:	if (state->deckCount[nextPlayer] == 0){
    #####:  986:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####:  987:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####:  988:	    state->deckCount[nextPlayer]++;
    #####:  989:	    state->discard[nextPlayer][i] = -1;
    #####:  990:	    state->discardCount[nextPlayer]--;
        -:  991:	  }
        -:  992:			    
    #####:  993:	  shuffle(nextPlayer,state);//Shuffle the deck
        -:  994:	} 
    #####:  995:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  996:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  997:	state->deckCount[nextPlayer]--;
    #####:  998:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  999:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1000:	state->deckCount[nextPlayer]--;
        -: 1001:      }    
        -: 1002:		       
    #####: 1003:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
    #####: 1004:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1005:	state->playedCardCount++;
    #####: 1006:	tributeRevealedCards[1] = -1;
        -: 1007:      }
        -: 1008:
    #####: 1009:      for (i = 0; i <= 2; i ++){
    #####: 1010:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
    #####: 1011:	  state->coins += 2;
        -: 1012:	}
        -: 1013:		    
    #####: 1014:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
    #####: 1015:	  drawCard(currentPlayer, state);
    #####: 1016:	  drawCard(currentPlayer, state);
        -: 1017:	}
        -: 1018:	else{//Action Card
    #####: 1019:	  state->numActions = state->numActions + 2;
        -: 1020:	}
        -: 1021:      }
        -: 1022:	    
    #####: 1023:      return 0;
        -: 1024:		
        -: 1025:    case ambassador:
        -: 1026:
       38: 1027:      j = 0;		//used to check if player has enough cards to discard
        -: 1028:
       38: 1029:      if (choice2 > 2 || choice2 < 0)
        -: 1030:	{
    #####: 1031:	  return -1;				
        -: 1032:	}
        -: 1033:
       38: 1034:      if (choice1 == handPos)
        -: 1035:	{
    #####: 1036:	  return -1;
        -: 1037:	}
        -: 1038:
      234: 1039:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1040:	{
      196: 1041:	  if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1042:	    {
        7: 1043:	      j++;
        -: 1044:	    }
        -: 1045:	}
       38: 1046:      if (j < choice2)
        -: 1047:	{
       21: 1048:	  return -1;				
        -: 1049:	}
        -: 1050:
       17: 1051:      if (DEBUG) 
        -: 1052:	printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1053:
        -: 1054:      //increase supply count for choosen card by amount being discarded
       17: 1055:      state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1056:			
        -: 1057:      //each other player gains a copy of revealed card
       48: 1058:      for (i = 0; i < state->numPlayers; i++)
        -: 1059:	{
       31: 1060:	  if (i != currentPlayer)
        -: 1061:	    {
       14: 1062:	      gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1063:	    }
        -: 1064:	}
        -: 1065:
        -: 1066:      //discard played card from hand
       17: 1067:      discardCard(handPos, currentPlayer, state, 0);			
        -: 1068:
        -: 1069:      //trash copies of cards returned to supply
       22: 1070:      for (j = 0; j < choice2; j++)
        -: 1071:	{
       13: 1072:	  for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1073:	    {
       13: 1074:	      if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1075:		{
        5: 1076:		  discardCard(i, currentPlayer, state, 1);
        5: 1077:		  break;
        -: 1078:		}
        -: 1079:	    }
        -: 1080:	}			
        -: 1081:
       17: 1082:      return 0;
        -: 1083:		
        -: 1084:    case cutpurse:
        -: 1085:
        3: 1086:      updateCoins(currentPlayer, state, 2);
        9: 1087:      for (i = 0; i < state->numPlayers; i++)
        -: 1088:	{
        6: 1089:	  if (i != currentPlayer)
        -: 1090:	    {
        3: 1091:	      for (j = 0; j < state->handCount[i]; j++)
        -: 1092:		{
    #####: 1093:		  if (state->hand[i][j] == copper)
        -: 1094:		    {
    #####: 1095:		      discardCard(j, i, state, 0);
    #####: 1096:		      break;
        -: 1097:		    }
    #####: 1098:		  if (j == state->handCount[i])
        -: 1099:		    {
    #####: 1100:		      for (k = 0; k < state->handCount[i]; k++)
        -: 1101:			{
    #####: 1102:			  if (DEBUG)
        -: 1103:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1104:			}	
    #####: 1105:		      break;
        -: 1106:		    }		
        -: 1107:		}
        -: 1108:					
        -: 1109:	    }
        -: 1110:				
        -: 1111:	}				
        -: 1112:
        -: 1113:      //discard played card from hand
        3: 1114:      discardCard(handPos, currentPlayer, state, 0);			
        -: 1115:
        3: 1116:      return 0;
        -: 1117:
        -: 1118:		
        -: 1119:    case embargo: 
        -: 1120:      //+2 Coins
       27: 1121:      state->coins = state->coins + 2;
        -: 1122:			
        -: 1123:      //see if selected pile is in play
       27: 1124:      if ( state->supplyCount[choice1] == -1 )
        -: 1125:	{
    #####: 1126:	  return -1;
        -: 1127:	}
        -: 1128:			
        -: 1129:      //add embargo token to selected supply pile
       27: 1130:      state->embargoTokens[choice1]++;
        -: 1131:			
        -: 1132:      //trash card
       27: 1133:      discardCard(handPos, currentPlayer, state, 1);		
       27: 1134:      return 0;
        -: 1135:		
        -: 1136:    case outpost:
        -: 1137:      //set outpost flag
    #####: 1138:      state->outpostPlayed++;
        -: 1139:			
        -: 1140:      //discard card
    #####: 1141:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1142:      return 0;
        -: 1143:		
        -: 1144:    case salvager:
        -: 1145:      //+1 buy
    #####: 1146:      state->numBuys++;
        -: 1147:			
    #####: 1148:      if (choice1)
        -: 1149:	{
        -: 1150:	  //gain coins equal to trashed card
    #####: 1151:	  state->coins = state->coins + getCost( handCard(choice1, state) );
        -: 1152:	  //trash card
    #####: 1153:	  discardCard(choice1, currentPlayer, state, 1);	
        -: 1154:	}
        -: 1155:			
        -: 1156:      //discard card
    #####: 1157:      discardCard(handPos, currentPlayer, state, 0);
    #####: 1158:      return 0;
        -: 1159:		
        -: 1160:    case sea_hag:
       91: 1161:      for (i = 0; i < state->numPlayers; i++){
       57: 1162:	if (i != currentPlayer){
       23: 1163:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
       23: 1164:	  state->discardCount[i]++;
       23: 1165:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1166:	}
        -: 1167:      }
       34: 1168:      return 0;
        -: 1169:		
        -: 1170:    case treasure_map:
        -: 1171:      //search hand for another treasure_map
       25: 1172:      index = -1;
      150: 1173:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1174:	{
      125: 1175:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -: 1176:	    {
    #####: 1177:	      index = i;
    #####: 1178:	      break;
        -: 1179:	    }
        -: 1180:	}
       25: 1181:      if (index > -1)
        -: 1182:	{
        -: 1183:	  //trash both treasure cards
    #####: 1184:	  discardCard(handPos, currentPlayer, state, 1);
    #####: 1185:	  discardCard(index, currentPlayer, state, 1);
        -: 1186:
        -: 1187:	  //gain 4 Gold cards
    #####: 1188:	  for (i = 0; i < 4; i++)
        -: 1189:	    {
    #####: 1190:	      gainCard(gold, state, 1, currentPlayer);
        -: 1191:	    }
        -: 1192:				
        -: 1193:	  //return success
    #####: 1194:	  return 1;
        -: 1195:	}
        -: 1196:			
        -: 1197:      //no second treasure_map found in hand
       25: 1198:      return -1;
        -: 1199:    }
        -: 1200:
        5: 1201:  return -1;
        -: 1202:}
        -: 1203:
       79: 1204:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1205:{
        -: 1206:	
        -: 1207:  //if card is not trashed, added to Played pile 
       79: 1208:  if (trashFlag < 1)
        -: 1209:    {
        -: 1210:      //add card to played pile
       41: 1211:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
       41: 1212:      state->playedCardCount++;
        -: 1213:    }
        -: 1214:	
        -: 1215:  //set played card to -1
       79: 1216:  state->hand[currentPlayer][handPos] = -1;
        -: 1217:	
        -: 1218:  //remove card from player's hand
       79: 1219:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
        -: 1220:    {
        -: 1221:      //reduce number of cards in hand
       10: 1222:      state->handCount[currentPlayer]--;
       10: 1223:      state->discardCount[currentPlayer]++;
        -: 1224:    }
       69: 1225:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
        -: 1226:    {
        -: 1227:      //reduce number of cards in hand
    #####: 1228:      state->handCount[currentPlayer]--;
    #####: 1229:      state->discardCount[currentPlayer]++;
        -: 1230:    }
        -: 1231:  else 	
        -: 1232:    {
        -: 1233:      //replace discarded card with last card in hand
       69: 1234:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1235:      //set last card to -1
       69: 1236:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1237:      //reduce number of cards in hand
       69: 1238:      state->handCount[currentPlayer]--;
       69: 1239:      state->discardCount[currentPlayer]++;
        -: 1240:    }
        -: 1241:	
       79: 1242:  return 0;
        -: 1243:}
        -: 1244:
      172: 1245:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1246:{
        -: 1247:  //Note: supplyPos is enum of choosen card
        -: 1248:	
        -: 1249:  //check if supply pile is empty (0) or card is not used in game (-1)
      172: 1250:  if ( supplyCount(supplyPos, state) < 1 )
        -: 1251:    {
        2: 1252:      return -1;
        -: 1253:    }
        -: 1254:	
        -: 1255:  //added card for [whoseTurn] current player:
        -: 1256:  // toFlag = 0 : add to discard
        -: 1257:  // toFlag = 1 : add to deck
        -: 1258:  // toFlag = 2 : add to hand
        -: 1259:
      170: 1260:  if (toFlag == 1)
        -: 1261:    {
    #####: 1262:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
    #####: 1263:      state->deckCount[player]++;
        -: 1264:    }
      170: 1265:  else if (toFlag == 2)
        -: 1266:    {
    #####: 1267:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
    #####: 1268:      state->handCount[player]++;
        -: 1269:    }
        -: 1270:  else
        -: 1271:    {
      170: 1272:      state->discard[player][ state->discardCount[player] ] = supplyPos;
      170: 1273:      state->discardCount[player]++;
        -: 1274:    }
        -: 1275:	
        -: 1276:  //decrease number in supply pile
      170: 1277:  state->supplyCount[supplyPos]--;
        -: 1278:	 
      170: 1279:  return 0;
        -: 1280:}
        -: 1281:
      410: 1282:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1283:{
        -: 1284:  int i;
        -: 1285:	
        -: 1286:  //reset coin count
      410: 1287:  state->coins = 0;
        -: 1288:
        -: 1289:  //add coins for each Treasure card in player's hand
     2416: 1290:  for (i = 0; i < state->handCount[player]; i++)
        -: 1291:    {
     2006: 1292:      if (state->hand[player][i] == copper)
        -: 1293:	{
      596: 1294:	  state->coins += 1;
        -: 1295:	}
     1410: 1296:      else if (state->hand[player][i] == silver)
        -: 1297:	{
      151: 1298:	  state->coins += 2;
        -: 1299:	}
     1259: 1300:      else if (state->hand[player][i] == gold)
        -: 1301:	{
    #####: 1302:	  state->coins += 3;
        -: 1303:	}	
        -: 1304:    }	
        -: 1305:
        -: 1306:  //add bonus
      410: 1307:  state->coins += bonus;
        -: 1308:
      410: 1309:  return 0;
        -: 1310:}
        -: 1311:
        -: 1312://end of dominion.c
        -: 1313:
File 'dominion.c'
Lines executed:61.43% of 586
dominion.c:creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:4
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
     9573:    8:int compare(const void* a, const void* b) {
     9573:    9:  if (*(int*)a > *(int*)b)
     4273:   10:    return 1;
     5300:   11:  if (*(int*)a < *(int*)b)
     1368:   12:    return -1;
     3932:   13:  return 0;
        -:   14:}
        -:   15:
    #####:   16:struct gameState* newGame() {
    #####:   17:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:  return g;
        -:   19:}
        -:   20:
    #####:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:		  int k8, int k9, int k10) {
    #####:   23:  int* k = malloc(10 * sizeof(int));
    #####:   24:  k[0] = k1;
    #####:   25:  k[1] = k2;
    #####:   26:  k[2] = k3;
    #####:   27:  k[3] = k4;
    #####:   28:  k[4] = k5;
    #####:   29:  k[5] = k6;
    #####:   30:  k[6] = k7;
    #####:   31:  k[7] = k8;
    #####:   32:  k[8] = k9;
    #####:   33:  k[9] = k10;
    #####:   34:  return k;
        -:   35:}
        -:   36:
        4:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		   struct gameState *state) {
        -:   39:
        -:   40:  int i;
        -:   41:  int j;
        -:   42:  int it;			
        -:   43:  //set up random number generator
        4:   44:  SelectStream(1);
        4:   45:  PutSeed((long)randomSeed);
        -:   46:  
        -:   47:  //check number of players
        4:   48:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:    {
    #####:   50:      return -1;
        -:   51:    }
        -:   52:
        -:   53:  //set number of players
        4:   54:  state->numPlayers = numPlayers;
        -:   55:
        -:   56:  //check selected kingdom cards are different
       44:   57:  for (i = 0; i < 10; i++)
        -:   58:    {
      440:   59:      for (j = 0; j < 10; j++)
        -:   60:        {
      400:   61:	  if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:	    {
    #####:   63:	      return -1;
        -:   64:	    }
        -:   65:        }
        -:   66:    }
        -:   67:
        -:   68:
        -:   69:  //initialize supply
        -:   70:  ///////////////////////////////
        -:   71:
        -:   72:  //set number of Curse cards
        4:   73:  if (numPlayers == 2)
        -:   74:    {
        4:   75:      state->supplyCount[curse] = 10;
        -:   76:    }
    #####:   77:  else if (numPlayers == 3)
        -:   78:    {
    #####:   79:      state->supplyCount[curse] = 20;
        -:   80:    }
        -:   81:  else
        -:   82:    {
    #####:   83:      state->supplyCount[curse] = 30;
        -:   84:    }
        -:   85:
        -:   86:  //set number of Victory cards
        4:   87:  if (numPlayers == 2)
        -:   88:    {
        4:   89:      state->supplyCount[estate] = 8;
        4:   90:      state->supplyCount[duchy] = 8;
        4:   91:      state->supplyCount[province] = 8;
        -:   92:    }
        -:   93:  else
        -:   94:    {
    #####:   95:      state->supplyCount[estate] = 12;
    #####:   96:      state->supplyCount[duchy] = 12;
    #####:   97:      state->supplyCount[province] = 12;
        -:   98:    }
        -:   99:
        -:  100:  //set number of Treasure cards
        4:  101:  state->supplyCount[copper] = 60 - (7 * numPlayers);
        4:  102:  state->supplyCount[silver] = 40;
        4:  103:  state->supplyCount[gold] = 30;
        -:  104:
        -:  105:  //set number of Kingdom cards
       84:  106:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:    {
      660:  108:      for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:	{
      620:  110:	  if (kingdomCards[j] == i)
        -:  111:	    {
        -:  112:	      //check if card is a 'Victory' Kingdom card
       45:  113:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:		{
        5:  115:		  if (numPlayers == 2){ 
        5:  116:		    state->supplyCount[i] = 8; 
        -:  117:		  }
    #####:  118:		  else{ state->supplyCount[i] = 12; }
        -:  119:		}
        -:  120:	      else
        -:  121:		{
       35:  122:		  state->supplyCount[i] = 10;
        -:  123:		}
       40:  124:	      break;
        -:  125:	    }
        -:  126:	  else    //card is not in the set choosen for the game
        -:  127:	    {
      580:  128:	      state->supplyCount[i] = -1;
        -:  129:	    }
        -:  130:	}
        -:  131:
        -:  132:    }
        -:  133:
        -:  134:  ////////////////////////
        -:  135:  //supply intilization complete
        -:  136:
        -:  137:  //set player decks
       12:  138:  for (i = 0; i < numPlayers; i++)
        -:  139:    {
        8:  140:      state->deckCount[i] = 0;
       32:  141:      for (j = 0; j < 3; j++)
        -:  142:	{
       24:  143:	  state->deck[i][j] = estate;
       24:  144:	  state->deckCount[i]++;
        -:  145:	}
       64:  146:      for (j = 3; j < 10; j++)
        -:  147:	{
       56:  148:	  state->deck[i][j] = copper;
       56:  149:	  state->deckCount[i]++;		
        -:  150:	}
        -:  151:    }
        -:  152:
        -:  153:  //shuffle player decks
       12:  154:  for (i = 0; i < numPlayers; i++)
        -:  155:    {
        8:  156:      if ( shuffle(i, state) < 0 )
        -:  157:	{
    #####:  158:	  return -1;
        -:  159:	}
        -:  160:    }
        -:  161:
        -:  162:  //draw player hands
       12:  163:  for (i = 0; i < numPlayers; i++)
        -:  164:    {  
        -:  165:      //initialize hand size to zero
        8:  166:      state->handCount[i] = 0;
        8:  167:      state->discardCount[i] = 0;
        -:  168:      //draw 5 cards
        -:  169:      // for (j = 0; j < 5; j++)
        -:  170:      //	{
        -:  171:      //	  drawCard(i, state);
        -:  172:      //	}
        -:  173:    }
        -:  174:  
        -:  175:  //set embargo tokens to 0 for all supply piles
      112:  176:  for (i = 0; i <= treasure_map; i++)
        -:  177:    {
      108:  178:      state->embargoTokens[i] = 0;
        -:  179:    }
        -:  180:
        -:  181:  //initialize first player's turn
        4:  182:  state->outpostPlayed = 0;
        4:  183:  state->phase = 0;
        4:  184:  state->numActions = 1;
        4:  185:  state->numBuys = 1;
        4:  186:  state->playedCardCount = 0;
        4:  187:  state->whoseTurn = 0;
        4:  188:  state->handCount[state->whoseTurn] = 0;
        -:  189:  //int it; move to top
        -:  190:
        -:  191:  //Moved draw cards to here, only drawing at the start of a turn
       24:  192:  for (it = 0; it < 5; it++){
       20:  193:    drawCard(state->whoseTurn, state);
        -:  194:  }
        -:  195:
        4:  196:  updateCoins(state->whoseTurn, state, 0);
        -:  197:
        4:  198:  return 0;
        -:  199:}
        -:  200:
      254:  201:int shuffle(int player, struct gameState *state) {
        -:  202: 
        -:  203:
        -:  204:  int newDeck[MAX_DECK];
      254:  205:  int newDeckPos = 0;
        -:  206:  int card;
        -:  207:  int i;
        -:  208:
      254:  209:  if (state->deckCount[player] < 1)
    #####:  210:    return -1;
      254:  211:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
        -:  212:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
     3845:  214:  while (state->deckCount[player] > 0) {
     3337:  215:    card = floor(Random() * state->deckCount[player]);
     3337:  216:    newDeck[newDeckPos] = state->deck[player][card];
     3337:  217:    newDeckPos++;
    20677:  218:    for (i = card; i < state->deckCount[player]-1; i++) {
    17340:  219:      state->deck[player][i] = state->deck[player][i+1];
        -:  220:    }
     3337:  221:    state->deckCount[player]--;
        -:  222:  }
     3591:  223:  for (i = 0; i < newDeckPos; i++) {
     3337:  224:    state->deck[player][i] = newDeck[i];
     3337:  225:    state->deckCount[player]++;
        -:  226:  }
        -:  227:
      254:  228:  return 0;
        -:  229:}
        -:  230:
      243:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  232:{	
        -:  233:  int card;
      243:  234:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:  //check if it is the right phase
      243:  237:  if (state->phase != 0)
        -:  238:    {
    #####:  239:      return -1;
        -:  240:    }
        -:  241:	
        -:  242:  //check if player has enough actions
      243:  243:  if ( state->numActions < 1 )
        -:  244:    {
    #####:  245:      return -1;
        -:  246:    }
        -:  247:	
        -:  248:  //get card played
      243:  249:  card = handCard(handPos, state);
        -:  250:	
        -:  251:  //check if selected card is an action
      243:  252:  if ( card < adventurer || card > treasure_map )
        -:  253:    {
    #####:  254:      return -1;
        -:  255:    }
        -:  256:	
        -:  257:  //play card
      243:  258:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
        -:  259:    {
       69:  260:      return -1;
        -:  261:    }
        -:  262:	
        -:  263:  //reduce number of actions
        -:  264:
      174:  265:  state->numActions--;
        -:  266:
        -:  267:  //update coins (Treasure cards may be added with card draws)
      174:  268:  updateCoins(state->whoseTurn, state, coin_bonus);
        -:  269:	
      174:  270:  return 0;
        -:  271:}
        -:  272:
      290:  273:int buyCard(int supplyPos, struct gameState *state) {
        -:  274:  int who;
      290:  275:  if (DEBUG){
        -:  276:    printf("Entering buyCard...\n");
        -:  277:  }
        -:  278:
        -:  279:  // I don't know what to do about the phase thing.
        -:  280:
      290:  281:  who = state->whoseTurn;
        -:  282:
      290:  283:  if (state->numBuys < 1){
    #####:  284:    if (DEBUG)
        -:  285:      printf("You do not have any buys left\n");
    #####:  286:    return -1;
      290:  287:  } else if (supplyCount(supplyPos, state) <1){
    #####:  288:    if (DEBUG)
        -:  289:      printf("There are not any of that type of card left\n");
    #####:  290:    return -1;
      290:  291:  } else if (state->coins < getCost(supplyPos)){
       70:  292:    if (DEBUG) 
        -:  293:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
       70:  294:    return -1;
        -:  295:  } else {
      220:  296:    state->phase=1;
        -:  297:    //state->supplyCount[supplyPos]--;
      220:  298:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  299:  
      220:  300:    state->coins = (state->coins) - (getCost(supplyPos));
      220:  301:    state->numBuys--;
      220:  302:    if (DEBUG)
        -:  303:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  304:  }
        -:  305:
        -:  306:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  307:  //state->discardCount[who]++;
        -:  308:    
      220:  309:  return 0;
        -:  310:}
        -:  311:
    #####:  312:int numHandCards(struct gameState *state) {
    #####:  313:  return state->handCount[ whoseTurn(state) ];
        -:  314:}
        -:  315:
      251:  316:int handCard(int handPos, struct gameState *state) {
      251:  317:  int currentPlayer = whoseTurn(state);
      251:  318:  return state->hand[currentPlayer][handPos];
        -:  319:}
        -:  320:
      541:  321:int supplyCount(int card, struct gameState *state) {
      541:  322:  return state->supplyCount[card];
        -:  323:}
        -:  324:
    #####:  325:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  326:  int i;
    #####:  327:  int count = 0;
        -:  328:
    #####:  329:  for (i = 0; i < state->deckCount[player]; i++)
        -:  330:    {
    #####:  331:      if (state->deck[player][i] == card) count++;
        -:  332:    }
        -:  333:
    #####:  334:  for (i = 0; i < state->handCount[player]; i++)
        -:  335:    {
    #####:  336:      if (state->hand[player][i] == card) count++;
        -:  337:    }
        -:  338:
    #####:  339:  for (i = 0; i < state->discardCount[player]; i++)
        -:  340:    {
    #####:  341:      if (state->discard[player][i] == card) count++;
        -:  342:    }
        -:  343:
    #####:  344:  return count;
        -:  345:}
        -:  346:
     1096:  347:int whoseTurn(struct gameState *state) {
     1096:  348:  return state->whoseTurn;
        -:  349:}
        -:  350:
      602:  351:int endTurn(struct gameState *state) {
        -:  352:  int k;
        -:  353:  int i;
      602:  354:  int currentPlayer = whoseTurn(state);
        -:  355:  
        -:  356:  //Discard hand
     3521:  357:  for (i = 0; i < state->handCount[currentPlayer]; i++){
     2919:  358:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
     2919:  359:    state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  360:  }
      602:  361:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  362:    
        -:  363:  //Code for determining the player
      602:  364:  if (currentPlayer < (state->numPlayers - 1)){ 
      261:  365:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  366:  }
        -:  367:  else{
      341:  368:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  369:  }
        -:  370:
      602:  371:  state->outpostPlayed = 0;
      602:  372:  state->phase = 0;
      602:  373:  state->numActions = 1;
      602:  374:  state->coins = 0;
      602:  375:  state->numBuys = 1;
      602:  376:  state->playedCardCount = 0;
      602:  377:  state->handCount[state->whoseTurn] = 0;
        -:  378:
        -:  379:  //int k; move to top
        -:  380:  //Next player draws hand
     3612:  381:  for (k = 0; k < 5; k++){
     3010:  382:    drawCard(state->whoseTurn, state);//Draw a card
        -:  383:  }
        -:  384:
        -:  385:  //Update money
      602:  386:  updateCoins(state->whoseTurn, state , 0);
        -:  387:
      602:  388:  return 0;
        -:  389:}
        -:  390:
      606:  391:int isGameOver(struct gameState *state) {
        -:  392:  int i;
        -:  393:  int j;
        -:  394:	
        -:  395:  //if stack of Province cards is empty, the game ends
      606:  396:  if (state->supplyCount[province] == 0)
        -:  397:    {
    #####:  398:      return 1;
        -:  399:    }
        -:  400:
        -:  401:  //if three supply pile are at 0, the game ends
      606:  402:  j = 0;
    15756:  403:  for (i = 0; i < 25; i++)
        -:  404:    {
    15150:  405:      if (state->supplyCount[i] == 0)
        -:  406:	{
      793:  407:	  j++;
        -:  408:	}
        -:  409:    }
      606:  410:  if ( j >= 3)
        -:  411:    {
        4:  412:      return 1;
        -:  413:    }
        -:  414:
      602:  415:  return 0;
        -:  416:}
        -:  417:
        6:  418:int scoreFor (int player, struct gameState *state) {
        -:  419:
        -:  420:  int i;
        6:  421:  int score = 0;
        -:  422:  //score from hand
       26:  423:  for (i = 0; i < state->handCount[player]; i++)
        -:  424:    {
       20:  425:      if (state->hand[player][i] == curse) { score = score - 1; };
       20:  426:      if (state->hand[player][i] == estate) { score = score + 1; };
       20:  427:      if (state->hand[player][i] == duchy) { score = score + 3; };
       20:  428:      if (state->hand[player][i] == province) { score = score + 6; };
       20:  429:      if (state->hand[player][i] == great_hall) { score = score + 1; };
       20:  430:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
        -:  431:    }
        -:  432:
        -:  433:  //score from discard
       79:  434:  for (i = 0; i < state->discardCount[player]; i++)
        -:  435:    {
       73:  436:      if (state->discard[player][i] == curse) { score = score - 1; };
       73:  437:      if (state->discard[player][i] == estate) { score = score + 1; };
       73:  438:      if (state->discard[player][i] == duchy) { score = score + 3; };
       73:  439:      if (state->discard[player][i] == province) { score = score + 6; };
       73:  440:      if (state->discard[player][i] == great_hall) { score = score + 1; };
       73:  441:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
        -:  442:    }
        -:  443:
        -:  444:  //score from deck
       79:  445:  for (i = 0; i < state->discardCount[player]; i++)
        -:  446:    {
       73:  447:      if (state->deck[player][i] == curse) { score = score - 1; };
       73:  448:      if (state->deck[player][i] == estate) { score = score + 1; };
       73:  449:      if (state->deck[player][i] == duchy) { score = score + 3; };
       73:  450:      if (state->deck[player][i] == province) { score = score + 6; };
       73:  451:      if (state->deck[player][i] == great_hall) { score = score + 1; };
       73:  452:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
        -:  453:    }
        -:  454:
        6:  455:  return score;
        -:  456:}
        -:  457:
    #####:  458:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  459:  int i;	
        -:  460:  int j;
        -:  461:  int highScore;
        -:  462:  int currentPlayer;
        -:  463:
        -:  464:  //get score for each player
    #####:  465:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  466:    {
        -:  467:      //set unused player scores to -9999
    #####:  468:      if (i >= state->numPlayers)
        -:  469:	{
    #####:  470:	  players[i] = -9999;
        -:  471:	}
        -:  472:      else
        -:  473:	{
    #####:  474:	  players[i] = scoreFor (i, state);
        -:  475:	}
        -:  476:    }
        -:  477:
        -:  478:  //find highest score
    #####:  479:  j = 0;
    #####:  480:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  481:    {
    #####:  482:      if (players[i] > players[j])
        -:  483:	{
    #####:  484:	  j = i;
        -:  485:	}
        -:  486:    }
    #####:  487:  highScore = players[j];
        -:  488:
        -:  489:  //add 1 to players who had less turns
    #####:  490:  currentPlayer = whoseTurn(state);
    #####:  491:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  492:    {
    #####:  493:      if ( players[i] == highScore && i > currentPlayer )
        -:  494:	{
    #####:  495:	  players[i]++;
        -:  496:	}
        -:  497:    }
        -:  498:
        -:  499:  //find new highest score
    #####:  500:  j = 0;
    #####:  501:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  502:    {
    #####:  503:      if ( players[i] > players[j] )
        -:  504:	{
    #####:  505:	  j = i;
        -:  506:	}
        -:  507:    }
    #####:  508:  highScore = players[j];
        -:  509:
        -:  510:  //set winners in array to 1 and rest to 0
    #####:  511:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  512:    {
    #####:  513:      if ( players[i] == highScore )
        -:  514:	{
    #####:  515:	  players[i] = 1;
        -:  516:	}
        -:  517:      else
        -:  518:	{
    #####:  519:	  players[i] = 0;
        -:  520:	}
        -:  521:    }
        -:  522:
    #####:  523:  return 0;
        -:  524:}
        -:  525:
     3077:  526:int drawCard(int player, struct gameState *state)
        -:  527:{	int count;
        -:  528:  int deckCounter;
     3077:  529:  if (state->deckCount[player] <= 0){//Deck is empty
        -:  530:    
        -:  531:    //Step 1 Shuffle the discard pile back into a deck
        -:  532:    int i;
        -:  533:    //Move discard to deck
     3503:  534:    for (i = 0; i < state->discardCount[player];i++){
     3257:  535:      state->deck[player][i] = state->discard[player][i];
     3257:  536:      state->discard[player][i] = -1;
        -:  537:    }
        -:  538:
      246:  539:    state->deckCount[player] = state->discardCount[player];
      246:  540:    state->discardCount[player] = 0;//Reset discard
        -:  541:
        -:  542:    //Shufffle the deck
      246:  543:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  544:   
      246:  545:    if (DEBUG){//Debug statements
        -:  546:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  547:    }
        -:  548:    
      246:  549:    state->discardCount[player] = 0;
        -:  550:
        -:  551:    //Step 2 Draw Card
      246:  552:    count = state->handCount[player];//Get current player's hand count
        -:  553:    
      246:  554:    if (DEBUG){//Debug statements
        -:  555:      printf("Current hand count: %d\n", count);
        -:  556:    }
        -:  557:    
      246:  558:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  559:
      246:  560:    if (deckCounter == 0)
    #####:  561:      return -1;
        -:  562:
      246:  563:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
      246:  564:    state->deckCount[player]--;
      246:  565:    state->handCount[player]++;//Increment hand count
        -:  566:  }
        -:  567:
        -:  568:  else{
     2831:  569:    int count = state->handCount[player];//Get current hand count for player
        -:  570:    int deckCounter;
     2831:  571:    if (DEBUG){//Debug statements
        -:  572:      printf("Current hand count: %d\n", count);
        -:  573:    }
        -:  574:
     2831:  575:    deckCounter = state->deckCount[player];//Create holder for the deck count
     2831:  576:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
     2831:  577:    state->deckCount[player]--;
     2831:  578:    state->handCount[player]++;//Increment hand count
        -:  579:  }
        -:  580:
     3077:  581:  return 0;
        -:  582:}
        -:  583:
    11777:  584:int getCost(int cardNumber)
        -:  585:{
    11777:  586:  switch( cardNumber ) 
        -:  587:    {
        -:  588:    case curse:
    #####:  589:      return 0;
        -:  590:    case estate:
      864:  591:      return 2;
        -:  592:    case duchy:
      648:  593:      return 5;
        -:  594:    case province:
      624:  595:      return 8;
        -:  596:    case copper:
     1376:  597:      return 0;
        -:  598:    case silver:
      928:  599:      return 3;
        -:  600:    case gold:
      632:  601:      return 6;
        -:  602:    case adventurer:
      175:  603:      return 6;
        -:  604:    case council_room:
       94:  605:      return 5;
        -:  606:    case feast:
    #####:  607:      return 4;
        -:  608:    case gardens:
      646:  609:      return 4;
        -:  610:    case mine:
      627:  611:      return 5;
        -:  612:    case remodel:
      547:  613:      return 4;
        -:  614:    case smithy:
      432:  615:      return 4;
        -:  616:    case village:
    #####:  617:      return 3;
        -:  618:    case baron:
      511:  619:      return 4;
        -:  620:    case great_hall:
      139:  621:      return 3;
        -:  622:    case minion:
      210:  623:      return 5;
        -:  624:    case steward:
      463:  625:      return 3;
        -:  626:    case tribute:
    #####:  627:      return 5;
        -:  628:    case ambassador:
      379:  629:      return 3;
        -:  630:    case cutpurse:
      543:  631:      return 4;
        -:  632:    case embargo: 
      362:  633:      return 2;
        -:  634:    case outpost:
      450:  635:      return 5;
        -:  636:    case salvager:
      342:  637:      return 4;
        -:  638:    case sea_hag:
      557:  639:      return 4;
        -:  640:    case treasure_map:
       88:  641:      return 4;
        -:  642:    }
        -:  643:	
      140:  644:  return -1;
        -:  645:}
        -:  646:
    #####:  647:int adventurerCard(int drawntreasure, struct gameState *state, int currentPlayer, int cardDrawn, int temphand [], int handPos, int z, int i){
    #####:  648:  int count = 0;
        -:  649:
    #####:  650:  while(drawntreasure<2){
    #####:  651:    count++;
    #####:  652:    if (state->deckCount[currentPlayer] <1)//if the deck is empty we need to shuffle discard and add to deck
    #####:  653:      shuffle(currentPlayer, state);
    #####:  654:    drawCard(currentPlayer, state);
    #####:  655:    cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
    #####:  656:    if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
    #####:  657:      drawntreasure++;
        -:  658:    else{
    #####:  659:      temphand[z]=cardDrawn;
    #####:  660:      state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####:  661:      z++;
        -:  662:    }
        -:  663:  }
        -:  664:
    #####:  665:  while(z-1>=0){
    #####:  666:    state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
    #####:  667:    z=z-1;
        -:  668:  }
        -:  669:
    #####:  670:  discardCard(handPos, currentPlayer, state, 0);
        -:  671:  //printf("count = %d\n", count);
        -:  672:
    #####:  673:  return 0;
        -:  674:}
        -:  675:
        2:  676:int councilRoomCard(struct gameState *state, int currentPlayer, int handPos, int i){
       10:  677:  for (i = 0; i < 4; i++)
        8:  678:    drawCard(currentPlayer, state);
        2:  679:  state->numBuys++;
        6:  680:  for (i = 0; i < state->numPlayers; i++){  //Each other player draws a card
        4:  681:    if ( i != currentPlayer )
        2:  682:      drawCard(i, state);
        -:  683:  }
        2:  684:  discardCard(handPos, currentPlayer, state, 0); //put played card in played card pile
        -:  685:      
        2:  686:  return 0;
        -:  687:}
        -:  688:
    #####:  689:int feastCard(struct gameState *state, int temphand [], int currentPlayer, int choice1, int i, int x){
    #####:  690:  for (i = 0; i <= state->handCount[currentPlayer]; i++){  
    #####:  691:    temphand[i] = state->hand[currentPlayer][i];
    #####:  692:    state->hand[currentPlayer][i] = -1;
        -:  693:  }
    #####:  694:  updateCoins(currentPlayer, state, 5);
    #####:  695:  x = 1;
    #####:  696:  while( x == 1) {
    #####:  697:    if (supplyCount(choice1, state) <= 0){
    #####:  698:      if (DEBUG)
        -:  699:        printf("None of that card left, sorry!\n");
        -:  700:
    #####:  701:      if (DEBUG)
        -:  702:        printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  703:    }
    #####:  704:    else if (state->coins < getCost(choice1)){
    #####:  705:      printf("That card is too expensive!\n");
    #####:  706:      if (DEBUG)
        -:  707:        printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  708:    }
        -:  709:    else{
    #####:  710:      if (DEBUG)
        -:  711:        printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
    #####:  712:      gainCard(choice1, state, 0, currentPlayer);
    #####:  713:      x = 0;
    #####:  714:      if (DEBUG)
        -:  715:        printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  716:    }
        -:  717:  }
        -:  718:
    #####:  719:  for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  720:    state->hand[currentPlayer][i] = temphand[i];
    #####:  721:    temphand[i] = -1;
        -:  722:  }
        -:  723:            
    #####:  724:      return 0;
        -:  725:}
        -:  726:
    #####:  727:int mineCard(struct gameState *state, int currentPlayer, int choice1, int choice2, int handPos, int i, int j){
    #####:  728:  j = state->hand[currentPlayer][choice1];  //store card we will trash
    #####:  729:  if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
    #####:  730:    return -1;  
    #####:  731:  if (choice2 > treasure_map || choice2 < curse)
    #####:  732:    return -1;
    #####:  733:  if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
    #####:  734:    return -1;
    #####:  735:  gainCard(choice2, state, 2, currentPlayer);
    #####:  736:  discardCard(handPos, currentPlayer, state, 0);
    #####:  737:  for (i = 0; i < state->handCount[currentPlayer]; i++){
    #####:  738:    if (state->hand[currentPlayer][i] == j){
    #####:  739:      discardCard(i, currentPlayer, state, 0);      
    #####:  740:      break;
        -:  741:    }
        -:  742:  }
        -:  743:      
    #####:  744:      return 0;
        -:  745:}
        -:  746:
       21:  747:int remodelCard(struct gameState *state, int currentPlayer, int choice1, int choice2, int handPos, int i, int j){
       21:  748:  j = state->hand[currentPlayer][choice1];  //store card we will trash
       21:  749:  if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
       15:  750:    return -1;
        6:  751:  gainCard(choice2, state, 0, currentPlayer);
        6:  752:  discardCard(handPos, currentPlayer, state, 0);
       11:  753:  for (i = 0; i < state->handCount[currentPlayer]; i++){
       11:  754:    if (state->hand[currentPlayer][i] == j){
        6:  755:        discardCard(i, currentPlayer, state, 0);      
        6:  756:        break;
        -:  757:    }
        -:  758:  }
        6:  759:      return 0;
        -:  760:}
        -:  761:
      243:  762:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  763:{
        -:  764:  int i;
        -:  765:  int j;
        -:  766:  int k;
        -:  767:  int x;
        -:  768:  int index;
      243:  769:  int currentPlayer = whoseTurn(state);
      243:  770:  int nextPlayer = currentPlayer + 1;
        -:  771:
      243:  772:  int tributeRevealedCards[2] = {-1, -1};
        -:  773:  int temphand[MAX_HAND];// moved above the if statement
      243:  774:  int drawntreasure=0;
        -:  775:  int cardDrawn;
      243:  776:  int z = 0;// this is the counter for the temp hand
      243:  777:  if (nextPlayer > (state->numPlayers - 1)){
      112:  778:    nextPlayer = 0;
        -:  779:  }
        -:  780:  
        -:  781:	
        -:  782:  //uses switch to select card and perform actions
      243:  783:  switch( card ) 
        -:  784:    {
        -:  785:    case adventurer:
    #####:  786:      adventurerCard(drawntreasure, state, currentPlayer, cardDrawn, temphand, handPos, z, i);
    #####:  787:      break;
        -:  788:      
        -:  789:    case council_room:
        2:  790:      councilRoomCard(state, currentPlayer, handPos, i);
        2:  791:      break;
        -:  792:			
        -:  793:    case feast:
    #####:  794:      feastCard(state, temphand, currentPlayer, choice1, i, x);
    #####:  795:      break;
        -:  796:
        -:  797:    case gardens:
    #####:  798:      return -1;
        -:  799:			
        -:  800:    case mine:
    #####:  801:      mineCard(state, currentPlayer, choice1, choice2, handPos, i, j);
    #####:  802:      break;
        -:  803:			
        -:  804:    case remodel:
       21:  805:      remodelCard(state, currentPlayer, choice1, choice2, handPos, i, j);
       21:  806:      break;
        -:  807:		
        -:  808:    case smithy:
        -:  809:      //+3 Cards
       36:  810:      for (i = 0; i < 3; i++)
        -:  811:	{
       27:  812:	  drawCard(currentPlayer, state);
        -:  813:	}
        -:  814:			
        -:  815:      //discard card from hand
        9:  816:      discardCard(handPos, currentPlayer, state, 0);
        9:  817:      return 0;
        -:  818:		
        -:  819:    case village:
        -:  820:      //+1 Card
    #####:  821:      drawCard(currentPlayer, state);
        -:  822:			
        -:  823:      //+2 Actions
    #####:  824:      state->numActions = state->numActions + 2;
        -:  825:			
        -:  826:      //discard played card from hand
    #####:  827:      discardCard(handPos, currentPlayer, state, 0);
    #####:  828:      return 0;
        -:  829:		
        -:  830:    case baron:
       12:  831:      state->numBuys++;//Increase buys by 1!
       12:  832:      if (choice1 > 0){//Boolean true or going to discard an estate
        5:  833:	int p = 0;//Iterator for hand!
        5:  834:	int card_not_discarded = 1;//Flag for discard set!
       40:  835:	while(card_not_discarded){
       30:  836:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
        1:  837:	    state->coins += 4;//Add 4 coins to the amount of coins
        1:  838:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
        1:  839:	    state->discardCount[currentPlayer]++;
        5:  840:	    for (;p < state->handCount[currentPlayer]; p++){
        4:  841:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
        -:  842:	    }
        1:  843:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
        1:  844:	    state->handCount[currentPlayer]--;
        1:  845:	    card_not_discarded = 0;//Exit the loop
        -:  846:	  }
       29:  847:	  else if (p > state->handCount[currentPlayer]){
        4:  848:	    if(DEBUG) {
        -:  849:	      printf("No estate cards in your hand, invalid choice\n");
        -:  850:	      printf("Must gain an estate if there are any\n");
        -:  851:	    }
        4:  852:	    if (supplyCount(estate, state) > 0){
    #####:  853:	      gainCard(estate, state, 0, currentPlayer);
    #####:  854:	      state->supplyCount[estate]--;//Decrement estates
    #####:  855:	      if (supplyCount(estate, state) == 0){
    #####:  856:		isGameOver(state);
        -:  857:	      }
        -:  858:	    }
        4:  859:	    card_not_discarded = 0;//Exit the loop
        -:  860:	  }
        -:  861:			    
        -:  862:	  else{
       25:  863:	    p++;//Next card
        -:  864:	  }
        -:  865:	}
        -:  866:      }
        -:  867:			    
        -:  868:      else{
        7:  869:	if (supplyCount(estate, state) > 0){
    #####:  870:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  871:	  state->supplyCount[estate]--;//Decrement Estates
    #####:  872:	  if (supplyCount(estate, state) == 0){
    #####:  873:	    isGameOver(state);
        -:  874:	  }
        -:  875:	}
        -:  876:      }
        -:  877:	    
        -:  878:      
       12:  879:      return 0;
        -:  880:		
        -:  881:    case great_hall:
        -:  882:      //+1 Card
    #####:  883:      drawCard(currentPlayer, state);
        -:  884:			
        -:  885:      //+1 Actions
    #####:  886:      state->numActions++;
        -:  887:			
        -:  888:      //discard card from hand
    #####:  889:      discardCard(handPos, currentPlayer, state, 0);
    #####:  890:      return 0;
        -:  891:		
        -:  892:    case minion:
        -:  893:      //+1 action
    #####:  894:      state->numActions++;
        -:  895:			
        -:  896:      //discard card from hand
    #####:  897:      discardCard(handPos, currentPlayer, state, 0);
        -:  898:			
    #####:  899:      if (choice1)		//+2 coins
        -:  900:	{
    #####:  901:	  state->coins = state->coins + 2;
        -:  902:	}
        -:  903:			
    #####:  904:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  905:	{
        -:  906:	  //discard hand
    #####:  907:	  while(numHandCards(state) > 0)
        -:  908:	    {
    #####:  909:	      discardCard(handPos, currentPlayer, state, 0);
        -:  910:	    }
        -:  911:				
        -:  912:	  //draw 4
    #####:  913:	  for (i = 0; i < 4; i++)
        -:  914:	    {
    #####:  915:	      drawCard(currentPlayer, state);
        -:  916:	    }
        -:  917:				
        -:  918:	  //other players discard hand and redraw if hand size > 4
    #####:  919:	  for (i = 0; i < state->numPlayers; i++)
        -:  920:	    {
    #####:  921:	      if (i != currentPlayer)
        -:  922:		{
    #####:  923:		  if ( state->handCount[i] > 4 )
        -:  924:		    {
        -:  925:		      //discard hand
    #####:  926:		      while( state->handCount[i] > 0 )
        -:  927:			{
    #####:  928:			  discardCard(handPos, i, state, 0);
        -:  929:			}
        -:  930:							
        -:  931:		      //draw 4
    #####:  932:		      for (j = 0; j < 4; j++)
        -:  933:			{
    #####:  934:			  drawCard(i, state);
        -:  935:			}
        -:  936:		    }
        -:  937:		}
        -:  938:	    }
        -:  939:				
        -:  940:	}
    #####:  941:      return 0;
        -:  942:		
        -:  943:    case steward:
        -:  944:     //discard card from hand
       19:  945:      discardCard(handPos, currentPlayer, state, 0);
       19:  946:      if (choice1 == 1)
        -:  947:	{
        -:  948:	  //+2 cards
        5:  949:	  drawCard(currentPlayer, state);
        5:  950:	  drawCard(currentPlayer, state);
        -:  951:	}
       14:  952:      else if (choice1 == 2)
        -:  953:	{
        -:  954:	  //+2 coins
        4:  955:	  state->coins = state->coins + 2;
        -:  956:	}
        -:  957:      else
        -:  958:	{
        -:  959:	  //trash 2 cards in hand
       10:  960:	  discardCard(choice2, currentPlayer, state, 1);
       10:  961:	  discardCard(choice3, currentPlayer, state, 1);
        -:  962:	}
        -:  963:			
       19:  964:      return 0;
        -:  965:		
        -:  966:    case tribute:
    #####:  967:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####:  968:	if (state->deckCount[nextPlayer] > 0){
    #####:  969:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  970:	  state->deckCount[nextPlayer]--;
        -:  971:	}
    #####:  972:	else if (state->discardCount[nextPlayer] > 0){
    #####:  973:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####:  974:	  state->discardCount[nextPlayer]--;
        -:  975:	}
        -:  976:	else{
        -:  977:	  //No Card to Reveal
    #####:  978:	  if (DEBUG){
        -:  979:	    printf("No cards to reveal\n");
        -:  980:	  }
        -:  981:	}
        -:  982:      }
        -:  983:	    
        -:  984:      else{
    #####:  985:	if (state->deckCount[nextPlayer] == 0){
    #####:  986:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####:  987:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####:  988:	    state->deckCount[nextPlayer]++;
    #####:  989:	    state->discard[nextPlayer][i] = -1;
    #####:  990:	    state->discardCount[nextPlayer]--;
        -:  991:	  }
        -:  992:			    
    #####:  993:	  shuffle(nextPlayer,state);//Shuffle the deck
        -:  994:	} 
    #####:  995:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  996:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  997:	state->deckCount[nextPlayer]--;
    #####:  998:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  999:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1000:	state->deckCount[nextPlayer]--;
        -: 1001:      }    
        -: 1002:		       
    #####: 1003:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
    #####: 1004:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1005:	state->playedCardCount++;
    #####: 1006:	tributeRevealedCards[1] = -1;
        -: 1007:      }
        -: 1008:
    #####: 1009:      for (i = 0; i <= 2; i ++){
    #####: 1010:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
    #####: 1011:	  state->coins += 2;
        -: 1012:	}
        -: 1013:		    
    #####: 1014:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
    #####: 1015:	  drawCard(currentPlayer, state);
    #####: 1016:	  drawCard(currentPlayer, state);
        -: 1017:	}
        -: 1018:	else{//Action Card
    #####: 1019:	  state->numActions = state->numActions + 2;
        -: 1020:	}
        -: 1021:      }
        -: 1022:	    
    #####: 1023:      return 0;
        -: 1024:		
        -: 1025:    case ambassador:
        -: 1026:
       38: 1027:      j = 0;		//used to check if player has enough cards to discard
        -: 1028:
       38: 1029:      if (choice2 > 2 || choice2 < 0)
        -: 1030:	{
    #####: 1031:	  return -1;				
        -: 1032:	}
        -: 1033:
       38: 1034:      if (choice1 == handPos)
        -: 1035:	{
    #####: 1036:	  return -1;
        -: 1037:	}
        -: 1038:
      234: 1039:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1040:	{
      196: 1041:	  if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1042:	    {
        7: 1043:	      j++;
        -: 1044:	    }
        -: 1045:	}
       38: 1046:      if (j < choice2)
        -: 1047:	{
       21: 1048:	  return -1;				
        -: 1049:	}
        -: 1050:
       17: 1051:      if (DEBUG) 
        -: 1052:	printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1053:
        -: 1054:      //increase supply count for choosen card by amount being discarded
       17: 1055:      state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1056:			
        -: 1057:      //each other player gains a copy of revealed card
       48: 1058:      for (i = 0; i < state->numPlayers; i++)
        -: 1059:	{
       31: 1060:	  if (i != currentPlayer)
        -: 1061:	    {
       14: 1062:	      gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1063:	    }
        -: 1064:	}
        -: 1065:
        -: 1066:      //discard played card from hand
       17: 1067:      discardCard(handPos, currentPlayer, state, 0);			
        -: 1068:
        -: 1069:      //trash copies of cards returned to supply
       22: 1070:      for (j = 0; j < choice2; j++)
        -: 1071:	{
       13: 1072:	  for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1073:	    {
       13: 1074:	      if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1075:		{
        5: 1076:		  discardCard(i, currentPlayer, state, 1);
        5: 1077:		  break;
        -: 1078:		}
        -: 1079:	    }
        -: 1080:	}			
        -: 1081:
       17: 1082:      return 0;
        -: 1083:		
        -: 1084:    case cutpurse:
        -: 1085:
        5: 1086:      updateCoins(currentPlayer, state, 2);
       15: 1087:      for (i = 0; i < state->numPlayers; i++)
        -: 1088:	{
       10: 1089:	  if (i != currentPlayer)
        -: 1090:	    {
        5: 1091:	      for (j = 0; j < state->handCount[i]; j++)
        -: 1092:		{
    #####: 1093:		  if (state->hand[i][j] == copper)
        -: 1094:		    {
    #####: 1095:		      discardCard(j, i, state, 0);
    #####: 1096:		      break;
        -: 1097:		    }
    #####: 1098:		  if (j == state->handCount[i])
        -: 1099:		    {
    #####: 1100:		      for (k = 0; k < state->handCount[i]; k++)
        -: 1101:			{
    #####: 1102:			  if (DEBUG)
        -: 1103:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1104:			}	
    #####: 1105:		      break;
        -: 1106:		    }		
        -: 1107:		}
        -: 1108:					
        -: 1109:	    }
        -: 1110:				
        -: 1111:	}				
        -: 1112:
        -: 1113:      //discard played card from hand
        5: 1114:      discardCard(handPos, currentPlayer, state, 0);			
        -: 1115:
        5: 1116:      return 0;
        -: 1117:
        -: 1118:		
        -: 1119:    case embargo: 
        -: 1120:      //+2 Coins
       27: 1121:      state->coins = state->coins + 2;
        -: 1122:			
        -: 1123:      //see if selected pile is in play
       27: 1124:      if ( state->supplyCount[choice1] == -1 )
        -: 1125:	{
    #####: 1126:	  return -1;
        -: 1127:	}
        -: 1128:			
        -: 1129:      //add embargo token to selected supply pile
       27: 1130:      state->embargoTokens[choice1]++;
        -: 1131:			
        -: 1132:      //trash card
       27: 1133:      discardCard(handPos, currentPlayer, state, 1);		
       27: 1134:      return 0;
        -: 1135:		
        -: 1136:    case outpost:
        -: 1137:      //set outpost flag
        1: 1138:      state->outpostPlayed++;
        -: 1139:			
        -: 1140:      //discard card
        1: 1141:      discardCard(handPos, currentPlayer, state, 0);
        1: 1142:      return 0;
        -: 1143:		
        -: 1144:    case salvager:
        -: 1145:      //+1 buy
       10: 1146:      state->numBuys++;
        -: 1147:			
       10: 1148:      if (choice1)
        -: 1149:	{
        -: 1150:	  //gain coins equal to trashed card
        8: 1151:	  state->coins = state->coins + getCost( handCard(choice1, state) );
        -: 1152:	  //trash card
        8: 1153:	  discardCard(choice1, currentPlayer, state, 1);	
        -: 1154:	}
        -: 1155:			
        -: 1156:      //discard card
       10: 1157:      discardCard(handPos, currentPlayer, state, 0);
       10: 1158:      return 0;
        -: 1159:		
        -: 1160:    case sea_hag:
      211: 1161:      for (i = 0; i < state->numPlayers; i++){
      137: 1162:	if (i != currentPlayer){
       63: 1163:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
       63: 1164:	  state->discardCount[i]++;
       63: 1165:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1166:	}
        -: 1167:      }
       74: 1168:      return 0;
        -: 1169:		
        -: 1170:    case treasure_map:
        -: 1171:      //search hand for another treasure_map
       25: 1172:      index = -1;
      150: 1173:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1174:	{
      125: 1175:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -: 1176:	    {
    #####: 1177:	      index = i;
    #####: 1178:	      break;
        -: 1179:	    }
        -: 1180:	}
       25: 1181:      if (index > -1)
        -: 1182:	{
        -: 1183:	  //trash both treasure cards
    #####: 1184:	  discardCard(handPos, currentPlayer, state, 1);
    #####: 1185:	  discardCard(index, currentPlayer, state, 1);
        -: 1186:
        -: 1187:	  //gain 4 Gold cards
    #####: 1188:	  for (i = 0; i < 4; i++)
        -: 1189:	    {
    #####: 1190:	      gainCard(gold, state, 1, currentPlayer);
        -: 1191:	    }
        -: 1192:				
        -: 1193:	  //return success
    #####: 1194:	  return 1;
        -: 1195:	}
        -: 1196:			
        -: 1197:      //no second treasure_map found in hand
       25: 1198:      return -1;
        -: 1199:    }
        -: 1200:
       23: 1201:  return -1;
        -: 1202:}
        -: 1203:
      135: 1204:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1205:{
        -: 1206:	
        -: 1207:  //if card is not trashed, added to Played pile 
      135: 1208:  if (trashFlag < 1)
        -: 1209:    {
        -: 1210:      //add card to played pile
       75: 1211:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
       75: 1212:      state->playedCardCount++;
        -: 1213:    }
        -: 1214:	
        -: 1215:  //set played card to -1
      135: 1216:  state->hand[currentPlayer][handPos] = -1;
        -: 1217:	
        -: 1218:  //remove card from player's hand
      135: 1219:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
        -: 1220:    {
        -: 1221:      //reduce number of cards in hand
       21: 1222:      state->handCount[currentPlayer]--;
       21: 1223:      state->discardCount[currentPlayer]++;
        -: 1224:    }
      114: 1225:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
        -: 1226:    {
        -: 1227:      //reduce number of cards in hand
    #####: 1228:      state->handCount[currentPlayer]--;
    #####: 1229:      state->discardCount[currentPlayer]++;
        -: 1230:    }
        -: 1231:  else 	
        -: 1232:    {
        -: 1233:      //replace discarded card with last card in hand
      114: 1234:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1235:      //set last card to -1
      114: 1236:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1237:      //reduce number of cards in hand
      114: 1238:      state->handCount[currentPlayer]--;
      114: 1239:      state->discardCount[currentPlayer]++;
        -: 1240:    }
        -: 1241:	
      135: 1242:  return 0;
        -: 1243:}
        -: 1244:
      240: 1245:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1246:{
        -: 1247:  //Note: supplyPos is enum of choosen card
        -: 1248:	
        -: 1249:  //check if supply pile is empty (0) or card is not used in game (-1)
      240: 1250:  if ( supplyCount(supplyPos, state) < 1 )
        -: 1251:    {
        2: 1252:      return -1;
        -: 1253:    }
        -: 1254:	
        -: 1255:  //added card for [whoseTurn] current player:
        -: 1256:  // toFlag = 0 : add to discard
        -: 1257:  // toFlag = 1 : add to deck
        -: 1258:  // toFlag = 2 : add to hand
        -: 1259:
      238: 1260:  if (toFlag == 1)
        -: 1261:    {
    #####: 1262:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
    #####: 1263:      state->deckCount[player]++;
        -: 1264:    }
      238: 1265:  else if (toFlag == 2)
        -: 1266:    {
    #####: 1267:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
    #####: 1268:      state->handCount[player]++;
        -: 1269:    }
        -: 1270:  else
        -: 1271:    {
      238: 1272:      state->discard[player][ state->discardCount[player] ] = supplyPos;
      238: 1273:      state->discardCount[player]++;
        -: 1274:    }
        -: 1275:	
        -: 1276:  //decrease number in supply pile
      238: 1277:  state->supplyCount[supplyPos]--;
        -: 1278:	 
      238: 1279:  return 0;
        -: 1280:}
        -: 1281:
      785: 1282:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1283:{
        -: 1284:  int i;
        -: 1285:	
        -: 1286:  //reset coin count
      785: 1287:  state->coins = 0;
        -: 1288:
        -: 1289:  //add coins for each Treasure card in player's hand
     4629: 1290:  for (i = 0; i < state->handCount[player]; i++)
        -: 1291:    {
     3844: 1292:      if (state->hand[player][i] == copper)
        -: 1293:	{
      758: 1294:	  state->coins += 1;
        -: 1295:	}
     3086: 1296:      else if (state->hand[player][i] == silver)
        -: 1297:	{
      302: 1298:	  state->coins += 2;
        -: 1299:	}
     2784: 1300:      else if (state->hand[player][i] == gold)
        -: 1301:	{
    #####: 1302:	  state->coins += 3;
        -: 1303:	}	
        -: 1304:    }	
        -: 1305:
        -: 1306:  //add bonus
      785: 1307:  state->coins += bonus;
        -: 1308:
      785: 1309:  return 0;
        -: 1310:}
        -: 1311:
        -: 1312://end of dominion.c
        -: 1313:
File 'dominion.c'
Lines executed:62.29% of 586
dominion.c:creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:5
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
    11588:    8:int compare(const void* a, const void* b) {
    11588:    9:  if (*(int*)a > *(int*)b)
     5243:   10:    return 1;
     6345:   11:  if (*(int*)a < *(int*)b)
     1707:   12:    return -1;
     4638:   13:  return 0;
        -:   14:}
        -:   15:
    #####:   16:struct gameState* newGame() {
    #####:   17:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:  return g;
        -:   19:}
        -:   20:
    #####:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:		  int k8, int k9, int k10) {
    #####:   23:  int* k = malloc(10 * sizeof(int));
    #####:   24:  k[0] = k1;
    #####:   25:  k[1] = k2;
    #####:   26:  k[2] = k3;
    #####:   27:  k[3] = k4;
    #####:   28:  k[4] = k5;
    #####:   29:  k[5] = k6;
    #####:   30:  k[6] = k7;
    #####:   31:  k[7] = k8;
    #####:   32:  k[8] = k9;
    #####:   33:  k[9] = k10;
    #####:   34:  return k;
        -:   35:}
        -:   36:
        5:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		   struct gameState *state) {
        -:   39:
        -:   40:  int i;
        -:   41:  int j;
        -:   42:  int it;			
        -:   43:  //set up random number generator
        5:   44:  SelectStream(1);
        5:   45:  PutSeed((long)randomSeed);
        -:   46:  
        -:   47:  //check number of players
        5:   48:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:    {
    #####:   50:      return -1;
        -:   51:    }
        -:   52:
        -:   53:  //set number of players
        5:   54:  state->numPlayers = numPlayers;
        -:   55:
        -:   56:  //check selected kingdom cards are different
       55:   57:  for (i = 0; i < 10; i++)
        -:   58:    {
      550:   59:      for (j = 0; j < 10; j++)
        -:   60:        {
      500:   61:	  if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:	    {
    #####:   63:	      return -1;
        -:   64:	    }
        -:   65:        }
        -:   66:    }
        -:   67:
        -:   68:
        -:   69:  //initialize supply
        -:   70:  ///////////////////////////////
        -:   71:
        -:   72:  //set number of Curse cards
        5:   73:  if (numPlayers == 2)
        -:   74:    {
        5:   75:      state->supplyCount[curse] = 10;
        -:   76:    }
    #####:   77:  else if (numPlayers == 3)
        -:   78:    {
    #####:   79:      state->supplyCount[curse] = 20;
        -:   80:    }
        -:   81:  else
        -:   82:    {
    #####:   83:      state->supplyCount[curse] = 30;
        -:   84:    }
        -:   85:
        -:   86:  //set number of Victory cards
        5:   87:  if (numPlayers == 2)
        -:   88:    {
        5:   89:      state->supplyCount[estate] = 8;
        5:   90:      state->supplyCount[duchy] = 8;
        5:   91:      state->supplyCount[province] = 8;
        -:   92:    }
        -:   93:  else
        -:   94:    {
    #####:   95:      state->supplyCount[estate] = 12;
    #####:   96:      state->supplyCount[duchy] = 12;
    #####:   97:      state->supplyCount[province] = 12;
        -:   98:    }
        -:   99:
        -:  100:  //set number of Treasure cards
        5:  101:  state->supplyCount[copper] = 60 - (7 * numPlayers);
        5:  102:  state->supplyCount[silver] = 40;
        5:  103:  state->supplyCount[gold] = 30;
        -:  104:
        -:  105:  //set number of Kingdom cards
      105:  106:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:    {
      825:  108:      for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:	{
      775:  110:	  if (kingdomCards[j] == i)
        -:  111:	    {
        -:  112:	      //check if card is a 'Victory' Kingdom card
       56:  113:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:		{
        6:  115:		  if (numPlayers == 2){ 
        6:  116:		    state->supplyCount[i] = 8; 
        -:  117:		  }
    #####:  118:		  else{ state->supplyCount[i] = 12; }
        -:  119:		}
        -:  120:	      else
        -:  121:		{
       44:  122:		  state->supplyCount[i] = 10;
        -:  123:		}
       50:  124:	      break;
        -:  125:	    }
        -:  126:	  else    //card is not in the set choosen for the game
        -:  127:	    {
      725:  128:	      state->supplyCount[i] = -1;
        -:  129:	    }
        -:  130:	}
        -:  131:
        -:  132:    }
        -:  133:
        -:  134:  ////////////////////////
        -:  135:  //supply intilization complete
        -:  136:
        -:  137:  //set player decks
       15:  138:  for (i = 0; i < numPlayers; i++)
        -:  139:    {
       10:  140:      state->deckCount[i] = 0;
       40:  141:      for (j = 0; j < 3; j++)
        -:  142:	{
       30:  143:	  state->deck[i][j] = estate;
       30:  144:	  state->deckCount[i]++;
        -:  145:	}
       80:  146:      for (j = 3; j < 10; j++)
        -:  147:	{
       70:  148:	  state->deck[i][j] = copper;
       70:  149:	  state->deckCount[i]++;		
        -:  150:	}
        -:  151:    }
        -:  152:
        -:  153:  //shuffle player decks
       15:  154:  for (i = 0; i < numPlayers; i++)
        -:  155:    {
       10:  156:      if ( shuffle(i, state) < 0 )
        -:  157:	{
    #####:  158:	  return -1;
        -:  159:	}
        -:  160:    }
        -:  161:
        -:  162:  //draw player hands
       15:  163:  for (i = 0; i < numPlayers; i++)
        -:  164:    {  
        -:  165:      //initialize hand size to zero
       10:  166:      state->handCount[i] = 0;
       10:  167:      state->discardCount[i] = 0;
        -:  168:      //draw 5 cards
        -:  169:      // for (j = 0; j < 5; j++)
        -:  170:      //	{
        -:  171:      //	  drawCard(i, state);
        -:  172:      //	}
        -:  173:    }
        -:  174:  
        -:  175:  //set embargo tokens to 0 for all supply piles
      140:  176:  for (i = 0; i <= treasure_map; i++)
        -:  177:    {
      135:  178:      state->embargoTokens[i] = 0;
        -:  179:    }
        -:  180:
        -:  181:  //initialize first player's turn
        5:  182:  state->outpostPlayed = 0;
        5:  183:  state->phase = 0;
        5:  184:  state->numActions = 1;
        5:  185:  state->numBuys = 1;
        5:  186:  state->playedCardCount = 0;
        5:  187:  state->whoseTurn = 0;
        5:  188:  state->handCount[state->whoseTurn] = 0;
        -:  189:  //int it; move to top
        -:  190:
        -:  191:  //Moved draw cards to here, only drawing at the start of a turn
       30:  192:  for (it = 0; it < 5; it++){
       25:  193:    drawCard(state->whoseTurn, state);
        -:  194:  }
        -:  195:
        5:  196:  updateCoins(state->whoseTurn, state, 0);
        -:  197:
        5:  198:  return 0;
        -:  199:}
        -:  200:
      280:  201:int shuffle(int player, struct gameState *state) {
        -:  202: 
        -:  203:
        -:  204:  int newDeck[MAX_DECK];
      280:  205:  int newDeckPos = 0;
        -:  206:  int card;
        -:  207:  int i;
        -:  208:
      280:  209:  if (state->deckCount[player] < 1)
    #####:  210:    return -1;
      280:  211:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
        -:  212:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
     4488:  214:  while (state->deckCount[player] > 0) {
     3928:  215:    card = floor(Random() * state->deckCount[player]);
     3928:  216:    newDeck[newDeckPos] = state->deck[player][card];
     3928:  217:    newDeckPos++;
    24979:  218:    for (i = card; i < state->deckCount[player]-1; i++) {
    21051:  219:      state->deck[player][i] = state->deck[player][i+1];
        -:  220:    }
     3928:  221:    state->deckCount[player]--;
        -:  222:  }
     4208:  223:  for (i = 0; i < newDeckPos; i++) {
     3928:  224:    state->deck[player][i] = newDeck[i];
     3928:  225:    state->deckCount[player]++;
        -:  226:  }
        -:  227:
      280:  228:  return 0;
        -:  229:}
        -:  230:
      360:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  232:{	
        -:  233:  int card;
      360:  234:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:  //check if it is the right phase
      360:  237:  if (state->phase != 0)
        -:  238:    {
    #####:  239:      return -1;
        -:  240:    }
        -:  241:	
        -:  242:  //check if player has enough actions
      360:  243:  if ( state->numActions < 1 )
        -:  244:    {
    #####:  245:      return -1;
        -:  246:    }
        -:  247:	
        -:  248:  //get card played
      360:  249:  card = handCard(handPos, state);
        -:  250:	
        -:  251:  //check if selected card is an action
      360:  252:  if ( card < adventurer || card > treasure_map )
        -:  253:    {
    #####:  254:      return -1;
        -:  255:    }
        -:  256:	
        -:  257:  //play card
      360:  258:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
        -:  259:    {
      162:  260:      return -1;
        -:  261:    }
        -:  262:	
        -:  263:  //reduce number of actions
        -:  264:
      198:  265:  state->numActions--;
        -:  266:
        -:  267:  //update coins (Treasure cards may be added with card draws)
      198:  268:  updateCoins(state->whoseTurn, state, coin_bonus);
        -:  269:	
      198:  270:  return 0;
        -:  271:}
        -:  272:
      340:  273:int buyCard(int supplyPos, struct gameState *state) {
        -:  274:  int who;
      340:  275:  if (DEBUG){
        -:  276:    printf("Entering buyCard...\n");
        -:  277:  }
        -:  278:
        -:  279:  // I don't know what to do about the phase thing.
        -:  280:
      340:  281:  who = state->whoseTurn;
        -:  282:
      340:  283:  if (state->numBuys < 1){
    #####:  284:    if (DEBUG)
        -:  285:      printf("You do not have any buys left\n");
    #####:  286:    return -1;
      340:  287:  } else if (supplyCount(supplyPos, state) <1){
    #####:  288:    if (DEBUG)
        -:  289:      printf("There are not any of that type of card left\n");
    #####:  290:    return -1;
      340:  291:  } else if (state->coins < getCost(supplyPos)){
       70:  292:    if (DEBUG) 
        -:  293:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
       70:  294:    return -1;
        -:  295:  } else {
      270:  296:    state->phase=1;
        -:  297:    //state->supplyCount[supplyPos]--;
      270:  298:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  299:  
      270:  300:    state->coins = (state->coins) - (getCost(supplyPos));
      270:  301:    state->numBuys--;
      270:  302:    if (DEBUG)
        -:  303:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  304:  }
        -:  305:
        -:  306:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  307:  //state->discardCount[who]++;
        -:  308:    
      270:  309:  return 0;
        -:  310:}
        -:  311:
    #####:  312:int numHandCards(struct gameState *state) {
    #####:  313:  return state->handCount[ whoseTurn(state) ];
        -:  314:}
        -:  315:
      368:  316:int handCard(int handPos, struct gameState *state) {
      368:  317:  int currentPlayer = whoseTurn(state);
      368:  318:  return state->hand[currentPlayer][handPos];
        -:  319:}
        -:  320:
      645:  321:int supplyCount(int card, struct gameState *state) {
      645:  322:  return state->supplyCount[card];
        -:  323:}
        -:  324:
    #####:  325:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  326:  int i;
    #####:  327:  int count = 0;
        -:  328:
    #####:  329:  for (i = 0; i < state->deckCount[player]; i++)
        -:  330:    {
    #####:  331:      if (state->deck[player][i] == card) count++;
        -:  332:    }
        -:  333:
    #####:  334:  for (i = 0; i < state->handCount[player]; i++)
        -:  335:    {
    #####:  336:      if (state->hand[player][i] == card) count++;
        -:  337:    }
        -:  338:
    #####:  339:  for (i = 0; i < state->discardCount[player]; i++)
        -:  340:    {
    #####:  341:      if (state->discard[player][i] == card) count++;
        -:  342:    }
        -:  343:
    #####:  344:  return count;
        -:  345:}
        -:  346:
     1437:  347:int whoseTurn(struct gameState *state) {
     1437:  348:  return state->whoseTurn;
        -:  349:}
        -:  350:
      709:  351:int endTurn(struct gameState *state) {
        -:  352:  int k;
        -:  353:  int i;
      709:  354:  int currentPlayer = whoseTurn(state);
        -:  355:  
        -:  356:  //Discard hand
     4152:  357:  for (i = 0; i < state->handCount[currentPlayer]; i++){
     3443:  358:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
     3443:  359:    state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  360:  }
      709:  361:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  362:    
        -:  363:  //Code for determining the player
      709:  364:  if (currentPlayer < (state->numPlayers - 1)){ 
      281:  365:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  366:  }
        -:  367:  else{
      428:  368:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  369:  }
        -:  370:
      709:  371:  state->outpostPlayed = 0;
      709:  372:  state->phase = 0;
      709:  373:  state->numActions = 1;
      709:  374:  state->coins = 0;
      709:  375:  state->numBuys = 1;
      709:  376:  state->playedCardCount = 0;
      709:  377:  state->handCount[state->whoseTurn] = 0;
        -:  378:
        -:  379:  //int k; move to top
        -:  380:  //Next player draws hand
     4254:  381:  for (k = 0; k < 5; k++){
     3545:  382:    drawCard(state->whoseTurn, state);//Draw a card
        -:  383:  }
        -:  384:
        -:  385:  //Update money
      709:  386:  updateCoins(state->whoseTurn, state , 0);
        -:  387:
      709:  388:  return 0;
        -:  389:}
        -:  390:
      714:  391:int isGameOver(struct gameState *state) {
        -:  392:  int i;
        -:  393:  int j;
        -:  394:	
        -:  395:  //if stack of Province cards is empty, the game ends
      714:  396:  if (state->supplyCount[province] == 0)
        -:  397:    {
    #####:  398:      return 1;
        -:  399:    }
        -:  400:
        -:  401:  //if three supply pile are at 0, the game ends
      714:  402:  j = 0;
    18564:  403:  for (i = 0; i < 25; i++)
        -:  404:    {
    17850:  405:      if (state->supplyCount[i] == 0)
        -:  406:	{
      956:  407:	  j++;
        -:  408:	}
        -:  409:    }
      714:  410:  if ( j >= 3)
        -:  411:    {
        5:  412:      return 1;
        -:  413:    }
        -:  414:
      709:  415:  return 0;
        -:  416:}
        -:  417:
        7:  418:int scoreFor (int player, struct gameState *state) {
        -:  419:
        -:  420:  int i;
        7:  421:  int score = 0;
        -:  422:  //score from hand
       32:  423:  for (i = 0; i < state->handCount[player]; i++)
        -:  424:    {
       25:  425:      if (state->hand[player][i] == curse) { score = score - 1; };
       25:  426:      if (state->hand[player][i] == estate) { score = score + 1; };
       25:  427:      if (state->hand[player][i] == duchy) { score = score + 3; };
       25:  428:      if (state->hand[player][i] == province) { score = score + 6; };
       25:  429:      if (state->hand[player][i] == great_hall) { score = score + 1; };
       25:  430:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
        -:  431:    }
        -:  432:
        -:  433:  //score from discard
      103:  434:  for (i = 0; i < state->discardCount[player]; i++)
        -:  435:    {
       96:  436:      if (state->discard[player][i] == curse) { score = score - 1; };
       96:  437:      if (state->discard[player][i] == estate) { score = score + 1; };
       96:  438:      if (state->discard[player][i] == duchy) { score = score + 3; };
       96:  439:      if (state->discard[player][i] == province) { score = score + 6; };
       96:  440:      if (state->discard[player][i] == great_hall) { score = score + 1; };
       96:  441:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
        -:  442:    }
        -:  443:
        -:  444:  //score from deck
      103:  445:  for (i = 0; i < state->discardCount[player]; i++)
        -:  446:    {
       96:  447:      if (state->deck[player][i] == curse) { score = score - 1; };
       96:  448:      if (state->deck[player][i] == estate) { score = score + 1; };
       96:  449:      if (state->deck[player][i] == duchy) { score = score + 3; };
       96:  450:      if (state->deck[player][i] == province) { score = score + 6; };
       96:  451:      if (state->deck[player][i] == great_hall) { score = score + 1; };
       96:  452:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
        -:  453:    }
        -:  454:
        7:  455:  return score;
        -:  456:}
        -:  457:
    #####:  458:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  459:  int i;	
        -:  460:  int j;
        -:  461:  int highScore;
        -:  462:  int currentPlayer;
        -:  463:
        -:  464:  //get score for each player
    #####:  465:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  466:    {
        -:  467:      //set unused player scores to -9999
    #####:  468:      if (i >= state->numPlayers)
        -:  469:	{
    #####:  470:	  players[i] = -9999;
        -:  471:	}
        -:  472:      else
        -:  473:	{
    #####:  474:	  players[i] = scoreFor (i, state);
        -:  475:	}
        -:  476:    }
        -:  477:
        -:  478:  //find highest score
    #####:  479:  j = 0;
    #####:  480:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  481:    {
    #####:  482:      if (players[i] > players[j])
        -:  483:	{
    #####:  484:	  j = i;
        -:  485:	}
        -:  486:    }
    #####:  487:  highScore = players[j];
        -:  488:
        -:  489:  //add 1 to players who had less turns
    #####:  490:  currentPlayer = whoseTurn(state);
    #####:  491:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  492:    {
    #####:  493:      if ( players[i] == highScore && i > currentPlayer )
        -:  494:	{
    #####:  495:	  players[i]++;
        -:  496:	}
        -:  497:    }
        -:  498:
        -:  499:  //find new highest score
    #####:  500:  j = 0;
    #####:  501:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  502:    {
    #####:  503:      if ( players[i] > players[j] )
        -:  504:	{
    #####:  505:	  j = i;
        -:  506:	}
        -:  507:    }
    #####:  508:  highScore = players[j];
        -:  509:
        -:  510:  //set winners in array to 1 and rest to 0
    #####:  511:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  512:    {
    #####:  513:      if ( players[i] == highScore )
        -:  514:	{
    #####:  515:	  players[i] = 1;
        -:  516:	}
        -:  517:      else
        -:  518:	{
    #####:  519:	  players[i] = 0;
        -:  520:	}
        -:  521:    }
        -:  522:
    #####:  523:  return 0;
        -:  524:}
        -:  525:
     3633:  526:int drawCard(int player, struct gameState *state)
        -:  527:{	int count;
        -:  528:  int deckCounter;
     3633:  529:  if (state->deckCount[player] <= 0){//Deck is empty
        -:  530:    
        -:  531:    //Step 1 Shuffle the discard pile back into a deck
        -:  532:    int i;
        -:  533:    //Move discard to deck
     4098:  534:    for (i = 0; i < state->discardCount[player];i++){
     3828:  535:      state->deck[player][i] = state->discard[player][i];
     3828:  536:      state->discard[player][i] = -1;
        -:  537:    }
        -:  538:
      270:  539:    state->deckCount[player] = state->discardCount[player];
      270:  540:    state->discardCount[player] = 0;//Reset discard
        -:  541:
        -:  542:    //Shufffle the deck
      270:  543:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  544:   
      270:  545:    if (DEBUG){//Debug statements
        -:  546:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  547:    }
        -:  548:    
      270:  549:    state->discardCount[player] = 0;
        -:  550:
        -:  551:    //Step 2 Draw Card
      270:  552:    count = state->handCount[player];//Get current player's hand count
        -:  553:    
      270:  554:    if (DEBUG){//Debug statements
        -:  555:      printf("Current hand count: %d\n", count);
        -:  556:    }
        -:  557:    
      270:  558:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  559:
      270:  560:    if (deckCounter == 0)
    #####:  561:      return -1;
        -:  562:
      270:  563:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
      270:  564:    state->deckCount[player]--;
      270:  565:    state->handCount[player]++;//Increment hand count
        -:  566:  }
        -:  567:
        -:  568:  else{
     3363:  569:    int count = state->handCount[player];//Get current hand count for player
        -:  570:    int deckCounter;
     3363:  571:    if (DEBUG){//Debug statements
        -:  572:      printf("Current hand count: %d\n", count);
        -:  573:    }
        -:  574:
     3363:  575:    deckCounter = state->deckCount[player];//Create holder for the deck count
     3363:  576:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
     3363:  577:    state->deckCount[player]--;
     3363:  578:    state->handCount[player]++;//Increment hand count
        -:  579:  }
        -:  580:
     3633:  581:  return 0;
        -:  582:}
        -:  583:
    13852:  584:int getCost(int cardNumber)
        -:  585:{
    13852:  586:  switch( cardNumber ) 
        -:  587:    {
        -:  588:    case curse:
    #####:  589:      return 0;
        -:  590:    case estate:
     1019:  591:      return 2;
        -:  592:    case duchy:
      759:  593:      return 5;
        -:  594:    case province:
      734:  595:      return 8;
        -:  596:    case copper:
     1612:  597:      return 0;
        -:  598:    case silver:
     1085:  599:      return 3;
        -:  600:    case gold:
      742:  601:      return 6;
        -:  602:    case adventurer:
      175:  603:      return 6;
        -:  604:    case council_room:
      204:  605:      return 5;
        -:  606:    case feast:
    #####:  607:      return 4;
        -:  608:    case gardens:
      646:  609:      return 4;
        -:  610:    case mine:
      627:  611:      return 5;
        -:  612:    case remodel:
      661:  613:      return 4;
        -:  614:    case smithy:
      547:  615:      return 4;
        -:  616:    case village:
      126:  617:      return 3;
        -:  618:    case baron:
      511:  619:      return 4;
        -:  620:    case great_hall:
      265:  621:      return 3;
        -:  622:    case minion:
      320:  623:      return 5;
        -:  624:    case steward:
      463:  625:      return 3;
        -:  626:    case tribute:
    #####:  627:      return 5;
        -:  628:    case ambassador:
      501:  629:      return 3;
        -:  630:    case cutpurse:
      655:  631:      return 4;
        -:  632:    case embargo: 
      492:  633:      return 2;
        -:  634:    case outpost:
      450:  635:      return 5;
        -:  636:    case salvager:
      342:  637:      return 4;
        -:  638:    case sea_hag:
      557:  639:      return 4;
        -:  640:    case treasure_map:
      202:  641:      return 4;
        -:  642:    }
        -:  643:	
      157:  644:  return -1;
        -:  645:}
        -:  646:
    #####:  647:int adventurerCard(int drawntreasure, struct gameState *state, int currentPlayer, int cardDrawn, int temphand [], int handPos, int z, int i){
    #####:  648:  int count = 0;
        -:  649:
    #####:  650:  while(drawntreasure<2){
    #####:  651:    count++;
    #####:  652:    if (state->deckCount[currentPlayer] <1)//if the deck is empty we need to shuffle discard and add to deck
    #####:  653:      shuffle(currentPlayer, state);
    #####:  654:    drawCard(currentPlayer, state);
    #####:  655:    cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
    #####:  656:    if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
    #####:  657:      drawntreasure++;
        -:  658:    else{
    #####:  659:      temphand[z]=cardDrawn;
    #####:  660:      state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####:  661:      z++;
        -:  662:    }
        -:  663:  }
        -:  664:
    #####:  665:  while(z-1>=0){
    #####:  666:    state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
    #####:  667:    z=z-1;
        -:  668:  }
        -:  669:
    #####:  670:  discardCard(handPos, currentPlayer, state, 0);
        -:  671:  //printf("count = %d\n", count);
        -:  672:
    #####:  673:  return 0;
        -:  674:}
        -:  675:
        2:  676:int councilRoomCard(struct gameState *state, int currentPlayer, int handPos, int i){
       10:  677:  for (i = 0; i < 4; i++)
        8:  678:    drawCard(currentPlayer, state);
        2:  679:  state->numBuys++;
        6:  680:  for (i = 0; i < state->numPlayers; i++){  //Each other player draws a card
        4:  681:    if ( i != currentPlayer )
        2:  682:      drawCard(i, state);
        -:  683:  }
        2:  684:  discardCard(handPos, currentPlayer, state, 0); //put played card in played card pile
        -:  685:      
        2:  686:  return 0;
        -:  687:}
        -:  688:
    #####:  689:int feastCard(struct gameState *state, int temphand [], int currentPlayer, int choice1, int i, int x){
    #####:  690:  for (i = 0; i <= state->handCount[currentPlayer]; i++){  
    #####:  691:    temphand[i] = state->hand[currentPlayer][i];
    #####:  692:    state->hand[currentPlayer][i] = -1;
        -:  693:  }
    #####:  694:  updateCoins(currentPlayer, state, 5);
    #####:  695:  x = 1;
    #####:  696:  while( x == 1) {
    #####:  697:    if (supplyCount(choice1, state) <= 0){
    #####:  698:      if (DEBUG)
        -:  699:        printf("None of that card left, sorry!\n");
        -:  700:
    #####:  701:      if (DEBUG)
        -:  702:        printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  703:    }
    #####:  704:    else if (state->coins < getCost(choice1)){
    #####:  705:      printf("That card is too expensive!\n");
    #####:  706:      if (DEBUG)
        -:  707:        printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  708:    }
        -:  709:    else{
    #####:  710:      if (DEBUG)
        -:  711:        printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
    #####:  712:      gainCard(choice1, state, 0, currentPlayer);
    #####:  713:      x = 0;
    #####:  714:      if (DEBUG)
        -:  715:        printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  716:    }
        -:  717:  }
        -:  718:
    #####:  719:  for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  720:    state->hand[currentPlayer][i] = temphand[i];
    #####:  721:    temphand[i] = -1;
        -:  722:  }
        -:  723:            
    #####:  724:      return 0;
        -:  725:}
        -:  726:
    #####:  727:int mineCard(struct gameState *state, int currentPlayer, int choice1, int choice2, int handPos, int i, int j){
    #####:  728:  j = state->hand[currentPlayer][choice1];  //store card we will trash
    #####:  729:  if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
    #####:  730:    return -1;  
    #####:  731:  if (choice2 > treasure_map || choice2 < curse)
    #####:  732:    return -1;
    #####:  733:  if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
    #####:  734:    return -1;
    #####:  735:  gainCard(choice2, state, 2, currentPlayer);
    #####:  736:  discardCard(handPos, currentPlayer, state, 0);
    #####:  737:  for (i = 0; i < state->handCount[currentPlayer]; i++){
    #####:  738:    if (state->hand[currentPlayer][i] == j){
    #####:  739:      discardCard(i, currentPlayer, state, 0);      
    #####:  740:      break;
        -:  741:    }
        -:  742:  }
        -:  743:      
    #####:  744:      return 0;
        -:  745:}
        -:  746:
       24:  747:int remodelCard(struct gameState *state, int currentPlayer, int choice1, int choice2, int handPos, int i, int j){
       24:  748:  j = state->hand[currentPlayer][choice1];  //store card we will trash
       24:  749:  if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
       17:  750:    return -1;
        7:  751:  gainCard(choice2, state, 0, currentPlayer);
        7:  752:  discardCard(handPos, currentPlayer, state, 0);
       13:  753:  for (i = 0; i < state->handCount[currentPlayer]; i++){
       13:  754:    if (state->hand[currentPlayer][i] == j){
        7:  755:        discardCard(i, currentPlayer, state, 0);      
        7:  756:        break;
        -:  757:    }
        -:  758:  }
        7:  759:      return 0;
        -:  760:}
        -:  761:
      360:  762:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  763:{
        -:  764:  int i;
        -:  765:  int j;
        -:  766:  int k;
        -:  767:  int x;
        -:  768:  int index;
      360:  769:  int currentPlayer = whoseTurn(state);
      360:  770:  int nextPlayer = currentPlayer + 1;
        -:  771:
      360:  772:  int tributeRevealedCards[2] = {-1, -1};
        -:  773:  int temphand[MAX_HAND];// moved above the if statement
      360:  774:  int drawntreasure=0;
        -:  775:  int cardDrawn;
      360:  776:  int z = 0;// this is the counter for the temp hand
      360:  777:  if (nextPlayer > (state->numPlayers - 1)){
      224:  778:    nextPlayer = 0;
        -:  779:  }
        -:  780:  
        -:  781:	
        -:  782:  //uses switch to select card and perform actions
      360:  783:  switch( card ) 
        -:  784:    {
        -:  785:    case adventurer:
    #####:  786:      adventurerCard(drawntreasure, state, currentPlayer, cardDrawn, temphand, handPos, z, i);
    #####:  787:      break;
        -:  788:      
        -:  789:    case council_room:
        2:  790:      councilRoomCard(state, currentPlayer, handPos, i);
        2:  791:      break;
        -:  792:			
        -:  793:    case feast:
    #####:  794:      feastCard(state, temphand, currentPlayer, choice1, i, x);
    #####:  795:      break;
        -:  796:
        -:  797:    case gardens:
    #####:  798:      return -1;
        -:  799:			
        -:  800:    case mine:
    #####:  801:      mineCard(state, currentPlayer, choice1, choice2, handPos, i, j);
    #####:  802:      break;
        -:  803:			
        -:  804:    case remodel:
       24:  805:      remodelCard(state, currentPlayer, choice1, choice2, handPos, i, j);
       24:  806:      break;
        -:  807:		
        -:  808:    case smithy:
        -:  809:      //+3 Cards
       48:  810:      for (i = 0; i < 3; i++)
        -:  811:	{
       36:  812:	  drawCard(currentPlayer, state);
        -:  813:	}
        -:  814:			
        -:  815:      //discard card from hand
       12:  816:      discardCard(handPos, currentPlayer, state, 0);
       12:  817:      return 0;
        -:  818:		
        -:  819:    case village:
        -:  820:      //+1 Card
        7:  821:      drawCard(currentPlayer, state);
        -:  822:			
        -:  823:      //+2 Actions
        7:  824:      state->numActions = state->numActions + 2;
        -:  825:			
        -:  826:      //discard played card from hand
        7:  827:      discardCard(handPos, currentPlayer, state, 0);
        7:  828:      return 0;
        -:  829:		
        -:  830:    case baron:
       12:  831:      state->numBuys++;//Increase buys by 1!
       12:  832:      if (choice1 > 0){//Boolean true or going to discard an estate
        5:  833:	int p = 0;//Iterator for hand!
        5:  834:	int card_not_discarded = 1;//Flag for discard set!
       40:  835:	while(card_not_discarded){
       30:  836:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
        1:  837:	    state->coins += 4;//Add 4 coins to the amount of coins
        1:  838:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
        1:  839:	    state->discardCount[currentPlayer]++;
        5:  840:	    for (;p < state->handCount[currentPlayer]; p++){
        4:  841:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
        -:  842:	    }
        1:  843:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
        1:  844:	    state->handCount[currentPlayer]--;
        1:  845:	    card_not_discarded = 0;//Exit the loop
        -:  846:	  }
       29:  847:	  else if (p > state->handCount[currentPlayer]){
        4:  848:	    if(DEBUG) {
        -:  849:	      printf("No estate cards in your hand, invalid choice\n");
        -:  850:	      printf("Must gain an estate if there are any\n");
        -:  851:	    }
        4:  852:	    if (supplyCount(estate, state) > 0){
    #####:  853:	      gainCard(estate, state, 0, currentPlayer);
    #####:  854:	      state->supplyCount[estate]--;//Decrement estates
    #####:  855:	      if (supplyCount(estate, state) == 0){
    #####:  856:		isGameOver(state);
        -:  857:	      }
        -:  858:	    }
        4:  859:	    card_not_discarded = 0;//Exit the loop
        -:  860:	  }
        -:  861:			    
        -:  862:	  else{
       25:  863:	    p++;//Next card
        -:  864:	  }
        -:  865:	}
        -:  866:      }
        -:  867:			    
        -:  868:      else{
        7:  869:	if (supplyCount(estate, state) > 0){
    #####:  870:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  871:	  state->supplyCount[estate]--;//Decrement Estates
    #####:  872:	  if (supplyCount(estate, state) == 0){
    #####:  873:	    isGameOver(state);
        -:  874:	  }
        -:  875:	}
        -:  876:      }
        -:  877:	    
        -:  878:      
       12:  879:      return 0;
        -:  880:		
        -:  881:    case great_hall:
        -:  882:      //+1 Card
    #####:  883:      drawCard(currentPlayer, state);
        -:  884:			
        -:  885:      //+1 Actions
    #####:  886:      state->numActions++;
        -:  887:			
        -:  888:      //discard card from hand
    #####:  889:      discardCard(handPos, currentPlayer, state, 0);
    #####:  890:      return 0;
        -:  891:		
        -:  892:    case minion:
        -:  893:      //+1 action
    #####:  894:      state->numActions++;
        -:  895:			
        -:  896:      //discard card from hand
    #####:  897:      discardCard(handPos, currentPlayer, state, 0);
        -:  898:			
    #####:  899:      if (choice1)		//+2 coins
        -:  900:	{
    #####:  901:	  state->coins = state->coins + 2;
        -:  902:	}
        -:  903:			
    #####:  904:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  905:	{
        -:  906:	  //discard hand
    #####:  907:	  while(numHandCards(state) > 0)
        -:  908:	    {
    #####:  909:	      discardCard(handPos, currentPlayer, state, 0);
        -:  910:	    }
        -:  911:				
        -:  912:	  //draw 4
    #####:  913:	  for (i = 0; i < 4; i++)
        -:  914:	    {
    #####:  915:	      drawCard(currentPlayer, state);
        -:  916:	    }
        -:  917:				
        -:  918:	  //other players discard hand and redraw if hand size > 4
    #####:  919:	  for (i = 0; i < state->numPlayers; i++)
        -:  920:	    {
    #####:  921:	      if (i != currentPlayer)
        -:  922:		{
    #####:  923:		  if ( state->handCount[i] > 4 )
        -:  924:		    {
        -:  925:		      //discard hand
    #####:  926:		      while( state->handCount[i] > 0 )
        -:  927:			{
    #####:  928:			  discardCard(handPos, i, state, 0);
        -:  929:			}
        -:  930:							
        -:  931:		      //draw 4
    #####:  932:		      for (j = 0; j < 4; j++)
        -:  933:			{
    #####:  934:			  drawCard(i, state);
        -:  935:			}
        -:  936:		    }
        -:  937:		}
        -:  938:	    }
        -:  939:				
        -:  940:	}
    #####:  941:      return 0;
        -:  942:		
        -:  943:    case steward:
        -:  944:     //discard card from hand
       19:  945:      discardCard(handPos, currentPlayer, state, 0);
       19:  946:      if (choice1 == 1)
        -:  947:	{
        -:  948:	  //+2 cards
        5:  949:	  drawCard(currentPlayer, state);
        5:  950:	  drawCard(currentPlayer, state);
        -:  951:	}
       14:  952:      else if (choice1 == 2)
        -:  953:	{
        -:  954:	  //+2 coins
        4:  955:	  state->coins = state->coins + 2;
        -:  956:	}
        -:  957:      else
        -:  958:	{
        -:  959:	  //trash 2 cards in hand
       10:  960:	  discardCard(choice2, currentPlayer, state, 1);
       10:  961:	  discardCard(choice3, currentPlayer, state, 1);
        -:  962:	}
        -:  963:			
       19:  964:      return 0;
        -:  965:		
        -:  966:    case tribute:
    #####:  967:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####:  968:	if (state->deckCount[nextPlayer] > 0){
    #####:  969:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  970:	  state->deckCount[nextPlayer]--;
        -:  971:	}
    #####:  972:	else if (state->discardCount[nextPlayer] > 0){
    #####:  973:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####:  974:	  state->discardCount[nextPlayer]--;
        -:  975:	}
        -:  976:	else{
        -:  977:	  //No Card to Reveal
    #####:  978:	  if (DEBUG){
        -:  979:	    printf("No cards to reveal\n");
        -:  980:	  }
        -:  981:	}
        -:  982:      }
        -:  983:	    
        -:  984:      else{
    #####:  985:	if (state->deckCount[nextPlayer] == 0){
    #####:  986:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####:  987:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####:  988:	    state->deckCount[nextPlayer]++;
    #####:  989:	    state->discard[nextPlayer][i] = -1;
    #####:  990:	    state->discardCount[nextPlayer]--;
        -:  991:	  }
        -:  992:			    
    #####:  993:	  shuffle(nextPlayer,state);//Shuffle the deck
        -:  994:	} 
    #####:  995:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  996:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####:  997:	state->deckCount[nextPlayer]--;
    #####:  998:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  999:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1000:	state->deckCount[nextPlayer]--;
        -: 1001:      }    
        -: 1002:		       
    #####: 1003:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
    #####: 1004:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1005:	state->playedCardCount++;
    #####: 1006:	tributeRevealedCards[1] = -1;
        -: 1007:      }
        -: 1008:
    #####: 1009:      for (i = 0; i <= 2; i ++){
    #####: 1010:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
    #####: 1011:	  state->coins += 2;
        -: 1012:	}
        -: 1013:		    
    #####: 1014:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
    #####: 1015:	  drawCard(currentPlayer, state);
    #####: 1016:	  drawCard(currentPlayer, state);
        -: 1017:	}
        -: 1018:	else{//Action Card
    #####: 1019:	  state->numActions = state->numActions + 2;
        -: 1020:	}
        -: 1021:      }
        -: 1022:	    
    #####: 1023:      return 0;
        -: 1024:		
        -: 1025:    case ambassador:
        -: 1026:
       50: 1027:      j = 0;		//used to check if player has enough cards to discard
        -: 1028:
       50: 1029:      if (choice2 > 2 || choice2 < 0)
        -: 1030:	{
    #####: 1031:	  return -1;				
        -: 1032:	}
        -: 1033:
       50: 1034:      if (choice1 == handPos)
        -: 1035:	{
    #####: 1036:	  return -1;
        -: 1037:	}
        -: 1038:
      306: 1039:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1040:	{
      256: 1041:	  if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1042:	    {
        9: 1043:	      j++;
        -: 1044:	    }
        -: 1045:	}
       50: 1046:      if (j < choice2)
        -: 1047:	{
       28: 1048:	  return -1;				
        -: 1049:	}
        -: 1050:
       22: 1051:      if (DEBUG) 
        -: 1052:	printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1053:
        -: 1054:      //increase supply count for choosen card by amount being discarded
       22: 1055:      state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1056:			
        -: 1057:      //each other player gains a copy of revealed card
       60: 1058:      for (i = 0; i < state->numPlayers; i++)
        -: 1059:	{
       38: 1060:	  if (i != currentPlayer)
        -: 1061:	    {
       17: 1062:	      gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1063:	    }
        -: 1064:	}
        -: 1065:
        -: 1066:      //discard played card from hand
       22: 1067:      discardCard(handPos, currentPlayer, state, 0);			
        -: 1068:
        -: 1069:      //trash copies of cards returned to supply
       28: 1070:      for (j = 0; j < choice2; j++)
        -: 1071:	{
       15: 1072:	  for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1073:	    {
       15: 1074:	      if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1075:		{
        6: 1076:		  discardCard(i, currentPlayer, state, 1);
        6: 1077:		  break;
        -: 1078:		}
        -: 1079:	    }
        -: 1080:	}			
        -: 1081:
       22: 1082:      return 0;
        -: 1083:		
        -: 1084:    case cutpurse:
        -: 1085:
        6: 1086:      updateCoins(currentPlayer, state, 2);
       17: 1087:      for (i = 0; i < state->numPlayers; i++)
        -: 1088:	{
       11: 1089:	  if (i != currentPlayer)
        -: 1090:	    {
        5: 1091:	      for (j = 0; j < state->handCount[i]; j++)
        -: 1092:		{
    #####: 1093:		  if (state->hand[i][j] == copper)
        -: 1094:		    {
    #####: 1095:		      discardCard(j, i, state, 0);
    #####: 1096:		      break;
        -: 1097:		    }
    #####: 1098:		  if (j == state->handCount[i])
        -: 1099:		    {
    #####: 1100:		      for (k = 0; k < state->handCount[i]; k++)
        -: 1101:			{
    #####: 1102:			  if (DEBUG)
        -: 1103:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1104:			}	
    #####: 1105:		      break;
        -: 1106:		    }		
        -: 1107:		}
        -: 1108:					
        -: 1109:	    }
        -: 1110:				
        -: 1111:	}				
        -: 1112:
        -: 1113:      //discard played card from hand
        6: 1114:      discardCard(handPos, currentPlayer, state, 0);			
        -: 1115:
        6: 1116:      return 0;
        -: 1117:
        -: 1118:		
        -: 1119:    case embargo: 
        -: 1120:      //+2 Coins
       35: 1121:      state->coins = state->coins + 2;
        -: 1122:			
        -: 1123:      //see if selected pile is in play
       35: 1124:      if ( state->supplyCount[choice1] == -1 )
        -: 1125:	{
    #####: 1126:	  return -1;
        -: 1127:	}
        -: 1128:			
        -: 1129:      //add embargo token to selected supply pile
       35: 1130:      state->embargoTokens[choice1]++;
        -: 1131:			
        -: 1132:      //trash card
       35: 1133:      discardCard(handPos, currentPlayer, state, 1);		
       35: 1134:      return 0;
        -: 1135:		
        -: 1136:    case outpost:
        -: 1137:      //set outpost flag
        1: 1138:      state->outpostPlayed++;
        -: 1139:			
        -: 1140:      //discard card
        1: 1141:      discardCard(handPos, currentPlayer, state, 0);
        1: 1142:      return 0;
        -: 1143:		
        -: 1144:    case salvager:
        -: 1145:      //+1 buy
       10: 1146:      state->numBuys++;
        -: 1147:			
       10: 1148:      if (choice1)
        -: 1149:	{
        -: 1150:	  //gain coins equal to trashed card
        8: 1151:	  state->coins = state->coins + getCost( handCard(choice1, state) );
        -: 1152:	  //trash card
        8: 1153:	  discardCard(choice1, currentPlayer, state, 1);	
        -: 1154:	}
        -: 1155:			
        -: 1156:      //discard card
       10: 1157:      discardCard(handPos, currentPlayer, state, 0);
       10: 1158:      return 0;
        -: 1159:		
        -: 1160:    case sea_hag:
      211: 1161:      for (i = 0; i < state->numPlayers; i++){
      137: 1162:	if (i != currentPlayer){
       63: 1163:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
       63: 1164:	  state->discardCount[i]++;
       63: 1165:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1166:	}
        -: 1167:      }
       74: 1168:      return 0;
        -: 1169:		
        -: 1170:    case treasure_map:
        -: 1171:      //search hand for another treasure_map
      108: 1172:      index = -1;
      648: 1173:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1174:	{
      540: 1175:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -: 1176:	    {
    #####: 1177:	      index = i;
    #####: 1178:	      break;
        -: 1179:	    }
        -: 1180:	}
      108: 1181:      if (index > -1)
        -: 1182:	{
        -: 1183:	  //trash both treasure cards
    #####: 1184:	  discardCard(handPos, currentPlayer, state, 1);
    #####: 1185:	  discardCard(index, currentPlayer, state, 1);
        -: 1186:
        -: 1187:	  //gain 4 Gold cards
    #####: 1188:	  for (i = 0; i < 4; i++)
        -: 1189:	    {
    #####: 1190:	      gainCard(gold, state, 1, currentPlayer);
        -: 1191:	    }
        -: 1192:				
        -: 1193:	  //return success
    #####: 1194:	  return 1;
        -: 1195:	}
        -: 1196:			
        -: 1197:      //no second treasure_map found in hand
      108: 1198:      return -1;
        -: 1199:    }
        -: 1200:
       26: 1201:  return -1;
        -: 1202:}
        -: 1203:
      162: 1204:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1205:{
        -: 1206:	
        -: 1207:  //if card is not trashed, added to Played pile 
      162: 1208:  if (trashFlag < 1)
        -: 1209:    {
        -: 1210:      //add card to played pile
       93: 1211:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
       93: 1212:      state->playedCardCount++;
        -: 1213:    }
        -: 1214:	
        -: 1215:  //set played card to -1
      162: 1216:  state->hand[currentPlayer][handPos] = -1;
        -: 1217:	
        -: 1218:  //remove card from player's hand
      162: 1219:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
        -: 1220:    {
        -: 1221:      //reduce number of cards in hand
       22: 1222:      state->handCount[currentPlayer]--;
       22: 1223:      state->discardCount[currentPlayer]++;
        -: 1224:    }
      140: 1225:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
        -: 1226:    {
        -: 1227:      //reduce number of cards in hand
    #####: 1228:      state->handCount[currentPlayer]--;
    #####: 1229:      state->discardCount[currentPlayer]++;
        -: 1230:    }
        -: 1231:  else 	
        -: 1232:    {
        -: 1233:      //replace discarded card with last card in hand
      140: 1234:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1235:      //set last card to -1
      140: 1236:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1237:      //reduce number of cards in hand
      140: 1238:      state->handCount[currentPlayer]--;
      140: 1239:      state->discardCount[currentPlayer]++;
        -: 1240:    }
        -: 1241:	
      162: 1242:  return 0;
        -: 1243:}
        -: 1244:
      294: 1245:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1246:{
        -: 1247:  //Note: supplyPos is enum of choosen card
        -: 1248:	
        -: 1249:  //check if supply pile is empty (0) or card is not used in game (-1)
      294: 1250:  if ( supplyCount(supplyPos, state) < 1 )
        -: 1251:    {
        2: 1252:      return -1;
        -: 1253:    }
        -: 1254:	
        -: 1255:  //added card for [whoseTurn] current player:
        -: 1256:  // toFlag = 0 : add to discard
        -: 1257:  // toFlag = 1 : add to deck
        -: 1258:  // toFlag = 2 : add to hand
        -: 1259:
      292: 1260:  if (toFlag == 1)
        -: 1261:    {
    #####: 1262:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
    #####: 1263:      state->deckCount[player]++;
        -: 1264:    }
      292: 1265:  else if (toFlag == 2)
        -: 1266:    {
    #####: 1267:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
    #####: 1268:      state->handCount[player]++;
        -: 1269:    }
        -: 1270:  else
        -: 1271:    {
      292: 1272:      state->discard[player][ state->discardCount[player] ] = supplyPos;
      292: 1273:      state->discardCount[player]++;
        -: 1274:    }
        -: 1275:	
        -: 1276:  //decrease number in supply pile
      292: 1277:  state->supplyCount[supplyPos]--;
        -: 1278:	 
      292: 1279:  return 0;
        -: 1280:}
        -: 1281:
      918: 1282:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1283:{
        -: 1284:  int i;
        -: 1285:	
        -: 1286:  //reset coin count
      918: 1287:  state->coins = 0;
        -: 1288:
        -: 1289:  //add coins for each Treasure card in player's hand
     5418: 1290:  for (i = 0; i < state->handCount[player]; i++)
        -: 1291:    {
     4500: 1292:      if (state->hand[player][i] == copper)
        -: 1293:	{
      938: 1294:	  state->coins += 1;
        -: 1295:	}
     3562: 1296:      else if (state->hand[player][i] == silver)
        -: 1297:	{
      341: 1298:	  state->coins += 2;
        -: 1299:	}
     3221: 1300:      else if (state->hand[player][i] == gold)
        -: 1301:	{
    #####: 1302:	  state->coins += 3;
        -: 1303:	}	
        -: 1304:    }	
        -: 1305:
        -: 1306:  //add bonus
      918: 1307:  state->coins += bonus;
        -: 1308:
      918: 1309:  return 0;
        -: 1310:}
        -: 1311:
        -: 1312://end of dominion.c
        -: 1313:
File 'dominion.c'
Lines executed:68.94% of 586
dominion.c:creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:6
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
    13073:    8:int compare(const void* a, const void* b) {
    13073:    9:  if (*(int*)a > *(int*)b)
     5988:   10:    return 1;
     7085:   11:  if (*(int*)a < *(int*)b)
     1995:   12:    return -1;
     5090:   13:  return 0;
        -:   14:}
        -:   15:
    #####:   16:struct gameState* newGame() {
    #####:   17:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:  return g;
        -:   19:}
        -:   20:
    #####:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:		  int k8, int k9, int k10) {
    #####:   23:  int* k = malloc(10 * sizeof(int));
    #####:   24:  k[0] = k1;
    #####:   25:  k[1] = k2;
    #####:   26:  k[2] = k3;
    #####:   27:  k[3] = k4;
    #####:   28:  k[4] = k5;
    #####:   29:  k[5] = k6;
    #####:   30:  k[6] = k7;
    #####:   31:  k[7] = k8;
    #####:   32:  k[8] = k9;
    #####:   33:  k[9] = k10;
    #####:   34:  return k;
        -:   35:}
        -:   36:
        6:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		   struct gameState *state) {
        -:   39:
        -:   40:  int i;
        -:   41:  int j;
        -:   42:  int it;			
        -:   43:  //set up random number generator
        6:   44:  SelectStream(1);
        6:   45:  PutSeed((long)randomSeed);
        -:   46:  
        -:   47:  //check number of players
        6:   48:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:    {
    #####:   50:      return -1;
        -:   51:    }
        -:   52:
        -:   53:  //set number of players
        6:   54:  state->numPlayers = numPlayers;
        -:   55:
        -:   56:  //check selected kingdom cards are different
       66:   57:  for (i = 0; i < 10; i++)
        -:   58:    {
      660:   59:      for (j = 0; j < 10; j++)
        -:   60:        {
      600:   61:	  if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:	    {
    #####:   63:	      return -1;
        -:   64:	    }
        -:   65:        }
        -:   66:    }
        -:   67:
        -:   68:
        -:   69:  //initialize supply
        -:   70:  ///////////////////////////////
        -:   71:
        -:   72:  //set number of Curse cards
        6:   73:  if (numPlayers == 2)
        -:   74:    {
        6:   75:      state->supplyCount[curse] = 10;
        -:   76:    }
    #####:   77:  else if (numPlayers == 3)
        -:   78:    {
    #####:   79:      state->supplyCount[curse] = 20;
        -:   80:    }
        -:   81:  else
        -:   82:    {
    #####:   83:      state->supplyCount[curse] = 30;
        -:   84:    }
        -:   85:
        -:   86:  //set number of Victory cards
        6:   87:  if (numPlayers == 2)
        -:   88:    {
        6:   89:      state->supplyCount[estate] = 8;
        6:   90:      state->supplyCount[duchy] = 8;
        6:   91:      state->supplyCount[province] = 8;
        -:   92:    }
        -:   93:  else
        -:   94:    {
    #####:   95:      state->supplyCount[estate] = 12;
    #####:   96:      state->supplyCount[duchy] = 12;
    #####:   97:      state->supplyCount[province] = 12;
        -:   98:    }
        -:   99:
        -:  100:  //set number of Treasure cards
        6:  101:  state->supplyCount[copper] = 60 - (7 * numPlayers);
        6:  102:  state->supplyCount[silver] = 40;
        6:  103:  state->supplyCount[gold] = 30;
        -:  104:
        -:  105:  //set number of Kingdom cards
      126:  106:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:    {
      990:  108:      for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:	{
      930:  110:	  if (kingdomCards[j] == i)
        -:  111:	    {
        -:  112:	      //check if card is a 'Victory' Kingdom card
       66:  113:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:		{
        6:  115:		  if (numPlayers == 2){ 
        6:  116:		    state->supplyCount[i] = 8; 
        -:  117:		  }
    #####:  118:		  else{ state->supplyCount[i] = 12; }
        -:  119:		}
        -:  120:	      else
        -:  121:		{
       54:  122:		  state->supplyCount[i] = 10;
        -:  123:		}
       60:  124:	      break;
        -:  125:	    }
        -:  126:	  else    //card is not in the set choosen for the game
        -:  127:	    {
      870:  128:	      state->supplyCount[i] = -1;
        -:  129:	    }
        -:  130:	}
        -:  131:
        -:  132:    }
        -:  133:
        -:  134:  ////////////////////////
        -:  135:  //supply intilization complete
        -:  136:
        -:  137:  //set player decks
       18:  138:  for (i = 0; i < numPlayers; i++)
        -:  139:    {
       12:  140:      state->deckCount[i] = 0;
       48:  141:      for (j = 0; j < 3; j++)
        -:  142:	{
       36:  143:	  state->deck[i][j] = estate;
       36:  144:	  state->deckCount[i]++;
        -:  145:	}
       96:  146:      for (j = 3; j < 10; j++)
        -:  147:	{
       84:  148:	  state->deck[i][j] = copper;
       84:  149:	  state->deckCount[i]++;		
        -:  150:	}
        -:  151:    }
        -:  152:
        -:  153:  //shuffle player decks
       18:  154:  for (i = 0; i < numPlayers; i++)
        -:  155:    {
       12:  156:      if ( shuffle(i, state) < 0 )
        -:  157:	{
    #####:  158:	  return -1;
        -:  159:	}
        -:  160:    }
        -:  161:
        -:  162:  //draw player hands
       18:  163:  for (i = 0; i < numPlayers; i++)
        -:  164:    {  
        -:  165:      //initialize hand size to zero
       12:  166:      state->handCount[i] = 0;
       12:  167:      state->discardCount[i] = 0;
        -:  168:      //draw 5 cards
        -:  169:      // for (j = 0; j < 5; j++)
        -:  170:      //	{
        -:  171:      //	  drawCard(i, state);
        -:  172:      //	}
        -:  173:    }
        -:  174:  
        -:  175:  //set embargo tokens to 0 for all supply piles
      168:  176:  for (i = 0; i <= treasure_map; i++)
        -:  177:    {
      162:  178:      state->embargoTokens[i] = 0;
        -:  179:    }
        -:  180:
        -:  181:  //initialize first player's turn
        6:  182:  state->outpostPlayed = 0;
        6:  183:  state->phase = 0;
        6:  184:  state->numActions = 1;
        6:  185:  state->numBuys = 1;
        6:  186:  state->playedCardCount = 0;
        6:  187:  state->whoseTurn = 0;
        6:  188:  state->handCount[state->whoseTurn] = 0;
        -:  189:  //int it; move to top
        -:  190:
        -:  191:  //Moved draw cards to here, only drawing at the start of a turn
       36:  192:  for (it = 0; it < 5; it++){
       30:  193:    drawCard(state->whoseTurn, state);
        -:  194:  }
        -:  195:
        6:  196:  updateCoins(state->whoseTurn, state, 0);
        -:  197:
        6:  198:  return 0;
        -:  199:}
        -:  200:
      298:  201:int shuffle(int player, struct gameState *state) {
        -:  202: 
        -:  203:
        -:  204:  int newDeck[MAX_DECK];
      298:  205:  int newDeckPos = 0;
        -:  206:  int card;
        -:  207:  int i;
        -:  208:
      298:  209:  if (state->deckCount[player] < 1)
    #####:  210:    return -1;
      298:  211:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
        -:  212:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
     4941:  214:  while (state->deckCount[player] > 0) {
     4345:  215:    card = floor(Random() * state->deckCount[player]);
     4345:  216:    newDeck[newDeckPos] = state->deck[player][card];
     4345:  217:    newDeckPos++;
    28853:  218:    for (i = card; i < state->deckCount[player]-1; i++) {
    24508:  219:      state->deck[player][i] = state->deck[player][i+1];
        -:  220:    }
     4345:  221:    state->deckCount[player]--;
        -:  222:  }
     4643:  223:  for (i = 0; i < newDeckPos; i++) {
     4345:  224:    state->deck[player][i] = newDeck[i];
     4345:  225:    state->deckCount[player]++;
        -:  226:  }
        -:  227:
      298:  228:  return 0;
        -:  229:}
        -:  230:
      437:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  232:{	
        -:  233:  int card;
      437:  234:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:  //check if it is the right phase
      437:  237:  if (state->phase != 0)
        -:  238:    {
    #####:  239:      return -1;
        -:  240:    }
        -:  241:	
        -:  242:  //check if player has enough actions
      437:  243:  if ( state->numActions < 1 )
        -:  244:    {
    #####:  245:      return -1;
        -:  246:    }
        -:  247:	
        -:  248:  //get card played
      437:  249:  card = handCard(handPos, state);
        -:  250:	
        -:  251:  //check if selected card is an action
      437:  252:  if ( card < adventurer || card > treasure_map )
        -:  253:    {
    #####:  254:      return -1;
        -:  255:    }
        -:  256:	
        -:  257:  //play card
      437:  258:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
        -:  259:    {
      210:  260:      return -1;
        -:  261:    }
        -:  262:	
        -:  263:  //reduce number of actions
        -:  264:
      227:  265:  state->numActions--;
        -:  266:
        -:  267:  //update coins (Treasure cards may be added with card draws)
      227:  268:  updateCoins(state->whoseTurn, state, coin_bonus);
        -:  269:	
      227:  270:  return 0;
        -:  271:}
        -:  272:
      399:  273:int buyCard(int supplyPos, struct gameState *state) {
        -:  274:  int who;
      399:  275:  if (DEBUG){
        -:  276:    printf("Entering buyCard...\n");
        -:  277:  }
        -:  278:
        -:  279:  // I don't know what to do about the phase thing.
        -:  280:
      399:  281:  who = state->whoseTurn;
        -:  282:
      399:  283:  if (state->numBuys < 1){
    #####:  284:    if (DEBUG)
        -:  285:      printf("You do not have any buys left\n");
    #####:  286:    return -1;
      399:  287:  } else if (supplyCount(supplyPos, state) <1){
    #####:  288:    if (DEBUG)
        -:  289:      printf("There are not any of that type of card left\n");
    #####:  290:    return -1;
      399:  291:  } else if (state->coins < getCost(supplyPos)){
       90:  292:    if (DEBUG) 
        -:  293:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
       90:  294:    return -1;
        -:  295:  } else {
      309:  296:    state->phase=1;
        -:  297:    //state->supplyCount[supplyPos]--;
      309:  298:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  299:  
      309:  300:    state->coins = (state->coins) - (getCost(supplyPos));
      309:  301:    state->numBuys--;
      309:  302:    if (DEBUG)
        -:  303:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  304:  }
        -:  305:
        -:  306:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  307:  //state->discardCount[who]++;
        -:  308:    
      309:  309:  return 0;
        -:  310:}
        -:  311:
    #####:  312:int numHandCards(struct gameState *state) {
    #####:  313:  return state->handCount[ whoseTurn(state) ];
        -:  314:}
        -:  315:
      447:  316:int handCard(int handPos, struct gameState *state) {
      447:  317:  int currentPlayer = whoseTurn(state);
      447:  318:  return state->hand[currentPlayer][handPos];
        -:  319:}
        -:  320:
      835:  321:int supplyCount(int card, struct gameState *state) {
      835:  322:  return state->supplyCount[card];
        -:  323:}
        -:  324:
    #####:  325:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  326:  int i;
    #####:  327:  int count = 0;
        -:  328:
    #####:  329:  for (i = 0; i < state->deckCount[player]; i++)
        -:  330:    {
    #####:  331:      if (state->deck[player][i] == card) count++;
        -:  332:    }
        -:  333:
    #####:  334:  for (i = 0; i < state->handCount[player]; i++)
        -:  335:    {
    #####:  336:      if (state->hand[player][i] == card) count++;
        -:  337:    }
        -:  338:
    #####:  339:  for (i = 0; i < state->discardCount[player]; i++)
        -:  340:    {
    #####:  341:      if (state->discard[player][i] == card) count++;
        -:  342:    }
        -:  343:
    #####:  344:  return count;
        -:  345:}
        -:  346:
     1658:  347:int whoseTurn(struct gameState *state) {
     1658:  348:  return state->whoseTurn;
        -:  349:}
        -:  350:
      774:  351:int endTurn(struct gameState *state) {
        -:  352:  int k;
        -:  353:  int i;
      774:  354:  int currentPlayer = whoseTurn(state);
        -:  355:  
        -:  356:  //Discard hand
     4516:  357:  for (i = 0; i < state->handCount[currentPlayer]; i++){
     3742:  358:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
     3742:  359:    state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  360:  }
      774:  361:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  362:    
        -:  363:  //Code for determining the player
      774:  364:  if (currentPlayer < (state->numPlayers - 1)){ 
      314:  365:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  366:  }
        -:  367:  else{
      460:  368:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  369:  }
        -:  370:
      774:  371:  state->outpostPlayed = 0;
      774:  372:  state->phase = 0;
      774:  373:  state->numActions = 1;
      774:  374:  state->coins = 0;
      774:  375:  state->numBuys = 1;
      774:  376:  state->playedCardCount = 0;
      774:  377:  state->handCount[state->whoseTurn] = 0;
        -:  378:
        -:  379:  //int k; move to top
        -:  380:  //Next player draws hand
     4644:  381:  for (k = 0; k < 5; k++){
     3870:  382:    drawCard(state->whoseTurn, state);//Draw a card
        -:  383:  }
        -:  384:
        -:  385:  //Update money
      774:  386:  updateCoins(state->whoseTurn, state , 0);
        -:  387:
      774:  388:  return 0;
        -:  389:}
        -:  390:
      780:  391:int isGameOver(struct gameState *state) {
        -:  392:  int i;
        -:  393:  int j;
        -:  394:	
        -:  395:  //if stack of Province cards is empty, the game ends
      780:  396:  if (state->supplyCount[province] == 0)
        -:  397:    {
    #####:  398:      return 1;
        -:  399:    }
        -:  400:
        -:  401:  //if three supply pile are at 0, the game ends
      780:  402:  j = 0;
    20280:  403:  for (i = 0; i < 25; i++)
        -:  404:    {
    19500:  405:      if (state->supplyCount[i] == 0)
        -:  406:	{
     1023:  407:	  j++;
        -:  408:	}
        -:  409:    }
      780:  410:  if ( j >= 3)
        -:  411:    {
        6:  412:      return 1;
        -:  413:    }
        -:  414:
      774:  415:  return 0;
        -:  416:}
        -:  417:
        9:  418:int scoreFor (int player, struct gameState *state) {
        -:  419:
        -:  420:  int i;
        9:  421:  int score = 0;
        -:  422:  //score from hand
       39:  423:  for (i = 0; i < state->handCount[player]; i++)
        -:  424:    {
       30:  425:      if (state->hand[player][i] == curse) { score = score - 1; };
       30:  426:      if (state->hand[player][i] == estate) { score = score + 1; };
       30:  427:      if (state->hand[player][i] == duchy) { score = score + 3; };
       30:  428:      if (state->hand[player][i] == province) { score = score + 6; };
       30:  429:      if (state->hand[player][i] == great_hall) { score = score + 1; };
       30:  430:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
        -:  431:    }
        -:  432:
        -:  433:  //score from discard
      123:  434:  for (i = 0; i < state->discardCount[player]; i++)
        -:  435:    {
      114:  436:      if (state->discard[player][i] == curse) { score = score - 1; };
      114:  437:      if (state->discard[player][i] == estate) { score = score + 1; };
      114:  438:      if (state->discard[player][i] == duchy) { score = score + 3; };
      114:  439:      if (state->discard[player][i] == province) { score = score + 6; };
      114:  440:      if (state->discard[player][i] == great_hall) { score = score + 1; };
      114:  441:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
        -:  442:    }
        -:  443:
        -:  444:  //score from deck
      123:  445:  for (i = 0; i < state->discardCount[player]; i++)
        -:  446:    {
      114:  447:      if (state->deck[player][i] == curse) { score = score - 1; };
      114:  448:      if (state->deck[player][i] == estate) { score = score + 1; };
      114:  449:      if (state->deck[player][i] == duchy) { score = score + 3; };
      114:  450:      if (state->deck[player][i] == province) { score = score + 6; };
      114:  451:      if (state->deck[player][i] == great_hall) { score = score + 1; };
      114:  452:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
        -:  453:    }
        -:  454:
        9:  455:  return score;
        -:  456:}
        -:  457:
    #####:  458:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  459:  int i;	
        -:  460:  int j;
        -:  461:  int highScore;
        -:  462:  int currentPlayer;
        -:  463:
        -:  464:  //get score for each player
    #####:  465:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  466:    {
        -:  467:      //set unused player scores to -9999
    #####:  468:      if (i >= state->numPlayers)
        -:  469:	{
    #####:  470:	  players[i] = -9999;
        -:  471:	}
        -:  472:      else
        -:  473:	{
    #####:  474:	  players[i] = scoreFor (i, state);
        -:  475:	}
        -:  476:    }
        -:  477:
        -:  478:  //find highest score
    #####:  479:  j = 0;
    #####:  480:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  481:    {
    #####:  482:      if (players[i] > players[j])
        -:  483:	{
    #####:  484:	  j = i;
        -:  485:	}
        -:  486:    }
    #####:  487:  highScore = players[j];
        -:  488:
        -:  489:  //add 1 to players who had less turns
    #####:  490:  currentPlayer = whoseTurn(state);
    #####:  491:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  492:    {
    #####:  493:      if ( players[i] == highScore && i > currentPlayer )
        -:  494:	{
    #####:  495:	  players[i]++;
        -:  496:	}
        -:  497:    }
        -:  498:
        -:  499:  //find new highest score
    #####:  500:  j = 0;
    #####:  501:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  502:    {
    #####:  503:      if ( players[i] > players[j] )
        -:  504:	{
    #####:  505:	  j = i;
        -:  506:	}
        -:  507:    }
    #####:  508:  highScore = players[j];
        -:  509:
        -:  510:  //set winners in array to 1 and rest to 0
    #####:  511:  for (i = 0; i < MAX_PLAYERS; i++)
        -:  512:    {
    #####:  513:      if ( players[i] == highScore )
        -:  514:	{
    #####:  515:	  players[i] = 1;
        -:  516:	}
        -:  517:      else
        -:  518:	{
    #####:  519:	  players[i] = 0;
        -:  520:	}
        -:  521:    }
        -:  522:
    #####:  523:  return 0;
        -:  524:}
        -:  525:
     3967:  526:int drawCard(int player, struct gameState *state)
        -:  527:{	int count;
        -:  528:  int deckCounter;
     3967:  529:  if (state->deckCount[player] <= 0){//Deck is empty
        -:  530:    
        -:  531:    //Step 1 Shuffle the discard pile back into a deck
        -:  532:    int i;
        -:  533:    //Move discard to deck
     4511:  534:    for (i = 0; i < state->discardCount[player];i++){
     4225:  535:      state->deck[player][i] = state->discard[player][i];
     4225:  536:      state->discard[player][i] = -1;
        -:  537:    }
        -:  538:
      286:  539:    state->deckCount[player] = state->discardCount[player];
      286:  540:    state->discardCount[player] = 0;//Reset discard
        -:  541:
        -:  542:    //Shufffle the deck
      286:  543:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  544:   
      286:  545:    if (DEBUG){//Debug statements
        -:  546:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  547:    }
        -:  548:    
      286:  549:    state->discardCount[player] = 0;
        -:  550:
        -:  551:    //Step 2 Draw Card
      286:  552:    count = state->handCount[player];//Get current player's hand count
        -:  553:    
      286:  554:    if (DEBUG){//Debug statements
        -:  555:      printf("Current hand count: %d\n", count);
        -:  556:    }
        -:  557:    
      286:  558:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  559:
      286:  560:    if (deckCounter == 0)
    #####:  561:      return -1;
        -:  562:
      286:  563:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
      286:  564:    state->deckCount[player]--;
      286:  565:    state->handCount[player]++;//Increment hand count
        -:  566:  }
        -:  567:
        -:  568:  else{
     3681:  569:    int count = state->handCount[player];//Get current hand count for player
        -:  570:    int deckCounter;
     3681:  571:    if (DEBUG){//Debug statements
        -:  572:      printf("Current hand count: %d\n", count);
        -:  573:    }
        -:  574:
     3681:  575:    deckCounter = state->deckCount[player];//Create holder for the deck count
     3681:  576:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
     3681:  577:    state->deckCount[player]--;
     3681:  578:    state->handCount[player]++;//Increment hand count
        -:  579:  }
        -:  580:
     3967:  581:  return 0;
        -:  582:}
        -:  583:
    15871:  584:int getCost(int cardNumber)
        -:  585:{
    15871:  586:  switch( cardNumber ) 
        -:  587:    {
        -:  588:    case curse:
    #####:  589:      return 0;
        -:  590:    case estate:
     1190:  591:      return 2;
        -:  592:    case duchy:
      879:  593:      return 5;
        -:  594:    case province:
      843:  595:      return 8;
        -:  596:    case copper:
     1787:  597:      return 0;
        -:  598:    case silver:
     1228:  599:      return 3;
        -:  600:    case gold:
      851:  601:      return 6;
        -:  602:    case adventurer:
      284:  603:      return 6;
        -:  604:    case council_room:
      204:  605:      return 5;
        -:  606:    case feast:
      122:  607:      return 4;
        -:  608:    case gardens:
      646:  609:      return 4;
        -:  610:    case mine:
      746:  611:      return 5;
        -:  612:    case remodel:
      661:  613:      return 4;
        -:  614:    case smithy:
      547:  615:      return 4;
        -:  616:    case village:
      244:  617:      return 3;
        -:  618:    case baron:
      511:  619:      return 4;
        -:  620:    case great_hall:
      265:  621:      return 3;
        -:  622:    case minion:
      320:  623:      return 5;
        -:  624:    case steward:
      463:  625:      return 3;
        -:  626:    case tribute:
      114:  627:      return 5;
        -:  628:    case ambassador:
      625:  629:      return 3;
        -:  630:    case cutpurse:
      773:  631:      return 4;
        -:  632:    case embargo: 
      624:  633:      return 2;
        -:  634:    case outpost:
      571:  635:      return 5;
        -:  636:    case salvager:
      457:  637:      return 4;
        -:  638:    case sea_hag:
      557:  639:      return 4;
        -:  640:    case treasure_map:
      202:  641:      return 4;
        -:  642:    }
        -:  643:	
      157:  644:  return -1;
        -:  645:}
        -:  646:
    #####:  647:int adventurerCard(int drawntreasure, struct gameState *state, int currentPlayer, int cardDrawn, int temphand [], int handPos, int z, int i){
    #####:  648:  int count = 0;
        -:  649:
    #####:  650:  while(drawntreasure<2){
    #####:  651:    count++;
    #####:  652:    if (state->deckCount[currentPlayer] <1)//if the deck is empty we need to shuffle discard and add to deck
    #####:  653:      shuffle(currentPlayer, state);
    #####:  654:    drawCard(currentPlayer, state);
    #####:  655:    cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
    #####:  656:    if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
    #####:  657:      drawntreasure++;
        -:  658:    else{
    #####:  659:      temphand[z]=cardDrawn;
    #####:  660:      state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####:  661:      z++;
        -:  662:    }
        -:  663:  }
        -:  664:
    #####:  665:  while(z-1>=0){
    #####:  666:    state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
    #####:  667:    z=z-1;
        -:  668:  }
        -:  669:
    #####:  670:  discardCard(handPos, currentPlayer, state, 0);
        -:  671:  //printf("count = %d\n", count);
        -:  672:
    #####:  673:  return 0;
        -:  674:}
        -:  675:
        2:  676:int councilRoomCard(struct gameState *state, int currentPlayer, int handPos, int i){
       10:  677:  for (i = 0; i < 4; i++)
        8:  678:    drawCard(currentPlayer, state);
        2:  679:  state->numBuys++;
        6:  680:  for (i = 0; i < state->numPlayers; i++){  //Each other player draws a card
        4:  681:    if ( i != currentPlayer )
        2:  682:      drawCard(i, state);
        -:  683:  }
        2:  684:  discardCard(handPos, currentPlayer, state, 0); //put played card in played card pile
        -:  685:      
        2:  686:  return 0;
        -:  687:}
        -:  688:
       44:  689:int feastCard(struct gameState *state, int temphand [], int currentPlayer, int choice1, int i, int x){
      308:  690:  for (i = 0; i <= state->handCount[currentPlayer]; i++){  
      264:  691:    temphand[i] = state->hand[currentPlayer][i];
      264:  692:    state->hand[currentPlayer][i] = -1;
        -:  693:  }
       44:  694:  updateCoins(currentPlayer, state, 5);
       44:  695:  x = 1;
      132:  696:  while( x == 1) {
       44:  697:    if (supplyCount(choice1, state) <= 0){
    #####:  698:      if (DEBUG)
        -:  699:        printf("None of that card left, sorry!\n");
        -:  700:
    #####:  701:      if (DEBUG)
        -:  702:        printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  703:    }
       44:  704:    else if (state->coins < getCost(choice1)){
    #####:  705:      printf("That card is too expensive!\n");
    #####:  706:      if (DEBUG)
        -:  707:        printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  708:    }
        -:  709:    else{
       44:  710:      if (DEBUG)
        -:  711:        printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
       44:  712:      gainCard(choice1, state, 0, currentPlayer);
       44:  713:      x = 0;
       44:  714:      if (DEBUG)
        -:  715:        printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  716:    }
        -:  717:  }
        -:  718:
      308:  719:  for (i = 0; i <= state->handCount[currentPlayer]; i++){
      264:  720:    state->hand[currentPlayer][i] = temphand[i];
      264:  721:    temphand[i] = -1;
        -:  722:  }
        -:  723:            
       44:  724:      return 0;
        -:  725:}
        -:  726:
    #####:  727:int mineCard(struct gameState *state, int currentPlayer, int choice1, int choice2, int handPos, int i, int j){
    #####:  728:  j = state->hand[currentPlayer][choice1];  //store card we will trash
    #####:  729:  if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
    #####:  730:    return -1;  
    #####:  731:  if (choice2 > treasure_map || choice2 < curse)
    #####:  732:    return -1;
    #####:  733:  if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
    #####:  734:    return -1;
    #####:  735:  gainCard(choice2, state, 2, currentPlayer);
    #####:  736:  discardCard(handPos, currentPlayer, state, 0);
    #####:  737:  for (i = 0; i < state->handCount[currentPlayer]; i++){
    #####:  738:    if (state->hand[currentPlayer][i] == j){
    #####:  739:      discardCard(i, currentPlayer, state, 0);      
    #####:  740:      break;
        -:  741:    }
        -:  742:  }
        -:  743:      
    #####:  744:      return 0;
        -:  745:}
        -:  746:
       24:  747:int remodelCard(struct gameState *state, int currentPlayer, int choice1, int choice2, int handPos, int i, int j){
       24:  748:  j = state->hand[currentPlayer][choice1];  //store card we will trash
       24:  749:  if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
       17:  750:    return -1;
        7:  751:  gainCard(choice2, state, 0, currentPlayer);
        7:  752:  discardCard(handPos, currentPlayer, state, 0);
       13:  753:  for (i = 0; i < state->handCount[currentPlayer]; i++){
       13:  754:    if (state->hand[currentPlayer][i] == j){
        7:  755:        discardCard(i, currentPlayer, state, 0);      
        7:  756:        break;
        -:  757:    }
        -:  758:  }
        7:  759:      return 0;
        -:  760:}
        -:  761:
      437:  762:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  763:{
        -:  764:  int i;
        -:  765:  int j;
        -:  766:  int k;
        -:  767:  int x;
        -:  768:  int index;
      437:  769:  int currentPlayer = whoseTurn(state);
      437:  770:  int nextPlayer = currentPlayer + 1;
        -:  771:
      437:  772:  int tributeRevealedCards[2] = {-1, -1};
        -:  773:  int temphand[MAX_HAND];// moved above the if statement
      437:  774:  int drawntreasure=0;
        -:  775:  int cardDrawn;
      437:  776:  int z = 0;// this is the counter for the temp hand
      437:  777:  if (nextPlayer > (state->numPlayers - 1)){
      238:  778:    nextPlayer = 0;
        -:  779:  }
        -:  780:  
        -:  781:	
        -:  782:  //uses switch to select card and perform actions
      437:  783:  switch( card ) 
        -:  784:    {
        -:  785:    case adventurer:
    #####:  786:      adventurerCard(drawntreasure, state, currentPlayer, cardDrawn, temphand, handPos, z, i);
    #####:  787:      break;
        -:  788:      
        -:  789:    case council_room:
        2:  790:      councilRoomCard(state, currentPlayer, handPos, i);
        2:  791:      break;
        -:  792:			
        -:  793:    case feast:
       44:  794:      feastCard(state, temphand, currentPlayer, choice1, i, x);
       44:  795:      break;
        -:  796:
        -:  797:    case gardens:
    #####:  798:      return -1;
        -:  799:			
        -:  800:    case mine:
    #####:  801:      mineCard(state, currentPlayer, choice1, choice2, handPos, i, j);
    #####:  802:      break;
        -:  803:			
        -:  804:    case remodel:
       24:  805:      remodelCard(state, currentPlayer, choice1, choice2, handPos, i, j);
       24:  806:      break;
        -:  807:		
        -:  808:    case smithy:
        -:  809:      //+3 Cards
       48:  810:      for (i = 0; i < 3; i++)
        -:  811:	{
       36:  812:	  drawCard(currentPlayer, state);
        -:  813:	}
        -:  814:			
        -:  815:      //discard card from hand
       12:  816:      discardCard(handPos, currentPlayer, state, 0);
       12:  817:      return 0;
        -:  818:		
        -:  819:    case village:
        -:  820:      //+1 Card
       11:  821:      drawCard(currentPlayer, state);
        -:  822:			
        -:  823:      //+2 Actions
       11:  824:      state->numActions = state->numActions + 2;
        -:  825:			
        -:  826:      //discard played card from hand
       11:  827:      discardCard(handPos, currentPlayer, state, 0);
       11:  828:      return 0;
        -:  829:		
        -:  830:    case baron:
       12:  831:      state->numBuys++;//Increase buys by 1!
       12:  832:      if (choice1 > 0){//Boolean true or going to discard an estate
        5:  833:	int p = 0;//Iterator for hand!
        5:  834:	int card_not_discarded = 1;//Flag for discard set!
       40:  835:	while(card_not_discarded){
       30:  836:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
        1:  837:	    state->coins += 4;//Add 4 coins to the amount of coins
        1:  838:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
        1:  839:	    state->discardCount[currentPlayer]++;
        5:  840:	    for (;p < state->handCount[currentPlayer]; p++){
        4:  841:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
        -:  842:	    }
        1:  843:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
        1:  844:	    state->handCount[currentPlayer]--;
        1:  845:	    card_not_discarded = 0;//Exit the loop
        -:  846:	  }
       29:  847:	  else if (p > state->handCount[currentPlayer]){
        4:  848:	    if(DEBUG) {
        -:  849:	      printf("No estate cards in your hand, invalid choice\n");
        -:  850:	      printf("Must gain an estate if there are any\n");
        -:  851:	    }
        4:  852:	    if (supplyCount(estate, state) > 0){
    #####:  853:	      gainCard(estate, state, 0, currentPlayer);
    #####:  854:	      state->supplyCount[estate]--;//Decrement estates
    #####:  855:	      if (supplyCount(estate, state) == 0){
    #####:  856:		isGameOver(state);
        -:  857:	      }
        -:  858:	    }
        4:  859:	    card_not_discarded = 0;//Exit the loop
        -:  860:	  }
        -:  861:			    
        -:  862:	  else{
       25:  863:	    p++;//Next card
        -:  864:	  }
        -:  865:	}
        -:  866:      }
        -:  867:			    
        -:  868:      else{
        7:  869:	if (supplyCount(estate, state) > 0){
    #####:  870:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  871:	  state->supplyCount[estate]--;//Decrement Estates
    #####:  872:	  if (supplyCount(estate, state) == 0){
    #####:  873:	    isGameOver(state);
        -:  874:	  }
        -:  875:	}
        -:  876:      }
        -:  877:	    
        -:  878:      
       12:  879:      return 0;
        -:  880:		
        -:  881:    case great_hall:
        -:  882:      //+1 Card
    #####:  883:      drawCard(currentPlayer, state);
        -:  884:			
        -:  885:      //+1 Actions
    #####:  886:      state->numActions++;
        -:  887:			
        -:  888:      //discard card from hand
    #####:  889:      discardCard(handPos, currentPlayer, state, 0);
    #####:  890:      return 0;
        -:  891:		
        -:  892:    case minion:
        -:  893:      //+1 action
    #####:  894:      state->numActions++;
        -:  895:			
        -:  896:      //discard card from hand
    #####:  897:      discardCard(handPos, currentPlayer, state, 0);
        -:  898:			
    #####:  899:      if (choice1)		//+2 coins
        -:  900:	{
    #####:  901:	  state->coins = state->coins + 2;
        -:  902:	}
        -:  903:			
    #####:  904:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  905:	{
        -:  906:	  //discard hand
    #####:  907:	  while(numHandCards(state) > 0)
        -:  908:	    {
    #####:  909:	      discardCard(handPos, currentPlayer, state, 0);
        -:  910:	    }
        -:  911:				
        -:  912:	  //draw 4
    #####:  913:	  for (i = 0; i < 4; i++)
        -:  914:	    {
    #####:  915:	      drawCard(currentPlayer, state);
        -:  916:	    }
        -:  917:				
        -:  918:	  //other players discard hand and redraw if hand size > 4
    #####:  919:	  for (i = 0; i < state->numPlayers; i++)
        -:  920:	    {
    #####:  921:	      if (i != currentPlayer)
        -:  922:		{
    #####:  923:		  if ( state->handCount[i] > 4 )
        -:  924:		    {
        -:  925:		      //discard hand
    #####:  926:		      while( state->handCount[i] > 0 )
        -:  927:			{
    #####:  928:			  discardCard(handPos, i, state, 0);
        -:  929:			}
        -:  930:							
        -:  931:		      //draw 4
    #####:  932:		      for (j = 0; j < 4; j++)
        -:  933:			{
    #####:  934:			  drawCard(i, state);
        -:  935:			}
        -:  936:		    }
        -:  937:		}
        -:  938:	    }
        -:  939:				
        -:  940:	}
    #####:  941:      return 0;
        -:  942:		
        -:  943:    case steward:
        -:  944:     //discard card from hand
       19:  945:      discardCard(handPos, currentPlayer, state, 0);
       19:  946:      if (choice1 == 1)
        -:  947:	{
        -:  948:	  //+2 cards
        5:  949:	  drawCard(currentPlayer, state);
        5:  950:	  drawCard(currentPlayer, state);
        -:  951:	}
       14:  952:      else if (choice1 == 2)
        -:  953:	{
        -:  954:	  //+2 coins
        4:  955:	  state->coins = state->coins + 2;
        -:  956:	}
        -:  957:      else
        -:  958:	{
        -:  959:	  //trash 2 cards in hand
       10:  960:	  discardCard(choice2, currentPlayer, state, 1);
       10:  961:	  discardCard(choice3, currentPlayer, state, 1);
        -:  962:	}
        -:  963:			
       19:  964:      return 0;
        -:  965:		
        -:  966:    case tribute:
        2:  967:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####:  968:	if (state->deckCount[nextPlayer] > 0){
    #####:  969:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####:  970:	  state->deckCount[nextPlayer]--;
        -:  971:	}
    #####:  972:	else if (state->discardCount[nextPlayer] > 0){
    #####:  973:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####:  974:	  state->discardCount[nextPlayer]--;
        -:  975:	}
        -:  976:	else{
        -:  977:	  //No Card to Reveal
    #####:  978:	  if (DEBUG){
        -:  979:	    printf("No cards to reveal\n");
        -:  980:	  }
        -:  981:	}
        -:  982:      }
        -:  983:	    
        -:  984:      else{
        2:  985:	if (state->deckCount[nextPlayer] == 0){
    #####:  986:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####:  987:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####:  988:	    state->deckCount[nextPlayer]++;
    #####:  989:	    state->discard[nextPlayer][i] = -1;
    #####:  990:	    state->discardCount[nextPlayer]--;
        -:  991:	  }
        -:  992:			    
    #####:  993:	  shuffle(nextPlayer,state);//Shuffle the deck
        -:  994:	} 
        2:  995:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
        2:  996:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
        2:  997:	state->deckCount[nextPlayer]--;
        2:  998:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
        2:  999:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
        2: 1000:	state->deckCount[nextPlayer]--;
        -: 1001:      }    
        -: 1002:		       
        2: 1003:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
        2: 1004:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
        2: 1005:	state->playedCardCount++;
        2: 1006:	tributeRevealedCards[1] = -1;
        -: 1007:      }
        -: 1008:
        8: 1009:      for (i = 0; i <= 2; i ++){
        7: 1010:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
        1: 1011:	  state->coins += 2;
        -: 1012:	}
        -: 1013:		    
        5: 1014:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
    #####: 1015:	  drawCard(currentPlayer, state);
    #####: 1016:	  drawCard(currentPlayer, state);
        -: 1017:	}
        -: 1018:	else{//Action Card
        5: 1019:	  state->numActions = state->numActions + 2;
        -: 1020:	}
        -: 1021:      }
        -: 1022:	    
        2: 1023:      return 0;
        -: 1024:		
        -: 1025:    case ambassador:
        -: 1026:
       58: 1027:      j = 0;		//used to check if player has enough cards to discard
        -: 1028:
       58: 1029:      if (choice2 > 2 || choice2 < 0)
        -: 1030:	{
    #####: 1031:	  return -1;				
        -: 1032:	}
        -: 1033:
       58: 1034:      if (choice1 == handPos)
        -: 1035:	{
    #####: 1036:	  return -1;
        -: 1037:	}
        -: 1038:
      354: 1039:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1040:	{
      296: 1041:	  if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1042:	    {
       14: 1043:	      j++;
        -: 1044:	    }
        -: 1045:	}
       58: 1046:      if (j < choice2)
        -: 1047:	{
       32: 1048:	  return -1;				
        -: 1049:	}
        -: 1050:
       26: 1051:      if (DEBUG) 
        -: 1052:	printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1053:
        -: 1054:      //increase supply count for choosen card by amount being discarded
       26: 1055:      state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1056:			
        -: 1057:      //each other player gains a copy of revealed card
       72: 1058:      for (i = 0; i < state->numPlayers; i++)
        -: 1059:	{
       46: 1060:	  if (i != currentPlayer)
        -: 1061:	    {
       21: 1062:	      gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1063:	    }
        -: 1064:	}
        -: 1065:
        -: 1066:      //discard played card from hand
       26: 1067:      discardCard(handPos, currentPlayer, state, 0);			
        -: 1068:
        -: 1069:      //trash copies of cards returned to supply
       33: 1070:      for (j = 0; j < choice2; j++)
        -: 1071:	{
       19: 1072:	  for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1073:	    {
       19: 1074:	      if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1075:		{
        7: 1076:		  discardCard(i, currentPlayer, state, 1);
        7: 1077:		  break;
        -: 1078:		}
        -: 1079:	    }
        -: 1080:	}			
        -: 1081:
       26: 1082:      return 0;
        -: 1083:		
        -: 1084:    case cutpurse:
        -: 1085:
        8: 1086:      updateCoins(currentPlayer, state, 2);
       23: 1087:      for (i = 0; i < state->numPlayers; i++)
        -: 1088:	{
       15: 1089:	  if (i != currentPlayer)
        -: 1090:	    {
        7: 1091:	      for (j = 0; j < state->handCount[i]; j++)
        -: 1092:		{
    #####: 1093:		  if (state->hand[i][j] == copper)
        -: 1094:		    {
    #####: 1095:		      discardCard(j, i, state, 0);
    #####: 1096:		      break;
        -: 1097:		    }
    #####: 1098:		  if (j == state->handCount[i])
        -: 1099:		    {
    #####: 1100:		      for (k = 0; k < state->handCount[i]; k++)
        -: 1101:			{
    #####: 1102:			  if (DEBUG)
        -: 1103:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1104:			}	
    #####: 1105:		      break;
        -: 1106:		    }		
        -: 1107:		}
        -: 1108:					
        -: 1109:	    }
        -: 1110:				
        -: 1111:	}				
        -: 1112:
        -: 1113:      //discard played card from hand
        8: 1114:      discardCard(handPos, currentPlayer, state, 0);			
        -: 1115:
        8: 1116:      return 0;
        -: 1117:
        -: 1118:		
        -: 1119:    case embargo: 
        -: 1120:      //+2 Coins
       43: 1121:      state->coins = state->coins + 2;
        -: 1122:			
        -: 1123:      //see if selected pile is in play
       43: 1124:      if ( state->supplyCount[choice1] == -1 )
        -: 1125:	{
    #####: 1126:	  return -1;
        -: 1127:	}
        -: 1128:			
        -: 1129:      //add embargo token to selected supply pile
       43: 1130:      state->embargoTokens[choice1]++;
        -: 1131:			
        -: 1132:      //trash card
       43: 1133:      discardCard(handPos, currentPlayer, state, 1);		
       43: 1134:      return 0;
        -: 1135:		
        -: 1136:    case outpost:
        -: 1137:      //set outpost flag
        7: 1138:      state->outpostPlayed++;
        -: 1139:			
        -: 1140:      //discard card
        7: 1141:      discardCard(handPos, currentPlayer, state, 0);
        7: 1142:      return 0;
        -: 1143:		
        -: 1144:    case salvager:
        -: 1145:      //+1 buy
       13: 1146:      state->numBuys++;
        -: 1147:			
       13: 1148:      if (choice1)
        -: 1149:	{
        -: 1150:	  //gain coins equal to trashed card
       10: 1151:	  state->coins = state->coins + getCost( handCard(choice1, state) );
        -: 1152:	  //trash card
       10: 1153:	  discardCard(choice1, currentPlayer, state, 1);	
        -: 1154:	}
        -: 1155:			
        -: 1156:      //discard card
       13: 1157:      discardCard(handPos, currentPlayer, state, 0);
       13: 1158:      return 0;
        -: 1159:		
        -: 1160:    case sea_hag:
      211: 1161:      for (i = 0; i < state->numPlayers; i++){
      137: 1162:	if (i != currentPlayer){
       63: 1163:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
       63: 1164:	  state->discardCount[i]++;
       63: 1165:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1166:	}
        -: 1167:      }
       74: 1168:      return 0;
        -: 1169:		
        -: 1170:    case treasure_map:
        -: 1171:      //search hand for another treasure_map
      108: 1172:      index = -1;
      648: 1173:      for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1174:	{
      540: 1175:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -: 1176:	    {
    #####: 1177:	      index = i;
    #####: 1178:	      break;
        -: 1179:	    }
        -: 1180:	}
      108: 1181:      if (index > -1)
        -: 1182:	{
        -: 1183:	  //trash both treasure cards
    #####: 1184:	  discardCard(handPos, currentPlayer, state, 1);
    #####: 1185:	  discardCard(index, currentPlayer, state, 1);
        -: 1186:
        -: 1187:	  //gain 4 Gold cards
    #####: 1188:	  for (i = 0; i < 4; i++)
        -: 1189:	    {
    #####: 1190:	      gainCard(gold, state, 1, currentPlayer);
        -: 1191:	    }
        -: 1192:				
        -: 1193:	  //return success
    #####: 1194:	  return 1;
        -: 1195:	}
        -: 1196:			
        -: 1197:      //no second treasure_map found in hand
      108: 1198:      return -1;
        -: 1199:    }
        -: 1200:
       70: 1201:  return -1;
        -: 1202:}
        -: 1203:
      192: 1204:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1205:{
        -: 1206:	
        -: 1207:  //if card is not trashed, added to Played pile 
      192: 1208:  if (trashFlag < 1)
        -: 1209:    {
        -: 1210:      //add card to played pile
      112: 1211:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
      112: 1212:      state->playedCardCount++;
        -: 1213:    }
        -: 1214:	
        -: 1215:  //set played card to -1
      192: 1216:  state->hand[currentPlayer][handPos] = -1;
        -: 1217:	
        -: 1218:  //remove card from player's hand
      192: 1219:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
        -: 1220:    {
        -: 1221:      //reduce number of cards in hand
       27: 1222:      state->handCount[currentPlayer]--;
       27: 1223:      state->discardCount[currentPlayer]++;
        -: 1224:    }
      165: 1225:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
        -: 1226:    {
        -: 1227:      //reduce number of cards in hand
    #####: 1228:      state->handCount[currentPlayer]--;
    #####: 1229:      state->discardCount[currentPlayer]++;
        -: 1230:    }
        -: 1231:  else 	
        -: 1232:    {
        -: 1233:      //replace discarded card with last card in hand
      165: 1234:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1235:      //set last card to -1
      165: 1236:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1237:      //reduce number of cards in hand
      165: 1238:      state->handCount[currentPlayer]--;
      165: 1239:      state->discardCount[currentPlayer]++;
        -: 1240:    }
        -: 1241:	
      192: 1242:  return 0;
        -: 1243:}
        -: 1244:
      381: 1245:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1246:{
        -: 1247:  //Note: supplyPos is enum of choosen card
        -: 1248:	
        -: 1249:  //check if supply pile is empty (0) or card is not used in game (-1)
      381: 1250:  if ( supplyCount(supplyPos, state) < 1 )
        -: 1251:    {
        3: 1252:      return -1;
        -: 1253:    }
        -: 1254:	
        -: 1255:  //added card for [whoseTurn] current player:
        -: 1256:  // toFlag = 0 : add to discard
        -: 1257:  // toFlag = 1 : add to deck
        -: 1258:  // toFlag = 2 : add to hand
        -: 1259:
      378: 1260:  if (toFlag == 1)
        -: 1261:    {
    #####: 1262:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
    #####: 1263:      state->deckCount[player]++;
        -: 1264:    }
      378: 1265:  else if (toFlag == 2)
        -: 1266:    {
    #####: 1267:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
    #####: 1268:      state->handCount[player]++;
        -: 1269:    }
        -: 1270:  else
        -: 1271:    {
      378: 1272:      state->discard[player][ state->discardCount[player] ] = supplyPos;
      378: 1273:      state->discardCount[player]++;
        -: 1274:    }
        -: 1275:	
        -: 1276:  //decrease number in supply pile
      378: 1277:  state->supplyCount[supplyPos]--;
        -: 1278:	 
      378: 1279:  return 0;
        -: 1280:}
        -: 1281:
     1059: 1282:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1283:{
        -: 1284:  int i;
        -: 1285:	
        -: 1286:  //reset coin count
     1059: 1287:  state->coins = 0;
        -: 1288:
        -: 1289:  //add coins for each Treasure card in player's hand
     6238: 1290:  for (i = 0; i < state->handCount[player]; i++)
        -: 1291:    {
     5179: 1292:      if (state->hand[player][i] == copper)
        -: 1293:	{
     1081: 1294:	  state->coins += 1;
        -: 1295:	}
     4098: 1296:      else if (state->hand[player][i] == silver)
        -: 1297:	{
      356: 1298:	  state->coins += 2;
        -: 1299:	}
     3742: 1300:      else if (state->hand[player][i] == gold)
        -: 1301:	{
    #####: 1302:	  state->coins += 3;
        -: 1303:	}	
        -: 1304:    }	
        -: 1305:
        -: 1306:  //add bonus
     1059: 1307:  state->coins += bonus;
        -: 1308:
     1059: 1309:  return 0;
        -: 1310:}
        -: 1311:
        -: 1312://end of dominion.c
        -: 1313:
