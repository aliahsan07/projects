File 'dominion.c'
Lines executed:27.11% of 557
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
      364:    8:int compare(const void* a, const void* b) {
      364:    9:	if (*(int*)a > *(int*)b)
    #####:   10:		return 1;
      364:   11:	if (*(int*)a < *(int*)b)
      130:   12:		return -1;
      234:   13:	return 0;
        -:   14:}
        -:   15:
       20:   16:struct gameState* newGame() {
       20:   17:	struct gameState* g = malloc(sizeof(struct gameState));
       20:   18:	return g;
        -:   19:}
        -:   20:
       97:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:	int k8, int k9, int k10) {
       97:   23:	int* k = malloc(10 * sizeof(int));
       97:   24:	k[0] = k1;
       97:   25:	k[1] = k2;
       97:   26:	k[2] = k3;
       97:   27:	k[3] = k4;
       97:   28:	k[4] = k5;
       97:   29:	k[5] = k6;
       97:   30:	k[6] = k7;
       97:   31:	k[7] = k8;
       97:   32:	k[8] = k9;
       97:   33:	k[9] = k10;
       97:   34:	return k;
        -:   35:}
        -:   36:
       97:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		struct gameState *state) {
        -:   39:
        -:   40:	int i;
        -:   41:	int j;
        -:   42:	int it;
        -:   43:	//set up random number generator
       97:   44:	SelectStream(1);
       97:   45:	PutSeed((long)randomSeed);
        -:   46:
        -:   47:	//check number of players
       97:   48:	if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:	{
    #####:   50:		return -1;
        -:   51:	}
        -:   52:
        -:   53:	//set number of players
       97:   54:	state->numPlayers = numPlayers;
        -:   55:
        -:   56:	//check selected kingdom cards are different
      320:   57:	for (i = 0; i < 10; i++)
        -:   58:	{
     3023:   59:		for (j = 0; j < 10; j++)
        -:   60:		{
     2800:   61:			if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:			{
       87:   63:				return -1;
        -:   64:			}
        -:   65:		}
        -:   66:	}
        -:   67:
        -:   68:
        -:   69:	//initialize supply
        -:   70:	///////////////////////////////
        -:   71:
        -:   72:	//set number of Curse cards
       10:   73:	if (numPlayers == 2)
        -:   74:	{
        6:   75:		state->supplyCount[curse] = 10;
        -:   76:	}
        4:   77:	else if (numPlayers == 3)
        -:   78:	{
        2:   79:		state->supplyCount[curse] = 20;
        -:   80:	}
        -:   81:	else
        -:   82:	{
        2:   83:		state->supplyCount[curse] = 30;
        -:   84:	}
        -:   85:
        -:   86:	//set number of Victory cards
       10:   87:	if (numPlayers == 2)
        -:   88:	{
        6:   89:		state->supplyCount[estate] = 8;
        6:   90:		state->supplyCount[duchy] = 8;
        6:   91:		state->supplyCount[province] = 8;
        -:   92:	}
        -:   93:	else
        -:   94:	{
        4:   95:		state->supplyCount[estate] = 12;
        4:   96:		state->supplyCount[duchy] = 12;
        4:   97:		state->supplyCount[province] = 12;
        -:   98:	}
        -:   99:
        -:  100:	//set number of Treasure cards
       10:  101:	state->supplyCount[copper] = 60 - (7 * numPlayers);
       10:  102:	state->supplyCount[silver] = 40;
       10:  103:	state->supplyCount[gold] = 30;
        -:  104:
        -:  105:	//set number of Kingdom cards
      210:  106:	for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:	{
     1650:  108:		for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:		{
     1550:  110:			if (kingdomCards[j] == i)
        -:  111:			{
        -:  112:				//check if card is a 'Victory' Kingdom card
      100:  113:				if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:				{
       18:  115:					if (numPlayers == 2){
        5:  116:						state->supplyCount[i] = 8;
        -:  117:					}
        4:  118:					else{ state->supplyCount[i] = 12; }
        -:  119:				}
        -:  120:				else
        -:  121:				{
       91:  122:					state->supplyCount[i] = 10;
        -:  123:				}
      100:  124:				break;
        -:  125:			}
        -:  126:			else    //card is not in the set choosen for the game
        -:  127:			{
     1450:  128:				state->supplyCount[i] = -1;
        -:  129:			}
        -:  130:		}
        -:  131:
        -:  132:	}
        -:  133:
        -:  134:	////////////////////////
        -:  135:	//supply intilization complete
        -:  136:
        -:  137:	//set player decks
       36:  138:	for (i = 0; i < numPlayers; i++)
        -:  139:	{
       26:  140:		state->deckCount[i] = 0;
      104:  141:		for (j = 0; j < 3; j++)
        -:  142:		{
       78:  143:			state->deck[i][j] = estate;
       78:  144:			state->deckCount[i]++;
        -:  145:		}
      208:  146:		for (j = 3; j < 10; j++)
        -:  147:		{
      182:  148:			state->deck[i][j] = copper;
      182:  149:			state->deckCount[i]++;
        -:  150:		}
        -:  151:	}
        -:  152:
        -:  153:	//shuffle player decks
       36:  154:	for (i = 0; i < numPlayers; i++)
        -:  155:	{
       26:  156:		if (shuffle(i, state) < 0)
        -:  157:		{
    #####:  158:			return -1;
        -:  159:		}
        -:  160:	}
        -:  161:
        -:  162:	//draw player hands
       36:  163:	for (i = 0; i < numPlayers; i++)
        -:  164:	{
        -:  165:		//initialize hand size to zero
       26:  166:		state->handCount[i] = 0;
       26:  167:		state->discardCount[i] = 0;
        -:  168:		//draw 5 cards
        -:  169:		// for (j = 0; j < 5; j++)
        -:  170:		//	{
        -:  171:		//	  drawCard(i, state);
        -:  172:		//	}
        -:  173:	}
        -:  174:
        -:  175:	//set embargo tokens to 0 for all supply piles
      280:  176:	for (i = 0; i <= treasure_map; i++)
        -:  177:	{
      270:  178:		state->embargoTokens[i] = 0;
        -:  179:	}
        -:  180:
        -:  181:	//initialize first player's turn
       10:  182:	state->outpostPlayed = 0;
       10:  183:	state->phase = 0;
       10:  184:	state->numActions = 1;
       10:  185:	state->numBuys = 1;
       10:  186:	state->playedCardCount = 0;
       10:  187:	state->whoseTurn = 0;
       10:  188:	state->handCount[state->whoseTurn] = 0;
        -:  189:	//int it; move to top
        -:  190:
        -:  191:	//Moved draw cards to here, only drawing at the start of a turn
       60:  192:	for (it = 0; it < 5; it++){
       50:  193:		drawCard(state->whoseTurn, state);
        -:  194:	}
        -:  195:
       10:  196:	updateCoins(state->whoseTurn, state, 0);
        -:  197:
       10:  198:	return 0;
        -:  199:}
        -:  200:
       41:  201:int shuffle(int player, struct gameState *state) {
        -:  202:
        -:  203:
        -:  204:	int newDeck[MAX_DECK];
       41:  205:	int newDeckPos = 0;
        -:  206:	int card;
        -:  207:	int i;
        -:  208:
       41:  209:	if (state->deckCount[player] < 1)
       15:  210:		return -1;
       26:  211:	qsort((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
        -:  212:	/* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
      312:  214:	while (state->deckCount[player] > 0) {
      260:  215:		card = floor(Random() * state->deckCount[player]);
      260:  216:		newDeck[newDeckPos] = state->deck[player][card];
      260:  217:		newDeckPos++;
      783:  218:		for (i = card; i < state->deckCount[player] - 1; i++) {
      523:  219:			state->deck[player][i] = state->deck[player][i + 1];
        -:  220:		}
      260:  221:		state->deckCount[player]--;
        -:  222:	}
      286:  223:	for (i = 0; i < newDeckPos; i++) {
      260:  224:		state->deck[player][i] = newDeck[i];
      260:  225:		state->deckCount[player]++;
        -:  226:	}
        -:  227:
       26:  228:	return 0;
        -:  229:}
        -:  230:
        6:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state)
        -:  232:{
        -:  233:	int card;
        6:  234:	int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:	//check if it is the right phase
        6:  237:	if (state->phase != 0)
        -:  238:	{
    #####:  239:		return -1;
        -:  240:	}
        -:  241:
        -:  242:	//check if player has enough actions
        6:  243:	if (state->numActions < 1)
        -:  244:	{
        6:  245:		return -1;
        -:  246:	}
        -:  247:
        -:  248:	//get card played
    #####:  249:	card = handCard(handPos, state);
        -:  250:
        -:  251:	//check if selected card is an action
    #####:  252:	if (card < adventurer || card > treasure_map)
        -:  253:	{
    #####:  254:		return -1;
        -:  255:	}
        -:  256:
        -:  257:	//play card
    #####:  258:	if (cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0)
        -:  259:	{
    #####:  260:		return -1;
        -:  261:	}
        -:  262:
        -:  263:	//reduce number of actions
    #####:  264:	state->numActions--;
        -:  265:
        -:  266:	//update coins (Treasure cards may be added with card draws)
    #####:  267:	updateCoins(state->whoseTurn, state, coin_bonus);
        -:  268:
    #####:  269:	return 0;
        -:  270:}
        -:  271:
        1:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:	int who;
        -:  274:	if (DEBUG){
        -:  275:		printf("Entering buyCard...\n");
        -:  276:	}
        -:  277:
        -:  278:	// I don't know what to do about the phase thing.
        -:  279:
        1:  280:	who = state->whoseTurn;
        -:  281:
        1:  282:	if (state->numBuys < 1){
        -:  283:		if (DEBUG)
        -:  284:			printf("You do not have any buys left\n");
        1:  285:		return -1;
        -:  286:	}
    #####:  287:	else if (supplyCount(supplyPos, state) < 1){
        -:  288:		if (DEBUG)
        -:  289:			printf("There are not any of that type of card left\n");
    #####:  290:		return -1;
        -:  291:	}
    #####:  292:	else if (state->coins < getCost(supplyPos)){
        -:  293:		if (DEBUG)
        -:  294:			printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  295:		return -1;
        -:  296:	}
        -:  297:	else {
    #####:  298:		state->phase = 1;
        -:  299:		//state->supplyCount[supplyPos]--;
    #####:  300:		gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  301:
    #####:  302:		state->coins = (state->coins) - (getCost(supplyPos));
    #####:  303:		state->numBuys--;
        -:  304:		if (DEBUG)
        -:  305:			printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  306:	}
        -:  307:
        -:  308:	//state->discard[who][state->discardCount[who]] = supplyPos;
        -:  309:	//state->discardCount[who]++;
        -:  310:
    #####:  311:	return 0;
        -:  312:}
        -:  313:
    #####:  314:int numHandCards(struct gameState *state) {
    #####:  315:	return state->handCount[whoseTurn(state)];
        -:  316:}
        -:  317:
    #####:  318:int handCard(int handPos, struct gameState *state) {
    #####:  319:	int currentPlayer = whoseTurn(state);
    #####:  320:	return state->hand[currentPlayer][handPos];
        -:  321:}
        -:  322:
    #####:  323:int supplyCount(int card, struct gameState *state) {
    #####:  324:	return state->supplyCount[card];
        -:  325:}
        -:  326:
    #####:  327:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  328:	int i;
    #####:  329:	int count = 0;
        -:  330:
    #####:  331:	for (i = 0; i < state->deckCount[player]; i++)
        -:  332:	{
    #####:  333:		if (state->deck[player][i] == card) count++;
        -:  334:	}
        -:  335:
    #####:  336:	for (i = 0; i < state->handCount[player]; i++)
        -:  337:	{
    #####:  338:		if (state->hand[player][i] == card) count++;
        -:  339:	}
        -:  340:
    #####:  341:	for (i = 0; i < state->discardCount[player]; i++)
        -:  342:	{
    #####:  343:		if (state->discard[player][i] == card) count++;
        -:  344:	}
        -:  345:
    #####:  346:	return count;
        -:  347:}
        -:  348:
        3:  349:int whoseTurn(struct gameState *state) {
        3:  350:	return state->whoseTurn;
        -:  351:}
        -:  352:
        3:  353:int endTurn(struct gameState *state) {
        -:  354:	int k;
        -:  355:	int i;
        3:  356:	int currentPlayer = whoseTurn(state);
        -:  357:
        -:  358:	//Discard hand
        3:  359:	for (i = 0; i < state->handCount[currentPlayer]; i++){
    #####:  360:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  361:		state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  362:	}
        3:  363:	state->handCount[currentPlayer] = 0;//Reset hand count
        -:  364:
        -:  365:	//Code for determining the player
        3:  366:	if (currentPlayer < (state->numPlayers - 1)){
    #####:  367:		state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  368:	}
        -:  369:	else{
        3:  370:		state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  371:	}
        -:  372:
        3:  373:	state->outpostPlayed = 0;
        3:  374:	state->phase = 0;
        3:  375:	state->numActions = 1;
        3:  376:	state->coins = 0;
        3:  377:	state->numBuys = 1;
        3:  378:	state->playedCardCount = 0;
        3:  379:	state->handCount[state->whoseTurn] = 0;
        -:  380:
        -:  381:	//int k; move to top
        -:  382:	//Next player draws hand
       18:  383:	for (k = 0; k < 5; k++){
       15:  384:		drawCard(state->whoseTurn, state);//Draw a card
        -:  385:	}
        -:  386:
        -:  387:	//Update money
        3:  388:	updateCoins(state->whoseTurn, state, 0);
        -:  389:
        3:  390:	return 0;
        -:  391:}
        -:  392:
    #####:  393:int isGameOver(struct gameState *state) {
        -:  394:	int i;
        -:  395:	int j;
        -:  396:
        -:  397:	//if stack of Province cards is empty, the game ends
    #####:  398:	if (state->supplyCount[province] == 0)
        -:  399:	{
    #####:  400:		return 1;
        -:  401:	}
        -:  402:
        -:  403:	//if three supply pile are at 0, the game ends
    #####:  404:	j = 0;
    #####:  405:	for (i = 0; i < 25; i++)
        -:  406:	{
    #####:  407:		if (state->supplyCount[i] == 0)
        -:  408:		{
    #####:  409:			j++;
        -:  410:		}
        -:  411:	}
    #####:  412:	if (j >= 3)
        -:  413:	{
    #####:  414:		return 1;
        -:  415:	}
        -:  416:
    #####:  417:	return 0;
        -:  418:}
        -:  419:
    #####:  420:int scoreFor(int player, struct gameState *state) {
        -:  421:
        -:  422:	int i;
    #####:  423:	int score = 0;
        -:  424:	//score from hand
    #####:  425:	for (i = 0; i < state->handCount[player]; i++)
        -:  426:	{
    #####:  427:		if (state->hand[player][i] == curse) { score = score - 1; };
    #####:  428:		if (state->hand[player][i] == estate) { score = score + 1; };
    #####:  429:		if (state->hand[player][i] == duchy) { score = score + 3; };
    #####:  430:		if (state->hand[player][i] == province) { score = score + 6; };
    #####:  431:		if (state->hand[player][i] == great_hall) { score = score + 1; };
    #####:  432:		if (state->hand[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  433:	}
        -:  434:
        -:  435:	//score from discard
    #####:  436:	for (i = 0; i < state->discardCount[player]; i++)
        -:  437:	{
    #####:  438:		if (state->discard[player][i] == curse) { score = score - 1; };
    #####:  439:		if (state->discard[player][i] == estate) { score = score + 1; };
    #####:  440:		if (state->discard[player][i] == duchy) { score = score + 3; };
    #####:  441:		if (state->discard[player][i] == province) { score = score + 6; };
    #####:  442:		if (state->discard[player][i] == great_hall) { score = score + 1; };
    #####:  443:		if (state->discard[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  444:	}
        -:  445:
        -:  446:	//score from deck
    #####:  447:	for (i = 0; i < state->discardCount[player]; i++)
        -:  448:	{
    #####:  449:		if (state->deck[player][i] == curse) { score = score - 1; };
    #####:  450:		if (state->deck[player][i] == estate) { score = score + 1; };
    #####:  451:		if (state->deck[player][i] == duchy) { score = score + 3; };
    #####:  452:		if (state->deck[player][i] == province) { score = score + 6; };
    #####:  453:		if (state->deck[player][i] == great_hall) { score = score + 1; };
    #####:  454:		if (state->deck[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  455:	}
        -:  456:
    #####:  457:	return score;
        -:  458:}
        -:  459:
    #####:  460:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  461:	int i;
        -:  462:	int j;
        -:  463:	int highScore;
        -:  464:	int currentPlayer;
        -:  465:
        -:  466:	//get score for each player
    #####:  467:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  468:	{
        -:  469:		//set unused player scores to -9999
    #####:  470:		if (i >= state->numPlayers)
        -:  471:		{
    #####:  472:			players[i] = -9999;
        -:  473:		}
        -:  474:		else
        -:  475:		{
    #####:  476:			players[i] = scoreFor(i, state);
        -:  477:		}
        -:  478:	}
        -:  479:
        -:  480:	//find highest score
    #####:  481:	j = 0;
    #####:  482:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  483:	{
    #####:  484:		if (players[i] > players[j])
        -:  485:		{
    #####:  486:			j = i;
        -:  487:		}
        -:  488:	}
    #####:  489:	highScore = players[j];
        -:  490:
        -:  491:	//add 1 to players who had less turns
    #####:  492:	currentPlayer = whoseTurn(state);
    #####:  493:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  494:	{
    #####:  495:		if (players[i] == highScore && i > currentPlayer)
        -:  496:		{
    #####:  497:			players[i]++;
        -:  498:		}
        -:  499:	}
        -:  500:
        -:  501:	//find new highest score
    #####:  502:	j = 0;
    #####:  503:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  504:	{
    #####:  505:		if (players[i] > players[j])
        -:  506:		{
    #####:  507:			j = i;
        -:  508:		}
        -:  509:	}
    #####:  510:	highScore = players[j];
        -:  511:
        -:  512:	//set winners in array to 1 and rest to 0
    #####:  513:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  514:	{
    #####:  515:		if (players[i] == highScore)
        -:  516:		{
    #####:  517:			players[i] = 1;
        -:  518:		}
        -:  519:		else
        -:  520:		{
    #####:  521:			players[i] = 0;
        -:  522:		}
        -:  523:	}
        -:  524:
    #####:  525:	return 0;
        -:  526:}
        -:  527:
       65:  528:int drawCard(int player, struct gameState *state)
        -:  529:{
        -:  530:	int count;
        -:  531:	int deckCounter;
       65:  532:	if (state->deckCount[player] <= 0){//Deck is empty
        -:  533:
        -:  534:		//Step 1 Shuffle the discard pile back into a deck
        -:  535:		int i;
        -:  536:		//Move discard to deck
       15:  537:		for (i = 0; i < state->discardCount[player]; i++){
    #####:  538:			state->deck[player][i] = state->discard[player][i];
    #####:  539:			state->discard[player][i] = -1;
        -:  540:		}
        -:  541:
       15:  542:		state->deckCount[player] = state->discardCount[player];
       15:  543:		state->discardCount[player] = 0;//Reset discard
        -:  544:
        -:  545:		//Shufffle the deck
       15:  546:		shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  547:
        -:  548:		if (DEBUG){//Debug statements
        -:  549:			printf("Deck count now: %d\n", state->deckCount[player]);
        -:  550:		}
        -:  551:
       15:  552:		state->discardCount[player] = 0;
        -:  553:
        -:  554:		//Step 2 Draw Card
       15:  555:		count = state->handCount[player];//Get current player's hand count
        -:  556:
        -:  557:		if (DEBUG){//Debug statements
        -:  558:			printf("Current hand count: %d\n", count);
        -:  559:		}
        -:  560:
       15:  561:		deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  562:
       15:  563:		if (deckCounter == 0)
       15:  564:			return -1;
        -:  565:
    #####:  566:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
    #####:  567:		state->deckCount[player]--;
    #####:  568:		state->handCount[player]++;//Increment hand count
        -:  569:	}
        -:  570:
        -:  571:	else{
       50:  572:		int count = state->handCount[player];//Get current hand count for player
        -:  573:		int deckCounter;
        -:  574:		if (DEBUG){//Debug statements
        -:  575:			printf("Current hand count: %d\n", count);
        -:  576:		}
        -:  577:
       50:  578:		deckCounter = state->deckCount[player];//Create holder for the deck count
       50:  579:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
       50:  580:		state->deckCount[player]--;
       50:  581:		state->handCount[player]++;//Increment hand count
        -:  582:	}
        -:  583:
       50:  584:	return 0;
        -:  585:}
        -:  586:
    #####:  587:int getCost(int cardNumber)
        -:  588:{
    #####:  589:	switch (cardNumber)
        -:  590:	{
        -:  591:	case curse:
    #####:  592:		return 0;
        -:  593:	case estate:
    #####:  594:		return 2;
        -:  595:	case duchy:
    #####:  596:		return 5;
        -:  597:	case province:
    #####:  598:		return 8;
        -:  599:	case copper:
    #####:  600:		return 0;
        -:  601:	case silver:
    #####:  602:		return 3;
        -:  603:	case gold:
    #####:  604:		return 6;
        -:  605:	case adventurer:
    #####:  606:		return 6;
        -:  607:	case council_room:
    #####:  608:		return 5;
        -:  609:	case feast:
    #####:  610:		return 4;
        -:  611:	case gardens:
    #####:  612:		return 4;
        -:  613:	case mine:
    #####:  614:		return 5;
        -:  615:	case remodel:
    #####:  616:		return 4;
        -:  617:	case smithy:
    #####:  618:		return 4;
        -:  619:	case village:
    #####:  620:		return 3;
        -:  621:	case baron:
    #####:  622:		return 4;
        -:  623:	case great_hall:
    #####:  624:		return 3;
        -:  625:	case minion:
    #####:  626:		return 5;
        -:  627:	case steward:
    #####:  628:		return 3;
        -:  629:	case tribute:
    #####:  630:		return 5;
        -:  631:	case ambassador:
    #####:  632:		return 3;
        -:  633:	case cutpurse:
    #####:  634:		return 4;
        -:  635:	case embargo:
    #####:  636:		return 2;
        -:  637:	case outpost:
    #####:  638:		return 5;
        -:  639:	case salvager:
    #####:  640:		return 4;
        -:  641:	case sea_hag:
    #####:  642:		return 4;
        -:  643:	case treasure_map:
    #####:  644:		return 4;
        -:  645:	}
        -:  646:
    #####:  647:	return -1;
        -:  648:}
        -:  649:
    #####:  650:void playAdventurer(struct gameState *state, int currentPlayer)
        -:  651:// Reveal cards from deck until 2 Treasure cards are found.  Put those Treasure cards in the hand and discard the rest.
        -:  652:{
    #####:  653:	int drawntreasure = 0;
        -:  654:	int temphand[MAX_HAND];
        -:  655:	int cardDrawn;
    #####:  656:	int z = 0; // this is the counter for the temp hand
        -:  657:
    #####:  658:	while (drawntreasure < 2){
    #####:  659:		if (state->deckCount[currentPlayer] < 1){//if the deck is empty we need to shuffle discard and add to deck
    #####:  660:			shuffle(currentPlayer, state);
        -:  661:		}
    #####:  662:		drawCard(currentPlayer, state);
    #####:  663:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer] - 1];//top card of hand is most recently drawn card.
    #####:  664:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
    #####:  665:			drawntreasure++;
        -:  666:		else{
    #####:  667:			temphand[z] = cardDrawn;
    #####:  668:			state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####:  669:			z++;
        -:  670:		}
        -:  671:	}
    #####:  672:	while (z - 1 >= 0){
    #####:  673:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; // discard all cards in play that have been drawn
    #####:  674:		z = z - 1;
        -:  675:	}
    #####:  676:}
        -:  677:
    #####:  678:int playRemodel(struct gameState *state, int currentPlayer, int choice1, int choice2, int handPos)
        -:  679://Trash a card in the hand, and gain a card costing up to $2 more than the trashed card
        -:  680:{
        -:  681:	int i;
    #####:  682:	int j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  683:
    #####:  684:	if ((getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2))
        -:  685:	{
    #####:  686:		return -1;
        -:  687:	}
        -:  688:
    #####:  689:	gainCard(choice2, state, 0, currentPlayer);
        -:  690:
        -:  691:	//discard card from hand
    #####:  692:	discardCard(handPos, currentPlayer, state, 0);
        -:  693:
        -:  694:	//discard trashed card
    #####:  695:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  696:	{
    #####:  697:		if (state->hand[currentPlayer][i] == j)
        -:  698:		{
    #####:  699:			discardCard(i, currentPlayer, state, 0);
    #####:  700:			break;
        -:  701:		}
        -:  702:	}
        -:  703:
    #####:  704:	return 0;
        -:  705:}
        -:  706:
    #####:  707:void playSmithy(struct gameState *state, int currentPlayer, int handPos)
        -:  708:// Draw 3 cards
        -:  709:{
        -:  710:	int i;
    #####:  711:	for (i = 0; i < 3; i++)
        -:  712:	{
    #####:  713:		drawCard(currentPlayer, state);
        -:  714:	}
        -:  715:
        -:  716:	//discard card from hand
    #####:  717:	discardCard(handPos, currentPlayer, state, 0);
    #####:  718:}
        -:  719:
    #####:  720:void playBaron(struct gameState *state, int currentPlayer, int choice1, int handPos)
        -:  721://Add a buy.  OPTION:  Discard an Estate card and gain $4.  Otherwise, gain an Estate card.
        -:  722:{
    #####:  723:	state->numBuys++;//Increase buys by 1!
    #####:  724:	if (choice1 > 0){//Boolean true or going to discard an estate
    #####:  725:		int p = 0;//Iterator for hand!
    #####:  726:		int card_not_discarded = 1;//Flag for discard set!
    #####:  727:		while (card_not_discarded){
    #####:  728:			if (state->hand[currentPlayer][p] == estate){ //Found an estate card!
    #####:  729:				state->coins += 4;//Add 4 coins to the amount of coins
    #####:  730:				state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  731:				state->discardCount[currentPlayer]++;
    #####:  732:				for (; p < state->handCount[currentPlayer]; p++){
    #####:  733:					state->hand[currentPlayer][p] = state->hand[currentPlayer][p + 1];
        -:  734:				}
    #####:  735:				state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  736:				state->handCount[currentPlayer]--;
    #####:  737:				card_not_discarded = 0;//Exit the loop
        -:  738:			}
    #####:  739:			else if (p > state->handCount[currentPlayer]){
        -:  740:				if (DEBUG) {
        -:  741:					printf("No estate cards in your hand, invalid choice\n");
        -:  742:					printf("Must gain an estate if there are any\n");
        -:  743:				}
    #####:  744:				if (supplyCount(estate, state) > 0){
    #####:  745:					gainCard(estate, state, 1, currentPlayer);
    #####:  746:					state->supplyCount[estate]--;//Decrement estates
    #####:  747:					if (supplyCount(estate, state) == 0){
    #####:  748:						isGameOver(state);
        -:  749:					}
        -:  750:				}
    #####:  751:				card_not_discarded = 0;//Exit the loop
        -:  752:			}
        -:  753:
        -:  754:			else{
    #####:  755:				p++;//Next card
        -:  756:			}
        -:  757:		}
        -:  758:	}
        -:  759:
        -:  760:	else{
    #####:  761:		if (supplyCount(estate, state) > 0){
    #####:  762:			gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  763:			state->supplyCount[estate]--;//Decrement Estates
    #####:  764:			if (supplyCount(estate, state) == 0){
    #####:  765:				isGameOver(state);
        -:  766:			}
        -:  767:		}
        -:  768:	}
    #####:  769:}
        -:  770:
    #####:  771:int playTreasureMap(struct gameState *state, int currentPlayer, int handPos)
        -:  772://Trashing two treasure map cards from the hand = four gold on top of the deck.
        -:  773:{
        -:  774:	int i;
        -:  775:	int index;
        -:  776:
        -:  777:	//search hand for another treasure_map
    #####:  778:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  779:	{
    #####:  780:		if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -:  781:		{
    #####:  782:			index = i;
    #####:  783:			break;
        -:  784:		}
        -:  785:	}
    #####:  786:	if (index > -1)
        -:  787:	{
        -:  788:		//trash both treasure cards
    #####:  789:		discardCard(handPos, currentPlayer, state, 1);
    #####:  790:		discardCard(index, currentPlayer, state, 1);
        -:  791:
        -:  792:		//gain 4 Gold cards
    #####:  793:		for (i = 0; i < 4; i++)
        -:  794:		{
    #####:  795:			gainCard(gold, state, 1, currentPlayer);
        -:  796:		}
        -:  797:
        -:  798:		//return success
    #####:  799:		return 1;
        -:  800:	}
        -:  801:
        -:  802:	//no second treasure_map found in hand
    #####:  803:	return -1;
        -:  804:}
        -:  805:
    #####:  806:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  807:{
        -:  808:	int i;
        -:  809:	int j;
        -:  810:	int k;
        -:  811:	//int x;  //Unused after while loop removed from feast.
    #####:  812:	int currentPlayer = whoseTurn(state);
    #####:  813:	int nextPlayer = currentPlayer + 1;
        -:  814:	int temphand[MAX_HAND];
        -:  815:
    #####:  816:	int tributeRevealedCards[2] = { -1, -1 };
        -:  817:
    #####:  818:	if (nextPlayer > (state->numPlayers - 1)){
    #####:  819:		nextPlayer = 0;
        -:  820:	}
        -:  821:
        -:  822:	//uses switch to select card and perform actions
    #####:  823:	switch (card)
        -:  824:	{
        -:  825:	case adventurer:
        -:  826:
    #####:  827:		playAdventurer(state, currentPlayer);
    #####:  828:		return 0;
        -:  829:
        -:  830:	case council_room:
        -:  831:		//+4 Cards
    #####:  832:		for (i = 0; i < 4; i++)
        -:  833:		{
    #####:  834:			drawCard(currentPlayer, state);
        -:  835:		}
        -:  836:
        -:  837:		//+1 Buy
    #####:  838:		state->numBuys++;
        -:  839:
        -:  840:		//Each other player draws a card
    #####:  841:		for (i = 0; i < state->numPlayers; i++)
        -:  842:		{
    #####:  843:			if (i != currentPlayer)
        -:  844:			{
    #####:  845:				drawCard(i, state);
        -:  846:			}
        -:  847:		}
        -:  848:
        -:  849:		//put played card in played card pile
    #####:  850:		discardCard(handPos, currentPlayer, state, 0);
        -:  851:
    #####:  852:		return 0;
        -:  853:
        -:  854:	case feast:
        -:  855:		//gain card with cost up to 5
        -:  856:		//Backup hand
    #####:  857:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  858:			temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  859:			state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  860:		}
        -:  861:		//Backup hand
        -:  862:
        -:  863:		//Update Coins for Buy
    #####:  864:		updateCoins(currentPlayer, state, 5);
        -:  865://		x = 1;//Condition to loop on
        -:  866://		while (x == 1) {//Buy one card
    #####:  867:			if (supplyCount(choice1, state) <= 0){
        -:  868:				if (DEBUG)
        -:  869:					printf("None of that card left, sorry!\n");
        -:  870:
        -:  871:				if (DEBUG){
        -:  872:					printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  873:				}
        -:  874:			}
    #####:  875:			else if (state->coins < getCost(choice1)){
    #####:  876:				printf("That card is too expensive!\n");
        -:  877:
        -:  878:				if (DEBUG){
        -:  879:					printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  880:				}
        -:  881:			}
        -:  882:			else{
        -:  883:
        -:  884:				if (DEBUG){
        -:  885:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  886:				}
        -:  887:
    #####:  888:				gainCard(choice1, state, 0, currentPlayer);//Gain the card
        -:  889://				x = 0;//No more buying cards
        -:  890:
        -:  891:				if (DEBUG){
        -:  892:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  893:				}
        -:  894:
        -:  895:			}
        -:  896://		}
        -:  897:
        -:  898:		//Reset Hand
    #####:  899:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  900:			state->hand[currentPlayer][i] = temphand[i];
    #####:  901:			temphand[i] = -1;
        -:  902:		}
        -:  903:		//Reset Hand
        -:  904:
    #####:  905:		return 0;
        -:  906:
        -:  907:	case gardens:
    #####:  908:		return -1;
        -:  909:
        -:  910:	case mine:
    #####:  911:		j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  912:
    #####:  913:		if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  914:		{
    #####:  915:			return -1;
        -:  916:		}
        -:  917:
    #####:  918:		if (choice2 > treasure_map || choice2 < curse)
        -:  919:		{
    #####:  920:			return -1;
        -:  921:		}
        -:  922:
    #####:  923:		if ((getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2))
        -:  924:		{
    #####:  925:			return -1;
        -:  926:		}
        -:  927:
    #####:  928:		gainCard(choice2, state, 2, currentPlayer);
        -:  929:
        -:  930:		//discard card from hand
    #####:  931:		discardCard(handPos, currentPlayer, state, 0);
        -:  932:
        -:  933:		//discard trashed card
    #####:  934:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  935:		{
    #####:  936:			if (state->hand[currentPlayer][i] == j)
        -:  937:			{
    #####:  938:				discardCard(i, currentPlayer, state, 0);
    #####:  939:				break;
        -:  940:			}
        -:  941:		}
        -:  942:
    #####:  943:		return 0;
        -:  944:
        -:  945:	case remodel:
        -:  946:
    #####:  947:		return playRemodel(state, currentPlayer, choice1, choice2, handPos);
        -:  948:
        -:  949:	case smithy:
        -:  950:
    #####:  951:		playSmithy(state, currentPlayer, handPos);
    #####:  952:		return 0;
        -:  953:
        -:  954:	case village:
        -:  955:		//+1 Card
    #####:  956:		drawCard(currentPlayer, state);
        -:  957:
        -:  958:		//+2 Actions
    #####:  959:		state->numActions = state->numActions + 2;
        -:  960:
        -:  961:		//discard played card from hand
    #####:  962:		discardCard(handPos, currentPlayer, state, 0);
    #####:  963:		return 0;
        -:  964:
        -:  965:	case baron:
        -:  966:
    #####:  967:		playBaron(state, currentPlayer, choice1, handPos);
    #####:  968:		return 0;
        -:  969:
        -:  970:	case great_hall:
        -:  971:		//+1 Card
    #####:  972:		drawCard(currentPlayer, state);
        -:  973:
        -:  974:		//+1 Actions
    #####:  975:		state->numActions++;
        -:  976:
        -:  977:		//discard card from hand
    #####:  978:		discardCard(handPos, currentPlayer, state, 0);
    #####:  979:		return 0;
        -:  980:
        -:  981:	case minion:
        -:  982:		//+1 action
    #####:  983:		state->numActions++;
        -:  984:
        -:  985:		//discard card from hand
    #####:  986:		discardCard(handPos, currentPlayer, state, 0);
        -:  987:
    #####:  988:		if (choice1)		//+2 coins
        -:  989:		{
    #####:  990:			state->coins = state->coins + 2;
        -:  991:		}
        -:  992:
    #####:  993:		else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  994:		{
        -:  995:			//discard hand
    #####:  996:			while (numHandCards(state) > 0)
        -:  997:			{
    #####:  998:				discardCard(handPos, currentPlayer, state, 0);
        -:  999:			}
        -: 1000:
        -: 1001:			//draw 4
    #####: 1002:			for (i = 0; i < 4; i++)
        -: 1003:			{
    #####: 1004:				drawCard(currentPlayer, state);
        -: 1005:			}
        -: 1006:
        -: 1007:			//other players discard hand and redraw if hand size > 4
    #####: 1008:			for (i = 0; i < state->numPlayers; i++)
        -: 1009:			{
    #####: 1010:				if (i != currentPlayer)
        -: 1011:				{
    #####: 1012:					if (state->handCount[i] > 4)
        -: 1013:					{
        -: 1014:						//discard hand
    #####: 1015:						while (state->handCount[i] > 0)
        -: 1016:						{
    #####: 1017:							discardCard(handPos, i, state, 0);
        -: 1018:						}
        -: 1019:
        -: 1020:						//draw 4
    #####: 1021:						for (j = 0; j < 4; j++)
        -: 1022:						{
    #####: 1023:							drawCard(i, state);
        -: 1024:						}
        -: 1025:					}
        -: 1026:				}
        -: 1027:			}
        -: 1028:
        -: 1029:		}
    #####: 1030:		return 0;
        -: 1031:
        -: 1032:	case steward:
    #####: 1033:		if (choice1 == 1)
        -: 1034:		{
        -: 1035:			//+2 cards
    #####: 1036:			drawCard(currentPlayer, state);
    #####: 1037:			drawCard(currentPlayer, state);
        -: 1038:		}
    #####: 1039:		else if (choice1 == 2)
        -: 1040:		{
        -: 1041:			//+2 coins
    #####: 1042:			state->coins = state->coins + 2;
        -: 1043:		}
        -: 1044:		else
        -: 1045:		{
        -: 1046:			//trash 2 cards in hand
    #####: 1047:			discardCard(choice2, currentPlayer, state, 1);
    #####: 1048:			discardCard(choice3, currentPlayer, state, 1);
        -: 1049:		}
        -: 1050:
        -: 1051:		//discard card from hand
    #####: 1052:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1053:		return 0;
        -: 1054:
        -: 1055:	case tribute:
    #####: 1056:		if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####: 1057:			if (state->deckCount[nextPlayer] > 0){
    #####: 1058:				tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1059:				state->deckCount[nextPlayer]--;
        -: 1060:			}
    #####: 1061:			else if (state->discardCount[nextPlayer] > 0){
    #####: 1062:				tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer] - 1];
    #####: 1063:				state->discardCount[nextPlayer]--;
        -: 1064:			}
        -: 1065:			else{
        -: 1066:				//No Card to Reveal
        -: 1067:				if (DEBUG){
        -: 1068:					printf("No cards to reveal\n");
        -: 1069:				}
        -: 1070:			}
        -: 1071:		}
        -: 1072:
        -: 1073:		else{
    #####: 1074:			if (state->deckCount[nextPlayer] == 0){
    #####: 1075:				for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####: 1076:					state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1077:					state->deckCount[nextPlayer]++;
    #####: 1078:					state->discard[nextPlayer][i] = -1;
    #####: 1079:					state->discardCount[nextPlayer]--;
        -: 1080:				}
        -: 1081:
    #####: 1082:				shuffle(nextPlayer, state);//Shuffle the deck
        -: 1083:			}
    #####: 1084:			tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1085:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1086:			state->deckCount[nextPlayer]--;
    #####: 1087:			tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1088:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1089:			state->deckCount[nextPlayer]--;
        -: 1090:		}
        -: 1091:
    #####: 1092:		if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
    #####: 1093:			state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1094:			state->playedCardCount++;
    #####: 1095:			tributeRevealedCards[1] = -1;
        -: 1096:		}
        -: 1097:
    #####: 1098:		for (i = 0; i <= 2; i++){
    #####: 1099:			if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
    #####: 1100:				state->coins += 2;
        -: 1101:			}
        -: 1102:
    #####: 1103:			else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
    #####: 1104:				drawCard(currentPlayer, state);
    #####: 1105:				drawCard(currentPlayer, state);
        -: 1106:			}
        -: 1107:			else{//Action Card
    #####: 1108:				state->numActions = state->numActions + 2;
        -: 1109:			}
        -: 1110:		}
        -: 1111:
    #####: 1112:		return 0;
        -: 1113:
        -: 1114:	case ambassador:
    #####: 1115:		j = 0;		//used to check if player has enough cards to discard
        -: 1116:
    #####: 1117:		if (choice2 > 2 || choice2 < 0)
        -: 1118:		{
    #####: 1119:			return -1;
        -: 1120:		}
        -: 1121:
    #####: 1122:		if (choice1 == handPos)
        -: 1123:		{
    #####: 1124:			return -1;
        -: 1125:		}
        -: 1126:
    #####: 1127:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1128:		{
    #####: 1129:			if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1130:			{
    #####: 1131:				j++;
        -: 1132:			}
        -: 1133:		}
    #####: 1134:		if (j < choice2)
        -: 1135:		{
    #####: 1136:			return -1;
        -: 1137:		}
        -: 1138:
        -: 1139:		if (DEBUG)
        -: 1140:			printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1141:
        -: 1142:		//increase supply count for choosen card by amount being discarded
    #####: 1143:		state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1144:
        -: 1145:		//each other player gains a copy of revealed card
    #####: 1146:		for (i = 0; i < state->numPlayers; i++)
        -: 1147:		{
    #####: 1148:			if (i != currentPlayer)
        -: 1149:			{
    #####: 1150:				gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1151:			}
        -: 1152:		}
        -: 1153:
        -: 1154:		//discard played card from hand
    #####: 1155:		discardCard(handPos, currentPlayer, state, 0);
        -: 1156:
        -: 1157:		//trash copies of cards returned to supply
    #####: 1158:		for (j = 0; j < choice2; j++)
        -: 1159:		{
    #####: 1160:			for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1161:			{
    #####: 1162:				if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1163:				{
    #####: 1164:					discardCard(i, currentPlayer, state, 1);
    #####: 1165:					break;
        -: 1166:				}
        -: 1167:			}
        -: 1168:		}
        -: 1169:
    #####: 1170:		return 0;
        -: 1171:
        -: 1172:	case cutpurse:
        -: 1173:
    #####: 1174:		updateCoins(currentPlayer, state, 2);
    #####: 1175:		for (i = 0; i < state->numPlayers; i++)
        -: 1176:		{
    #####: 1177:			if (i != currentPlayer)
        -: 1178:			{
    #####: 1179:				for (j = 0; j < state->handCount[i]; j++)
        -: 1180:				{
    #####: 1181:					if (state->hand[i][j] == copper)
        -: 1182:					{
    #####: 1183:						discardCard(j, i, state, 0);
    #####: 1184:						break;
        -: 1185:					}
    #####: 1186:					if (j == state->handCount[i])
        -: 1187:					{
    #####: 1188:						for (k = 0; k < state->handCount[i]; k++)
        -: 1189:						{
        -: 1190:							if (DEBUG)
        -: 1191:								printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1192:						}
    #####: 1193:						break;
        -: 1194:					}
        -: 1195:				}
        -: 1196:
        -: 1197:			}
        -: 1198:
        -: 1199:		}
        -: 1200:
        -: 1201:		//discard played card from hand
    #####: 1202:		discardCard(handPos, currentPlayer, state, 0);
        -: 1203:
    #####: 1204:		return 0;
        -: 1205:
        -: 1206:
        -: 1207:	case embargo:
        -: 1208:		//+2 Coins
    #####: 1209:		state->coins = state->coins + 2;
        -: 1210:
        -: 1211:		//see if selected pile is in play
    #####: 1212:		if (state->supplyCount[choice1] == -1)
        -: 1213:		{
    #####: 1214:			return -1;
        -: 1215:		}
        -: 1216:
        -: 1217:		//add embargo token to selected supply pile
    #####: 1218:		state->embargoTokens[choice1]++;
        -: 1219:
        -: 1220:		//trash card
    #####: 1221:		discardCard(handPos, currentPlayer, state, 1);
    #####: 1222:		return 0;
        -: 1223:
        -: 1224:	case outpost:
        -: 1225:		//set outpost flag
    #####: 1226:		state->outpostPlayed++;
        -: 1227:
        -: 1228:		//discard card
    #####: 1229:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1230:		return 0;
        -: 1231:
        -: 1232:	case salvager:
        -: 1233:		//+1 buy
    #####: 1234:		state->numBuys++;
        -: 1235:
    #####: 1236:		if (choice1)
        -: 1237:		{
        -: 1238:			//gain coins equal to trashed card
    #####: 1239:			state->coins = state->coins + getCost(handCard(choice1, state));
        -: 1240:			//trash card
    #####: 1241:			discardCard(choice1, currentPlayer, state, 1);
        -: 1242:		}
        -: 1243:
        -: 1244:		//discard card
    #####: 1245:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1246:		return 0;
        -: 1247:
        -: 1248:	case sea_hag:
    #####: 1249:		for (i = 0; i < state->numPlayers; i++){
    #####: 1250:			if (i != currentPlayer){
    #####: 1251:				state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1252:				state->discardCount[i]++;
    #####: 1253:				state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1254:			}
        -: 1255:		}
    #####: 1256:		return 0;
        -: 1257:
        -: 1258:	case treasure_map:
        -: 1259:
    #####: 1260:		return playTreasureMap(state, currentPlayer, handPos);
        -: 1261:	}
    #####: 1262:	return -1;
        -: 1263:}
        -: 1264:
    #####: 1265:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1266:{
        -: 1267:
        -: 1268:	//if card is not trashed, added to Played pile 
    #####: 1269:	if (trashFlag < 1)
        -: 1270:	{
        -: 1271:		//add card to played pile
    #####: 1272:		state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
    #####: 1273:		state->playedCardCount++;
        -: 1274:	}
        -: 1275:
        -: 1276:	//set played card to -1
    #####: 1277:	state->hand[currentPlayer][handPos] = -1;
        -: 1278:
        -: 1279:	//remove card from player's hand
    #####: 1280:	if (handPos == (state->handCount[currentPlayer] - 1)) 	//last card in hand array is played
        -: 1281:	{
        -: 1282:		//reduce number of cards in hand
    #####: 1283:		state->handCount[currentPlayer]--;
        -: 1284:	}
    #####: 1285:	else if (state->handCount[currentPlayer] == 1) //only one card in hand
        -: 1286:	{
        -: 1287:		//reduce number of cards in hand
    #####: 1288:		state->handCount[currentPlayer]--;
        -: 1289:	}
        -: 1290:	else
        -: 1291:	{
        -: 1292:		//replace discarded card with last card in hand
    #####: 1293:		state->hand[currentPlayer][handPos] = state->hand[currentPlayer][(state->handCount[currentPlayer] - 1)];
        -: 1294:		//set last card to -1
    #####: 1295:		state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1296:		//reduce number of cards in hand
    #####: 1297:		state->handCount[currentPlayer]--;
        -: 1298:	}
        -: 1299:
    #####: 1300:	return 0;
        -: 1301:}
        -: 1302:
    #####: 1303:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1304:{
        -: 1305:	//Note: supplyPos is enum of choosen card
        -: 1306:
        -: 1307:	//check if supply pile is empty (0) or card is not used in game (-1)
    #####: 1308:	if (supplyCount(supplyPos, state) < 1)
        -: 1309:	{
    #####: 1310:		return -1;
        -: 1311:	}
        -: 1312:
        -: 1313:	//added card for [whoseTurn] current player:
        -: 1314:	// toFlag = 0 : add to discard
        -: 1315:	// toFlag = 1 : add to deck
        -: 1316:	// toFlag = 2 : add to hand
        -: 1317:
    #####: 1318:	if (toFlag == 1)
        -: 1319:	{
    #####: 1320:		state->deck[player][state->deckCount[player]] = supplyPos;
    #####: 1321:		state->deckCount[player]++;
        -: 1322:	}
    #####: 1323:	else if (toFlag == 2)
        -: 1324:	{
    #####: 1325:		state->hand[player][state->handCount[player]] = supplyPos;
    #####: 1326:		state->handCount[player]++;
        -: 1327:	}
        -: 1328:	else
        -: 1329:	{
    #####: 1330:		state->discard[player][state->discardCount[player]] = supplyPos;
    #####: 1331:		state->discardCount[player]++;
        -: 1332:	}
        -: 1333:
        -: 1334:	//decrease number in supply pile
    #####: 1335:	state->supplyCount[supplyPos]--;
        -: 1336:
    #####: 1337:	return 0;
        -: 1338:}
        -: 1339:
       13: 1340:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1341:{
        -: 1342:	int i;
        -: 1343:
        -: 1344:	//reset coin count
       13: 1345:	state->coins = 0;
        -: 1346:
        -: 1347:	//add coins for each Treasure card in player's hand
       63: 1348:	for (i = 0; i < state->handCount[player]; i++)
        -: 1349:	{
       50: 1350:		if (state->hand[player][i] == copper)
        -: 1351:		{
       32: 1352:			state->coins += 1;
        -: 1353:		}
       18: 1354:		else if (state->hand[player][i] == silver)
        -: 1355:		{
    #####: 1356:			state->coins += 2;
        -: 1357:		}
       18: 1358:		else if (state->hand[player][i] == gold)
        -: 1359:		{
    #####: 1360:			state->coins += 3;
        -: 1361:		}
        -: 1362:	}
        -: 1363:
        -: 1364:	//add bonus
       13: 1365:	state->coins += bonus;
        -: 1366:
       13: 1367:	return 0;
        -: 1368:}
        -: 1369:
        -: 1370:
        -: 1371://end of dominion.c
File 'dominion.c'
Lines executed:27.11% of 557
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
      420:    8:int compare(const void* a, const void* b) {
      420:    9:	if (*(int*)a > *(int*)b)
    #####:   10:		return 1;
      420:   11:	if (*(int*)a < *(int*)b)
      150:   12:		return -1;
      270:   13:	return 0;
        -:   14:}
        -:   15:
       20:   16:struct gameState* newGame() {
       20:   17:	struct gameState* g = malloc(sizeof(struct gameState));
       20:   18:	return g;
        -:   19:}
        -:   20:
      228:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:	int k8, int k9, int k10) {
      228:   23:	int* k = malloc(10 * sizeof(int));
      228:   24:	k[0] = k1;
      228:   25:	k[1] = k2;
      228:   26:	k[2] = k3;
      228:   27:	k[3] = k4;
      228:   28:	k[4] = k5;
      228:   29:	k[5] = k6;
      228:   30:	k[6] = k7;
      228:   31:	k[7] = k8;
      228:   32:	k[8] = k9;
      228:   33:	k[9] = k10;
      228:   34:	return k;
        -:   35:}
        -:   36:
      228:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		struct gameState *state) {
        -:   39:
        -:   40:	int i;
        -:   41:	int j;
        -:   42:	int it;
        -:   43:	//set up random number generator
      228:   44:	SelectStream(1);
      228:   45:	PutSeed((long)randomSeed);
        -:   46:
        -:   47:	//check number of players
      228:   48:	if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:	{
    #####:   50:		return -1;
        -:   51:	}
        -:   52:
        -:   53:	//set number of players
      228:   54:	state->numPlayers = numPlayers;
        -:   55:
        -:   56:	//check selected kingdom cards are different
      644:   57:	for (i = 0; i < 10; i++)
        -:   58:	{
     5962:   59:		for (j = 0; j < 10; j++)
        -:   60:		{
     5546:   61:			if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:			{
      218:   63:				return -1;
        -:   64:			}
        -:   65:		}
        -:   66:	}
        -:   67:
        -:   68:
        -:   69:	//initialize supply
        -:   70:	///////////////////////////////
        -:   71:
        -:   72:	//set number of Curse cards
       10:   73:	if (numPlayers == 2)
        -:   74:	{
        3:   75:		state->supplyCount[curse] = 10;
        -:   76:	}
        7:   77:	else if (numPlayers == 3)
        -:   78:	{
        4:   79:		state->supplyCount[curse] = 20;
        -:   80:	}
        -:   81:	else
        -:   82:	{
        3:   83:		state->supplyCount[curse] = 30;
        -:   84:	}
        -:   85:
        -:   86:	//set number of Victory cards
       10:   87:	if (numPlayers == 2)
        -:   88:	{
        3:   89:		state->supplyCount[estate] = 8;
        3:   90:		state->supplyCount[duchy] = 8;
        3:   91:		state->supplyCount[province] = 8;
        -:   92:	}
        -:   93:	else
        -:   94:	{
        7:   95:		state->supplyCount[estate] = 12;
        7:   96:		state->supplyCount[duchy] = 12;
        7:   97:		state->supplyCount[province] = 12;
        -:   98:	}
        -:   99:
        -:  100:	//set number of Treasure cards
       10:  101:	state->supplyCount[copper] = 60 - (7 * numPlayers);
       10:  102:	state->supplyCount[silver] = 40;
       10:  103:	state->supplyCount[gold] = 30;
        -:  104:
        -:  105:	//set number of Kingdom cards
      210:  106:	for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:	{
     1650:  108:		for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:		{
     1550:  110:			if (kingdomCards[j] == i)
        -:  111:			{
        -:  112:				//check if card is a 'Victory' Kingdom card
      100:  113:				if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:				{
       12:  115:					if (numPlayers == 2){
        1:  116:						state->supplyCount[i] = 8;
        -:  117:					}
        5:  118:					else{ state->supplyCount[i] = 12; }
        -:  119:				}
        -:  120:				else
        -:  121:				{
       94:  122:					state->supplyCount[i] = 10;
        -:  123:				}
      100:  124:				break;
        -:  125:			}
        -:  126:			else    //card is not in the set choosen for the game
        -:  127:			{
     1450:  128:				state->supplyCount[i] = -1;
        -:  129:			}
        -:  130:		}
        -:  131:
        -:  132:	}
        -:  133:
        -:  134:	////////////////////////
        -:  135:	//supply intilization complete
        -:  136:
        -:  137:	//set player decks
       40:  138:	for (i = 0; i < numPlayers; i++)
        -:  139:	{
       30:  140:		state->deckCount[i] = 0;
      120:  141:		for (j = 0; j < 3; j++)
        -:  142:		{
       90:  143:			state->deck[i][j] = estate;
       90:  144:			state->deckCount[i]++;
        -:  145:		}
      240:  146:		for (j = 3; j < 10; j++)
        -:  147:		{
      210:  148:			state->deck[i][j] = copper;
      210:  149:			state->deckCount[i]++;
        -:  150:		}
        -:  151:	}
        -:  152:
        -:  153:	//shuffle player decks
       40:  154:	for (i = 0; i < numPlayers; i++)
        -:  155:	{
       30:  156:		if (shuffle(i, state) < 0)
        -:  157:		{
    #####:  158:			return -1;
        -:  159:		}
        -:  160:	}
        -:  161:
        -:  162:	//draw player hands
       40:  163:	for (i = 0; i < numPlayers; i++)
        -:  164:	{
        -:  165:		//initialize hand size to zero
       30:  166:		state->handCount[i] = 0;
       30:  167:		state->discardCount[i] = 0;
        -:  168:		//draw 5 cards
        -:  169:		// for (j = 0; j < 5; j++)
        -:  170:		//	{
        -:  171:		//	  drawCard(i, state);
        -:  172:		//	}
        -:  173:	}
        -:  174:
        -:  175:	//set embargo tokens to 0 for all supply piles
      280:  176:	for (i = 0; i <= treasure_map; i++)
        -:  177:	{
      270:  178:		state->embargoTokens[i] = 0;
        -:  179:	}
        -:  180:
        -:  181:	//initialize first player's turn
       10:  182:	state->outpostPlayed = 0;
       10:  183:	state->phase = 0;
       10:  184:	state->numActions = 1;
       10:  185:	state->numBuys = 1;
       10:  186:	state->playedCardCount = 0;
       10:  187:	state->whoseTurn = 0;
       10:  188:	state->handCount[state->whoseTurn] = 0;
        -:  189:	//int it; move to top
        -:  190:
        -:  191:	//Moved draw cards to here, only drawing at the start of a turn
       60:  192:	for (it = 0; it < 5; it++){
       50:  193:		drawCard(state->whoseTurn, state);
        -:  194:	}
        -:  195:
       10:  196:	updateCoins(state->whoseTurn, state, 0);
        -:  197:
       10:  198:	return 0;
        -:  199:}
        -:  200:
       40:  201:int shuffle(int player, struct gameState *state) {
        -:  202:
        -:  203:
        -:  204:	int newDeck[MAX_DECK];
       40:  205:	int newDeckPos = 0;
        -:  206:	int card;
        -:  207:	int i;
        -:  208:
       40:  209:	if (state->deckCount[player] < 1)
       10:  210:		return -1;
       30:  211:	qsort((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
        -:  212:	/* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
      360:  214:	while (state->deckCount[player] > 0) {
      300:  215:		card = floor(Random() * state->deckCount[player]);
      300:  216:		newDeck[newDeckPos] = state->deck[player][card];
      300:  217:		newDeckPos++;
      972:  218:		for (i = card; i < state->deckCount[player] - 1; i++) {
      672:  219:			state->deck[player][i] = state->deck[player][i + 1];
        -:  220:		}
      300:  221:		state->deckCount[player]--;
        -:  222:	}
      330:  223:	for (i = 0; i < newDeckPos; i++) {
      300:  224:		state->deck[player][i] = newDeck[i];
      300:  225:		state->deckCount[player]++;
        -:  226:	}
        -:  227:
       30:  228:	return 0;
        -:  229:}
        -:  230:
        4:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state)
        -:  232:{
        -:  233:	int card;
        4:  234:	int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:	//check if it is the right phase
        4:  237:	if (state->phase != 0)
        -:  238:	{
    #####:  239:		return -1;
        -:  240:	}
        -:  241:
        -:  242:	//check if player has enough actions
        4:  243:	if (state->numActions < 1)
        -:  244:	{
        4:  245:		return -1;
        -:  246:	}
        -:  247:
        -:  248:	//get card played
    #####:  249:	card = handCard(handPos, state);
        -:  250:
        -:  251:	//check if selected card is an action
    #####:  252:	if (card < adventurer || card > treasure_map)
        -:  253:	{
    #####:  254:		return -1;
        -:  255:	}
        -:  256:
        -:  257:	//play card
    #####:  258:	if (cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0)
        -:  259:	{
    #####:  260:		return -1;
        -:  261:	}
        -:  262:
        -:  263:	//reduce number of actions
    #####:  264:	state->numActions--;
        -:  265:
        -:  266:	//update coins (Treasure cards may be added with card draws)
    #####:  267:	updateCoins(state->whoseTurn, state, coin_bonus);
        -:  268:
    #####:  269:	return 0;
        -:  270:}
        -:  271:
        4:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:	int who;
        -:  274:	if (DEBUG){
        -:  275:		printf("Entering buyCard...\n");
        -:  276:	}
        -:  277:
        -:  278:	// I don't know what to do about the phase thing.
        -:  279:
        4:  280:	who = state->whoseTurn;
        -:  281:
        4:  282:	if (state->numBuys < 1){
        -:  283:		if (DEBUG)
        -:  284:			printf("You do not have any buys left\n");
        4:  285:		return -1;
        -:  286:	}
    #####:  287:	else if (supplyCount(supplyPos, state) < 1){
        -:  288:		if (DEBUG)
        -:  289:			printf("There are not any of that type of card left\n");
    #####:  290:		return -1;
        -:  291:	}
    #####:  292:	else if (state->coins < getCost(supplyPos)){
        -:  293:		if (DEBUG)
        -:  294:			printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  295:		return -1;
        -:  296:	}
        -:  297:	else {
    #####:  298:		state->phase = 1;
        -:  299:		//state->supplyCount[supplyPos]--;
    #####:  300:		gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  301:
    #####:  302:		state->coins = (state->coins) - (getCost(supplyPos));
    #####:  303:		state->numBuys--;
        -:  304:		if (DEBUG)
        -:  305:			printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  306:	}
        -:  307:
        -:  308:	//state->discard[who][state->discardCount[who]] = supplyPos;
        -:  309:	//state->discardCount[who]++;
        -:  310:
    #####:  311:	return 0;
        -:  312:}
        -:  313:
    #####:  314:int numHandCards(struct gameState *state) {
    #####:  315:	return state->handCount[whoseTurn(state)];
        -:  316:}
        -:  317:
    #####:  318:int handCard(int handPos, struct gameState *state) {
    #####:  319:	int currentPlayer = whoseTurn(state);
    #####:  320:	return state->hand[currentPlayer][handPos];
        -:  321:}
        -:  322:
    #####:  323:int supplyCount(int card, struct gameState *state) {
    #####:  324:	return state->supplyCount[card];
        -:  325:}
        -:  326:
    #####:  327:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  328:	int i;
    #####:  329:	int count = 0;
        -:  330:
    #####:  331:	for (i = 0; i < state->deckCount[player]; i++)
        -:  332:	{
    #####:  333:		if (state->deck[player][i] == card) count++;
        -:  334:	}
        -:  335:
    #####:  336:	for (i = 0; i < state->handCount[player]; i++)
        -:  337:	{
    #####:  338:		if (state->hand[player][i] == card) count++;
        -:  339:	}
        -:  340:
    #####:  341:	for (i = 0; i < state->discardCount[player]; i++)
        -:  342:	{
    #####:  343:		if (state->discard[player][i] == card) count++;
        -:  344:	}
        -:  345:
    #####:  346:	return count;
        -:  347:}
        -:  348:
        2:  349:int whoseTurn(struct gameState *state) {
        2:  350:	return state->whoseTurn;
        -:  351:}
        -:  352:
        2:  353:int endTurn(struct gameState *state) {
        -:  354:	int k;
        -:  355:	int i;
        2:  356:	int currentPlayer = whoseTurn(state);
        -:  357:
        -:  358:	//Discard hand
        2:  359:	for (i = 0; i < state->handCount[currentPlayer]; i++){
    #####:  360:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  361:		state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  362:	}
        2:  363:	state->handCount[currentPlayer] = 0;//Reset hand count
        -:  364:
        -:  365:	//Code for determining the player
        2:  366:	if (currentPlayer < (state->numPlayers - 1)){
    #####:  367:		state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  368:	}
        -:  369:	else{
        2:  370:		state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  371:	}
        -:  372:
        2:  373:	state->outpostPlayed = 0;
        2:  374:	state->phase = 0;
        2:  375:	state->numActions = 1;
        2:  376:	state->coins = 0;
        2:  377:	state->numBuys = 1;
        2:  378:	state->playedCardCount = 0;
        2:  379:	state->handCount[state->whoseTurn] = 0;
        -:  380:
        -:  381:	//int k; move to top
        -:  382:	//Next player draws hand
       12:  383:	for (k = 0; k < 5; k++){
       10:  384:		drawCard(state->whoseTurn, state);//Draw a card
        -:  385:	}
        -:  386:
        -:  387:	//Update money
        2:  388:	updateCoins(state->whoseTurn, state, 0);
        -:  389:
        2:  390:	return 0;
        -:  391:}
        -:  392:
    #####:  393:int isGameOver(struct gameState *state) {
        -:  394:	int i;
        -:  395:	int j;
        -:  396:
        -:  397:	//if stack of Province cards is empty, the game ends
    #####:  398:	if (state->supplyCount[province] == 0)
        -:  399:	{
    #####:  400:		return 1;
        -:  401:	}
        -:  402:
        -:  403:	//if three supply pile are at 0, the game ends
    #####:  404:	j = 0;
    #####:  405:	for (i = 0; i < 25; i++)
        -:  406:	{
    #####:  407:		if (state->supplyCount[i] == 0)
        -:  408:		{
    #####:  409:			j++;
        -:  410:		}
        -:  411:	}
    #####:  412:	if (j >= 3)
        -:  413:	{
    #####:  414:		return 1;
        -:  415:	}
        -:  416:
    #####:  417:	return 0;
        -:  418:}
        -:  419:
    #####:  420:int scoreFor(int player, struct gameState *state) {
        -:  421:
        -:  422:	int i;
    #####:  423:	int score = 0;
        -:  424:	//score from hand
    #####:  425:	for (i = 0; i < state->handCount[player]; i++)
        -:  426:	{
    #####:  427:		if (state->hand[player][i] == curse) { score = score - 1; };
    #####:  428:		if (state->hand[player][i] == estate) { score = score + 1; };
    #####:  429:		if (state->hand[player][i] == duchy) { score = score + 3; };
    #####:  430:		if (state->hand[player][i] == province) { score = score + 6; };
    #####:  431:		if (state->hand[player][i] == great_hall) { score = score + 1; };
    #####:  432:		if (state->hand[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  433:	}
        -:  434:
        -:  435:	//score from discard
    #####:  436:	for (i = 0; i < state->discardCount[player]; i++)
        -:  437:	{
    #####:  438:		if (state->discard[player][i] == curse) { score = score - 1; };
    #####:  439:		if (state->discard[player][i] == estate) { score = score + 1; };
    #####:  440:		if (state->discard[player][i] == duchy) { score = score + 3; };
    #####:  441:		if (state->discard[player][i] == province) { score = score + 6; };
    #####:  442:		if (state->discard[player][i] == great_hall) { score = score + 1; };
    #####:  443:		if (state->discard[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  444:	}
        -:  445:
        -:  446:	//score from deck
    #####:  447:	for (i = 0; i < state->discardCount[player]; i++)
        -:  448:	{
    #####:  449:		if (state->deck[player][i] == curse) { score = score - 1; };
    #####:  450:		if (state->deck[player][i] == estate) { score = score + 1; };
    #####:  451:		if (state->deck[player][i] == duchy) { score = score + 3; };
    #####:  452:		if (state->deck[player][i] == province) { score = score + 6; };
    #####:  453:		if (state->deck[player][i] == great_hall) { score = score + 1; };
    #####:  454:		if (state->deck[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  455:	}
        -:  456:
    #####:  457:	return score;
        -:  458:}
        -:  459:
    #####:  460:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  461:	int i;
        -:  462:	int j;
        -:  463:	int highScore;
        -:  464:	int currentPlayer;
        -:  465:
        -:  466:	//get score for each player
    #####:  467:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  468:	{
        -:  469:		//set unused player scores to -9999
    #####:  470:		if (i >= state->numPlayers)
        -:  471:		{
    #####:  472:			players[i] = -9999;
        -:  473:		}
        -:  474:		else
        -:  475:		{
    #####:  476:			players[i] = scoreFor(i, state);
        -:  477:		}
        -:  478:	}
        -:  479:
        -:  480:	//find highest score
    #####:  481:	j = 0;
    #####:  482:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  483:	{
    #####:  484:		if (players[i] > players[j])
        -:  485:		{
    #####:  486:			j = i;
        -:  487:		}
        -:  488:	}
    #####:  489:	highScore = players[j];
        -:  490:
        -:  491:	//add 1 to players who had less turns
    #####:  492:	currentPlayer = whoseTurn(state);
    #####:  493:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  494:	{
    #####:  495:		if (players[i] == highScore && i > currentPlayer)
        -:  496:		{
    #####:  497:			players[i]++;
        -:  498:		}
        -:  499:	}
        -:  500:
        -:  501:	//find new highest score
    #####:  502:	j = 0;
    #####:  503:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  504:	{
    #####:  505:		if (players[i] > players[j])
        -:  506:		{
    #####:  507:			j = i;
        -:  508:		}
        -:  509:	}
    #####:  510:	highScore = players[j];
        -:  511:
        -:  512:	//set winners in array to 1 and rest to 0
    #####:  513:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  514:	{
    #####:  515:		if (players[i] == highScore)
        -:  516:		{
    #####:  517:			players[i] = 1;
        -:  518:		}
        -:  519:		else
        -:  520:		{
    #####:  521:			players[i] = 0;
        -:  522:		}
        -:  523:	}
        -:  524:
    #####:  525:	return 0;
        -:  526:}
        -:  527:
       60:  528:int drawCard(int player, struct gameState *state)
        -:  529:{
        -:  530:	int count;
        -:  531:	int deckCounter;
       60:  532:	if (state->deckCount[player] <= 0){//Deck is empty
        -:  533:
        -:  534:		//Step 1 Shuffle the discard pile back into a deck
        -:  535:		int i;
        -:  536:		//Move discard to deck
       10:  537:		for (i = 0; i < state->discardCount[player]; i++){
    #####:  538:			state->deck[player][i] = state->discard[player][i];
    #####:  539:			state->discard[player][i] = -1;
        -:  540:		}
        -:  541:
       10:  542:		state->deckCount[player] = state->discardCount[player];
       10:  543:		state->discardCount[player] = 0;//Reset discard
        -:  544:
        -:  545:		//Shufffle the deck
       10:  546:		shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  547:
        -:  548:		if (DEBUG){//Debug statements
        -:  549:			printf("Deck count now: %d\n", state->deckCount[player]);
        -:  550:		}
        -:  551:
       10:  552:		state->discardCount[player] = 0;
        -:  553:
        -:  554:		//Step 2 Draw Card
       10:  555:		count = state->handCount[player];//Get current player's hand count
        -:  556:
        -:  557:		if (DEBUG){//Debug statements
        -:  558:			printf("Current hand count: %d\n", count);
        -:  559:		}
        -:  560:
       10:  561:		deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  562:
       10:  563:		if (deckCounter == 0)
       10:  564:			return -1;
        -:  565:
    #####:  566:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
    #####:  567:		state->deckCount[player]--;
    #####:  568:		state->handCount[player]++;//Increment hand count
        -:  569:	}
        -:  570:
        -:  571:	else{
       50:  572:		int count = state->handCount[player];//Get current hand count for player
        -:  573:		int deckCounter;
        -:  574:		if (DEBUG){//Debug statements
        -:  575:			printf("Current hand count: %d\n", count);
        -:  576:		}
        -:  577:
       50:  578:		deckCounter = state->deckCount[player];//Create holder for the deck count
       50:  579:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
       50:  580:		state->deckCount[player]--;
       50:  581:		state->handCount[player]++;//Increment hand count
        -:  582:	}
        -:  583:
       50:  584:	return 0;
        -:  585:}
        -:  586:
    #####:  587:int getCost(int cardNumber)
        -:  588:{
    #####:  589:	switch (cardNumber)
        -:  590:	{
        -:  591:	case curse:
    #####:  592:		return 0;
        -:  593:	case estate:
    #####:  594:		return 2;
        -:  595:	case duchy:
    #####:  596:		return 5;
        -:  597:	case province:
    #####:  598:		return 8;
        -:  599:	case copper:
    #####:  600:		return 0;
        -:  601:	case silver:
    #####:  602:		return 3;
        -:  603:	case gold:
    #####:  604:		return 6;
        -:  605:	case adventurer:
    #####:  606:		return 6;
        -:  607:	case council_room:
    #####:  608:		return 5;
        -:  609:	case feast:
    #####:  610:		return 4;
        -:  611:	case gardens:
    #####:  612:		return 4;
        -:  613:	case mine:
    #####:  614:		return 5;
        -:  615:	case remodel:
    #####:  616:		return 4;
        -:  617:	case smithy:
    #####:  618:		return 4;
        -:  619:	case village:
    #####:  620:		return 3;
        -:  621:	case baron:
    #####:  622:		return 4;
        -:  623:	case great_hall:
    #####:  624:		return 3;
        -:  625:	case minion:
    #####:  626:		return 5;
        -:  627:	case steward:
    #####:  628:		return 3;
        -:  629:	case tribute:
    #####:  630:		return 5;
        -:  631:	case ambassador:
    #####:  632:		return 3;
        -:  633:	case cutpurse:
    #####:  634:		return 4;
        -:  635:	case embargo:
    #####:  636:		return 2;
        -:  637:	case outpost:
    #####:  638:		return 5;
        -:  639:	case salvager:
    #####:  640:		return 4;
        -:  641:	case sea_hag:
    #####:  642:		return 4;
        -:  643:	case treasure_map:
    #####:  644:		return 4;
        -:  645:	}
        -:  646:
    #####:  647:	return -1;
        -:  648:}
        -:  649:
    #####:  650:void playAdventurer(struct gameState *state, int currentPlayer)
        -:  651:// Reveal cards from deck until 2 Treasure cards are found.  Put those Treasure cards in the hand and discard the rest.
        -:  652:{
    #####:  653:	int drawntreasure = 0;
        -:  654:	int temphand[MAX_HAND];
        -:  655:	int cardDrawn;
    #####:  656:	int z = 0; // this is the counter for the temp hand
        -:  657:
    #####:  658:	while (drawntreasure < 2){
    #####:  659:		if (state->deckCount[currentPlayer] < 1){//if the deck is empty we need to shuffle discard and add to deck
    #####:  660:			shuffle(currentPlayer, state);
        -:  661:		}
    #####:  662:		drawCard(currentPlayer, state);
    #####:  663:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer] - 1];//top card of hand is most recently drawn card.
    #####:  664:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
    #####:  665:			drawntreasure++;
        -:  666:		else{
    #####:  667:			temphand[z] = cardDrawn;
    #####:  668:			state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####:  669:			z++;
        -:  670:		}
        -:  671:	}
    #####:  672:	while (z - 1 >= 0){
    #####:  673:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; // discard all cards in play that have been drawn
    #####:  674:		z = z - 1;
        -:  675:	}
    #####:  676:}
        -:  677:
    #####:  678:int playRemodel(struct gameState *state, int currentPlayer, int choice1, int choice2, int handPos)
        -:  679://Trash a card in the hand, and gain a card costing up to $2 more than the trashed card
        -:  680:{
        -:  681:	int i;
    #####:  682:	int j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  683:
    #####:  684:	if ((getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2))
        -:  685:	{
    #####:  686:		return -1;
        -:  687:	}
        -:  688:
    #####:  689:	gainCard(choice2, state, 0, currentPlayer);
        -:  690:
        -:  691:	//discard card from hand
    #####:  692:	discardCard(handPos, currentPlayer, state, 0);
        -:  693:
        -:  694:	//discard trashed card
    #####:  695:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  696:	{
    #####:  697:		if (state->hand[currentPlayer][i] == j)
        -:  698:		{
    #####:  699:			discardCard(i, currentPlayer, state, 0);
    #####:  700:			break;
        -:  701:		}
        -:  702:	}
        -:  703:
    #####:  704:	return 0;
        -:  705:}
        -:  706:
    #####:  707:void playSmithy(struct gameState *state, int currentPlayer, int handPos)
        -:  708:// Draw 3 cards
        -:  709:{
        -:  710:	int i;
    #####:  711:	for (i = 0; i < 3; i++)
        -:  712:	{
    #####:  713:		drawCard(currentPlayer, state);
        -:  714:	}
        -:  715:
        -:  716:	//discard card from hand
    #####:  717:	discardCard(handPos, currentPlayer, state, 0);
    #####:  718:}
        -:  719:
    #####:  720:void playBaron(struct gameState *state, int currentPlayer, int choice1, int handPos)
        -:  721://Add a buy.  OPTION:  Discard an Estate card and gain $4.  Otherwise, gain an Estate card.
        -:  722:{
    #####:  723:	state->numBuys++;//Increase buys by 1!
    #####:  724:	if (choice1 > 0){//Boolean true or going to discard an estate
    #####:  725:		int p = 0;//Iterator for hand!
    #####:  726:		int card_not_discarded = 1;//Flag for discard set!
    #####:  727:		while (card_not_discarded){
    #####:  728:			if (state->hand[currentPlayer][p] == estate){ //Found an estate card!
    #####:  729:				state->coins += 4;//Add 4 coins to the amount of coins
    #####:  730:				state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  731:				state->discardCount[currentPlayer]++;
    #####:  732:				for (; p < state->handCount[currentPlayer]; p++){
    #####:  733:					state->hand[currentPlayer][p] = state->hand[currentPlayer][p + 1];
        -:  734:				}
    #####:  735:				state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  736:				state->handCount[currentPlayer]--;
    #####:  737:				card_not_discarded = 0;//Exit the loop
        -:  738:			}
    #####:  739:			else if (p > state->handCount[currentPlayer]){
        -:  740:				if (DEBUG) {
        -:  741:					printf("No estate cards in your hand, invalid choice\n");
        -:  742:					printf("Must gain an estate if there are any\n");
        -:  743:				}
    #####:  744:				if (supplyCount(estate, state) > 0){
    #####:  745:					gainCard(estate, state, 1, currentPlayer);
    #####:  746:					state->supplyCount[estate]--;//Decrement estates
    #####:  747:					if (supplyCount(estate, state) == 0){
    #####:  748:						isGameOver(state);
        -:  749:					}
        -:  750:				}
    #####:  751:				card_not_discarded = 0;//Exit the loop
        -:  752:			}
        -:  753:
        -:  754:			else{
    #####:  755:				p++;//Next card
        -:  756:			}
        -:  757:		}
        -:  758:	}
        -:  759:
        -:  760:	else{
    #####:  761:		if (supplyCount(estate, state) > 0){
    #####:  762:			gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  763:			state->supplyCount[estate]--;//Decrement Estates
    #####:  764:			if (supplyCount(estate, state) == 0){
    #####:  765:				isGameOver(state);
        -:  766:			}
        -:  767:		}
        -:  768:	}
    #####:  769:}
        -:  770:
    #####:  771:int playTreasureMap(struct gameState *state, int currentPlayer, int handPos)
        -:  772://Trashing two treasure map cards from the hand = four gold on top of the deck.
        -:  773:{
        -:  774:	int i;
        -:  775:	int index;
        -:  776:
        -:  777:	//search hand for another treasure_map
    #####:  778:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  779:	{
    #####:  780:		if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -:  781:		{
    #####:  782:			index = i;
    #####:  783:			break;
        -:  784:		}
        -:  785:	}
    #####:  786:	if (index > -1)
        -:  787:	{
        -:  788:		//trash both treasure cards
    #####:  789:		discardCard(handPos, currentPlayer, state, 1);
    #####:  790:		discardCard(index, currentPlayer, state, 1);
        -:  791:
        -:  792:		//gain 4 Gold cards
    #####:  793:		for (i = 0; i < 4; i++)
        -:  794:		{
    #####:  795:			gainCard(gold, state, 1, currentPlayer);
        -:  796:		}
        -:  797:
        -:  798:		//return success
    #####:  799:		return 1;
        -:  800:	}
        -:  801:
        -:  802:	//no second treasure_map found in hand
    #####:  803:	return -1;
        -:  804:}
        -:  805:
    #####:  806:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  807:{
        -:  808:	int i;
        -:  809:	int j;
        -:  810:	int k;
        -:  811:	//int x;  //Unused after while loop removed from feast.
    #####:  812:	int currentPlayer = whoseTurn(state);
    #####:  813:	int nextPlayer = currentPlayer + 1;
        -:  814:	int temphand[MAX_HAND];
        -:  815:
    #####:  816:	int tributeRevealedCards[2] = { -1, -1 };
        -:  817:
    #####:  818:	if (nextPlayer > (state->numPlayers - 1)){
    #####:  819:		nextPlayer = 0;
        -:  820:	}
        -:  821:
        -:  822:	//uses switch to select card and perform actions
    #####:  823:	switch (card)
        -:  824:	{
        -:  825:	case adventurer:
        -:  826:
    #####:  827:		playAdventurer(state, currentPlayer);
    #####:  828:		return 0;
        -:  829:
        -:  830:	case council_room:
        -:  831:		//+4 Cards
    #####:  832:		for (i = 0; i < 4; i++)
        -:  833:		{
    #####:  834:			drawCard(currentPlayer, state);
        -:  835:		}
        -:  836:
        -:  837:		//+1 Buy
    #####:  838:		state->numBuys++;
        -:  839:
        -:  840:		//Each other player draws a card
    #####:  841:		for (i = 0; i < state->numPlayers; i++)
        -:  842:		{
    #####:  843:			if (i != currentPlayer)
        -:  844:			{
    #####:  845:				drawCard(i, state);
        -:  846:			}
        -:  847:		}
        -:  848:
        -:  849:		//put played card in played card pile
    #####:  850:		discardCard(handPos, currentPlayer, state, 0);
        -:  851:
    #####:  852:		return 0;
        -:  853:
        -:  854:	case feast:
        -:  855:		//gain card with cost up to 5
        -:  856:		//Backup hand
    #####:  857:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  858:			temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  859:			state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  860:		}
        -:  861:		//Backup hand
        -:  862:
        -:  863:		//Update Coins for Buy
    #####:  864:		updateCoins(currentPlayer, state, 5);
        -:  865://		x = 1;//Condition to loop on
        -:  866://		while (x == 1) {//Buy one card
    #####:  867:			if (supplyCount(choice1, state) <= 0){
        -:  868:				if (DEBUG)
        -:  869:					printf("None of that card left, sorry!\n");
        -:  870:
        -:  871:				if (DEBUG){
        -:  872:					printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  873:				}
        -:  874:			}
    #####:  875:			else if (state->coins < getCost(choice1)){
    #####:  876:				printf("That card is too expensive!\n");
        -:  877:
        -:  878:				if (DEBUG){
        -:  879:					printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  880:				}
        -:  881:			}
        -:  882:			else{
        -:  883:
        -:  884:				if (DEBUG){
        -:  885:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  886:				}
        -:  887:
    #####:  888:				gainCard(choice1, state, 0, currentPlayer);//Gain the card
        -:  889://				x = 0;//No more buying cards
        -:  890:
        -:  891:				if (DEBUG){
        -:  892:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  893:				}
        -:  894:
        -:  895:			}
        -:  896://		}
        -:  897:
        -:  898:		//Reset Hand
    #####:  899:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  900:			state->hand[currentPlayer][i] = temphand[i];
    #####:  901:			temphand[i] = -1;
        -:  902:		}
        -:  903:		//Reset Hand
        -:  904:
    #####:  905:		return 0;
        -:  906:
        -:  907:	case gardens:
    #####:  908:		return -1;
        -:  909:
        -:  910:	case mine:
    #####:  911:		j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  912:
    #####:  913:		if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  914:		{
    #####:  915:			return -1;
        -:  916:		}
        -:  917:
    #####:  918:		if (choice2 > treasure_map || choice2 < curse)
        -:  919:		{
    #####:  920:			return -1;
        -:  921:		}
        -:  922:
    #####:  923:		if ((getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2))
        -:  924:		{
    #####:  925:			return -1;
        -:  926:		}
        -:  927:
    #####:  928:		gainCard(choice2, state, 2, currentPlayer);
        -:  929:
        -:  930:		//discard card from hand
    #####:  931:		discardCard(handPos, currentPlayer, state, 0);
        -:  932:
        -:  933:		//discard trashed card
    #####:  934:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  935:		{
    #####:  936:			if (state->hand[currentPlayer][i] == j)
        -:  937:			{
    #####:  938:				discardCard(i, currentPlayer, state, 0);
    #####:  939:				break;
        -:  940:			}
        -:  941:		}
        -:  942:
    #####:  943:		return 0;
        -:  944:
        -:  945:	case remodel:
        -:  946:
    #####:  947:		return playRemodel(state, currentPlayer, choice1, choice2, handPos);
        -:  948:
        -:  949:	case smithy:
        -:  950:
    #####:  951:		playSmithy(state, currentPlayer, handPos);
    #####:  952:		return 0;
        -:  953:
        -:  954:	case village:
        -:  955:		//+1 Card
    #####:  956:		drawCard(currentPlayer, state);
        -:  957:
        -:  958:		//+2 Actions
    #####:  959:		state->numActions = state->numActions + 2;
        -:  960:
        -:  961:		//discard played card from hand
    #####:  962:		discardCard(handPos, currentPlayer, state, 0);
    #####:  963:		return 0;
        -:  964:
        -:  965:	case baron:
        -:  966:
    #####:  967:		playBaron(state, currentPlayer, choice1, handPos);
    #####:  968:		return 0;
        -:  969:
        -:  970:	case great_hall:
        -:  971:		//+1 Card
    #####:  972:		drawCard(currentPlayer, state);
        -:  973:
        -:  974:		//+1 Actions
    #####:  975:		state->numActions++;
        -:  976:
        -:  977:		//discard card from hand
    #####:  978:		discardCard(handPos, currentPlayer, state, 0);
    #####:  979:		return 0;
        -:  980:
        -:  981:	case minion:
        -:  982:		//+1 action
    #####:  983:		state->numActions++;
        -:  984:
        -:  985:		//discard card from hand
    #####:  986:		discardCard(handPos, currentPlayer, state, 0);
        -:  987:
    #####:  988:		if (choice1)		//+2 coins
        -:  989:		{
    #####:  990:			state->coins = state->coins + 2;
        -:  991:		}
        -:  992:
    #####:  993:		else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  994:		{
        -:  995:			//discard hand
    #####:  996:			while (numHandCards(state) > 0)
        -:  997:			{
    #####:  998:				discardCard(handPos, currentPlayer, state, 0);
        -:  999:			}
        -: 1000:
        -: 1001:			//draw 4
    #####: 1002:			for (i = 0; i < 4; i++)
        -: 1003:			{
    #####: 1004:				drawCard(currentPlayer, state);
        -: 1005:			}
        -: 1006:
        -: 1007:			//other players discard hand and redraw if hand size > 4
    #####: 1008:			for (i = 0; i < state->numPlayers; i++)
        -: 1009:			{
    #####: 1010:				if (i != currentPlayer)
        -: 1011:				{
    #####: 1012:					if (state->handCount[i] > 4)
        -: 1013:					{
        -: 1014:						//discard hand
    #####: 1015:						while (state->handCount[i] > 0)
        -: 1016:						{
    #####: 1017:							discardCard(handPos, i, state, 0);
        -: 1018:						}
        -: 1019:
        -: 1020:						//draw 4
    #####: 1021:						for (j = 0; j < 4; j++)
        -: 1022:						{
    #####: 1023:							drawCard(i, state);
        -: 1024:						}
        -: 1025:					}
        -: 1026:				}
        -: 1027:			}
        -: 1028:
        -: 1029:		}
    #####: 1030:		return 0;
        -: 1031:
        -: 1032:	case steward:
    #####: 1033:		if (choice1 == 1)
        -: 1034:		{
        -: 1035:			//+2 cards
    #####: 1036:			drawCard(currentPlayer, state);
    #####: 1037:			drawCard(currentPlayer, state);
        -: 1038:		}
    #####: 1039:		else if (choice1 == 2)
        -: 1040:		{
        -: 1041:			//+2 coins
    #####: 1042:			state->coins = state->coins + 2;
        -: 1043:		}
        -: 1044:		else
        -: 1045:		{
        -: 1046:			//trash 2 cards in hand
    #####: 1047:			discardCard(choice2, currentPlayer, state, 1);
    #####: 1048:			discardCard(choice3, currentPlayer, state, 1);
        -: 1049:		}
        -: 1050:
        -: 1051:		//discard card from hand
    #####: 1052:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1053:		return 0;
        -: 1054:
        -: 1055:	case tribute:
    #####: 1056:		if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####: 1057:			if (state->deckCount[nextPlayer] > 0){
    #####: 1058:				tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1059:				state->deckCount[nextPlayer]--;
        -: 1060:			}
    #####: 1061:			else if (state->discardCount[nextPlayer] > 0){
    #####: 1062:				tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer] - 1];
    #####: 1063:				state->discardCount[nextPlayer]--;
        -: 1064:			}
        -: 1065:			else{
        -: 1066:				//No Card to Reveal
        -: 1067:				if (DEBUG){
        -: 1068:					printf("No cards to reveal\n");
        -: 1069:				}
        -: 1070:			}
        -: 1071:		}
        -: 1072:
        -: 1073:		else{
    #####: 1074:			if (state->deckCount[nextPlayer] == 0){
    #####: 1075:				for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####: 1076:					state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1077:					state->deckCount[nextPlayer]++;
    #####: 1078:					state->discard[nextPlayer][i] = -1;
    #####: 1079:					state->discardCount[nextPlayer]--;
        -: 1080:				}
        -: 1081:
    #####: 1082:				shuffle(nextPlayer, state);//Shuffle the deck
        -: 1083:			}
    #####: 1084:			tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1085:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1086:			state->deckCount[nextPlayer]--;
    #####: 1087:			tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1088:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1089:			state->deckCount[nextPlayer]--;
        -: 1090:		}
        -: 1091:
    #####: 1092:		if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
    #####: 1093:			state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1094:			state->playedCardCount++;
    #####: 1095:			tributeRevealedCards[1] = -1;
        -: 1096:		}
        -: 1097:
    #####: 1098:		for (i = 0; i <= 2; i++){
    #####: 1099:			if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
    #####: 1100:				state->coins += 2;
        -: 1101:			}
        -: 1102:
    #####: 1103:			else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
    #####: 1104:				drawCard(currentPlayer, state);
    #####: 1105:				drawCard(currentPlayer, state);
        -: 1106:			}
        -: 1107:			else{//Action Card
    #####: 1108:				state->numActions = state->numActions + 2;
        -: 1109:			}
        -: 1110:		}
        -: 1111:
    #####: 1112:		return 0;
        -: 1113:
        -: 1114:	case ambassador:
    #####: 1115:		j = 0;		//used to check if player has enough cards to discard
        -: 1116:
    #####: 1117:		if (choice2 > 2 || choice2 < 0)
        -: 1118:		{
    #####: 1119:			return -1;
        -: 1120:		}
        -: 1121:
    #####: 1122:		if (choice1 == handPos)
        -: 1123:		{
    #####: 1124:			return -1;
        -: 1125:		}
        -: 1126:
    #####: 1127:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1128:		{
    #####: 1129:			if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1130:			{
    #####: 1131:				j++;
        -: 1132:			}
        -: 1133:		}
    #####: 1134:		if (j < choice2)
        -: 1135:		{
    #####: 1136:			return -1;
        -: 1137:		}
        -: 1138:
        -: 1139:		if (DEBUG)
        -: 1140:			printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1141:
        -: 1142:		//increase supply count for choosen card by amount being discarded
    #####: 1143:		state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1144:
        -: 1145:		//each other player gains a copy of revealed card
    #####: 1146:		for (i = 0; i < state->numPlayers; i++)
        -: 1147:		{
    #####: 1148:			if (i != currentPlayer)
        -: 1149:			{
    #####: 1150:				gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1151:			}
        -: 1152:		}
        -: 1153:
        -: 1154:		//discard played card from hand
    #####: 1155:		discardCard(handPos, currentPlayer, state, 0);
        -: 1156:
        -: 1157:		//trash copies of cards returned to supply
    #####: 1158:		for (j = 0; j < choice2; j++)
        -: 1159:		{
    #####: 1160:			for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1161:			{
    #####: 1162:				if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1163:				{
    #####: 1164:					discardCard(i, currentPlayer, state, 1);
    #####: 1165:					break;
        -: 1166:				}
        -: 1167:			}
        -: 1168:		}
        -: 1169:
    #####: 1170:		return 0;
        -: 1171:
        -: 1172:	case cutpurse:
        -: 1173:
    #####: 1174:		updateCoins(currentPlayer, state, 2);
    #####: 1175:		for (i = 0; i < state->numPlayers; i++)
        -: 1176:		{
    #####: 1177:			if (i != currentPlayer)
        -: 1178:			{
    #####: 1179:				for (j = 0; j < state->handCount[i]; j++)
        -: 1180:				{
    #####: 1181:					if (state->hand[i][j] == copper)
        -: 1182:					{
    #####: 1183:						discardCard(j, i, state, 0);
    #####: 1184:						break;
        -: 1185:					}
    #####: 1186:					if (j == state->handCount[i])
        -: 1187:					{
    #####: 1188:						for (k = 0; k < state->handCount[i]; k++)
        -: 1189:						{
        -: 1190:							if (DEBUG)
        -: 1191:								printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1192:						}
    #####: 1193:						break;
        -: 1194:					}
        -: 1195:				}
        -: 1196:
        -: 1197:			}
        -: 1198:
        -: 1199:		}
        -: 1200:
        -: 1201:		//discard played card from hand
    #####: 1202:		discardCard(handPos, currentPlayer, state, 0);
        -: 1203:
    #####: 1204:		return 0;
        -: 1205:
        -: 1206:
        -: 1207:	case embargo:
        -: 1208:		//+2 Coins
    #####: 1209:		state->coins = state->coins + 2;
        -: 1210:
        -: 1211:		//see if selected pile is in play
    #####: 1212:		if (state->supplyCount[choice1] == -1)
        -: 1213:		{
    #####: 1214:			return -1;
        -: 1215:		}
        -: 1216:
        -: 1217:		//add embargo token to selected supply pile
    #####: 1218:		state->embargoTokens[choice1]++;
        -: 1219:
        -: 1220:		//trash card
    #####: 1221:		discardCard(handPos, currentPlayer, state, 1);
    #####: 1222:		return 0;
        -: 1223:
        -: 1224:	case outpost:
        -: 1225:		//set outpost flag
    #####: 1226:		state->outpostPlayed++;
        -: 1227:
        -: 1228:		//discard card
    #####: 1229:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1230:		return 0;
        -: 1231:
        -: 1232:	case salvager:
        -: 1233:		//+1 buy
    #####: 1234:		state->numBuys++;
        -: 1235:
    #####: 1236:		if (choice1)
        -: 1237:		{
        -: 1238:			//gain coins equal to trashed card
    #####: 1239:			state->coins = state->coins + getCost(handCard(choice1, state));
        -: 1240:			//trash card
    #####: 1241:			discardCard(choice1, currentPlayer, state, 1);
        -: 1242:		}
        -: 1243:
        -: 1244:		//discard card
    #####: 1245:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1246:		return 0;
        -: 1247:
        -: 1248:	case sea_hag:
    #####: 1249:		for (i = 0; i < state->numPlayers; i++){
    #####: 1250:			if (i != currentPlayer){
    #####: 1251:				state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1252:				state->discardCount[i]++;
    #####: 1253:				state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1254:			}
        -: 1255:		}
    #####: 1256:		return 0;
        -: 1257:
        -: 1258:	case treasure_map:
        -: 1259:
    #####: 1260:		return playTreasureMap(state, currentPlayer, handPos);
        -: 1261:	}
    #####: 1262:	return -1;
        -: 1263:}
        -: 1264:
    #####: 1265:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1266:{
        -: 1267:
        -: 1268:	//if card is not trashed, added to Played pile 
    #####: 1269:	if (trashFlag < 1)
        -: 1270:	{
        -: 1271:		//add card to played pile
    #####: 1272:		state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
    #####: 1273:		state->playedCardCount++;
        -: 1274:	}
        -: 1275:
        -: 1276:	//set played card to -1
    #####: 1277:	state->hand[currentPlayer][handPos] = -1;
        -: 1278:
        -: 1279:	//remove card from player's hand
    #####: 1280:	if (handPos == (state->handCount[currentPlayer] - 1)) 	//last card in hand array is played
        -: 1281:	{
        -: 1282:		//reduce number of cards in hand
    #####: 1283:		state->handCount[currentPlayer]--;
        -: 1284:	}
    #####: 1285:	else if (state->handCount[currentPlayer] == 1) //only one card in hand
        -: 1286:	{
        -: 1287:		//reduce number of cards in hand
    #####: 1288:		state->handCount[currentPlayer]--;
        -: 1289:	}
        -: 1290:	else
        -: 1291:	{
        -: 1292:		//replace discarded card with last card in hand
    #####: 1293:		state->hand[currentPlayer][handPos] = state->hand[currentPlayer][(state->handCount[currentPlayer] - 1)];
        -: 1294:		//set last card to -1
    #####: 1295:		state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1296:		//reduce number of cards in hand
    #####: 1297:		state->handCount[currentPlayer]--;
        -: 1298:	}
        -: 1299:
    #####: 1300:	return 0;
        -: 1301:}
        -: 1302:
    #####: 1303:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1304:{
        -: 1305:	//Note: supplyPos is enum of choosen card
        -: 1306:
        -: 1307:	//check if supply pile is empty (0) or card is not used in game (-1)
    #####: 1308:	if (supplyCount(supplyPos, state) < 1)
        -: 1309:	{
    #####: 1310:		return -1;
        -: 1311:	}
        -: 1312:
        -: 1313:	//added card for [whoseTurn] current player:
        -: 1314:	// toFlag = 0 : add to discard
        -: 1315:	// toFlag = 1 : add to deck
        -: 1316:	// toFlag = 2 : add to hand
        -: 1317:
    #####: 1318:	if (toFlag == 1)
        -: 1319:	{
    #####: 1320:		state->deck[player][state->deckCount[player]] = supplyPos;
    #####: 1321:		state->deckCount[player]++;
        -: 1322:	}
    #####: 1323:	else if (toFlag == 2)
        -: 1324:	{
    #####: 1325:		state->hand[player][state->handCount[player]] = supplyPos;
    #####: 1326:		state->handCount[player]++;
        -: 1327:	}
        -: 1328:	else
        -: 1329:	{
    #####: 1330:		state->discard[player][state->discardCount[player]] = supplyPos;
    #####: 1331:		state->discardCount[player]++;
        -: 1332:	}
        -: 1333:
        -: 1334:	//decrease number in supply pile
    #####: 1335:	state->supplyCount[supplyPos]--;
        -: 1336:
    #####: 1337:	return 0;
        -: 1338:}
        -: 1339:
       12: 1340:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1341:{
        -: 1342:	int i;
        -: 1343:
        -: 1344:	//reset coin count
       12: 1345:	state->coins = 0;
        -: 1346:
        -: 1347:	//add coins for each Treasure card in player's hand
       62: 1348:	for (i = 0; i < state->handCount[player]; i++)
        -: 1349:	{
       50: 1350:		if (state->hand[player][i] == copper)
        -: 1351:		{
       39: 1352:			state->coins += 1;
        -: 1353:		}
       11: 1354:		else if (state->hand[player][i] == silver)
        -: 1355:		{
    #####: 1356:			state->coins += 2;
        -: 1357:		}
       11: 1358:		else if (state->hand[player][i] == gold)
        -: 1359:		{
    #####: 1360:			state->coins += 3;
        -: 1361:		}
        -: 1362:	}
        -: 1363:
        -: 1364:	//add bonus
       12: 1365:	state->coins += bonus;
        -: 1366:
       12: 1367:	return 0;
        -: 1368:}
        -: 1369:
        -: 1370:
        -: 1371://end of dominion.c
File 'dominion.c'
Lines executed:27.11% of 557
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
      462:    8:int compare(const void* a, const void* b) {
      462:    9:	if (*(int*)a > *(int*)b)
    #####:   10:		return 1;
      462:   11:	if (*(int*)a < *(int*)b)
      165:   12:		return -1;
      297:   13:	return 0;
        -:   14:}
        -:   15:
       20:   16:struct gameState* newGame() {
       20:   17:	struct gameState* g = malloc(sizeof(struct gameState));
       20:   18:	return g;
        -:   19:}
        -:   20:
      103:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:	int k8, int k9, int k10) {
      103:   23:	int* k = malloc(10 * sizeof(int));
      103:   24:	k[0] = k1;
      103:   25:	k[1] = k2;
      103:   26:	k[2] = k3;
      103:   27:	k[3] = k4;
      103:   28:	k[4] = k5;
      103:   29:	k[5] = k6;
      103:   30:	k[6] = k7;
      103:   31:	k[7] = k8;
      103:   32:	k[8] = k9;
      103:   33:	k[9] = k10;
      103:   34:	return k;
        -:   35:}
        -:   36:
      103:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		struct gameState *state) {
        -:   39:
        -:   40:	int i;
        -:   41:	int j;
        -:   42:	int it;
        -:   43:	//set up random number generator
      103:   44:	SelectStream(1);
      103:   45:	PutSeed((long)randomSeed);
        -:   46:
        -:   47:	//check number of players
      103:   48:	if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:	{
    #####:   50:		return -1;
        -:   51:	}
        -:   52:
        -:   53:	//set number of players
      103:   54:	state->numPlayers = numPlayers;
        -:   55:
        -:   56:	//check selected kingdom cards are different
      333:   57:	for (i = 0; i < 10; i++)
        -:   58:	{
     3145:   59:		for (j = 0; j < 10; j++)
        -:   60:		{
     2915:   61:			if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:			{
       93:   63:				return -1;
        -:   64:			}
        -:   65:		}
        -:   66:	}
        -:   67:
        -:   68:
        -:   69:	//initialize supply
        -:   70:	///////////////////////////////
        -:   71:
        -:   72:	//set number of Curse cards
       10:   73:	if (numPlayers == 2)
        -:   74:	{
        2:   75:		state->supplyCount[curse] = 10;
        -:   76:	}
        8:   77:	else if (numPlayers == 3)
        -:   78:	{
        3:   79:		state->supplyCount[curse] = 20;
        -:   80:	}
        -:   81:	else
        -:   82:	{
        5:   83:		state->supplyCount[curse] = 30;
        -:   84:	}
        -:   85:
        -:   86:	//set number of Victory cards
       10:   87:	if (numPlayers == 2)
        -:   88:	{
        2:   89:		state->supplyCount[estate] = 8;
        2:   90:		state->supplyCount[duchy] = 8;
        2:   91:		state->supplyCount[province] = 8;
        -:   92:	}
        -:   93:	else
        -:   94:	{
        8:   95:		state->supplyCount[estate] = 12;
        8:   96:		state->supplyCount[duchy] = 12;
        8:   97:		state->supplyCount[province] = 12;
        -:   98:	}
        -:   99:
        -:  100:	//set number of Treasure cards
       10:  101:	state->supplyCount[copper] = 60 - (7 * numPlayers);
       10:  102:	state->supplyCount[silver] = 40;
       10:  103:	state->supplyCount[gold] = 30;
        -:  104:
        -:  105:	//set number of Kingdom cards
      210:  106:	for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:	{
     1650:  108:		for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:		{
     1550:  110:			if (kingdomCards[j] == i)
        -:  111:			{
        -:  112:				//check if card is a 'Victory' Kingdom card
      100:  113:				if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:				{
       22:  115:					if (numPlayers == 2){
        2:  116:						state->supplyCount[i] = 8;
        -:  117:					}
        9:  118:					else{ state->supplyCount[i] = 12; }
        -:  119:				}
        -:  120:				else
        -:  121:				{
       89:  122:					state->supplyCount[i] = 10;
        -:  123:				}
      100:  124:				break;
        -:  125:			}
        -:  126:			else    //card is not in the set choosen for the game
        -:  127:			{
     1450:  128:				state->supplyCount[i] = -1;
        -:  129:			}
        -:  130:		}
        -:  131:
        -:  132:	}
        -:  133:
        -:  134:	////////////////////////
        -:  135:	//supply intilization complete
        -:  136:
        -:  137:	//set player decks
       43:  138:	for (i = 0; i < numPlayers; i++)
        -:  139:	{
       33:  140:		state->deckCount[i] = 0;
      132:  141:		for (j = 0; j < 3; j++)
        -:  142:		{
       99:  143:			state->deck[i][j] = estate;
       99:  144:			state->deckCount[i]++;
        -:  145:		}
      264:  146:		for (j = 3; j < 10; j++)
        -:  147:		{
      231:  148:			state->deck[i][j] = copper;
      231:  149:			state->deckCount[i]++;
        -:  150:		}
        -:  151:	}
        -:  152:
        -:  153:	//shuffle player decks
       43:  154:	for (i = 0; i < numPlayers; i++)
        -:  155:	{
       33:  156:		if (shuffle(i, state) < 0)
        -:  157:		{
    #####:  158:			return -1;
        -:  159:		}
        -:  160:	}
        -:  161:
        -:  162:	//draw player hands
       43:  163:	for (i = 0; i < numPlayers; i++)
        -:  164:	{
        -:  165:		//initialize hand size to zero
       33:  166:		state->handCount[i] = 0;
       33:  167:		state->discardCount[i] = 0;
        -:  168:		//draw 5 cards
        -:  169:		// for (j = 0; j < 5; j++)
        -:  170:		//	{
        -:  171:		//	  drawCard(i, state);
        -:  172:		//	}
        -:  173:	}
        -:  174:
        -:  175:	//set embargo tokens to 0 for all supply piles
      280:  176:	for (i = 0; i <= treasure_map; i++)
        -:  177:	{
      270:  178:		state->embargoTokens[i] = 0;
        -:  179:	}
        -:  180:
        -:  181:	//initialize first player's turn
       10:  182:	state->outpostPlayed = 0;
       10:  183:	state->phase = 0;
       10:  184:	state->numActions = 1;
       10:  185:	state->numBuys = 1;
       10:  186:	state->playedCardCount = 0;
       10:  187:	state->whoseTurn = 0;
       10:  188:	state->handCount[state->whoseTurn] = 0;
        -:  189:	//int it; move to top
        -:  190:
        -:  191:	//Moved draw cards to here, only drawing at the start of a turn
       60:  192:	for (it = 0; it < 5; it++){
       50:  193:		drawCard(state->whoseTurn, state);
        -:  194:	}
        -:  195:
       10:  196:	updateCoins(state->whoseTurn, state, 0);
        -:  197:
       10:  198:	return 0;
        -:  199:}
        -:  200:
       48:  201:int shuffle(int player, struct gameState *state) {
        -:  202:
        -:  203:
        -:  204:	int newDeck[MAX_DECK];
       48:  205:	int newDeckPos = 0;
        -:  206:	int card;
        -:  207:	int i;
        -:  208:
       48:  209:	if (state->deckCount[player] < 1)
       15:  210:		return -1;
       33:  211:	qsort((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
        -:  212:	/* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
      396:  214:	while (state->deckCount[player] > 0) {
      330:  215:		card = floor(Random() * state->deckCount[player]);
      330:  216:		newDeck[newDeckPos] = state->deck[player][card];
      330:  217:		newDeckPos++;
     1031:  218:		for (i = card; i < state->deckCount[player] - 1; i++) {
      701:  219:			state->deck[player][i] = state->deck[player][i + 1];
        -:  220:		}
      330:  221:		state->deckCount[player]--;
        -:  222:	}
      363:  223:	for (i = 0; i < newDeckPos; i++) {
      330:  224:		state->deck[player][i] = newDeck[i];
      330:  225:		state->deckCount[player]++;
        -:  226:	}
        -:  227:
       33:  228:	return 0;
        -:  229:}
        -:  230:
        2:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state)
        -:  232:{
        -:  233:	int card;
        2:  234:	int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:	//check if it is the right phase
        2:  237:	if (state->phase != 0)
        -:  238:	{
    #####:  239:		return -1;
        -:  240:	}
        -:  241:
        -:  242:	//check if player has enough actions
        2:  243:	if (state->numActions < 1)
        -:  244:	{
        2:  245:		return -1;
        -:  246:	}
        -:  247:
        -:  248:	//get card played
    #####:  249:	card = handCard(handPos, state);
        -:  250:
        -:  251:	//check if selected card is an action
    #####:  252:	if (card < adventurer || card > treasure_map)
        -:  253:	{
    #####:  254:		return -1;
        -:  255:	}
        -:  256:
        -:  257:	//play card
    #####:  258:	if (cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0)
        -:  259:	{
    #####:  260:		return -1;
        -:  261:	}
        -:  262:
        -:  263:	//reduce number of actions
    #####:  264:	state->numActions--;
        -:  265:
        -:  266:	//update coins (Treasure cards may be added with card draws)
    #####:  267:	updateCoins(state->whoseTurn, state, coin_bonus);
        -:  268:
    #####:  269:	return 0;
        -:  270:}
        -:  271:
        5:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:	int who;
        -:  274:	if (DEBUG){
        -:  275:		printf("Entering buyCard...\n");
        -:  276:	}
        -:  277:
        -:  278:	// I don't know what to do about the phase thing.
        -:  279:
        5:  280:	who = state->whoseTurn;
        -:  281:
        5:  282:	if (state->numBuys < 1){
        -:  283:		if (DEBUG)
        -:  284:			printf("You do not have any buys left\n");
        5:  285:		return -1;
        -:  286:	}
    #####:  287:	else if (supplyCount(supplyPos, state) < 1){
        -:  288:		if (DEBUG)
        -:  289:			printf("There are not any of that type of card left\n");
    #####:  290:		return -1;
        -:  291:	}
    #####:  292:	else if (state->coins < getCost(supplyPos)){
        -:  293:		if (DEBUG)
        -:  294:			printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  295:		return -1;
        -:  296:	}
        -:  297:	else {
    #####:  298:		state->phase = 1;
        -:  299:		//state->supplyCount[supplyPos]--;
    #####:  300:		gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  301:
    #####:  302:		state->coins = (state->coins) - (getCost(supplyPos));
    #####:  303:		state->numBuys--;
        -:  304:		if (DEBUG)
        -:  305:			printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  306:	}
        -:  307:
        -:  308:	//state->discard[who][state->discardCount[who]] = supplyPos;
        -:  309:	//state->discardCount[who]++;
        -:  310:
    #####:  311:	return 0;
        -:  312:}
        -:  313:
    #####:  314:int numHandCards(struct gameState *state) {
    #####:  315:	return state->handCount[whoseTurn(state)];
        -:  316:}
        -:  317:
    #####:  318:int handCard(int handPos, struct gameState *state) {
    #####:  319:	int currentPlayer = whoseTurn(state);
    #####:  320:	return state->hand[currentPlayer][handPos];
        -:  321:}
        -:  322:
    #####:  323:int supplyCount(int card, struct gameState *state) {
    #####:  324:	return state->supplyCount[card];
        -:  325:}
        -:  326:
    #####:  327:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  328:	int i;
    #####:  329:	int count = 0;
        -:  330:
    #####:  331:	for (i = 0; i < state->deckCount[player]; i++)
        -:  332:	{
    #####:  333:		if (state->deck[player][i] == card) count++;
        -:  334:	}
        -:  335:
    #####:  336:	for (i = 0; i < state->handCount[player]; i++)
        -:  337:	{
    #####:  338:		if (state->hand[player][i] == card) count++;
        -:  339:	}
        -:  340:
    #####:  341:	for (i = 0; i < state->discardCount[player]; i++)
        -:  342:	{
    #####:  343:		if (state->discard[player][i] == card) count++;
        -:  344:	}
        -:  345:
    #####:  346:	return count;
        -:  347:}
        -:  348:
        3:  349:int whoseTurn(struct gameState *state) {
        3:  350:	return state->whoseTurn;
        -:  351:}
        -:  352:
        3:  353:int endTurn(struct gameState *state) {
        -:  354:	int k;
        -:  355:	int i;
        3:  356:	int currentPlayer = whoseTurn(state);
        -:  357:
        -:  358:	//Discard hand
        3:  359:	for (i = 0; i < state->handCount[currentPlayer]; i++){
    #####:  360:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  361:		state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  362:	}
        3:  363:	state->handCount[currentPlayer] = 0;//Reset hand count
        -:  364:
        -:  365:	//Code for determining the player
        3:  366:	if (currentPlayer < (state->numPlayers - 1)){
    #####:  367:		state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  368:	}
        -:  369:	else{
        3:  370:		state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  371:	}
        -:  372:
        3:  373:	state->outpostPlayed = 0;
        3:  374:	state->phase = 0;
        3:  375:	state->numActions = 1;
        3:  376:	state->coins = 0;
        3:  377:	state->numBuys = 1;
        3:  378:	state->playedCardCount = 0;
        3:  379:	state->handCount[state->whoseTurn] = 0;
        -:  380:
        -:  381:	//int k; move to top
        -:  382:	//Next player draws hand
       18:  383:	for (k = 0; k < 5; k++){
       15:  384:		drawCard(state->whoseTurn, state);//Draw a card
        -:  385:	}
        -:  386:
        -:  387:	//Update money
        3:  388:	updateCoins(state->whoseTurn, state, 0);
        -:  389:
        3:  390:	return 0;
        -:  391:}
        -:  392:
    #####:  393:int isGameOver(struct gameState *state) {
        -:  394:	int i;
        -:  395:	int j;
        -:  396:
        -:  397:	//if stack of Province cards is empty, the game ends
    #####:  398:	if (state->supplyCount[province] == 0)
        -:  399:	{
    #####:  400:		return 1;
        -:  401:	}
        -:  402:
        -:  403:	//if three supply pile are at 0, the game ends
    #####:  404:	j = 0;
    #####:  405:	for (i = 0; i < 25; i++)
        -:  406:	{
    #####:  407:		if (state->supplyCount[i] == 0)
        -:  408:		{
    #####:  409:			j++;
        -:  410:		}
        -:  411:	}
    #####:  412:	if (j >= 3)
        -:  413:	{
    #####:  414:		return 1;
        -:  415:	}
        -:  416:
    #####:  417:	return 0;
        -:  418:}
        -:  419:
    #####:  420:int scoreFor(int player, struct gameState *state) {
        -:  421:
        -:  422:	int i;
    #####:  423:	int score = 0;
        -:  424:	//score from hand
    #####:  425:	for (i = 0; i < state->handCount[player]; i++)
        -:  426:	{
    #####:  427:		if (state->hand[player][i] == curse) { score = score - 1; };
    #####:  428:		if (state->hand[player][i] == estate) { score = score + 1; };
    #####:  429:		if (state->hand[player][i] == duchy) { score = score + 3; };
    #####:  430:		if (state->hand[player][i] == province) { score = score + 6; };
    #####:  431:		if (state->hand[player][i] == great_hall) { score = score + 1; };
    #####:  432:		if (state->hand[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  433:	}
        -:  434:
        -:  435:	//score from discard
    #####:  436:	for (i = 0; i < state->discardCount[player]; i++)
        -:  437:	{
    #####:  438:		if (state->discard[player][i] == curse) { score = score - 1; };
    #####:  439:		if (state->discard[player][i] == estate) { score = score + 1; };
    #####:  440:		if (state->discard[player][i] == duchy) { score = score + 3; };
    #####:  441:		if (state->discard[player][i] == province) { score = score + 6; };
    #####:  442:		if (state->discard[player][i] == great_hall) { score = score + 1; };
    #####:  443:		if (state->discard[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  444:	}
        -:  445:
        -:  446:	//score from deck
    #####:  447:	for (i = 0; i < state->discardCount[player]; i++)
        -:  448:	{
    #####:  449:		if (state->deck[player][i] == curse) { score = score - 1; };
    #####:  450:		if (state->deck[player][i] == estate) { score = score + 1; };
    #####:  451:		if (state->deck[player][i] == duchy) { score = score + 3; };
    #####:  452:		if (state->deck[player][i] == province) { score = score + 6; };
    #####:  453:		if (state->deck[player][i] == great_hall) { score = score + 1; };
    #####:  454:		if (state->deck[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  455:	}
        -:  456:
    #####:  457:	return score;
        -:  458:}
        -:  459:
    #####:  460:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  461:	int i;
        -:  462:	int j;
        -:  463:	int highScore;
        -:  464:	int currentPlayer;
        -:  465:
        -:  466:	//get score for each player
    #####:  467:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  468:	{
        -:  469:		//set unused player scores to -9999
    #####:  470:		if (i >= state->numPlayers)
        -:  471:		{
    #####:  472:			players[i] = -9999;
        -:  473:		}
        -:  474:		else
        -:  475:		{
    #####:  476:			players[i] = scoreFor(i, state);
        -:  477:		}
        -:  478:	}
        -:  479:
        -:  480:	//find highest score
    #####:  481:	j = 0;
    #####:  482:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  483:	{
    #####:  484:		if (players[i] > players[j])
        -:  485:		{
    #####:  486:			j = i;
        -:  487:		}
        -:  488:	}
    #####:  489:	highScore = players[j];
        -:  490:
        -:  491:	//add 1 to players who had less turns
    #####:  492:	currentPlayer = whoseTurn(state);
    #####:  493:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  494:	{
    #####:  495:		if (players[i] == highScore && i > currentPlayer)
        -:  496:		{
    #####:  497:			players[i]++;
        -:  498:		}
        -:  499:	}
        -:  500:
        -:  501:	//find new highest score
    #####:  502:	j = 0;
    #####:  503:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  504:	{
    #####:  505:		if (players[i] > players[j])
        -:  506:		{
    #####:  507:			j = i;
        -:  508:		}
        -:  509:	}
    #####:  510:	highScore = players[j];
        -:  511:
        -:  512:	//set winners in array to 1 and rest to 0
    #####:  513:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  514:	{
    #####:  515:		if (players[i] == highScore)
        -:  516:		{
    #####:  517:			players[i] = 1;
        -:  518:		}
        -:  519:		else
        -:  520:		{
    #####:  521:			players[i] = 0;
        -:  522:		}
        -:  523:	}
        -:  524:
    #####:  525:	return 0;
        -:  526:}
        -:  527:
       65:  528:int drawCard(int player, struct gameState *state)
        -:  529:{
        -:  530:	int count;
        -:  531:	int deckCounter;
       65:  532:	if (state->deckCount[player] <= 0){//Deck is empty
        -:  533:
        -:  534:		//Step 1 Shuffle the discard pile back into a deck
        -:  535:		int i;
        -:  536:		//Move discard to deck
       15:  537:		for (i = 0; i < state->discardCount[player]; i++){
    #####:  538:			state->deck[player][i] = state->discard[player][i];
    #####:  539:			state->discard[player][i] = -1;
        -:  540:		}
        -:  541:
       15:  542:		state->deckCount[player] = state->discardCount[player];
       15:  543:		state->discardCount[player] = 0;//Reset discard
        -:  544:
        -:  545:		//Shufffle the deck
       15:  546:		shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  547:
        -:  548:		if (DEBUG){//Debug statements
        -:  549:			printf("Deck count now: %d\n", state->deckCount[player]);
        -:  550:		}
        -:  551:
       15:  552:		state->discardCount[player] = 0;
        -:  553:
        -:  554:		//Step 2 Draw Card
       15:  555:		count = state->handCount[player];//Get current player's hand count
        -:  556:
        -:  557:		if (DEBUG){//Debug statements
        -:  558:			printf("Current hand count: %d\n", count);
        -:  559:		}
        -:  560:
       15:  561:		deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  562:
       15:  563:		if (deckCounter == 0)
       15:  564:			return -1;
        -:  565:
    #####:  566:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
    #####:  567:		state->deckCount[player]--;
    #####:  568:		state->handCount[player]++;//Increment hand count
        -:  569:	}
        -:  570:
        -:  571:	else{
       50:  572:		int count = state->handCount[player];//Get current hand count for player
        -:  573:		int deckCounter;
        -:  574:		if (DEBUG){//Debug statements
        -:  575:			printf("Current hand count: %d\n", count);
        -:  576:		}
        -:  577:
       50:  578:		deckCounter = state->deckCount[player];//Create holder for the deck count
       50:  579:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
       50:  580:		state->deckCount[player]--;
       50:  581:		state->handCount[player]++;//Increment hand count
        -:  582:	}
        -:  583:
       50:  584:	return 0;
        -:  585:}
        -:  586:
    #####:  587:int getCost(int cardNumber)
        -:  588:{
    #####:  589:	switch (cardNumber)
        -:  590:	{
        -:  591:	case curse:
    #####:  592:		return 0;
        -:  593:	case estate:
    #####:  594:		return 2;
        -:  595:	case duchy:
    #####:  596:		return 5;
        -:  597:	case province:
    #####:  598:		return 8;
        -:  599:	case copper:
    #####:  600:		return 0;
        -:  601:	case silver:
    #####:  602:		return 3;
        -:  603:	case gold:
    #####:  604:		return 6;
        -:  605:	case adventurer:
    #####:  606:		return 6;
        -:  607:	case council_room:
    #####:  608:		return 5;
        -:  609:	case feast:
    #####:  610:		return 4;
        -:  611:	case gardens:
    #####:  612:		return 4;
        -:  613:	case mine:
    #####:  614:		return 5;
        -:  615:	case remodel:
    #####:  616:		return 4;
        -:  617:	case smithy:
    #####:  618:		return 4;
        -:  619:	case village:
    #####:  620:		return 3;
        -:  621:	case baron:
    #####:  622:		return 4;
        -:  623:	case great_hall:
    #####:  624:		return 3;
        -:  625:	case minion:
    #####:  626:		return 5;
        -:  627:	case steward:
    #####:  628:		return 3;
        -:  629:	case tribute:
    #####:  630:		return 5;
        -:  631:	case ambassador:
    #####:  632:		return 3;
        -:  633:	case cutpurse:
    #####:  634:		return 4;
        -:  635:	case embargo:
    #####:  636:		return 2;
        -:  637:	case outpost:
    #####:  638:		return 5;
        -:  639:	case salvager:
    #####:  640:		return 4;
        -:  641:	case sea_hag:
    #####:  642:		return 4;
        -:  643:	case treasure_map:
    #####:  644:		return 4;
        -:  645:	}
        -:  646:
    #####:  647:	return -1;
        -:  648:}
        -:  649:
    #####:  650:void playAdventurer(struct gameState *state, int currentPlayer)
        -:  651:// Reveal cards from deck until 2 Treasure cards are found.  Put those Treasure cards in the hand and discard the rest.
        -:  652:{
    #####:  653:	int drawntreasure = 0;
        -:  654:	int temphand[MAX_HAND];
        -:  655:	int cardDrawn;
    #####:  656:	int z = 0; // this is the counter for the temp hand
        -:  657:
    #####:  658:	while (drawntreasure < 2){
    #####:  659:		if (state->deckCount[currentPlayer] < 1){//if the deck is empty we need to shuffle discard and add to deck
    #####:  660:			shuffle(currentPlayer, state);
        -:  661:		}
    #####:  662:		drawCard(currentPlayer, state);
    #####:  663:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer] - 1];//top card of hand is most recently drawn card.
    #####:  664:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
    #####:  665:			drawntreasure++;
        -:  666:		else{
    #####:  667:			temphand[z] = cardDrawn;
    #####:  668:			state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####:  669:			z++;
        -:  670:		}
        -:  671:	}
    #####:  672:	while (z - 1 >= 0){
    #####:  673:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; // discard all cards in play that have been drawn
    #####:  674:		z = z - 1;
        -:  675:	}
    #####:  676:}
        -:  677:
    #####:  678:int playRemodel(struct gameState *state, int currentPlayer, int choice1, int choice2, int handPos)
        -:  679://Trash a card in the hand, and gain a card costing up to $2 more than the trashed card
        -:  680:{
        -:  681:	int i;
    #####:  682:	int j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  683:
    #####:  684:	if ((getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2))
        -:  685:	{
    #####:  686:		return -1;
        -:  687:	}
        -:  688:
    #####:  689:	gainCard(choice2, state, 0, currentPlayer);
        -:  690:
        -:  691:	//discard card from hand
    #####:  692:	discardCard(handPos, currentPlayer, state, 0);
        -:  693:
        -:  694:	//discard trashed card
    #####:  695:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  696:	{
    #####:  697:		if (state->hand[currentPlayer][i] == j)
        -:  698:		{
    #####:  699:			discardCard(i, currentPlayer, state, 0);
    #####:  700:			break;
        -:  701:		}
        -:  702:	}
        -:  703:
    #####:  704:	return 0;
        -:  705:}
        -:  706:
    #####:  707:void playSmithy(struct gameState *state, int currentPlayer, int handPos)
        -:  708:// Draw 3 cards
        -:  709:{
        -:  710:	int i;
    #####:  711:	for (i = 0; i < 3; i++)
        -:  712:	{
    #####:  713:		drawCard(currentPlayer, state);
        -:  714:	}
        -:  715:
        -:  716:	//discard card from hand
    #####:  717:	discardCard(handPos, currentPlayer, state, 0);
    #####:  718:}
        -:  719:
    #####:  720:void playBaron(struct gameState *state, int currentPlayer, int choice1, int handPos)
        -:  721://Add a buy.  OPTION:  Discard an Estate card and gain $4.  Otherwise, gain an Estate card.
        -:  722:{
    #####:  723:	state->numBuys++;//Increase buys by 1!
    #####:  724:	if (choice1 > 0){//Boolean true or going to discard an estate
    #####:  725:		int p = 0;//Iterator for hand!
    #####:  726:		int card_not_discarded = 1;//Flag for discard set!
    #####:  727:		while (card_not_discarded){
    #####:  728:			if (state->hand[currentPlayer][p] == estate){ //Found an estate card!
    #####:  729:				state->coins += 4;//Add 4 coins to the amount of coins
    #####:  730:				state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  731:				state->discardCount[currentPlayer]++;
    #####:  732:				for (; p < state->handCount[currentPlayer]; p++){
    #####:  733:					state->hand[currentPlayer][p] = state->hand[currentPlayer][p + 1];
        -:  734:				}
    #####:  735:				state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  736:				state->handCount[currentPlayer]--;
    #####:  737:				card_not_discarded = 0;//Exit the loop
        -:  738:			}
    #####:  739:			else if (p > state->handCount[currentPlayer]){
        -:  740:				if (DEBUG) {
        -:  741:					printf("No estate cards in your hand, invalid choice\n");
        -:  742:					printf("Must gain an estate if there are any\n");
        -:  743:				}
    #####:  744:				if (supplyCount(estate, state) > 0){
    #####:  745:					gainCard(estate, state, 1, currentPlayer);
    #####:  746:					state->supplyCount[estate]--;//Decrement estates
    #####:  747:					if (supplyCount(estate, state) == 0){
    #####:  748:						isGameOver(state);
        -:  749:					}
        -:  750:				}
    #####:  751:				card_not_discarded = 0;//Exit the loop
        -:  752:			}
        -:  753:
        -:  754:			else{
    #####:  755:				p++;//Next card
        -:  756:			}
        -:  757:		}
        -:  758:	}
        -:  759:
        -:  760:	else{
    #####:  761:		if (supplyCount(estate, state) > 0){
    #####:  762:			gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  763:			state->supplyCount[estate]--;//Decrement Estates
    #####:  764:			if (supplyCount(estate, state) == 0){
    #####:  765:				isGameOver(state);
        -:  766:			}
        -:  767:		}
        -:  768:	}
    #####:  769:}
        -:  770:
    #####:  771:int playTreasureMap(struct gameState *state, int currentPlayer, int handPos)
        -:  772://Trashing two treasure map cards from the hand = four gold on top of the deck.
        -:  773:{
        -:  774:	int i;
        -:  775:	int index;
        -:  776:
        -:  777:	//search hand for another treasure_map
    #####:  778:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  779:	{
    #####:  780:		if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -:  781:		{
    #####:  782:			index = i;
    #####:  783:			break;
        -:  784:		}
        -:  785:	}
    #####:  786:	if (index > -1)
        -:  787:	{
        -:  788:		//trash both treasure cards
    #####:  789:		discardCard(handPos, currentPlayer, state, 1);
    #####:  790:		discardCard(index, currentPlayer, state, 1);
        -:  791:
        -:  792:		//gain 4 Gold cards
    #####:  793:		for (i = 0; i < 4; i++)
        -:  794:		{
    #####:  795:			gainCard(gold, state, 1, currentPlayer);
        -:  796:		}
        -:  797:
        -:  798:		//return success
    #####:  799:		return 1;
        -:  800:	}
        -:  801:
        -:  802:	//no second treasure_map found in hand
    #####:  803:	return -1;
        -:  804:}
        -:  805:
    #####:  806:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  807:{
        -:  808:	int i;
        -:  809:	int j;
        -:  810:	int k;
        -:  811:	//int x;  //Unused after while loop removed from feast.
    #####:  812:	int currentPlayer = whoseTurn(state);
    #####:  813:	int nextPlayer = currentPlayer + 1;
        -:  814:	int temphand[MAX_HAND];
        -:  815:
    #####:  816:	int tributeRevealedCards[2] = { -1, -1 };
        -:  817:
    #####:  818:	if (nextPlayer > (state->numPlayers - 1)){
    #####:  819:		nextPlayer = 0;
        -:  820:	}
        -:  821:
        -:  822:	//uses switch to select card and perform actions
    #####:  823:	switch (card)
        -:  824:	{
        -:  825:	case adventurer:
        -:  826:
    #####:  827:		playAdventurer(state, currentPlayer);
    #####:  828:		return 0;
        -:  829:
        -:  830:	case council_room:
        -:  831:		//+4 Cards
    #####:  832:		for (i = 0; i < 4; i++)
        -:  833:		{
    #####:  834:			drawCard(currentPlayer, state);
        -:  835:		}
        -:  836:
        -:  837:		//+1 Buy
    #####:  838:		state->numBuys++;
        -:  839:
        -:  840:		//Each other player draws a card
    #####:  841:		for (i = 0; i < state->numPlayers; i++)
        -:  842:		{
    #####:  843:			if (i != currentPlayer)
        -:  844:			{
    #####:  845:				drawCard(i, state);
        -:  846:			}
        -:  847:		}
        -:  848:
        -:  849:		//put played card in played card pile
    #####:  850:		discardCard(handPos, currentPlayer, state, 0);
        -:  851:
    #####:  852:		return 0;
        -:  853:
        -:  854:	case feast:
        -:  855:		//gain card with cost up to 5
        -:  856:		//Backup hand
    #####:  857:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  858:			temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  859:			state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  860:		}
        -:  861:		//Backup hand
        -:  862:
        -:  863:		//Update Coins for Buy
    #####:  864:		updateCoins(currentPlayer, state, 5);
        -:  865://		x = 1;//Condition to loop on
        -:  866://		while (x == 1) {//Buy one card
    #####:  867:			if (supplyCount(choice1, state) <= 0){
        -:  868:				if (DEBUG)
        -:  869:					printf("None of that card left, sorry!\n");
        -:  870:
        -:  871:				if (DEBUG){
        -:  872:					printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  873:				}
        -:  874:			}
    #####:  875:			else if (state->coins < getCost(choice1)){
    #####:  876:				printf("That card is too expensive!\n");
        -:  877:
        -:  878:				if (DEBUG){
        -:  879:					printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  880:				}
        -:  881:			}
        -:  882:			else{
        -:  883:
        -:  884:				if (DEBUG){
        -:  885:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  886:				}
        -:  887:
    #####:  888:				gainCard(choice1, state, 0, currentPlayer);//Gain the card
        -:  889://				x = 0;//No more buying cards
        -:  890:
        -:  891:				if (DEBUG){
        -:  892:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  893:				}
        -:  894:
        -:  895:			}
        -:  896://		}
        -:  897:
        -:  898:		//Reset Hand
    #####:  899:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  900:			state->hand[currentPlayer][i] = temphand[i];
    #####:  901:			temphand[i] = -1;
        -:  902:		}
        -:  903:		//Reset Hand
        -:  904:
    #####:  905:		return 0;
        -:  906:
        -:  907:	case gardens:
    #####:  908:		return -1;
        -:  909:
        -:  910:	case mine:
    #####:  911:		j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  912:
    #####:  913:		if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  914:		{
    #####:  915:			return -1;
        -:  916:		}
        -:  917:
    #####:  918:		if (choice2 > treasure_map || choice2 < curse)
        -:  919:		{
    #####:  920:			return -1;
        -:  921:		}
        -:  922:
    #####:  923:		if ((getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2))
        -:  924:		{
    #####:  925:			return -1;
        -:  926:		}
        -:  927:
    #####:  928:		gainCard(choice2, state, 2, currentPlayer);
        -:  929:
        -:  930:		//discard card from hand
    #####:  931:		discardCard(handPos, currentPlayer, state, 0);
        -:  932:
        -:  933:		//discard trashed card
    #####:  934:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  935:		{
    #####:  936:			if (state->hand[currentPlayer][i] == j)
        -:  937:			{
    #####:  938:				discardCard(i, currentPlayer, state, 0);
    #####:  939:				break;
        -:  940:			}
        -:  941:		}
        -:  942:
    #####:  943:		return 0;
        -:  944:
        -:  945:	case remodel:
        -:  946:
    #####:  947:		return playRemodel(state, currentPlayer, choice1, choice2, handPos);
        -:  948:
        -:  949:	case smithy:
        -:  950:
    #####:  951:		playSmithy(state, currentPlayer, handPos);
    #####:  952:		return 0;
        -:  953:
        -:  954:	case village:
        -:  955:		//+1 Card
    #####:  956:		drawCard(currentPlayer, state);
        -:  957:
        -:  958:		//+2 Actions
    #####:  959:		state->numActions = state->numActions + 2;
        -:  960:
        -:  961:		//discard played card from hand
    #####:  962:		discardCard(handPos, currentPlayer, state, 0);
    #####:  963:		return 0;
        -:  964:
        -:  965:	case baron:
        -:  966:
    #####:  967:		playBaron(state, currentPlayer, choice1, handPos);
    #####:  968:		return 0;
        -:  969:
        -:  970:	case great_hall:
        -:  971:		//+1 Card
    #####:  972:		drawCard(currentPlayer, state);
        -:  973:
        -:  974:		//+1 Actions
    #####:  975:		state->numActions++;
        -:  976:
        -:  977:		//discard card from hand
    #####:  978:		discardCard(handPos, currentPlayer, state, 0);
    #####:  979:		return 0;
        -:  980:
        -:  981:	case minion:
        -:  982:		//+1 action
    #####:  983:		state->numActions++;
        -:  984:
        -:  985:		//discard card from hand
    #####:  986:		discardCard(handPos, currentPlayer, state, 0);
        -:  987:
    #####:  988:		if (choice1)		//+2 coins
        -:  989:		{
    #####:  990:			state->coins = state->coins + 2;
        -:  991:		}
        -:  992:
    #####:  993:		else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  994:		{
        -:  995:			//discard hand
    #####:  996:			while (numHandCards(state) > 0)
        -:  997:			{
    #####:  998:				discardCard(handPos, currentPlayer, state, 0);
        -:  999:			}
        -: 1000:
        -: 1001:			//draw 4
    #####: 1002:			for (i = 0; i < 4; i++)
        -: 1003:			{
    #####: 1004:				drawCard(currentPlayer, state);
        -: 1005:			}
        -: 1006:
        -: 1007:			//other players discard hand and redraw if hand size > 4
    #####: 1008:			for (i = 0; i < state->numPlayers; i++)
        -: 1009:			{
    #####: 1010:				if (i != currentPlayer)
        -: 1011:				{
    #####: 1012:					if (state->handCount[i] > 4)
        -: 1013:					{
        -: 1014:						//discard hand
    #####: 1015:						while (state->handCount[i] > 0)
        -: 1016:						{
    #####: 1017:							discardCard(handPos, i, state, 0);
        -: 1018:						}
        -: 1019:
        -: 1020:						//draw 4
    #####: 1021:						for (j = 0; j < 4; j++)
        -: 1022:						{
    #####: 1023:							drawCard(i, state);
        -: 1024:						}
        -: 1025:					}
        -: 1026:				}
        -: 1027:			}
        -: 1028:
        -: 1029:		}
    #####: 1030:		return 0;
        -: 1031:
        -: 1032:	case steward:
    #####: 1033:		if (choice1 == 1)
        -: 1034:		{
        -: 1035:			//+2 cards
    #####: 1036:			drawCard(currentPlayer, state);
    #####: 1037:			drawCard(currentPlayer, state);
        -: 1038:		}
    #####: 1039:		else if (choice1 == 2)
        -: 1040:		{
        -: 1041:			//+2 coins
    #####: 1042:			state->coins = state->coins + 2;
        -: 1043:		}
        -: 1044:		else
        -: 1045:		{
        -: 1046:			//trash 2 cards in hand
    #####: 1047:			discardCard(choice2, currentPlayer, state, 1);
    #####: 1048:			discardCard(choice3, currentPlayer, state, 1);
        -: 1049:		}
        -: 1050:
        -: 1051:		//discard card from hand
    #####: 1052:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1053:		return 0;
        -: 1054:
        -: 1055:	case tribute:
    #####: 1056:		if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####: 1057:			if (state->deckCount[nextPlayer] > 0){
    #####: 1058:				tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1059:				state->deckCount[nextPlayer]--;
        -: 1060:			}
    #####: 1061:			else if (state->discardCount[nextPlayer] > 0){
    #####: 1062:				tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer] - 1];
    #####: 1063:				state->discardCount[nextPlayer]--;
        -: 1064:			}
        -: 1065:			else{
        -: 1066:				//No Card to Reveal
        -: 1067:				if (DEBUG){
        -: 1068:					printf("No cards to reveal\n");
        -: 1069:				}
        -: 1070:			}
        -: 1071:		}
        -: 1072:
        -: 1073:		else{
    #####: 1074:			if (state->deckCount[nextPlayer] == 0){
    #####: 1075:				for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####: 1076:					state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1077:					state->deckCount[nextPlayer]++;
    #####: 1078:					state->discard[nextPlayer][i] = -1;
    #####: 1079:					state->discardCount[nextPlayer]--;
        -: 1080:				}
        -: 1081:
    #####: 1082:				shuffle(nextPlayer, state);//Shuffle the deck
        -: 1083:			}
    #####: 1084:			tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1085:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1086:			state->deckCount[nextPlayer]--;
    #####: 1087:			tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1088:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1089:			state->deckCount[nextPlayer]--;
        -: 1090:		}
        -: 1091:
    #####: 1092:		if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
    #####: 1093:			state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1094:			state->playedCardCount++;
    #####: 1095:			tributeRevealedCards[1] = -1;
        -: 1096:		}
        -: 1097:
    #####: 1098:		for (i = 0; i <= 2; i++){
    #####: 1099:			if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
    #####: 1100:				state->coins += 2;
        -: 1101:			}
        -: 1102:
    #####: 1103:			else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
    #####: 1104:				drawCard(currentPlayer, state);
    #####: 1105:				drawCard(currentPlayer, state);
        -: 1106:			}
        -: 1107:			else{//Action Card
    #####: 1108:				state->numActions = state->numActions + 2;
        -: 1109:			}
        -: 1110:		}
        -: 1111:
    #####: 1112:		return 0;
        -: 1113:
        -: 1114:	case ambassador:
    #####: 1115:		j = 0;		//used to check if player has enough cards to discard
        -: 1116:
    #####: 1117:		if (choice2 > 2 || choice2 < 0)
        -: 1118:		{
    #####: 1119:			return -1;
        -: 1120:		}
        -: 1121:
    #####: 1122:		if (choice1 == handPos)
        -: 1123:		{
    #####: 1124:			return -1;
        -: 1125:		}
        -: 1126:
    #####: 1127:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1128:		{
    #####: 1129:			if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1130:			{
    #####: 1131:				j++;
        -: 1132:			}
        -: 1133:		}
    #####: 1134:		if (j < choice2)
        -: 1135:		{
    #####: 1136:			return -1;
        -: 1137:		}
        -: 1138:
        -: 1139:		if (DEBUG)
        -: 1140:			printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1141:
        -: 1142:		//increase supply count for choosen card by amount being discarded
    #####: 1143:		state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1144:
        -: 1145:		//each other player gains a copy of revealed card
    #####: 1146:		for (i = 0; i < state->numPlayers; i++)
        -: 1147:		{
    #####: 1148:			if (i != currentPlayer)
        -: 1149:			{
    #####: 1150:				gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1151:			}
        -: 1152:		}
        -: 1153:
        -: 1154:		//discard played card from hand
    #####: 1155:		discardCard(handPos, currentPlayer, state, 0);
        -: 1156:
        -: 1157:		//trash copies of cards returned to supply
    #####: 1158:		for (j = 0; j < choice2; j++)
        -: 1159:		{
    #####: 1160:			for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1161:			{
    #####: 1162:				if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1163:				{
    #####: 1164:					discardCard(i, currentPlayer, state, 1);
    #####: 1165:					break;
        -: 1166:				}
        -: 1167:			}
        -: 1168:		}
        -: 1169:
    #####: 1170:		return 0;
        -: 1171:
        -: 1172:	case cutpurse:
        -: 1173:
    #####: 1174:		updateCoins(currentPlayer, state, 2);
    #####: 1175:		for (i = 0; i < state->numPlayers; i++)
        -: 1176:		{
    #####: 1177:			if (i != currentPlayer)
        -: 1178:			{
    #####: 1179:				for (j = 0; j < state->handCount[i]; j++)
        -: 1180:				{
    #####: 1181:					if (state->hand[i][j] == copper)
        -: 1182:					{
    #####: 1183:						discardCard(j, i, state, 0);
    #####: 1184:						break;
        -: 1185:					}
    #####: 1186:					if (j == state->handCount[i])
        -: 1187:					{
    #####: 1188:						for (k = 0; k < state->handCount[i]; k++)
        -: 1189:						{
        -: 1190:							if (DEBUG)
        -: 1191:								printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1192:						}
    #####: 1193:						break;
        -: 1194:					}
        -: 1195:				}
        -: 1196:
        -: 1197:			}
        -: 1198:
        -: 1199:		}
        -: 1200:
        -: 1201:		//discard played card from hand
    #####: 1202:		discardCard(handPos, currentPlayer, state, 0);
        -: 1203:
    #####: 1204:		return 0;
        -: 1205:
        -: 1206:
        -: 1207:	case embargo:
        -: 1208:		//+2 Coins
    #####: 1209:		state->coins = state->coins + 2;
        -: 1210:
        -: 1211:		//see if selected pile is in play
    #####: 1212:		if (state->supplyCount[choice1] == -1)
        -: 1213:		{
    #####: 1214:			return -1;
        -: 1215:		}
        -: 1216:
        -: 1217:		//add embargo token to selected supply pile
    #####: 1218:		state->embargoTokens[choice1]++;
        -: 1219:
        -: 1220:		//trash card
    #####: 1221:		discardCard(handPos, currentPlayer, state, 1);
    #####: 1222:		return 0;
        -: 1223:
        -: 1224:	case outpost:
        -: 1225:		//set outpost flag
    #####: 1226:		state->outpostPlayed++;
        -: 1227:
        -: 1228:		//discard card
    #####: 1229:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1230:		return 0;
        -: 1231:
        -: 1232:	case salvager:
        -: 1233:		//+1 buy
    #####: 1234:		state->numBuys++;
        -: 1235:
    #####: 1236:		if (choice1)
        -: 1237:		{
        -: 1238:			//gain coins equal to trashed card
    #####: 1239:			state->coins = state->coins + getCost(handCard(choice1, state));
        -: 1240:			//trash card
    #####: 1241:			discardCard(choice1, currentPlayer, state, 1);
        -: 1242:		}
        -: 1243:
        -: 1244:		//discard card
    #####: 1245:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1246:		return 0;
        -: 1247:
        -: 1248:	case sea_hag:
    #####: 1249:		for (i = 0; i < state->numPlayers; i++){
    #####: 1250:			if (i != currentPlayer){
    #####: 1251:				state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1252:				state->discardCount[i]++;
    #####: 1253:				state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1254:			}
        -: 1255:		}
    #####: 1256:		return 0;
        -: 1257:
        -: 1258:	case treasure_map:
        -: 1259:
    #####: 1260:		return playTreasureMap(state, currentPlayer, handPos);
        -: 1261:	}
    #####: 1262:	return -1;
        -: 1263:}
        -: 1264:
    #####: 1265:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1266:{
        -: 1267:
        -: 1268:	//if card is not trashed, added to Played pile 
    #####: 1269:	if (trashFlag < 1)
        -: 1270:	{
        -: 1271:		//add card to played pile
    #####: 1272:		state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
    #####: 1273:		state->playedCardCount++;
        -: 1274:	}
        -: 1275:
        -: 1276:	//set played card to -1
    #####: 1277:	state->hand[currentPlayer][handPos] = -1;
        -: 1278:
        -: 1279:	//remove card from player's hand
    #####: 1280:	if (handPos == (state->handCount[currentPlayer] - 1)) 	//last card in hand array is played
        -: 1281:	{
        -: 1282:		//reduce number of cards in hand
    #####: 1283:		state->handCount[currentPlayer]--;
        -: 1284:	}
    #####: 1285:	else if (state->handCount[currentPlayer] == 1) //only one card in hand
        -: 1286:	{
        -: 1287:		//reduce number of cards in hand
    #####: 1288:		state->handCount[currentPlayer]--;
        -: 1289:	}
        -: 1290:	else
        -: 1291:	{
        -: 1292:		//replace discarded card with last card in hand
    #####: 1293:		state->hand[currentPlayer][handPos] = state->hand[currentPlayer][(state->handCount[currentPlayer] - 1)];
        -: 1294:		//set last card to -1
    #####: 1295:		state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1296:		//reduce number of cards in hand
    #####: 1297:		state->handCount[currentPlayer]--;
        -: 1298:	}
        -: 1299:
    #####: 1300:	return 0;
        -: 1301:}
        -: 1302:
    #####: 1303:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1304:{
        -: 1305:	//Note: supplyPos is enum of choosen card
        -: 1306:
        -: 1307:	//check if supply pile is empty (0) or card is not used in game (-1)
    #####: 1308:	if (supplyCount(supplyPos, state) < 1)
        -: 1309:	{
    #####: 1310:		return -1;
        -: 1311:	}
        -: 1312:
        -: 1313:	//added card for [whoseTurn] current player:
        -: 1314:	// toFlag = 0 : add to discard
        -: 1315:	// toFlag = 1 : add to deck
        -: 1316:	// toFlag = 2 : add to hand
        -: 1317:
    #####: 1318:	if (toFlag == 1)
        -: 1319:	{
    #####: 1320:		state->deck[player][state->deckCount[player]] = supplyPos;
    #####: 1321:		state->deckCount[player]++;
        -: 1322:	}
    #####: 1323:	else if (toFlag == 2)
        -: 1324:	{
    #####: 1325:		state->hand[player][state->handCount[player]] = supplyPos;
    #####: 1326:		state->handCount[player]++;
        -: 1327:	}
        -: 1328:	else
        -: 1329:	{
    #####: 1330:		state->discard[player][state->discardCount[player]] = supplyPos;
    #####: 1331:		state->discardCount[player]++;
        -: 1332:	}
        -: 1333:
        -: 1334:	//decrease number in supply pile
    #####: 1335:	state->supplyCount[supplyPos]--;
        -: 1336:
    #####: 1337:	return 0;
        -: 1338:}
        -: 1339:
       13: 1340:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1341:{
        -: 1342:	int i;
        -: 1343:
        -: 1344:	//reset coin count
       13: 1345:	state->coins = 0;
        -: 1346:
        -: 1347:	//add coins for each Treasure card in player's hand
       63: 1348:	for (i = 0; i < state->handCount[player]; i++)
        -: 1349:	{
       50: 1350:		if (state->hand[player][i] == copper)
        -: 1351:		{
       31: 1352:			state->coins += 1;
        -: 1353:		}
       19: 1354:		else if (state->hand[player][i] == silver)
        -: 1355:		{
    #####: 1356:			state->coins += 2;
        -: 1357:		}
       19: 1358:		else if (state->hand[player][i] == gold)
        -: 1359:		{
    #####: 1360:			state->coins += 3;
        -: 1361:		}
        -: 1362:	}
        -: 1363:
        -: 1364:	//add bonus
       13: 1365:	state->coins += bonus;
        -: 1366:
       13: 1367:	return 0;
        -: 1368:}
        -: 1369:
        -: 1370:
        -: 1371://end of dominion.c
File 'dominion.c'
Lines executed:27.11% of 557
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
      476:    8:int compare(const void* a, const void* b) {
      476:    9:	if (*(int*)a > *(int*)b)
    #####:   10:		return 1;
      476:   11:	if (*(int*)a < *(int*)b)
      170:   12:		return -1;
      306:   13:	return 0;
        -:   14:}
        -:   15:
       20:   16:struct gameState* newGame() {
       20:   17:	struct gameState* g = malloc(sizeof(struct gameState));
       20:   18:	return g;
        -:   19:}
        -:   20:
      174:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:	int k8, int k9, int k10) {
      174:   23:	int* k = malloc(10 * sizeof(int));
      174:   24:	k[0] = k1;
      174:   25:	k[1] = k2;
      174:   26:	k[2] = k3;
      174:   27:	k[3] = k4;
      174:   28:	k[4] = k5;
      174:   29:	k[5] = k6;
      174:   30:	k[6] = k7;
      174:   31:	k[7] = k8;
      174:   32:	k[8] = k9;
      174:   33:	k[9] = k10;
      174:   34:	return k;
        -:   35:}
        -:   36:
      174:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		struct gameState *state) {
        -:   39:
        -:   40:	int i;
        -:   41:	int j;
        -:   42:	int it;
        -:   43:	//set up random number generator
      174:   44:	SelectStream(1);
      174:   45:	PutSeed((long)randomSeed);
        -:   46:
        -:   47:	//check number of players
      174:   48:	if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:	{
    #####:   50:		return -1;
        -:   51:	}
        -:   52:
        -:   53:	//set number of players
      174:   54:	state->numPlayers = numPlayers;
        -:   55:
        -:   56:	//check selected kingdom cards are different
      471:   57:	for (i = 0; i < 10; i++)
        -:   58:	{
     4266:   59:		for (j = 0; j < 10; j++)
        -:   60:		{
     3969:   61:			if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:			{
      164:   63:				return -1;
        -:   64:			}
        -:   65:		}
        -:   66:	}
        -:   67:
        -:   68:
        -:   69:	//initialize supply
        -:   70:	///////////////////////////////
        -:   71:
        -:   72:	//set number of Curse cards
       10:   73:	if (numPlayers == 2)
        -:   74:	{
        2:   75:		state->supplyCount[curse] = 10;
        -:   76:	}
        8:   77:	else if (numPlayers == 3)
        -:   78:	{
        2:   79:		state->supplyCount[curse] = 20;
        -:   80:	}
        -:   81:	else
        -:   82:	{
        6:   83:		state->supplyCount[curse] = 30;
        -:   84:	}
        -:   85:
        -:   86:	//set number of Victory cards
       10:   87:	if (numPlayers == 2)
        -:   88:	{
        2:   89:		state->supplyCount[estate] = 8;
        2:   90:		state->supplyCount[duchy] = 8;
        2:   91:		state->supplyCount[province] = 8;
        -:   92:	}
        -:   93:	else
        -:   94:	{
        8:   95:		state->supplyCount[estate] = 12;
        8:   96:		state->supplyCount[duchy] = 12;
        8:   97:		state->supplyCount[province] = 12;
        -:   98:	}
        -:   99:
        -:  100:	//set number of Treasure cards
       10:  101:	state->supplyCount[copper] = 60 - (7 * numPlayers);
       10:  102:	state->supplyCount[silver] = 40;
       10:  103:	state->supplyCount[gold] = 30;
        -:  104:
        -:  105:	//set number of Kingdom cards
      210:  106:	for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:	{
     1650:  108:		for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:		{
     1550:  110:			if (kingdomCards[j] == i)
        -:  111:			{
        -:  112:				//check if card is a 'Victory' Kingdom card
      100:  113:				if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:				{
       24:  115:					if (numPlayers == 2){
        2:  116:						state->supplyCount[i] = 8;
        -:  117:					}
       10:  118:					else{ state->supplyCount[i] = 12; }
        -:  119:				}
        -:  120:				else
        -:  121:				{
       88:  122:					state->supplyCount[i] = 10;
        -:  123:				}
      100:  124:				break;
        -:  125:			}
        -:  126:			else    //card is not in the set choosen for the game
        -:  127:			{
     1450:  128:				state->supplyCount[i] = -1;
        -:  129:			}
        -:  130:		}
        -:  131:
        -:  132:	}
        -:  133:
        -:  134:	////////////////////////
        -:  135:	//supply intilization complete
        -:  136:
        -:  137:	//set player decks
       44:  138:	for (i = 0; i < numPlayers; i++)
        -:  139:	{
       34:  140:		state->deckCount[i] = 0;
      136:  141:		for (j = 0; j < 3; j++)
        -:  142:		{
      102:  143:			state->deck[i][j] = estate;
      102:  144:			state->deckCount[i]++;
        -:  145:		}
      272:  146:		for (j = 3; j < 10; j++)
        -:  147:		{
      238:  148:			state->deck[i][j] = copper;
      238:  149:			state->deckCount[i]++;
        -:  150:		}
        -:  151:	}
        -:  152:
        -:  153:	//shuffle player decks
       44:  154:	for (i = 0; i < numPlayers; i++)
        -:  155:	{
       34:  156:		if (shuffle(i, state) < 0)
        -:  157:		{
    #####:  158:			return -1;
        -:  159:		}
        -:  160:	}
        -:  161:
        -:  162:	//draw player hands
       44:  163:	for (i = 0; i < numPlayers; i++)
        -:  164:	{
        -:  165:		//initialize hand size to zero
       34:  166:		state->handCount[i] = 0;
       34:  167:		state->discardCount[i] = 0;
        -:  168:		//draw 5 cards
        -:  169:		// for (j = 0; j < 5; j++)
        -:  170:		//	{
        -:  171:		//	  drawCard(i, state);
        -:  172:		//	}
        -:  173:	}
        -:  174:
        -:  175:	//set embargo tokens to 0 for all supply piles
      280:  176:	for (i = 0; i <= treasure_map; i++)
        -:  177:	{
      270:  178:		state->embargoTokens[i] = 0;
        -:  179:	}
        -:  180:
        -:  181:	//initialize first player's turn
       10:  182:	state->outpostPlayed = 0;
       10:  183:	state->phase = 0;
       10:  184:	state->numActions = 1;
       10:  185:	state->numBuys = 1;
       10:  186:	state->playedCardCount = 0;
       10:  187:	state->whoseTurn = 0;
       10:  188:	state->handCount[state->whoseTurn] = 0;
        -:  189:	//int it; move to top
        -:  190:
        -:  191:	//Moved draw cards to here, only drawing at the start of a turn
       60:  192:	for (it = 0; it < 5; it++){
       50:  193:		drawCard(state->whoseTurn, state);
        -:  194:	}
        -:  195:
       10:  196:	updateCoins(state->whoseTurn, state, 0);
        -:  197:
       10:  198:	return 0;
        -:  199:}
        -:  200:
       54:  201:int shuffle(int player, struct gameState *state) {
        -:  202:
        -:  203:
        -:  204:	int newDeck[MAX_DECK];
       54:  205:	int newDeckPos = 0;
        -:  206:	int card;
        -:  207:	int i;
        -:  208:
       54:  209:	if (state->deckCount[player] < 1)
       20:  210:		return -1;
       34:  211:	qsort((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
        -:  212:	/* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
      408:  214:	while (state->deckCount[player] > 0) {
      340:  215:		card = floor(Random() * state->deckCount[player]);
      340:  216:		newDeck[newDeckPos] = state->deck[player][card];
      340:  217:		newDeckPos++;
     1129:  218:		for (i = card; i < state->deckCount[player] - 1; i++) {
      789:  219:			state->deck[player][i] = state->deck[player][i + 1];
        -:  220:		}
      340:  221:		state->deckCount[player]--;
        -:  222:	}
      374:  223:	for (i = 0; i < newDeckPos; i++) {
      340:  224:		state->deck[player][i] = newDeck[i];
      340:  225:		state->deckCount[player]++;
        -:  226:	}
        -:  227:
       34:  228:	return 0;
        -:  229:}
        -:  230:
        4:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state)
        -:  232:{
        -:  233:	int card;
        4:  234:	int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:	//check if it is the right phase
        4:  237:	if (state->phase != 0)
        -:  238:	{
    #####:  239:		return -1;
        -:  240:	}
        -:  241:
        -:  242:	//check if player has enough actions
        4:  243:	if (state->numActions < 1)
        -:  244:	{
        4:  245:		return -1;
        -:  246:	}
        -:  247:
        -:  248:	//get card played
    #####:  249:	card = handCard(handPos, state);
        -:  250:
        -:  251:	//check if selected card is an action
    #####:  252:	if (card < adventurer || card > treasure_map)
        -:  253:	{
    #####:  254:		return -1;
        -:  255:	}
        -:  256:
        -:  257:	//play card
    #####:  258:	if (cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0)
        -:  259:	{
    #####:  260:		return -1;
        -:  261:	}
        -:  262:
        -:  263:	//reduce number of actions
    #####:  264:	state->numActions--;
        -:  265:
        -:  266:	//update coins (Treasure cards may be added with card draws)
    #####:  267:	updateCoins(state->whoseTurn, state, coin_bonus);
        -:  268:
    #####:  269:	return 0;
        -:  270:}
        -:  271:
        2:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:	int who;
        -:  274:	if (DEBUG){
        -:  275:		printf("Entering buyCard...\n");
        -:  276:	}
        -:  277:
        -:  278:	// I don't know what to do about the phase thing.
        -:  279:
        2:  280:	who = state->whoseTurn;
        -:  281:
        2:  282:	if (state->numBuys < 1){
        -:  283:		if (DEBUG)
        -:  284:			printf("You do not have any buys left\n");
        2:  285:		return -1;
        -:  286:	}
    #####:  287:	else if (supplyCount(supplyPos, state) < 1){
        -:  288:		if (DEBUG)
        -:  289:			printf("There are not any of that type of card left\n");
    #####:  290:		return -1;
        -:  291:	}
    #####:  292:	else if (state->coins < getCost(supplyPos)){
        -:  293:		if (DEBUG)
        -:  294:			printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  295:		return -1;
        -:  296:	}
        -:  297:	else {
    #####:  298:		state->phase = 1;
        -:  299:		//state->supplyCount[supplyPos]--;
    #####:  300:		gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  301:
    #####:  302:		state->coins = (state->coins) - (getCost(supplyPos));
    #####:  303:		state->numBuys--;
        -:  304:		if (DEBUG)
        -:  305:			printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  306:	}
        -:  307:
        -:  308:	//state->discard[who][state->discardCount[who]] = supplyPos;
        -:  309:	//state->discardCount[who]++;
        -:  310:
    #####:  311:	return 0;
        -:  312:}
        -:  313:
    #####:  314:int numHandCards(struct gameState *state) {
    #####:  315:	return state->handCount[whoseTurn(state)];
        -:  316:}
        -:  317:
    #####:  318:int handCard(int handPos, struct gameState *state) {
    #####:  319:	int currentPlayer = whoseTurn(state);
    #####:  320:	return state->hand[currentPlayer][handPos];
        -:  321:}
        -:  322:
    #####:  323:int supplyCount(int card, struct gameState *state) {
    #####:  324:	return state->supplyCount[card];
        -:  325:}
        -:  326:
    #####:  327:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  328:	int i;
    #####:  329:	int count = 0;
        -:  330:
    #####:  331:	for (i = 0; i < state->deckCount[player]; i++)
        -:  332:	{
    #####:  333:		if (state->deck[player][i] == card) count++;
        -:  334:	}
        -:  335:
    #####:  336:	for (i = 0; i < state->handCount[player]; i++)
        -:  337:	{
    #####:  338:		if (state->hand[player][i] == card) count++;
        -:  339:	}
        -:  340:
    #####:  341:	for (i = 0; i < state->discardCount[player]; i++)
        -:  342:	{
    #####:  343:		if (state->discard[player][i] == card) count++;
        -:  344:	}
        -:  345:
    #####:  346:	return count;
        -:  347:}
        -:  348:
        4:  349:int whoseTurn(struct gameState *state) {
        4:  350:	return state->whoseTurn;
        -:  351:}
        -:  352:
        4:  353:int endTurn(struct gameState *state) {
        -:  354:	int k;
        -:  355:	int i;
        4:  356:	int currentPlayer = whoseTurn(state);
        -:  357:
        -:  358:	//Discard hand
        4:  359:	for (i = 0; i < state->handCount[currentPlayer]; i++){
    #####:  360:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  361:		state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  362:	}
        4:  363:	state->handCount[currentPlayer] = 0;//Reset hand count
        -:  364:
        -:  365:	//Code for determining the player
        4:  366:	if (currentPlayer < (state->numPlayers - 1)){
    #####:  367:		state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  368:	}
        -:  369:	else{
        4:  370:		state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  371:	}
        -:  372:
        4:  373:	state->outpostPlayed = 0;
        4:  374:	state->phase = 0;
        4:  375:	state->numActions = 1;
        4:  376:	state->coins = 0;
        4:  377:	state->numBuys = 1;
        4:  378:	state->playedCardCount = 0;
        4:  379:	state->handCount[state->whoseTurn] = 0;
        -:  380:
        -:  381:	//int k; move to top
        -:  382:	//Next player draws hand
       24:  383:	for (k = 0; k < 5; k++){
       20:  384:		drawCard(state->whoseTurn, state);//Draw a card
        -:  385:	}
        -:  386:
        -:  387:	//Update money
        4:  388:	updateCoins(state->whoseTurn, state, 0);
        -:  389:
        4:  390:	return 0;
        -:  391:}
        -:  392:
    #####:  393:int isGameOver(struct gameState *state) {
        -:  394:	int i;
        -:  395:	int j;
        -:  396:
        -:  397:	//if stack of Province cards is empty, the game ends
    #####:  398:	if (state->supplyCount[province] == 0)
        -:  399:	{
    #####:  400:		return 1;
        -:  401:	}
        -:  402:
        -:  403:	//if three supply pile are at 0, the game ends
    #####:  404:	j = 0;
    #####:  405:	for (i = 0; i < 25; i++)
        -:  406:	{
    #####:  407:		if (state->supplyCount[i] == 0)
        -:  408:		{
    #####:  409:			j++;
        -:  410:		}
        -:  411:	}
    #####:  412:	if (j >= 3)
        -:  413:	{
    #####:  414:		return 1;
        -:  415:	}
        -:  416:
    #####:  417:	return 0;
        -:  418:}
        -:  419:
    #####:  420:int scoreFor(int player, struct gameState *state) {
        -:  421:
        -:  422:	int i;
    #####:  423:	int score = 0;
        -:  424:	//score from hand
    #####:  425:	for (i = 0; i < state->handCount[player]; i++)
        -:  426:	{
    #####:  427:		if (state->hand[player][i] == curse) { score = score - 1; };
    #####:  428:		if (state->hand[player][i] == estate) { score = score + 1; };
    #####:  429:		if (state->hand[player][i] == duchy) { score = score + 3; };
    #####:  430:		if (state->hand[player][i] == province) { score = score + 6; };
    #####:  431:		if (state->hand[player][i] == great_hall) { score = score + 1; };
    #####:  432:		if (state->hand[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  433:	}
        -:  434:
        -:  435:	//score from discard
    #####:  436:	for (i = 0; i < state->discardCount[player]; i++)
        -:  437:	{
    #####:  438:		if (state->discard[player][i] == curse) { score = score - 1; };
    #####:  439:		if (state->discard[player][i] == estate) { score = score + 1; };
    #####:  440:		if (state->discard[player][i] == duchy) { score = score + 3; };
    #####:  441:		if (state->discard[player][i] == province) { score = score + 6; };
    #####:  442:		if (state->discard[player][i] == great_hall) { score = score + 1; };
    #####:  443:		if (state->discard[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  444:	}
        -:  445:
        -:  446:	//score from deck
    #####:  447:	for (i = 0; i < state->discardCount[player]; i++)
        -:  448:	{
    #####:  449:		if (state->deck[player][i] == curse) { score = score - 1; };
    #####:  450:		if (state->deck[player][i] == estate) { score = score + 1; };
    #####:  451:		if (state->deck[player][i] == duchy) { score = score + 3; };
    #####:  452:		if (state->deck[player][i] == province) { score = score + 6; };
    #####:  453:		if (state->deck[player][i] == great_hall) { score = score + 1; };
    #####:  454:		if (state->deck[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  455:	}
        -:  456:
    #####:  457:	return score;
        -:  458:}
        -:  459:
    #####:  460:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  461:	int i;
        -:  462:	int j;
        -:  463:	int highScore;
        -:  464:	int currentPlayer;
        -:  465:
        -:  466:	//get score for each player
    #####:  467:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  468:	{
        -:  469:		//set unused player scores to -9999
    #####:  470:		if (i >= state->numPlayers)
        -:  471:		{
    #####:  472:			players[i] = -9999;
        -:  473:		}
        -:  474:		else
        -:  475:		{
    #####:  476:			players[i] = scoreFor(i, state);
        -:  477:		}
        -:  478:	}
        -:  479:
        -:  480:	//find highest score
    #####:  481:	j = 0;
    #####:  482:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  483:	{
    #####:  484:		if (players[i] > players[j])
        -:  485:		{
    #####:  486:			j = i;
        -:  487:		}
        -:  488:	}
    #####:  489:	highScore = players[j];
        -:  490:
        -:  491:	//add 1 to players who had less turns
    #####:  492:	currentPlayer = whoseTurn(state);
    #####:  493:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  494:	{
    #####:  495:		if (players[i] == highScore && i > currentPlayer)
        -:  496:		{
    #####:  497:			players[i]++;
        -:  498:		}
        -:  499:	}
        -:  500:
        -:  501:	//find new highest score
    #####:  502:	j = 0;
    #####:  503:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  504:	{
    #####:  505:		if (players[i] > players[j])
        -:  506:		{
    #####:  507:			j = i;
        -:  508:		}
        -:  509:	}
    #####:  510:	highScore = players[j];
        -:  511:
        -:  512:	//set winners in array to 1 and rest to 0
    #####:  513:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  514:	{
    #####:  515:		if (players[i] == highScore)
        -:  516:		{
    #####:  517:			players[i] = 1;
        -:  518:		}
        -:  519:		else
        -:  520:		{
    #####:  521:			players[i] = 0;
        -:  522:		}
        -:  523:	}
        -:  524:
    #####:  525:	return 0;
        -:  526:}
        -:  527:
       70:  528:int drawCard(int player, struct gameState *state)
        -:  529:{
        -:  530:	int count;
        -:  531:	int deckCounter;
       70:  532:	if (state->deckCount[player] <= 0){//Deck is empty
        -:  533:
        -:  534:		//Step 1 Shuffle the discard pile back into a deck
        -:  535:		int i;
        -:  536:		//Move discard to deck
       20:  537:		for (i = 0; i < state->discardCount[player]; i++){
    #####:  538:			state->deck[player][i] = state->discard[player][i];
    #####:  539:			state->discard[player][i] = -1;
        -:  540:		}
        -:  541:
       20:  542:		state->deckCount[player] = state->discardCount[player];
       20:  543:		state->discardCount[player] = 0;//Reset discard
        -:  544:
        -:  545:		//Shufffle the deck
       20:  546:		shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  547:
        -:  548:		if (DEBUG){//Debug statements
        -:  549:			printf("Deck count now: %d\n", state->deckCount[player]);
        -:  550:		}
        -:  551:
       20:  552:		state->discardCount[player] = 0;
        -:  553:
        -:  554:		//Step 2 Draw Card
       20:  555:		count = state->handCount[player];//Get current player's hand count
        -:  556:
        -:  557:		if (DEBUG){//Debug statements
        -:  558:			printf("Current hand count: %d\n", count);
        -:  559:		}
        -:  560:
       20:  561:		deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  562:
       20:  563:		if (deckCounter == 0)
       20:  564:			return -1;
        -:  565:
    #####:  566:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
    #####:  567:		state->deckCount[player]--;
    #####:  568:		state->handCount[player]++;//Increment hand count
        -:  569:	}
        -:  570:
        -:  571:	else{
       50:  572:		int count = state->handCount[player];//Get current hand count for player
        -:  573:		int deckCounter;
        -:  574:		if (DEBUG){//Debug statements
        -:  575:			printf("Current hand count: %d\n", count);
        -:  576:		}
        -:  577:
       50:  578:		deckCounter = state->deckCount[player];//Create holder for the deck count
       50:  579:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
       50:  580:		state->deckCount[player]--;
       50:  581:		state->handCount[player]++;//Increment hand count
        -:  582:	}
        -:  583:
       50:  584:	return 0;
        -:  585:}
        -:  586:
    #####:  587:int getCost(int cardNumber)
        -:  588:{
    #####:  589:	switch (cardNumber)
        -:  590:	{
        -:  591:	case curse:
    #####:  592:		return 0;
        -:  593:	case estate:
    #####:  594:		return 2;
        -:  595:	case duchy:
    #####:  596:		return 5;
        -:  597:	case province:
    #####:  598:		return 8;
        -:  599:	case copper:
    #####:  600:		return 0;
        -:  601:	case silver:
    #####:  602:		return 3;
        -:  603:	case gold:
    #####:  604:		return 6;
        -:  605:	case adventurer:
    #####:  606:		return 6;
        -:  607:	case council_room:
    #####:  608:		return 5;
        -:  609:	case feast:
    #####:  610:		return 4;
        -:  611:	case gardens:
    #####:  612:		return 4;
        -:  613:	case mine:
    #####:  614:		return 5;
        -:  615:	case remodel:
    #####:  616:		return 4;
        -:  617:	case smithy:
    #####:  618:		return 4;
        -:  619:	case village:
    #####:  620:		return 3;
        -:  621:	case baron:
    #####:  622:		return 4;
        -:  623:	case great_hall:
    #####:  624:		return 3;
        -:  625:	case minion:
    #####:  626:		return 5;
        -:  627:	case steward:
    #####:  628:		return 3;
        -:  629:	case tribute:
    #####:  630:		return 5;
        -:  631:	case ambassador:
    #####:  632:		return 3;
        -:  633:	case cutpurse:
    #####:  634:		return 4;
        -:  635:	case embargo:
    #####:  636:		return 2;
        -:  637:	case outpost:
    #####:  638:		return 5;
        -:  639:	case salvager:
    #####:  640:		return 4;
        -:  641:	case sea_hag:
    #####:  642:		return 4;
        -:  643:	case treasure_map:
    #####:  644:		return 4;
        -:  645:	}
        -:  646:
    #####:  647:	return -1;
        -:  648:}
        -:  649:
    #####:  650:void playAdventurer(struct gameState *state, int currentPlayer)
        -:  651:// Reveal cards from deck until 2 Treasure cards are found.  Put those Treasure cards in the hand and discard the rest.
        -:  652:{
    #####:  653:	int drawntreasure = 0;
        -:  654:	int temphand[MAX_HAND];
        -:  655:	int cardDrawn;
    #####:  656:	int z = 0; // this is the counter for the temp hand
        -:  657:
    #####:  658:	while (drawntreasure < 2){
    #####:  659:		if (state->deckCount[currentPlayer] < 1){//if the deck is empty we need to shuffle discard and add to deck
    #####:  660:			shuffle(currentPlayer, state);
        -:  661:		}
    #####:  662:		drawCard(currentPlayer, state);
    #####:  663:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer] - 1];//top card of hand is most recently drawn card.
    #####:  664:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
    #####:  665:			drawntreasure++;
        -:  666:		else{
    #####:  667:			temphand[z] = cardDrawn;
    #####:  668:			state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####:  669:			z++;
        -:  670:		}
        -:  671:	}
    #####:  672:	while (z - 1 >= 0){
    #####:  673:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; // discard all cards in play that have been drawn
    #####:  674:		z = z - 1;
        -:  675:	}
    #####:  676:}
        -:  677:
    #####:  678:int playRemodel(struct gameState *state, int currentPlayer, int choice1, int choice2, int handPos)
        -:  679://Trash a card in the hand, and gain a card costing up to $2 more than the trashed card
        -:  680:{
        -:  681:	int i;
    #####:  682:	int j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  683:
    #####:  684:	if ((getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2))
        -:  685:	{
    #####:  686:		return -1;
        -:  687:	}
        -:  688:
    #####:  689:	gainCard(choice2, state, 0, currentPlayer);
        -:  690:
        -:  691:	//discard card from hand
    #####:  692:	discardCard(handPos, currentPlayer, state, 0);
        -:  693:
        -:  694:	//discard trashed card
    #####:  695:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  696:	{
    #####:  697:		if (state->hand[currentPlayer][i] == j)
        -:  698:		{
    #####:  699:			discardCard(i, currentPlayer, state, 0);
    #####:  700:			break;
        -:  701:		}
        -:  702:	}
        -:  703:
    #####:  704:	return 0;
        -:  705:}
        -:  706:
    #####:  707:void playSmithy(struct gameState *state, int currentPlayer, int handPos)
        -:  708:// Draw 3 cards
        -:  709:{
        -:  710:	int i;
    #####:  711:	for (i = 0; i < 3; i++)
        -:  712:	{
    #####:  713:		drawCard(currentPlayer, state);
        -:  714:	}
        -:  715:
        -:  716:	//discard card from hand
    #####:  717:	discardCard(handPos, currentPlayer, state, 0);
    #####:  718:}
        -:  719:
    #####:  720:void playBaron(struct gameState *state, int currentPlayer, int choice1, int handPos)
        -:  721://Add a buy.  OPTION:  Discard an Estate card and gain $4.  Otherwise, gain an Estate card.
        -:  722:{
    #####:  723:	state->numBuys++;//Increase buys by 1!
    #####:  724:	if (choice1 > 0){//Boolean true or going to discard an estate
    #####:  725:		int p = 0;//Iterator for hand!
    #####:  726:		int card_not_discarded = 1;//Flag for discard set!
    #####:  727:		while (card_not_discarded){
    #####:  728:			if (state->hand[currentPlayer][p] == estate){ //Found an estate card!
    #####:  729:				state->coins += 4;//Add 4 coins to the amount of coins
    #####:  730:				state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  731:				state->discardCount[currentPlayer]++;
    #####:  732:				for (; p < state->handCount[currentPlayer]; p++){
    #####:  733:					state->hand[currentPlayer][p] = state->hand[currentPlayer][p + 1];
        -:  734:				}
    #####:  735:				state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  736:				state->handCount[currentPlayer]--;
    #####:  737:				card_not_discarded = 0;//Exit the loop
        -:  738:			}
    #####:  739:			else if (p > state->handCount[currentPlayer]){
        -:  740:				if (DEBUG) {
        -:  741:					printf("No estate cards in your hand, invalid choice\n");
        -:  742:					printf("Must gain an estate if there are any\n");
        -:  743:				}
    #####:  744:				if (supplyCount(estate, state) > 0){
    #####:  745:					gainCard(estate, state, 1, currentPlayer);
    #####:  746:					state->supplyCount[estate]--;//Decrement estates
    #####:  747:					if (supplyCount(estate, state) == 0){
    #####:  748:						isGameOver(state);
        -:  749:					}
        -:  750:				}
    #####:  751:				card_not_discarded = 0;//Exit the loop
        -:  752:			}
        -:  753:
        -:  754:			else{
    #####:  755:				p++;//Next card
        -:  756:			}
        -:  757:		}
        -:  758:	}
        -:  759:
        -:  760:	else{
    #####:  761:		if (supplyCount(estate, state) > 0){
    #####:  762:			gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  763:			state->supplyCount[estate]--;//Decrement Estates
    #####:  764:			if (supplyCount(estate, state) == 0){
    #####:  765:				isGameOver(state);
        -:  766:			}
        -:  767:		}
        -:  768:	}
    #####:  769:}
        -:  770:
    #####:  771:int playTreasureMap(struct gameState *state, int currentPlayer, int handPos)
        -:  772://Trashing two treasure map cards from the hand = four gold on top of the deck.
        -:  773:{
        -:  774:	int i;
        -:  775:	int index;
        -:  776:
        -:  777:	//search hand for another treasure_map
    #####:  778:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  779:	{
    #####:  780:		if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -:  781:		{
    #####:  782:			index = i;
    #####:  783:			break;
        -:  784:		}
        -:  785:	}
    #####:  786:	if (index > -1)
        -:  787:	{
        -:  788:		//trash both treasure cards
    #####:  789:		discardCard(handPos, currentPlayer, state, 1);
    #####:  790:		discardCard(index, currentPlayer, state, 1);
        -:  791:
        -:  792:		//gain 4 Gold cards
    #####:  793:		for (i = 0; i < 4; i++)
        -:  794:		{
    #####:  795:			gainCard(gold, state, 1, currentPlayer);
        -:  796:		}
        -:  797:
        -:  798:		//return success
    #####:  799:		return 1;
        -:  800:	}
        -:  801:
        -:  802:	//no second treasure_map found in hand
    #####:  803:	return -1;
        -:  804:}
        -:  805:
    #####:  806:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  807:{
        -:  808:	int i;
        -:  809:	int j;
        -:  810:	int k;
        -:  811:	//int x;  //Unused after while loop removed from feast.
    #####:  812:	int currentPlayer = whoseTurn(state);
    #####:  813:	int nextPlayer = currentPlayer + 1;
        -:  814:	int temphand[MAX_HAND];
        -:  815:
    #####:  816:	int tributeRevealedCards[2] = { -1, -1 };
        -:  817:
    #####:  818:	if (nextPlayer > (state->numPlayers - 1)){
    #####:  819:		nextPlayer = 0;
        -:  820:	}
        -:  821:
        -:  822:	//uses switch to select card and perform actions
    #####:  823:	switch (card)
        -:  824:	{
        -:  825:	case adventurer:
        -:  826:
    #####:  827:		playAdventurer(state, currentPlayer);
    #####:  828:		return 0;
        -:  829:
        -:  830:	case council_room:
        -:  831:		//+4 Cards
    #####:  832:		for (i = 0; i < 4; i++)
        -:  833:		{
    #####:  834:			drawCard(currentPlayer, state);
        -:  835:		}
        -:  836:
        -:  837:		//+1 Buy
    #####:  838:		state->numBuys++;
        -:  839:
        -:  840:		//Each other player draws a card
    #####:  841:		for (i = 0; i < state->numPlayers; i++)
        -:  842:		{
    #####:  843:			if (i != currentPlayer)
        -:  844:			{
    #####:  845:				drawCard(i, state);
        -:  846:			}
        -:  847:		}
        -:  848:
        -:  849:		//put played card in played card pile
    #####:  850:		discardCard(handPos, currentPlayer, state, 0);
        -:  851:
    #####:  852:		return 0;
        -:  853:
        -:  854:	case feast:
        -:  855:		//gain card with cost up to 5
        -:  856:		//Backup hand
    #####:  857:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  858:			temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  859:			state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  860:		}
        -:  861:		//Backup hand
        -:  862:
        -:  863:		//Update Coins for Buy
    #####:  864:		updateCoins(currentPlayer, state, 5);
        -:  865://		x = 1;//Condition to loop on
        -:  866://		while (x == 1) {//Buy one card
    #####:  867:			if (supplyCount(choice1, state) <= 0){
        -:  868:				if (DEBUG)
        -:  869:					printf("None of that card left, sorry!\n");
        -:  870:
        -:  871:				if (DEBUG){
        -:  872:					printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  873:				}
        -:  874:			}
    #####:  875:			else if (state->coins < getCost(choice1)){
    #####:  876:				printf("That card is too expensive!\n");
        -:  877:
        -:  878:				if (DEBUG){
        -:  879:					printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  880:				}
        -:  881:			}
        -:  882:			else{
        -:  883:
        -:  884:				if (DEBUG){
        -:  885:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  886:				}
        -:  887:
    #####:  888:				gainCard(choice1, state, 0, currentPlayer);//Gain the card
        -:  889://				x = 0;//No more buying cards
        -:  890:
        -:  891:				if (DEBUG){
        -:  892:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  893:				}
        -:  894:
        -:  895:			}
        -:  896://		}
        -:  897:
        -:  898:		//Reset Hand
    #####:  899:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  900:			state->hand[currentPlayer][i] = temphand[i];
    #####:  901:			temphand[i] = -1;
        -:  902:		}
        -:  903:		//Reset Hand
        -:  904:
    #####:  905:		return 0;
        -:  906:
        -:  907:	case gardens:
    #####:  908:		return -1;
        -:  909:
        -:  910:	case mine:
    #####:  911:		j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  912:
    #####:  913:		if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  914:		{
    #####:  915:			return -1;
        -:  916:		}
        -:  917:
    #####:  918:		if (choice2 > treasure_map || choice2 < curse)
        -:  919:		{
    #####:  920:			return -1;
        -:  921:		}
        -:  922:
    #####:  923:		if ((getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2))
        -:  924:		{
    #####:  925:			return -1;
        -:  926:		}
        -:  927:
    #####:  928:		gainCard(choice2, state, 2, currentPlayer);
        -:  929:
        -:  930:		//discard card from hand
    #####:  931:		discardCard(handPos, currentPlayer, state, 0);
        -:  932:
        -:  933:		//discard trashed card
    #####:  934:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  935:		{
    #####:  936:			if (state->hand[currentPlayer][i] == j)
        -:  937:			{
    #####:  938:				discardCard(i, currentPlayer, state, 0);
    #####:  939:				break;
        -:  940:			}
        -:  941:		}
        -:  942:
    #####:  943:		return 0;
        -:  944:
        -:  945:	case remodel:
        -:  946:
    #####:  947:		return playRemodel(state, currentPlayer, choice1, choice2, handPos);
        -:  948:
        -:  949:	case smithy:
        -:  950:
    #####:  951:		playSmithy(state, currentPlayer, handPos);
    #####:  952:		return 0;
        -:  953:
        -:  954:	case village:
        -:  955:		//+1 Card
    #####:  956:		drawCard(currentPlayer, state);
        -:  957:
        -:  958:		//+2 Actions
    #####:  959:		state->numActions = state->numActions + 2;
        -:  960:
        -:  961:		//discard played card from hand
    #####:  962:		discardCard(handPos, currentPlayer, state, 0);
    #####:  963:		return 0;
        -:  964:
        -:  965:	case baron:
        -:  966:
    #####:  967:		playBaron(state, currentPlayer, choice1, handPos);
    #####:  968:		return 0;
        -:  969:
        -:  970:	case great_hall:
        -:  971:		//+1 Card
    #####:  972:		drawCard(currentPlayer, state);
        -:  973:
        -:  974:		//+1 Actions
    #####:  975:		state->numActions++;
        -:  976:
        -:  977:		//discard card from hand
    #####:  978:		discardCard(handPos, currentPlayer, state, 0);
    #####:  979:		return 0;
        -:  980:
        -:  981:	case minion:
        -:  982:		//+1 action
    #####:  983:		state->numActions++;
        -:  984:
        -:  985:		//discard card from hand
    #####:  986:		discardCard(handPos, currentPlayer, state, 0);
        -:  987:
    #####:  988:		if (choice1)		//+2 coins
        -:  989:		{
    #####:  990:			state->coins = state->coins + 2;
        -:  991:		}
        -:  992:
    #####:  993:		else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  994:		{
        -:  995:			//discard hand
    #####:  996:			while (numHandCards(state) > 0)
        -:  997:			{
    #####:  998:				discardCard(handPos, currentPlayer, state, 0);
        -:  999:			}
        -: 1000:
        -: 1001:			//draw 4
    #####: 1002:			for (i = 0; i < 4; i++)
        -: 1003:			{
    #####: 1004:				drawCard(currentPlayer, state);
        -: 1005:			}
        -: 1006:
        -: 1007:			//other players discard hand and redraw if hand size > 4
    #####: 1008:			for (i = 0; i < state->numPlayers; i++)
        -: 1009:			{
    #####: 1010:				if (i != currentPlayer)
        -: 1011:				{
    #####: 1012:					if (state->handCount[i] > 4)
        -: 1013:					{
        -: 1014:						//discard hand
    #####: 1015:						while (state->handCount[i] > 0)
        -: 1016:						{
    #####: 1017:							discardCard(handPos, i, state, 0);
        -: 1018:						}
        -: 1019:
        -: 1020:						//draw 4
    #####: 1021:						for (j = 0; j < 4; j++)
        -: 1022:						{
    #####: 1023:							drawCard(i, state);
        -: 1024:						}
        -: 1025:					}
        -: 1026:				}
        -: 1027:			}
        -: 1028:
        -: 1029:		}
    #####: 1030:		return 0;
        -: 1031:
        -: 1032:	case steward:
    #####: 1033:		if (choice1 == 1)
        -: 1034:		{
        -: 1035:			//+2 cards
    #####: 1036:			drawCard(currentPlayer, state);
    #####: 1037:			drawCard(currentPlayer, state);
        -: 1038:		}
    #####: 1039:		else if (choice1 == 2)
        -: 1040:		{
        -: 1041:			//+2 coins
    #####: 1042:			state->coins = state->coins + 2;
        -: 1043:		}
        -: 1044:		else
        -: 1045:		{
        -: 1046:			//trash 2 cards in hand
    #####: 1047:			discardCard(choice2, currentPlayer, state, 1);
    #####: 1048:			discardCard(choice3, currentPlayer, state, 1);
        -: 1049:		}
        -: 1050:
        -: 1051:		//discard card from hand
    #####: 1052:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1053:		return 0;
        -: 1054:
        -: 1055:	case tribute:
    #####: 1056:		if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####: 1057:			if (state->deckCount[nextPlayer] > 0){
    #####: 1058:				tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1059:				state->deckCount[nextPlayer]--;
        -: 1060:			}
    #####: 1061:			else if (state->discardCount[nextPlayer] > 0){
    #####: 1062:				tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer] - 1];
    #####: 1063:				state->discardCount[nextPlayer]--;
        -: 1064:			}
        -: 1065:			else{
        -: 1066:				//No Card to Reveal
        -: 1067:				if (DEBUG){
        -: 1068:					printf("No cards to reveal\n");
        -: 1069:				}
        -: 1070:			}
        -: 1071:		}
        -: 1072:
        -: 1073:		else{
    #####: 1074:			if (state->deckCount[nextPlayer] == 0){
    #####: 1075:				for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####: 1076:					state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1077:					state->deckCount[nextPlayer]++;
    #####: 1078:					state->discard[nextPlayer][i] = -1;
    #####: 1079:					state->discardCount[nextPlayer]--;
        -: 1080:				}
        -: 1081:
    #####: 1082:				shuffle(nextPlayer, state);//Shuffle the deck
        -: 1083:			}
    #####: 1084:			tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1085:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1086:			state->deckCount[nextPlayer]--;
    #####: 1087:			tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1088:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1089:			state->deckCount[nextPlayer]--;
        -: 1090:		}
        -: 1091:
    #####: 1092:		if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
    #####: 1093:			state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1094:			state->playedCardCount++;
    #####: 1095:			tributeRevealedCards[1] = -1;
        -: 1096:		}
        -: 1097:
    #####: 1098:		for (i = 0; i <= 2; i++){
    #####: 1099:			if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
    #####: 1100:				state->coins += 2;
        -: 1101:			}
        -: 1102:
    #####: 1103:			else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
    #####: 1104:				drawCard(currentPlayer, state);
    #####: 1105:				drawCard(currentPlayer, state);
        -: 1106:			}
        -: 1107:			else{//Action Card
    #####: 1108:				state->numActions = state->numActions + 2;
        -: 1109:			}
        -: 1110:		}
        -: 1111:
    #####: 1112:		return 0;
        -: 1113:
        -: 1114:	case ambassador:
    #####: 1115:		j = 0;		//used to check if player has enough cards to discard
        -: 1116:
    #####: 1117:		if (choice2 > 2 || choice2 < 0)
        -: 1118:		{
    #####: 1119:			return -1;
        -: 1120:		}
        -: 1121:
    #####: 1122:		if (choice1 == handPos)
        -: 1123:		{
    #####: 1124:			return -1;
        -: 1125:		}
        -: 1126:
    #####: 1127:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1128:		{
    #####: 1129:			if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1130:			{
    #####: 1131:				j++;
        -: 1132:			}
        -: 1133:		}
    #####: 1134:		if (j < choice2)
        -: 1135:		{
    #####: 1136:			return -1;
        -: 1137:		}
        -: 1138:
        -: 1139:		if (DEBUG)
        -: 1140:			printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1141:
        -: 1142:		//increase supply count for choosen card by amount being discarded
    #####: 1143:		state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1144:
        -: 1145:		//each other player gains a copy of revealed card
    #####: 1146:		for (i = 0; i < state->numPlayers; i++)
        -: 1147:		{
    #####: 1148:			if (i != currentPlayer)
        -: 1149:			{
    #####: 1150:				gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1151:			}
        -: 1152:		}
        -: 1153:
        -: 1154:		//discard played card from hand
    #####: 1155:		discardCard(handPos, currentPlayer, state, 0);
        -: 1156:
        -: 1157:		//trash copies of cards returned to supply
    #####: 1158:		for (j = 0; j < choice2; j++)
        -: 1159:		{
    #####: 1160:			for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1161:			{
    #####: 1162:				if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1163:				{
    #####: 1164:					discardCard(i, currentPlayer, state, 1);
    #####: 1165:					break;
        -: 1166:				}
        -: 1167:			}
        -: 1168:		}
        -: 1169:
    #####: 1170:		return 0;
        -: 1171:
        -: 1172:	case cutpurse:
        -: 1173:
    #####: 1174:		updateCoins(currentPlayer, state, 2);
    #####: 1175:		for (i = 0; i < state->numPlayers; i++)
        -: 1176:		{
    #####: 1177:			if (i != currentPlayer)
        -: 1178:			{
    #####: 1179:				for (j = 0; j < state->handCount[i]; j++)
        -: 1180:				{
    #####: 1181:					if (state->hand[i][j] == copper)
        -: 1182:					{
    #####: 1183:						discardCard(j, i, state, 0);
    #####: 1184:						break;
        -: 1185:					}
    #####: 1186:					if (j == state->handCount[i])
        -: 1187:					{
    #####: 1188:						for (k = 0; k < state->handCount[i]; k++)
        -: 1189:						{
        -: 1190:							if (DEBUG)
        -: 1191:								printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1192:						}
    #####: 1193:						break;
        -: 1194:					}
        -: 1195:				}
        -: 1196:
        -: 1197:			}
        -: 1198:
        -: 1199:		}
        -: 1200:
        -: 1201:		//discard played card from hand
    #####: 1202:		discardCard(handPos, currentPlayer, state, 0);
        -: 1203:
    #####: 1204:		return 0;
        -: 1205:
        -: 1206:
        -: 1207:	case embargo:
        -: 1208:		//+2 Coins
    #####: 1209:		state->coins = state->coins + 2;
        -: 1210:
        -: 1211:		//see if selected pile is in play
    #####: 1212:		if (state->supplyCount[choice1] == -1)
        -: 1213:		{
    #####: 1214:			return -1;
        -: 1215:		}
        -: 1216:
        -: 1217:		//add embargo token to selected supply pile
    #####: 1218:		state->embargoTokens[choice1]++;
        -: 1219:
        -: 1220:		//trash card
    #####: 1221:		discardCard(handPos, currentPlayer, state, 1);
    #####: 1222:		return 0;
        -: 1223:
        -: 1224:	case outpost:
        -: 1225:		//set outpost flag
    #####: 1226:		state->outpostPlayed++;
        -: 1227:
        -: 1228:		//discard card
    #####: 1229:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1230:		return 0;
        -: 1231:
        -: 1232:	case salvager:
        -: 1233:		//+1 buy
    #####: 1234:		state->numBuys++;
        -: 1235:
    #####: 1236:		if (choice1)
        -: 1237:		{
        -: 1238:			//gain coins equal to trashed card
    #####: 1239:			state->coins = state->coins + getCost(handCard(choice1, state));
        -: 1240:			//trash card
    #####: 1241:			discardCard(choice1, currentPlayer, state, 1);
        -: 1242:		}
        -: 1243:
        -: 1244:		//discard card
    #####: 1245:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1246:		return 0;
        -: 1247:
        -: 1248:	case sea_hag:
    #####: 1249:		for (i = 0; i < state->numPlayers; i++){
    #####: 1250:			if (i != currentPlayer){
    #####: 1251:				state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1252:				state->discardCount[i]++;
    #####: 1253:				state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1254:			}
        -: 1255:		}
    #####: 1256:		return 0;
        -: 1257:
        -: 1258:	case treasure_map:
        -: 1259:
    #####: 1260:		return playTreasureMap(state, currentPlayer, handPos);
        -: 1261:	}
    #####: 1262:	return -1;
        -: 1263:}
        -: 1264:
    #####: 1265:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1266:{
        -: 1267:
        -: 1268:	//if card is not trashed, added to Played pile 
    #####: 1269:	if (trashFlag < 1)
        -: 1270:	{
        -: 1271:		//add card to played pile
    #####: 1272:		state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
    #####: 1273:		state->playedCardCount++;
        -: 1274:	}
        -: 1275:
        -: 1276:	//set played card to -1
    #####: 1277:	state->hand[currentPlayer][handPos] = -1;
        -: 1278:
        -: 1279:	//remove card from player's hand
    #####: 1280:	if (handPos == (state->handCount[currentPlayer] - 1)) 	//last card in hand array is played
        -: 1281:	{
        -: 1282:		//reduce number of cards in hand
    #####: 1283:		state->handCount[currentPlayer]--;
        -: 1284:	}
    #####: 1285:	else if (state->handCount[currentPlayer] == 1) //only one card in hand
        -: 1286:	{
        -: 1287:		//reduce number of cards in hand
    #####: 1288:		state->handCount[currentPlayer]--;
        -: 1289:	}
        -: 1290:	else
        -: 1291:	{
        -: 1292:		//replace discarded card with last card in hand
    #####: 1293:		state->hand[currentPlayer][handPos] = state->hand[currentPlayer][(state->handCount[currentPlayer] - 1)];
        -: 1294:		//set last card to -1
    #####: 1295:		state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1296:		//reduce number of cards in hand
    #####: 1297:		state->handCount[currentPlayer]--;
        -: 1298:	}
        -: 1299:
    #####: 1300:	return 0;
        -: 1301:}
        -: 1302:
    #####: 1303:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1304:{
        -: 1305:	//Note: supplyPos is enum of choosen card
        -: 1306:
        -: 1307:	//check if supply pile is empty (0) or card is not used in game (-1)
    #####: 1308:	if (supplyCount(supplyPos, state) < 1)
        -: 1309:	{
    #####: 1310:		return -1;
        -: 1311:	}
        -: 1312:
        -: 1313:	//added card for [whoseTurn] current player:
        -: 1314:	// toFlag = 0 : add to discard
        -: 1315:	// toFlag = 1 : add to deck
        -: 1316:	// toFlag = 2 : add to hand
        -: 1317:
    #####: 1318:	if (toFlag == 1)
        -: 1319:	{
    #####: 1320:		state->deck[player][state->deckCount[player]] = supplyPos;
    #####: 1321:		state->deckCount[player]++;
        -: 1322:	}
    #####: 1323:	else if (toFlag == 2)
        -: 1324:	{
    #####: 1325:		state->hand[player][state->handCount[player]] = supplyPos;
    #####: 1326:		state->handCount[player]++;
        -: 1327:	}
        -: 1328:	else
        -: 1329:	{
    #####: 1330:		state->discard[player][state->discardCount[player]] = supplyPos;
    #####: 1331:		state->discardCount[player]++;
        -: 1332:	}
        -: 1333:
        -: 1334:	//decrease number in supply pile
    #####: 1335:	state->supplyCount[supplyPos]--;
        -: 1336:
    #####: 1337:	return 0;
        -: 1338:}
        -: 1339:
       14: 1340:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1341:{
        -: 1342:	int i;
        -: 1343:
        -: 1344:	//reset coin count
       14: 1345:	state->coins = 0;
        -: 1346:
        -: 1347:	//add coins for each Treasure card in player's hand
       64: 1348:	for (i = 0; i < state->handCount[player]; i++)
        -: 1349:	{
       50: 1350:		if (state->hand[player][i] == copper)
        -: 1351:		{
       35: 1352:			state->coins += 1;
        -: 1353:		}
       15: 1354:		else if (state->hand[player][i] == silver)
        -: 1355:		{
    #####: 1356:			state->coins += 2;
        -: 1357:		}
       15: 1358:		else if (state->hand[player][i] == gold)
        -: 1359:		{
    #####: 1360:			state->coins += 3;
        -: 1361:		}
        -: 1362:	}
        -: 1363:
        -: 1364:	//add bonus
       14: 1365:	state->coins += bonus;
        -: 1366:
       14: 1367:	return 0;
        -: 1368:}
        -: 1369:
        -: 1370:
        -: 1371://end of dominion.c
File 'dominion.c'
Lines executed:27.11% of 557
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
      364:    8:int compare(const void* a, const void* b) {
      364:    9:	if (*(int*)a > *(int*)b)
    #####:   10:		return 1;
      364:   11:	if (*(int*)a < *(int*)b)
      130:   12:		return -1;
      234:   13:	return 0;
        -:   14:}
        -:   15:
       20:   16:struct gameState* newGame() {
       20:   17:	struct gameState* g = malloc(sizeof(struct gameState));
       20:   18:	return g;
        -:   19:}
        -:   20:
      161:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:	int k8, int k9, int k10) {
      161:   23:	int* k = malloc(10 * sizeof(int));
      161:   24:	k[0] = k1;
      161:   25:	k[1] = k2;
      161:   26:	k[2] = k3;
      161:   27:	k[3] = k4;
      161:   28:	k[4] = k5;
      161:   29:	k[5] = k6;
      161:   30:	k[6] = k7;
      161:   31:	k[7] = k8;
      161:   32:	k[8] = k9;
      161:   33:	k[9] = k10;
      161:   34:	return k;
        -:   35:}
        -:   36:
      161:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		struct gameState *state) {
        -:   39:
        -:   40:	int i;
        -:   41:	int j;
        -:   42:	int it;
        -:   43:	//set up random number generator
      161:   44:	SelectStream(1);
      161:   45:	PutSeed((long)randomSeed);
        -:   46:
        -:   47:	//check number of players
      161:   48:	if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:	{
    #####:   50:		return -1;
        -:   51:	}
        -:   52:
        -:   53:	//set number of players
      161:   54:	state->numPlayers = numPlayers;
        -:   55:
        -:   56:	//check selected kingdom cards are different
      450:   57:	for (i = 0; i < 10; i++)
        -:   58:	{
     4120:   59:		for (j = 0; j < 10; j++)
        -:   60:		{
     3831:   61:			if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:			{
      151:   63:				return -1;
        -:   64:			}
        -:   65:		}
        -:   66:	}
        -:   67:
        -:   68:
        -:   69:	//initialize supply
        -:   70:	///////////////////////////////
        -:   71:
        -:   72:	//set number of Curse cards
       10:   73:	if (numPlayers == 2)
        -:   74:	{
        6:   75:		state->supplyCount[curse] = 10;
        -:   76:	}
        4:   77:	else if (numPlayers == 3)
        -:   78:	{
        2:   79:		state->supplyCount[curse] = 20;
        -:   80:	}
        -:   81:	else
        -:   82:	{
        2:   83:		state->supplyCount[curse] = 30;
        -:   84:	}
        -:   85:
        -:   86:	//set number of Victory cards
       10:   87:	if (numPlayers == 2)
        -:   88:	{
        6:   89:		state->supplyCount[estate] = 8;
        6:   90:		state->supplyCount[duchy] = 8;
        6:   91:		state->supplyCount[province] = 8;
        -:   92:	}
        -:   93:	else
        -:   94:	{
        4:   95:		state->supplyCount[estate] = 12;
        4:   96:		state->supplyCount[duchy] = 12;
        4:   97:		state->supplyCount[province] = 12;
        -:   98:	}
        -:   99:
        -:  100:	//set number of Treasure cards
       10:  101:	state->supplyCount[copper] = 60 - (7 * numPlayers);
       10:  102:	state->supplyCount[silver] = 40;
       10:  103:	state->supplyCount[gold] = 30;
        -:  104:
        -:  105:	//set number of Kingdom cards
      210:  106:	for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:	{
     1650:  108:		for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:		{
     1550:  110:			if (kingdomCards[j] == i)
        -:  111:			{
        -:  112:				//check if card is a 'Victory' Kingdom card
      100:  113:				if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:				{
       10:  115:					if (numPlayers == 2){
        3:  116:						state->supplyCount[i] = 8;
        -:  117:					}
        2:  118:					else{ state->supplyCount[i] = 12; }
        -:  119:				}
        -:  120:				else
        -:  121:				{
       95:  122:					state->supplyCount[i] = 10;
        -:  123:				}
      100:  124:				break;
        -:  125:			}
        -:  126:			else    //card is not in the set choosen for the game
        -:  127:			{
     1450:  128:				state->supplyCount[i] = -1;
        -:  129:			}
        -:  130:		}
        -:  131:
        -:  132:	}
        -:  133:
        -:  134:	////////////////////////
        -:  135:	//supply intilization complete
        -:  136:
        -:  137:	//set player decks
       36:  138:	for (i = 0; i < numPlayers; i++)
        -:  139:	{
       26:  140:		state->deckCount[i] = 0;
      104:  141:		for (j = 0; j < 3; j++)
        -:  142:		{
       78:  143:			state->deck[i][j] = estate;
       78:  144:			state->deckCount[i]++;
        -:  145:		}
      208:  146:		for (j = 3; j < 10; j++)
        -:  147:		{
      182:  148:			state->deck[i][j] = copper;
      182:  149:			state->deckCount[i]++;
        -:  150:		}
        -:  151:	}
        -:  152:
        -:  153:	//shuffle player decks
       36:  154:	for (i = 0; i < numPlayers; i++)
        -:  155:	{
       26:  156:		if (shuffle(i, state) < 0)
        -:  157:		{
    #####:  158:			return -1;
        -:  159:		}
        -:  160:	}
        -:  161:
        -:  162:	//draw player hands
       36:  163:	for (i = 0; i < numPlayers; i++)
        -:  164:	{
        -:  165:		//initialize hand size to zero
       26:  166:		state->handCount[i] = 0;
       26:  167:		state->discardCount[i] = 0;
        -:  168:		//draw 5 cards
        -:  169:		// for (j = 0; j < 5; j++)
        -:  170:		//	{
        -:  171:		//	  drawCard(i, state);
        -:  172:		//	}
        -:  173:	}
        -:  174:
        -:  175:	//set embargo tokens to 0 for all supply piles
      280:  176:	for (i = 0; i <= treasure_map; i++)
        -:  177:	{
      270:  178:		state->embargoTokens[i] = 0;
        -:  179:	}
        -:  180:
        -:  181:	//initialize first player's turn
       10:  182:	state->outpostPlayed = 0;
       10:  183:	state->phase = 0;
       10:  184:	state->numActions = 1;
       10:  185:	state->numBuys = 1;
       10:  186:	state->playedCardCount = 0;
       10:  187:	state->whoseTurn = 0;
       10:  188:	state->handCount[state->whoseTurn] = 0;
        -:  189:	//int it; move to top
        -:  190:
        -:  191:	//Moved draw cards to here, only drawing at the start of a turn
       60:  192:	for (it = 0; it < 5; it++){
       50:  193:		drawCard(state->whoseTurn, state);
        -:  194:	}
        -:  195:
       10:  196:	updateCoins(state->whoseTurn, state, 0);
        -:  197:
       10:  198:	return 0;
        -:  199:}
        -:  200:
       41:  201:int shuffle(int player, struct gameState *state) {
        -:  202:
        -:  203:
        -:  204:	int newDeck[MAX_DECK];
       41:  205:	int newDeckPos = 0;
        -:  206:	int card;
        -:  207:	int i;
        -:  208:
       41:  209:	if (state->deckCount[player] < 1)
       15:  210:		return -1;
       26:  211:	qsort((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
        -:  212:	/* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
      312:  214:	while (state->deckCount[player] > 0) {
      260:  215:		card = floor(Random() * state->deckCount[player]);
      260:  216:		newDeck[newDeckPos] = state->deck[player][card];
      260:  217:		newDeckPos++;
      849:  218:		for (i = card; i < state->deckCount[player] - 1; i++) {
      589:  219:			state->deck[player][i] = state->deck[player][i + 1];
        -:  220:		}
      260:  221:		state->deckCount[player]--;
        -:  222:	}
      286:  223:	for (i = 0; i < newDeckPos; i++) {
      260:  224:		state->deck[player][i] = newDeck[i];
      260:  225:		state->deckCount[player]++;
        -:  226:	}
        -:  227:
       26:  228:	return 0;
        -:  229:}
        -:  230:
        4:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state)
        -:  232:{
        -:  233:	int card;
        4:  234:	int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:	//check if it is the right phase
        4:  237:	if (state->phase != 0)
        -:  238:	{
    #####:  239:		return -1;
        -:  240:	}
        -:  241:
        -:  242:	//check if player has enough actions
        4:  243:	if (state->numActions < 1)
        -:  244:	{
        4:  245:		return -1;
        -:  246:	}
        -:  247:
        -:  248:	//get card played
    #####:  249:	card = handCard(handPos, state);
        -:  250:
        -:  251:	//check if selected card is an action
    #####:  252:	if (card < adventurer || card > treasure_map)
        -:  253:	{
    #####:  254:		return -1;
        -:  255:	}
        -:  256:
        -:  257:	//play card
    #####:  258:	if (cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0)
        -:  259:	{
    #####:  260:		return -1;
        -:  261:	}
        -:  262:
        -:  263:	//reduce number of actions
    #####:  264:	state->numActions--;
        -:  265:
        -:  266:	//update coins (Treasure cards may be added with card draws)
    #####:  267:	updateCoins(state->whoseTurn, state, coin_bonus);
        -:  268:
    #####:  269:	return 0;
        -:  270:}
        -:  271:
        3:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:	int who;
        -:  274:	if (DEBUG){
        -:  275:		printf("Entering buyCard...\n");
        -:  276:	}
        -:  277:
        -:  278:	// I don't know what to do about the phase thing.
        -:  279:
        3:  280:	who = state->whoseTurn;
        -:  281:
        3:  282:	if (state->numBuys < 1){
        -:  283:		if (DEBUG)
        -:  284:			printf("You do not have any buys left\n");
        3:  285:		return -1;
        -:  286:	}
    #####:  287:	else if (supplyCount(supplyPos, state) < 1){
        -:  288:		if (DEBUG)
        -:  289:			printf("There are not any of that type of card left\n");
    #####:  290:		return -1;
        -:  291:	}
    #####:  292:	else if (state->coins < getCost(supplyPos)){
        -:  293:		if (DEBUG)
        -:  294:			printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  295:		return -1;
        -:  296:	}
        -:  297:	else {
    #####:  298:		state->phase = 1;
        -:  299:		//state->supplyCount[supplyPos]--;
    #####:  300:		gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  301:
    #####:  302:		state->coins = (state->coins) - (getCost(supplyPos));
    #####:  303:		state->numBuys--;
        -:  304:		if (DEBUG)
        -:  305:			printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  306:	}
        -:  307:
        -:  308:	//state->discard[who][state->discardCount[who]] = supplyPos;
        -:  309:	//state->discardCount[who]++;
        -:  310:
    #####:  311:	return 0;
        -:  312:}
        -:  313:
    #####:  314:int numHandCards(struct gameState *state) {
    #####:  315:	return state->handCount[whoseTurn(state)];
        -:  316:}
        -:  317:
    #####:  318:int handCard(int handPos, struct gameState *state) {
    #####:  319:	int currentPlayer = whoseTurn(state);
    #####:  320:	return state->hand[currentPlayer][handPos];
        -:  321:}
        -:  322:
    #####:  323:int supplyCount(int card, struct gameState *state) {
    #####:  324:	return state->supplyCount[card];
        -:  325:}
        -:  326:
    #####:  327:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  328:	int i;
    #####:  329:	int count = 0;
        -:  330:
    #####:  331:	for (i = 0; i < state->deckCount[player]; i++)
        -:  332:	{
    #####:  333:		if (state->deck[player][i] == card) count++;
        -:  334:	}
        -:  335:
    #####:  336:	for (i = 0; i < state->handCount[player]; i++)
        -:  337:	{
    #####:  338:		if (state->hand[player][i] == card) count++;
        -:  339:	}
        -:  340:
    #####:  341:	for (i = 0; i < state->discardCount[player]; i++)
        -:  342:	{
    #####:  343:		if (state->discard[player][i] == card) count++;
        -:  344:	}
        -:  345:
    #####:  346:	return count;
        -:  347:}
        -:  348:
        3:  349:int whoseTurn(struct gameState *state) {
        3:  350:	return state->whoseTurn;
        -:  351:}
        -:  352:
        3:  353:int endTurn(struct gameState *state) {
        -:  354:	int k;
        -:  355:	int i;
        3:  356:	int currentPlayer = whoseTurn(state);
        -:  357:
        -:  358:	//Discard hand
        3:  359:	for (i = 0; i < state->handCount[currentPlayer]; i++){
    #####:  360:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  361:		state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  362:	}
        3:  363:	state->handCount[currentPlayer] = 0;//Reset hand count
        -:  364:
        -:  365:	//Code for determining the player
        3:  366:	if (currentPlayer < (state->numPlayers - 1)){
    #####:  367:		state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  368:	}
        -:  369:	else{
        3:  370:		state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  371:	}
        -:  372:
        3:  373:	state->outpostPlayed = 0;
        3:  374:	state->phase = 0;
        3:  375:	state->numActions = 1;
        3:  376:	state->coins = 0;
        3:  377:	state->numBuys = 1;
        3:  378:	state->playedCardCount = 0;
        3:  379:	state->handCount[state->whoseTurn] = 0;
        -:  380:
        -:  381:	//int k; move to top
        -:  382:	//Next player draws hand
       18:  383:	for (k = 0; k < 5; k++){
       15:  384:		drawCard(state->whoseTurn, state);//Draw a card
        -:  385:	}
        -:  386:
        -:  387:	//Update money
        3:  388:	updateCoins(state->whoseTurn, state, 0);
        -:  389:
        3:  390:	return 0;
        -:  391:}
        -:  392:
    #####:  393:int isGameOver(struct gameState *state) {
        -:  394:	int i;
        -:  395:	int j;
        -:  396:
        -:  397:	//if stack of Province cards is empty, the game ends
    #####:  398:	if (state->supplyCount[province] == 0)
        -:  399:	{
    #####:  400:		return 1;
        -:  401:	}
        -:  402:
        -:  403:	//if three supply pile are at 0, the game ends
    #####:  404:	j = 0;
    #####:  405:	for (i = 0; i < 25; i++)
        -:  406:	{
    #####:  407:		if (state->supplyCount[i] == 0)
        -:  408:		{
    #####:  409:			j++;
        -:  410:		}
        -:  411:	}
    #####:  412:	if (j >= 3)
        -:  413:	{
    #####:  414:		return 1;
        -:  415:	}
        -:  416:
    #####:  417:	return 0;
        -:  418:}
        -:  419:
    #####:  420:int scoreFor(int player, struct gameState *state) {
        -:  421:
        -:  422:	int i;
    #####:  423:	int score = 0;
        -:  424:	//score from hand
    #####:  425:	for (i = 0; i < state->handCount[player]; i++)
        -:  426:	{
    #####:  427:		if (state->hand[player][i] == curse) { score = score - 1; };
    #####:  428:		if (state->hand[player][i] == estate) { score = score + 1; };
    #####:  429:		if (state->hand[player][i] == duchy) { score = score + 3; };
    #####:  430:		if (state->hand[player][i] == province) { score = score + 6; };
    #####:  431:		if (state->hand[player][i] == great_hall) { score = score + 1; };
    #####:  432:		if (state->hand[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  433:	}
        -:  434:
        -:  435:	//score from discard
    #####:  436:	for (i = 0; i < state->discardCount[player]; i++)
        -:  437:	{
    #####:  438:		if (state->discard[player][i] == curse) { score = score - 1; };
    #####:  439:		if (state->discard[player][i] == estate) { score = score + 1; };
    #####:  440:		if (state->discard[player][i] == duchy) { score = score + 3; };
    #####:  441:		if (state->discard[player][i] == province) { score = score + 6; };
    #####:  442:		if (state->discard[player][i] == great_hall) { score = score + 1; };
    #####:  443:		if (state->discard[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  444:	}
        -:  445:
        -:  446:	//score from deck
    #####:  447:	for (i = 0; i < state->discardCount[player]; i++)
        -:  448:	{
    #####:  449:		if (state->deck[player][i] == curse) { score = score - 1; };
    #####:  450:		if (state->deck[player][i] == estate) { score = score + 1; };
    #####:  451:		if (state->deck[player][i] == duchy) { score = score + 3; };
    #####:  452:		if (state->deck[player][i] == province) { score = score + 6; };
    #####:  453:		if (state->deck[player][i] == great_hall) { score = score + 1; };
    #####:  454:		if (state->deck[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  455:	}
        -:  456:
    #####:  457:	return score;
        -:  458:}
        -:  459:
    #####:  460:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  461:	int i;
        -:  462:	int j;
        -:  463:	int highScore;
        -:  464:	int currentPlayer;
        -:  465:
        -:  466:	//get score for each player
    #####:  467:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  468:	{
        -:  469:		//set unused player scores to -9999
    #####:  470:		if (i >= state->numPlayers)
        -:  471:		{
    #####:  472:			players[i] = -9999;
        -:  473:		}
        -:  474:		else
        -:  475:		{
    #####:  476:			players[i] = scoreFor(i, state);
        -:  477:		}
        -:  478:	}
        -:  479:
        -:  480:	//find highest score
    #####:  481:	j = 0;
    #####:  482:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  483:	{
    #####:  484:		if (players[i] > players[j])
        -:  485:		{
    #####:  486:			j = i;
        -:  487:		}
        -:  488:	}
    #####:  489:	highScore = players[j];
        -:  490:
        -:  491:	//add 1 to players who had less turns
    #####:  492:	currentPlayer = whoseTurn(state);
    #####:  493:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  494:	{
    #####:  495:		if (players[i] == highScore && i > currentPlayer)
        -:  496:		{
    #####:  497:			players[i]++;
        -:  498:		}
        -:  499:	}
        -:  500:
        -:  501:	//find new highest score
    #####:  502:	j = 0;
    #####:  503:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  504:	{
    #####:  505:		if (players[i] > players[j])
        -:  506:		{
    #####:  507:			j = i;
        -:  508:		}
        -:  509:	}
    #####:  510:	highScore = players[j];
        -:  511:
        -:  512:	//set winners in array to 1 and rest to 0
    #####:  513:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  514:	{
    #####:  515:		if (players[i] == highScore)
        -:  516:		{
    #####:  517:			players[i] = 1;
        -:  518:		}
        -:  519:		else
        -:  520:		{
    #####:  521:			players[i] = 0;
        -:  522:		}
        -:  523:	}
        -:  524:
    #####:  525:	return 0;
        -:  526:}
        -:  527:
       65:  528:int drawCard(int player, struct gameState *state)
        -:  529:{
        -:  530:	int count;
        -:  531:	int deckCounter;
       65:  532:	if (state->deckCount[player] <= 0){//Deck is empty
        -:  533:
        -:  534:		//Step 1 Shuffle the discard pile back into a deck
        -:  535:		int i;
        -:  536:		//Move discard to deck
       15:  537:		for (i = 0; i < state->discardCount[player]; i++){
    #####:  538:			state->deck[player][i] = state->discard[player][i];
    #####:  539:			state->discard[player][i] = -1;
        -:  540:		}
        -:  541:
       15:  542:		state->deckCount[player] = state->discardCount[player];
       15:  543:		state->discardCount[player] = 0;//Reset discard
        -:  544:
        -:  545:		//Shufffle the deck
       15:  546:		shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  547:
        -:  548:		if (DEBUG){//Debug statements
        -:  549:			printf("Deck count now: %d\n", state->deckCount[player]);
        -:  550:		}
        -:  551:
       15:  552:		state->discardCount[player] = 0;
        -:  553:
        -:  554:		//Step 2 Draw Card
       15:  555:		count = state->handCount[player];//Get current player's hand count
        -:  556:
        -:  557:		if (DEBUG){//Debug statements
        -:  558:			printf("Current hand count: %d\n", count);
        -:  559:		}
        -:  560:
       15:  561:		deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  562:
       15:  563:		if (deckCounter == 0)
       15:  564:			return -1;
        -:  565:
    #####:  566:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
    #####:  567:		state->deckCount[player]--;
    #####:  568:		state->handCount[player]++;//Increment hand count
        -:  569:	}
        -:  570:
        -:  571:	else{
       50:  572:		int count = state->handCount[player];//Get current hand count for player
        -:  573:		int deckCounter;
        -:  574:		if (DEBUG){//Debug statements
        -:  575:			printf("Current hand count: %d\n", count);
        -:  576:		}
        -:  577:
       50:  578:		deckCounter = state->deckCount[player];//Create holder for the deck count
       50:  579:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
       50:  580:		state->deckCount[player]--;
       50:  581:		state->handCount[player]++;//Increment hand count
        -:  582:	}
        -:  583:
       50:  584:	return 0;
        -:  585:}
        -:  586:
    #####:  587:int getCost(int cardNumber)
        -:  588:{
    #####:  589:	switch (cardNumber)
        -:  590:	{
        -:  591:	case curse:
    #####:  592:		return 0;
        -:  593:	case estate:
    #####:  594:		return 2;
        -:  595:	case duchy:
    #####:  596:		return 5;
        -:  597:	case province:
    #####:  598:		return 8;
        -:  599:	case copper:
    #####:  600:		return 0;
        -:  601:	case silver:
    #####:  602:		return 3;
        -:  603:	case gold:
    #####:  604:		return 6;
        -:  605:	case adventurer:
    #####:  606:		return 6;
        -:  607:	case council_room:
    #####:  608:		return 5;
        -:  609:	case feast:
    #####:  610:		return 4;
        -:  611:	case gardens:
    #####:  612:		return 4;
        -:  613:	case mine:
    #####:  614:		return 5;
        -:  615:	case remodel:
    #####:  616:		return 4;
        -:  617:	case smithy:
    #####:  618:		return 4;
        -:  619:	case village:
    #####:  620:		return 3;
        -:  621:	case baron:
    #####:  622:		return 4;
        -:  623:	case great_hall:
    #####:  624:		return 3;
        -:  625:	case minion:
    #####:  626:		return 5;
        -:  627:	case steward:
    #####:  628:		return 3;
        -:  629:	case tribute:
    #####:  630:		return 5;
        -:  631:	case ambassador:
    #####:  632:		return 3;
        -:  633:	case cutpurse:
    #####:  634:		return 4;
        -:  635:	case embargo:
    #####:  636:		return 2;
        -:  637:	case outpost:
    #####:  638:		return 5;
        -:  639:	case salvager:
    #####:  640:		return 4;
        -:  641:	case sea_hag:
    #####:  642:		return 4;
        -:  643:	case treasure_map:
    #####:  644:		return 4;
        -:  645:	}
        -:  646:
    #####:  647:	return -1;
        -:  648:}
        -:  649:
    #####:  650:void playAdventurer(struct gameState *state, int currentPlayer)
        -:  651:// Reveal cards from deck until 2 Treasure cards are found.  Put those Treasure cards in the hand and discard the rest.
        -:  652:{
    #####:  653:	int drawntreasure = 0;
        -:  654:	int temphand[MAX_HAND];
        -:  655:	int cardDrawn;
    #####:  656:	int z = 0; // this is the counter for the temp hand
        -:  657:
    #####:  658:	while (drawntreasure < 2){
    #####:  659:		if (state->deckCount[currentPlayer] < 1){//if the deck is empty we need to shuffle discard and add to deck
    #####:  660:			shuffle(currentPlayer, state);
        -:  661:		}
    #####:  662:		drawCard(currentPlayer, state);
    #####:  663:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer] - 1];//top card of hand is most recently drawn card.
    #####:  664:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
    #####:  665:			drawntreasure++;
        -:  666:		else{
    #####:  667:			temphand[z] = cardDrawn;
    #####:  668:			state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####:  669:			z++;
        -:  670:		}
        -:  671:	}
    #####:  672:	while (z - 1 >= 0){
    #####:  673:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; // discard all cards in play that have been drawn
    #####:  674:		z = z - 1;
        -:  675:	}
    #####:  676:}
        -:  677:
    #####:  678:int playRemodel(struct gameState *state, int currentPlayer, int choice1, int choice2, int handPos)
        -:  679://Trash a card in the hand, and gain a card costing up to $2 more than the trashed card
        -:  680:{
        -:  681:	int i;
    #####:  682:	int j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  683:
    #####:  684:	if ((getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2))
        -:  685:	{
    #####:  686:		return -1;
        -:  687:	}
        -:  688:
    #####:  689:	gainCard(choice2, state, 0, currentPlayer);
        -:  690:
        -:  691:	//discard card from hand
    #####:  692:	discardCard(handPos, currentPlayer, state, 0);
        -:  693:
        -:  694:	//discard trashed card
    #####:  695:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  696:	{
    #####:  697:		if (state->hand[currentPlayer][i] == j)
        -:  698:		{
    #####:  699:			discardCard(i, currentPlayer, state, 0);
    #####:  700:			break;
        -:  701:		}
        -:  702:	}
        -:  703:
    #####:  704:	return 0;
        -:  705:}
        -:  706:
    #####:  707:void playSmithy(struct gameState *state, int currentPlayer, int handPos)
        -:  708:// Draw 3 cards
        -:  709:{
        -:  710:	int i;
    #####:  711:	for (i = 0; i < 3; i++)
        -:  712:	{
    #####:  713:		drawCard(currentPlayer, state);
        -:  714:	}
        -:  715:
        -:  716:	//discard card from hand
    #####:  717:	discardCard(handPos, currentPlayer, state, 0);
    #####:  718:}
        -:  719:
    #####:  720:void playBaron(struct gameState *state, int currentPlayer, int choice1, int handPos)
        -:  721://Add a buy.  OPTION:  Discard an Estate card and gain $4.  Otherwise, gain an Estate card.
        -:  722:{
    #####:  723:	state->numBuys++;//Increase buys by 1!
    #####:  724:	if (choice1 > 0){//Boolean true or going to discard an estate
    #####:  725:		int p = 0;//Iterator for hand!
    #####:  726:		int card_not_discarded = 1;//Flag for discard set!
    #####:  727:		while (card_not_discarded){
    #####:  728:			if (state->hand[currentPlayer][p] == estate){ //Found an estate card!
    #####:  729:				state->coins += 4;//Add 4 coins to the amount of coins
    #####:  730:				state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  731:				state->discardCount[currentPlayer]++;
    #####:  732:				for (; p < state->handCount[currentPlayer]; p++){
    #####:  733:					state->hand[currentPlayer][p] = state->hand[currentPlayer][p + 1];
        -:  734:				}
    #####:  735:				state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  736:				state->handCount[currentPlayer]--;
    #####:  737:				card_not_discarded = 0;//Exit the loop
        -:  738:			}
    #####:  739:			else if (p > state->handCount[currentPlayer]){
        -:  740:				if (DEBUG) {
        -:  741:					printf("No estate cards in your hand, invalid choice\n");
        -:  742:					printf("Must gain an estate if there are any\n");
        -:  743:				}
    #####:  744:				if (supplyCount(estate, state) > 0){
    #####:  745:					gainCard(estate, state, 1, currentPlayer);
    #####:  746:					state->supplyCount[estate]--;//Decrement estates
    #####:  747:					if (supplyCount(estate, state) == 0){
    #####:  748:						isGameOver(state);
        -:  749:					}
        -:  750:				}
    #####:  751:				card_not_discarded = 0;//Exit the loop
        -:  752:			}
        -:  753:
        -:  754:			else{
    #####:  755:				p++;//Next card
        -:  756:			}
        -:  757:		}
        -:  758:	}
        -:  759:
        -:  760:	else{
    #####:  761:		if (supplyCount(estate, state) > 0){
    #####:  762:			gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  763:			state->supplyCount[estate]--;//Decrement Estates
    #####:  764:			if (supplyCount(estate, state) == 0){
    #####:  765:				isGameOver(state);
        -:  766:			}
        -:  767:		}
        -:  768:	}
    #####:  769:}
        -:  770:
    #####:  771:int playTreasureMap(struct gameState *state, int currentPlayer, int handPos)
        -:  772://Trashing two treasure map cards from the hand = four gold on top of the deck.
        -:  773:{
        -:  774:	int i;
        -:  775:	int index;
        -:  776:
        -:  777:	//search hand for another treasure_map
    #####:  778:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  779:	{
    #####:  780:		if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -:  781:		{
    #####:  782:			index = i;
    #####:  783:			break;
        -:  784:		}
        -:  785:	}
    #####:  786:	if (index > -1)
        -:  787:	{
        -:  788:		//trash both treasure cards
    #####:  789:		discardCard(handPos, currentPlayer, state, 1);
    #####:  790:		discardCard(index, currentPlayer, state, 1);
        -:  791:
        -:  792:		//gain 4 Gold cards
    #####:  793:		for (i = 0; i < 4; i++)
        -:  794:		{
    #####:  795:			gainCard(gold, state, 1, currentPlayer);
        -:  796:		}
        -:  797:
        -:  798:		//return success
    #####:  799:		return 1;
        -:  800:	}
        -:  801:
        -:  802:	//no second treasure_map found in hand
    #####:  803:	return -1;
        -:  804:}
        -:  805:
    #####:  806:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  807:{
        -:  808:	int i;
        -:  809:	int j;
        -:  810:	int k;
        -:  811:	//int x;  //Unused after while loop removed from feast.
    #####:  812:	int currentPlayer = whoseTurn(state);
    #####:  813:	int nextPlayer = currentPlayer + 1;
        -:  814:	int temphand[MAX_HAND];
        -:  815:
    #####:  816:	int tributeRevealedCards[2] = { -1, -1 };
        -:  817:
    #####:  818:	if (nextPlayer > (state->numPlayers - 1)){
    #####:  819:		nextPlayer = 0;
        -:  820:	}
        -:  821:
        -:  822:	//uses switch to select card and perform actions
    #####:  823:	switch (card)
        -:  824:	{
        -:  825:	case adventurer:
        -:  826:
    #####:  827:		playAdventurer(state, currentPlayer);
    #####:  828:		return 0;
        -:  829:
        -:  830:	case council_room:
        -:  831:		//+4 Cards
    #####:  832:		for (i = 0; i < 4; i++)
        -:  833:		{
    #####:  834:			drawCard(currentPlayer, state);
        -:  835:		}
        -:  836:
        -:  837:		//+1 Buy
    #####:  838:		state->numBuys++;
        -:  839:
        -:  840:		//Each other player draws a card
    #####:  841:		for (i = 0; i < state->numPlayers; i++)
        -:  842:		{
    #####:  843:			if (i != currentPlayer)
        -:  844:			{
    #####:  845:				drawCard(i, state);
        -:  846:			}
        -:  847:		}
        -:  848:
        -:  849:		//put played card in played card pile
    #####:  850:		discardCard(handPos, currentPlayer, state, 0);
        -:  851:
    #####:  852:		return 0;
        -:  853:
        -:  854:	case feast:
        -:  855:		//gain card with cost up to 5
        -:  856:		//Backup hand
    #####:  857:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  858:			temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  859:			state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  860:		}
        -:  861:		//Backup hand
        -:  862:
        -:  863:		//Update Coins for Buy
    #####:  864:		updateCoins(currentPlayer, state, 5);
        -:  865://		x = 1;//Condition to loop on
        -:  866://		while (x == 1) {//Buy one card
    #####:  867:			if (supplyCount(choice1, state) <= 0){
        -:  868:				if (DEBUG)
        -:  869:					printf("None of that card left, sorry!\n");
        -:  870:
        -:  871:				if (DEBUG){
        -:  872:					printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  873:				}
        -:  874:			}
    #####:  875:			else if (state->coins < getCost(choice1)){
    #####:  876:				printf("That card is too expensive!\n");
        -:  877:
        -:  878:				if (DEBUG){
        -:  879:					printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  880:				}
        -:  881:			}
        -:  882:			else{
        -:  883:
        -:  884:				if (DEBUG){
        -:  885:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  886:				}
        -:  887:
    #####:  888:				gainCard(choice1, state, 0, currentPlayer);//Gain the card
        -:  889://				x = 0;//No more buying cards
        -:  890:
        -:  891:				if (DEBUG){
        -:  892:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  893:				}
        -:  894:
        -:  895:			}
        -:  896://		}
        -:  897:
        -:  898:		//Reset Hand
    #####:  899:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  900:			state->hand[currentPlayer][i] = temphand[i];
    #####:  901:			temphand[i] = -1;
        -:  902:		}
        -:  903:		//Reset Hand
        -:  904:
    #####:  905:		return 0;
        -:  906:
        -:  907:	case gardens:
    #####:  908:		return -1;
        -:  909:
        -:  910:	case mine:
    #####:  911:		j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  912:
    #####:  913:		if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  914:		{
    #####:  915:			return -1;
        -:  916:		}
        -:  917:
    #####:  918:		if (choice2 > treasure_map || choice2 < curse)
        -:  919:		{
    #####:  920:			return -1;
        -:  921:		}
        -:  922:
    #####:  923:		if ((getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2))
        -:  924:		{
    #####:  925:			return -1;
        -:  926:		}
        -:  927:
    #####:  928:		gainCard(choice2, state, 2, currentPlayer);
        -:  929:
        -:  930:		//discard card from hand
    #####:  931:		discardCard(handPos, currentPlayer, state, 0);
        -:  932:
        -:  933:		//discard trashed card
    #####:  934:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  935:		{
    #####:  936:			if (state->hand[currentPlayer][i] == j)
        -:  937:			{
    #####:  938:				discardCard(i, currentPlayer, state, 0);
    #####:  939:				break;
        -:  940:			}
        -:  941:		}
        -:  942:
    #####:  943:		return 0;
        -:  944:
        -:  945:	case remodel:
        -:  946:
    #####:  947:		return playRemodel(state, currentPlayer, choice1, choice2, handPos);
        -:  948:
        -:  949:	case smithy:
        -:  950:
    #####:  951:		playSmithy(state, currentPlayer, handPos);
    #####:  952:		return 0;
        -:  953:
        -:  954:	case village:
        -:  955:		//+1 Card
    #####:  956:		drawCard(currentPlayer, state);
        -:  957:
        -:  958:		//+2 Actions
    #####:  959:		state->numActions = state->numActions + 2;
        -:  960:
        -:  961:		//discard played card from hand
    #####:  962:		discardCard(handPos, currentPlayer, state, 0);
    #####:  963:		return 0;
        -:  964:
        -:  965:	case baron:
        -:  966:
    #####:  967:		playBaron(state, currentPlayer, choice1, handPos);
    #####:  968:		return 0;
        -:  969:
        -:  970:	case great_hall:
        -:  971:		//+1 Card
    #####:  972:		drawCard(currentPlayer, state);
        -:  973:
        -:  974:		//+1 Actions
    #####:  975:		state->numActions++;
        -:  976:
        -:  977:		//discard card from hand
    #####:  978:		discardCard(handPos, currentPlayer, state, 0);
    #####:  979:		return 0;
        -:  980:
        -:  981:	case minion:
        -:  982:		//+1 action
    #####:  983:		state->numActions++;
        -:  984:
        -:  985:		//discard card from hand
    #####:  986:		discardCard(handPos, currentPlayer, state, 0);
        -:  987:
    #####:  988:		if (choice1)		//+2 coins
        -:  989:		{
    #####:  990:			state->coins = state->coins + 2;
        -:  991:		}
        -:  992:
    #####:  993:		else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  994:		{
        -:  995:			//discard hand
    #####:  996:			while (numHandCards(state) > 0)
        -:  997:			{
    #####:  998:				discardCard(handPos, currentPlayer, state, 0);
        -:  999:			}
        -: 1000:
        -: 1001:			//draw 4
    #####: 1002:			for (i = 0; i < 4; i++)
        -: 1003:			{
    #####: 1004:				drawCard(currentPlayer, state);
        -: 1005:			}
        -: 1006:
        -: 1007:			//other players discard hand and redraw if hand size > 4
    #####: 1008:			for (i = 0; i < state->numPlayers; i++)
        -: 1009:			{
    #####: 1010:				if (i != currentPlayer)
        -: 1011:				{
    #####: 1012:					if (state->handCount[i] > 4)
        -: 1013:					{
        -: 1014:						//discard hand
    #####: 1015:						while (state->handCount[i] > 0)
        -: 1016:						{
    #####: 1017:							discardCard(handPos, i, state, 0);
        -: 1018:						}
        -: 1019:
        -: 1020:						//draw 4
    #####: 1021:						for (j = 0; j < 4; j++)
        -: 1022:						{
    #####: 1023:							drawCard(i, state);
        -: 1024:						}
        -: 1025:					}
        -: 1026:				}
        -: 1027:			}
        -: 1028:
        -: 1029:		}
    #####: 1030:		return 0;
        -: 1031:
        -: 1032:	case steward:
    #####: 1033:		if (choice1 == 1)
        -: 1034:		{
        -: 1035:			//+2 cards
    #####: 1036:			drawCard(currentPlayer, state);
    #####: 1037:			drawCard(currentPlayer, state);
        -: 1038:		}
    #####: 1039:		else if (choice1 == 2)
        -: 1040:		{
        -: 1041:			//+2 coins
    #####: 1042:			state->coins = state->coins + 2;
        -: 1043:		}
        -: 1044:		else
        -: 1045:		{
        -: 1046:			//trash 2 cards in hand
    #####: 1047:			discardCard(choice2, currentPlayer, state, 1);
    #####: 1048:			discardCard(choice3, currentPlayer, state, 1);
        -: 1049:		}
        -: 1050:
        -: 1051:		//discard card from hand
    #####: 1052:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1053:		return 0;
        -: 1054:
        -: 1055:	case tribute:
    #####: 1056:		if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####: 1057:			if (state->deckCount[nextPlayer] > 0){
    #####: 1058:				tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1059:				state->deckCount[nextPlayer]--;
        -: 1060:			}
    #####: 1061:			else if (state->discardCount[nextPlayer] > 0){
    #####: 1062:				tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer] - 1];
    #####: 1063:				state->discardCount[nextPlayer]--;
        -: 1064:			}
        -: 1065:			else{
        -: 1066:				//No Card to Reveal
        -: 1067:				if (DEBUG){
        -: 1068:					printf("No cards to reveal\n");
        -: 1069:				}
        -: 1070:			}
        -: 1071:		}
        -: 1072:
        -: 1073:		else{
    #####: 1074:			if (state->deckCount[nextPlayer] == 0){
    #####: 1075:				for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####: 1076:					state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1077:					state->deckCount[nextPlayer]++;
    #####: 1078:					state->discard[nextPlayer][i] = -1;
    #####: 1079:					state->discardCount[nextPlayer]--;
        -: 1080:				}
        -: 1081:
    #####: 1082:				shuffle(nextPlayer, state);//Shuffle the deck
        -: 1083:			}
    #####: 1084:			tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1085:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1086:			state->deckCount[nextPlayer]--;
    #####: 1087:			tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1088:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1089:			state->deckCount[nextPlayer]--;
        -: 1090:		}
        -: 1091:
    #####: 1092:		if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
    #####: 1093:			state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1094:			state->playedCardCount++;
    #####: 1095:			tributeRevealedCards[1] = -1;
        -: 1096:		}
        -: 1097:
    #####: 1098:		for (i = 0; i <= 2; i++){
    #####: 1099:			if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
    #####: 1100:				state->coins += 2;
        -: 1101:			}
        -: 1102:
    #####: 1103:			else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
    #####: 1104:				drawCard(currentPlayer, state);
    #####: 1105:				drawCard(currentPlayer, state);
        -: 1106:			}
        -: 1107:			else{//Action Card
    #####: 1108:				state->numActions = state->numActions + 2;
        -: 1109:			}
        -: 1110:		}
        -: 1111:
    #####: 1112:		return 0;
        -: 1113:
        -: 1114:	case ambassador:
    #####: 1115:		j = 0;		//used to check if player has enough cards to discard
        -: 1116:
    #####: 1117:		if (choice2 > 2 || choice2 < 0)
        -: 1118:		{
    #####: 1119:			return -1;
        -: 1120:		}
        -: 1121:
    #####: 1122:		if (choice1 == handPos)
        -: 1123:		{
    #####: 1124:			return -1;
        -: 1125:		}
        -: 1126:
    #####: 1127:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1128:		{
    #####: 1129:			if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1130:			{
    #####: 1131:				j++;
        -: 1132:			}
        -: 1133:		}
    #####: 1134:		if (j < choice2)
        -: 1135:		{
    #####: 1136:			return -1;
        -: 1137:		}
        -: 1138:
        -: 1139:		if (DEBUG)
        -: 1140:			printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1141:
        -: 1142:		//increase supply count for choosen card by amount being discarded
    #####: 1143:		state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1144:
        -: 1145:		//each other player gains a copy of revealed card
    #####: 1146:		for (i = 0; i < state->numPlayers; i++)
        -: 1147:		{
    #####: 1148:			if (i != currentPlayer)
        -: 1149:			{
    #####: 1150:				gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1151:			}
        -: 1152:		}
        -: 1153:
        -: 1154:		//discard played card from hand
    #####: 1155:		discardCard(handPos, currentPlayer, state, 0);
        -: 1156:
        -: 1157:		//trash copies of cards returned to supply
    #####: 1158:		for (j = 0; j < choice2; j++)
        -: 1159:		{
    #####: 1160:			for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1161:			{
    #####: 1162:				if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1163:				{
    #####: 1164:					discardCard(i, currentPlayer, state, 1);
    #####: 1165:					break;
        -: 1166:				}
        -: 1167:			}
        -: 1168:		}
        -: 1169:
    #####: 1170:		return 0;
        -: 1171:
        -: 1172:	case cutpurse:
        -: 1173:
    #####: 1174:		updateCoins(currentPlayer, state, 2);
    #####: 1175:		for (i = 0; i < state->numPlayers; i++)
        -: 1176:		{
    #####: 1177:			if (i != currentPlayer)
        -: 1178:			{
    #####: 1179:				for (j = 0; j < state->handCount[i]; j++)
        -: 1180:				{
    #####: 1181:					if (state->hand[i][j] == copper)
        -: 1182:					{
    #####: 1183:						discardCard(j, i, state, 0);
    #####: 1184:						break;
        -: 1185:					}
    #####: 1186:					if (j == state->handCount[i])
        -: 1187:					{
    #####: 1188:						for (k = 0; k < state->handCount[i]; k++)
        -: 1189:						{
        -: 1190:							if (DEBUG)
        -: 1191:								printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1192:						}
    #####: 1193:						break;
        -: 1194:					}
        -: 1195:				}
        -: 1196:
        -: 1197:			}
        -: 1198:
        -: 1199:		}
        -: 1200:
        -: 1201:		//discard played card from hand
    #####: 1202:		discardCard(handPos, currentPlayer, state, 0);
        -: 1203:
    #####: 1204:		return 0;
        -: 1205:
        -: 1206:
        -: 1207:	case embargo:
        -: 1208:		//+2 Coins
    #####: 1209:		state->coins = state->coins + 2;
        -: 1210:
        -: 1211:		//see if selected pile is in play
    #####: 1212:		if (state->supplyCount[choice1] == -1)
        -: 1213:		{
    #####: 1214:			return -1;
        -: 1215:		}
        -: 1216:
        -: 1217:		//add embargo token to selected supply pile
    #####: 1218:		state->embargoTokens[choice1]++;
        -: 1219:
        -: 1220:		//trash card
    #####: 1221:		discardCard(handPos, currentPlayer, state, 1);
    #####: 1222:		return 0;
        -: 1223:
        -: 1224:	case outpost:
        -: 1225:		//set outpost flag
    #####: 1226:		state->outpostPlayed++;
        -: 1227:
        -: 1228:		//discard card
    #####: 1229:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1230:		return 0;
        -: 1231:
        -: 1232:	case salvager:
        -: 1233:		//+1 buy
    #####: 1234:		state->numBuys++;
        -: 1235:
    #####: 1236:		if (choice1)
        -: 1237:		{
        -: 1238:			//gain coins equal to trashed card
    #####: 1239:			state->coins = state->coins + getCost(handCard(choice1, state));
        -: 1240:			//trash card
    #####: 1241:			discardCard(choice1, currentPlayer, state, 1);
        -: 1242:		}
        -: 1243:
        -: 1244:		//discard card
    #####: 1245:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1246:		return 0;
        -: 1247:
        -: 1248:	case sea_hag:
    #####: 1249:		for (i = 0; i < state->numPlayers; i++){
    #####: 1250:			if (i != currentPlayer){
    #####: 1251:				state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1252:				state->discardCount[i]++;
    #####: 1253:				state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1254:			}
        -: 1255:		}
    #####: 1256:		return 0;
        -: 1257:
        -: 1258:	case treasure_map:
        -: 1259:
    #####: 1260:		return playTreasureMap(state, currentPlayer, handPos);
        -: 1261:	}
    #####: 1262:	return -1;
        -: 1263:}
        -: 1264:
    #####: 1265:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1266:{
        -: 1267:
        -: 1268:	//if card is not trashed, added to Played pile 
    #####: 1269:	if (trashFlag < 1)
        -: 1270:	{
        -: 1271:		//add card to played pile
    #####: 1272:		state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
    #####: 1273:		state->playedCardCount++;
        -: 1274:	}
        -: 1275:
        -: 1276:	//set played card to -1
    #####: 1277:	state->hand[currentPlayer][handPos] = -1;
        -: 1278:
        -: 1279:	//remove card from player's hand
    #####: 1280:	if (handPos == (state->handCount[currentPlayer] - 1)) 	//last card in hand array is played
        -: 1281:	{
        -: 1282:		//reduce number of cards in hand
    #####: 1283:		state->handCount[currentPlayer]--;
        -: 1284:	}
    #####: 1285:	else if (state->handCount[currentPlayer] == 1) //only one card in hand
        -: 1286:	{
        -: 1287:		//reduce number of cards in hand
    #####: 1288:		state->handCount[currentPlayer]--;
        -: 1289:	}
        -: 1290:	else
        -: 1291:	{
        -: 1292:		//replace discarded card with last card in hand
    #####: 1293:		state->hand[currentPlayer][handPos] = state->hand[currentPlayer][(state->handCount[currentPlayer] - 1)];
        -: 1294:		//set last card to -1
    #####: 1295:		state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1296:		//reduce number of cards in hand
    #####: 1297:		state->handCount[currentPlayer]--;
        -: 1298:	}
        -: 1299:
    #####: 1300:	return 0;
        -: 1301:}
        -: 1302:
    #####: 1303:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1304:{
        -: 1305:	//Note: supplyPos is enum of choosen card
        -: 1306:
        -: 1307:	//check if supply pile is empty (0) or card is not used in game (-1)
    #####: 1308:	if (supplyCount(supplyPos, state) < 1)
        -: 1309:	{
    #####: 1310:		return -1;
        -: 1311:	}
        -: 1312:
        -: 1313:	//added card for [whoseTurn] current player:
        -: 1314:	// toFlag = 0 : add to discard
        -: 1315:	// toFlag = 1 : add to deck
        -: 1316:	// toFlag = 2 : add to hand
        -: 1317:
    #####: 1318:	if (toFlag == 1)
        -: 1319:	{
    #####: 1320:		state->deck[player][state->deckCount[player]] = supplyPos;
    #####: 1321:		state->deckCount[player]++;
        -: 1322:	}
    #####: 1323:	else if (toFlag == 2)
        -: 1324:	{
    #####: 1325:		state->hand[player][state->handCount[player]] = supplyPos;
    #####: 1326:		state->handCount[player]++;
        -: 1327:	}
        -: 1328:	else
        -: 1329:	{
    #####: 1330:		state->discard[player][state->discardCount[player]] = supplyPos;
    #####: 1331:		state->discardCount[player]++;
        -: 1332:	}
        -: 1333:
        -: 1334:	//decrease number in supply pile
    #####: 1335:	state->supplyCount[supplyPos]--;
        -: 1336:
    #####: 1337:	return 0;
        -: 1338:}
        -: 1339:
       13: 1340:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1341:{
        -: 1342:	int i;
        -: 1343:
        -: 1344:	//reset coin count
       13: 1345:	state->coins = 0;
        -: 1346:
        -: 1347:	//add coins for each Treasure card in player's hand
       63: 1348:	for (i = 0; i < state->handCount[player]; i++)
        -: 1349:	{
       50: 1350:		if (state->hand[player][i] == copper)
        -: 1351:		{
       31: 1352:			state->coins += 1;
        -: 1353:		}
       19: 1354:		else if (state->hand[player][i] == silver)
        -: 1355:		{
    #####: 1356:			state->coins += 2;
        -: 1357:		}
       19: 1358:		else if (state->hand[player][i] == gold)
        -: 1359:		{
    #####: 1360:			state->coins += 3;
        -: 1361:		}
        -: 1362:	}
        -: 1363:
        -: 1364:	//add bonus
       13: 1365:	state->coins += bonus;
        -: 1366:
       13: 1367:	return 0;
        -: 1368:}
        -: 1369:
        -: 1370:
        -: 1371://end of dominion.c
File 'dominion.c'
Lines executed:27.11% of 557
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
      406:    8:int compare(const void* a, const void* b) {
      406:    9:	if (*(int*)a > *(int*)b)
    #####:   10:		return 1;
      406:   11:	if (*(int*)a < *(int*)b)
      145:   12:		return -1;
      261:   13:	return 0;
        -:   14:}
        -:   15:
       20:   16:struct gameState* newGame() {
       20:   17:	struct gameState* g = malloc(sizeof(struct gameState));
       20:   18:	return g;
        -:   19:}
        -:   20:
      147:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:	int k8, int k9, int k10) {
      147:   23:	int* k = malloc(10 * sizeof(int));
      147:   24:	k[0] = k1;
      147:   25:	k[1] = k2;
      147:   26:	k[2] = k3;
      147:   27:	k[3] = k4;
      147:   28:	k[4] = k5;
      147:   29:	k[5] = k6;
      147:   30:	k[6] = k7;
      147:   31:	k[7] = k8;
      147:   32:	k[8] = k9;
      147:   33:	k[9] = k10;
      147:   34:	return k;
        -:   35:}
        -:   36:
      147:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		struct gameState *state) {
        -:   39:
        -:   40:	int i;
        -:   41:	int j;
        -:   42:	int it;
        -:   43:	//set up random number generator
      147:   44:	SelectStream(1);
      147:   45:	PutSeed((long)randomSeed);
        -:   46:
        -:   47:	//check number of players
      147:   48:	if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:	{
    #####:   50:		return -1;
        -:   51:	}
        -:   52:
        -:   53:	//set number of players
      147:   54:	state->numPlayers = numPlayers;
        -:   55:
        -:   56:	//check selected kingdom cards are different
      426:   57:	for (i = 0; i < 10; i++)
        -:   58:	{
     3942:   59:		for (j = 0; j < 10; j++)
        -:   60:		{
     3663:   61:			if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:			{
      137:   63:				return -1;
        -:   64:			}
        -:   65:		}
        -:   66:	}
        -:   67:
        -:   68:
        -:   69:	//initialize supply
        -:   70:	///////////////////////////////
        -:   71:
        -:   72:	//set number of Curse cards
       10:   73:	if (numPlayers == 2)
        -:   74:	{
        3:   75:		state->supplyCount[curse] = 10;
        -:   76:	}
        7:   77:	else if (numPlayers == 3)
        -:   78:	{
        5:   79:		state->supplyCount[curse] = 20;
        -:   80:	}
        -:   81:	else
        -:   82:	{
        2:   83:		state->supplyCount[curse] = 30;
        -:   84:	}
        -:   85:
        -:   86:	//set number of Victory cards
       10:   87:	if (numPlayers == 2)
        -:   88:	{
        3:   89:		state->supplyCount[estate] = 8;
        3:   90:		state->supplyCount[duchy] = 8;
        3:   91:		state->supplyCount[province] = 8;
        -:   92:	}
        -:   93:	else
        -:   94:	{
        7:   95:		state->supplyCount[estate] = 12;
        7:   96:		state->supplyCount[duchy] = 12;
        7:   97:		state->supplyCount[province] = 12;
        -:   98:	}
        -:   99:
        -:  100:	//set number of Treasure cards
       10:  101:	state->supplyCount[copper] = 60 - (7 * numPlayers);
       10:  102:	state->supplyCount[silver] = 40;
       10:  103:	state->supplyCount[gold] = 30;
        -:  104:
        -:  105:	//set number of Kingdom cards
      210:  106:	for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:	{
     1650:  108:		for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:		{
     1550:  110:			if (kingdomCards[j] == i)
        -:  111:			{
        -:  112:				//check if card is a 'Victory' Kingdom card
      100:  113:				if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:				{
       16:  115:					if (numPlayers == 2){
        2:  116:						state->supplyCount[i] = 8;
        -:  117:					}
        6:  118:					else{ state->supplyCount[i] = 12; }
        -:  119:				}
        -:  120:				else
        -:  121:				{
       92:  122:					state->supplyCount[i] = 10;
        -:  123:				}
      100:  124:				break;
        -:  125:			}
        -:  126:			else    //card is not in the set choosen for the game
        -:  127:			{
     1450:  128:				state->supplyCount[i] = -1;
        -:  129:			}
        -:  130:		}
        -:  131:
        -:  132:	}
        -:  133:
        -:  134:	////////////////////////
        -:  135:	//supply intilization complete
        -:  136:
        -:  137:	//set player decks
       39:  138:	for (i = 0; i < numPlayers; i++)
        -:  139:	{
       29:  140:		state->deckCount[i] = 0;
      116:  141:		for (j = 0; j < 3; j++)
        -:  142:		{
       87:  143:			state->deck[i][j] = estate;
       87:  144:			state->deckCount[i]++;
        -:  145:		}
      232:  146:		for (j = 3; j < 10; j++)
        -:  147:		{
      203:  148:			state->deck[i][j] = copper;
      203:  149:			state->deckCount[i]++;
        -:  150:		}
        -:  151:	}
        -:  152:
        -:  153:	//shuffle player decks
       39:  154:	for (i = 0; i < numPlayers; i++)
        -:  155:	{
       29:  156:		if (shuffle(i, state) < 0)
        -:  157:		{
    #####:  158:			return -1;
        -:  159:		}
        -:  160:	}
        -:  161:
        -:  162:	//draw player hands
       39:  163:	for (i = 0; i < numPlayers; i++)
        -:  164:	{
        -:  165:		//initialize hand size to zero
       29:  166:		state->handCount[i] = 0;
       29:  167:		state->discardCount[i] = 0;
        -:  168:		//draw 5 cards
        -:  169:		// for (j = 0; j < 5; j++)
        -:  170:		//	{
        -:  171:		//	  drawCard(i, state);
        -:  172:		//	}
        -:  173:	}
        -:  174:
        -:  175:	//set embargo tokens to 0 for all supply piles
      280:  176:	for (i = 0; i <= treasure_map; i++)
        -:  177:	{
      270:  178:		state->embargoTokens[i] = 0;
        -:  179:	}
        -:  180:
        -:  181:	//initialize first player's turn
       10:  182:	state->outpostPlayed = 0;
       10:  183:	state->phase = 0;
       10:  184:	state->numActions = 1;
       10:  185:	state->numBuys = 1;
       10:  186:	state->playedCardCount = 0;
       10:  187:	state->whoseTurn = 0;
       10:  188:	state->handCount[state->whoseTurn] = 0;
        -:  189:	//int it; move to top
        -:  190:
        -:  191:	//Moved draw cards to here, only drawing at the start of a turn
       60:  192:	for (it = 0; it < 5; it++){
       50:  193:		drawCard(state->whoseTurn, state);
        -:  194:	}
        -:  195:
       10:  196:	updateCoins(state->whoseTurn, state, 0);
        -:  197:
       10:  198:	return 0;
        -:  199:}
        -:  200:
       49:  201:int shuffle(int player, struct gameState *state) {
        -:  202:
        -:  203:
        -:  204:	int newDeck[MAX_DECK];
       49:  205:	int newDeckPos = 0;
        -:  206:	int card;
        -:  207:	int i;
        -:  208:
       49:  209:	if (state->deckCount[player] < 1)
       20:  210:		return -1;
       29:  211:	qsort((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
        -:  212:	/* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
      348:  214:	while (state->deckCount[player] > 0) {
      290:  215:		card = floor(Random() * state->deckCount[player]);
      290:  216:		newDeck[newDeckPos] = state->deck[player][card];
      290:  217:		newDeckPos++;
      924:  218:		for (i = card; i < state->deckCount[player] - 1; i++) {
      634:  219:			state->deck[player][i] = state->deck[player][i + 1];
        -:  220:		}
      290:  221:		state->deckCount[player]--;
        -:  222:	}
      319:  223:	for (i = 0; i < newDeckPos; i++) {
      290:  224:		state->deck[player][i] = newDeck[i];
      290:  225:		state->deckCount[player]++;
        -:  226:	}
        -:  227:
       29:  228:	return 0;
        -:  229:}
        -:  230:
        2:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state)
        -:  232:{
        -:  233:	int card;
        2:  234:	int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:	//check if it is the right phase
        2:  237:	if (state->phase != 0)
        -:  238:	{
    #####:  239:		return -1;
        -:  240:	}
        -:  241:
        -:  242:	//check if player has enough actions
        2:  243:	if (state->numActions < 1)
        -:  244:	{
        2:  245:		return -1;
        -:  246:	}
        -:  247:
        -:  248:	//get card played
    #####:  249:	card = handCard(handPos, state);
        -:  250:
        -:  251:	//check if selected card is an action
    #####:  252:	if (card < adventurer || card > treasure_map)
        -:  253:	{
    #####:  254:		return -1;
        -:  255:	}
        -:  256:
        -:  257:	//play card
    #####:  258:	if (cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0)
        -:  259:	{
    #####:  260:		return -1;
        -:  261:	}
        -:  262:
        -:  263:	//reduce number of actions
    #####:  264:	state->numActions--;
        -:  265:
        -:  266:	//update coins (Treasure cards may be added with card draws)
    #####:  267:	updateCoins(state->whoseTurn, state, coin_bonus);
        -:  268:
    #####:  269:	return 0;
        -:  270:}
        -:  271:
        4:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:	int who;
        -:  274:	if (DEBUG){
        -:  275:		printf("Entering buyCard...\n");
        -:  276:	}
        -:  277:
        -:  278:	// I don't know what to do about the phase thing.
        -:  279:
        4:  280:	who = state->whoseTurn;
        -:  281:
        4:  282:	if (state->numBuys < 1){
        -:  283:		if (DEBUG)
        -:  284:			printf("You do not have any buys left\n");
        4:  285:		return -1;
        -:  286:	}
    #####:  287:	else if (supplyCount(supplyPos, state) < 1){
        -:  288:		if (DEBUG)
        -:  289:			printf("There are not any of that type of card left\n");
    #####:  290:		return -1;
        -:  291:	}
    #####:  292:	else if (state->coins < getCost(supplyPos)){
        -:  293:		if (DEBUG)
        -:  294:			printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  295:		return -1;
        -:  296:	}
        -:  297:	else {
    #####:  298:		state->phase = 1;
        -:  299:		//state->supplyCount[supplyPos]--;
    #####:  300:		gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  301:
    #####:  302:		state->coins = (state->coins) - (getCost(supplyPos));
    #####:  303:		state->numBuys--;
        -:  304:		if (DEBUG)
        -:  305:			printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  306:	}
        -:  307:
        -:  308:	//state->discard[who][state->discardCount[who]] = supplyPos;
        -:  309:	//state->discardCount[who]++;
        -:  310:
    #####:  311:	return 0;
        -:  312:}
        -:  313:
    #####:  314:int numHandCards(struct gameState *state) {
    #####:  315:	return state->handCount[whoseTurn(state)];
        -:  316:}
        -:  317:
    #####:  318:int handCard(int handPos, struct gameState *state) {
    #####:  319:	int currentPlayer = whoseTurn(state);
    #####:  320:	return state->hand[currentPlayer][handPos];
        -:  321:}
        -:  322:
    #####:  323:int supplyCount(int card, struct gameState *state) {
    #####:  324:	return state->supplyCount[card];
        -:  325:}
        -:  326:
    #####:  327:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  328:	int i;
    #####:  329:	int count = 0;
        -:  330:
    #####:  331:	for (i = 0; i < state->deckCount[player]; i++)
        -:  332:	{
    #####:  333:		if (state->deck[player][i] == card) count++;
        -:  334:	}
        -:  335:
    #####:  336:	for (i = 0; i < state->handCount[player]; i++)
        -:  337:	{
    #####:  338:		if (state->hand[player][i] == card) count++;
        -:  339:	}
        -:  340:
    #####:  341:	for (i = 0; i < state->discardCount[player]; i++)
        -:  342:	{
    #####:  343:		if (state->discard[player][i] == card) count++;
        -:  344:	}
        -:  345:
    #####:  346:	return count;
        -:  347:}
        -:  348:
        4:  349:int whoseTurn(struct gameState *state) {
        4:  350:	return state->whoseTurn;
        -:  351:}
        -:  352:
        4:  353:int endTurn(struct gameState *state) {
        -:  354:	int k;
        -:  355:	int i;
        4:  356:	int currentPlayer = whoseTurn(state);
        -:  357:
        -:  358:	//Discard hand
        4:  359:	for (i = 0; i < state->handCount[currentPlayer]; i++){
    #####:  360:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  361:		state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  362:	}
        4:  363:	state->handCount[currentPlayer] = 0;//Reset hand count
        -:  364:
        -:  365:	//Code for determining the player
        4:  366:	if (currentPlayer < (state->numPlayers - 1)){
    #####:  367:		state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  368:	}
        -:  369:	else{
        4:  370:		state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  371:	}
        -:  372:
        4:  373:	state->outpostPlayed = 0;
        4:  374:	state->phase = 0;
        4:  375:	state->numActions = 1;
        4:  376:	state->coins = 0;
        4:  377:	state->numBuys = 1;
        4:  378:	state->playedCardCount = 0;
        4:  379:	state->handCount[state->whoseTurn] = 0;
        -:  380:
        -:  381:	//int k; move to top
        -:  382:	//Next player draws hand
       24:  383:	for (k = 0; k < 5; k++){
       20:  384:		drawCard(state->whoseTurn, state);//Draw a card
        -:  385:	}
        -:  386:
        -:  387:	//Update money
        4:  388:	updateCoins(state->whoseTurn, state, 0);
        -:  389:
        4:  390:	return 0;
        -:  391:}
        -:  392:
    #####:  393:int isGameOver(struct gameState *state) {
        -:  394:	int i;
        -:  395:	int j;
        -:  396:
        -:  397:	//if stack of Province cards is empty, the game ends
    #####:  398:	if (state->supplyCount[province] == 0)
        -:  399:	{
    #####:  400:		return 1;
        -:  401:	}
        -:  402:
        -:  403:	//if three supply pile are at 0, the game ends
    #####:  404:	j = 0;
    #####:  405:	for (i = 0; i < 25; i++)
        -:  406:	{
    #####:  407:		if (state->supplyCount[i] == 0)
        -:  408:		{
    #####:  409:			j++;
        -:  410:		}
        -:  411:	}
    #####:  412:	if (j >= 3)
        -:  413:	{
    #####:  414:		return 1;
        -:  415:	}
        -:  416:
    #####:  417:	return 0;
        -:  418:}
        -:  419:
    #####:  420:int scoreFor(int player, struct gameState *state) {
        -:  421:
        -:  422:	int i;
    #####:  423:	int score = 0;
        -:  424:	//score from hand
    #####:  425:	for (i = 0; i < state->handCount[player]; i++)
        -:  426:	{
    #####:  427:		if (state->hand[player][i] == curse) { score = score - 1; };
    #####:  428:		if (state->hand[player][i] == estate) { score = score + 1; };
    #####:  429:		if (state->hand[player][i] == duchy) { score = score + 3; };
    #####:  430:		if (state->hand[player][i] == province) { score = score + 6; };
    #####:  431:		if (state->hand[player][i] == great_hall) { score = score + 1; };
    #####:  432:		if (state->hand[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  433:	}
        -:  434:
        -:  435:	//score from discard
    #####:  436:	for (i = 0; i < state->discardCount[player]; i++)
        -:  437:	{
    #####:  438:		if (state->discard[player][i] == curse) { score = score - 1; };
    #####:  439:		if (state->discard[player][i] == estate) { score = score + 1; };
    #####:  440:		if (state->discard[player][i] == duchy) { score = score + 3; };
    #####:  441:		if (state->discard[player][i] == province) { score = score + 6; };
    #####:  442:		if (state->discard[player][i] == great_hall) { score = score + 1; };
    #####:  443:		if (state->discard[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  444:	}
        -:  445:
        -:  446:	//score from deck
    #####:  447:	for (i = 0; i < state->discardCount[player]; i++)
        -:  448:	{
    #####:  449:		if (state->deck[player][i] == curse) { score = score - 1; };
    #####:  450:		if (state->deck[player][i] == estate) { score = score + 1; };
    #####:  451:		if (state->deck[player][i] == duchy) { score = score + 3; };
    #####:  452:		if (state->deck[player][i] == province) { score = score + 6; };
    #####:  453:		if (state->deck[player][i] == great_hall) { score = score + 1; };
    #####:  454:		if (state->deck[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  455:	}
        -:  456:
    #####:  457:	return score;
        -:  458:}
        -:  459:
    #####:  460:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  461:	int i;
        -:  462:	int j;
        -:  463:	int highScore;
        -:  464:	int currentPlayer;
        -:  465:
        -:  466:	//get score for each player
    #####:  467:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  468:	{
        -:  469:		//set unused player scores to -9999
    #####:  470:		if (i >= state->numPlayers)
        -:  471:		{
    #####:  472:			players[i] = -9999;
        -:  473:		}
        -:  474:		else
        -:  475:		{
    #####:  476:			players[i] = scoreFor(i, state);
        -:  477:		}
        -:  478:	}
        -:  479:
        -:  480:	//find highest score
    #####:  481:	j = 0;
    #####:  482:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  483:	{
    #####:  484:		if (players[i] > players[j])
        -:  485:		{
    #####:  486:			j = i;
        -:  487:		}
        -:  488:	}
    #####:  489:	highScore = players[j];
        -:  490:
        -:  491:	//add 1 to players who had less turns
    #####:  492:	currentPlayer = whoseTurn(state);
    #####:  493:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  494:	{
    #####:  495:		if (players[i] == highScore && i > currentPlayer)
        -:  496:		{
    #####:  497:			players[i]++;
        -:  498:		}
        -:  499:	}
        -:  500:
        -:  501:	//find new highest score
    #####:  502:	j = 0;
    #####:  503:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  504:	{
    #####:  505:		if (players[i] > players[j])
        -:  506:		{
    #####:  507:			j = i;
        -:  508:		}
        -:  509:	}
    #####:  510:	highScore = players[j];
        -:  511:
        -:  512:	//set winners in array to 1 and rest to 0
    #####:  513:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  514:	{
    #####:  515:		if (players[i] == highScore)
        -:  516:		{
    #####:  517:			players[i] = 1;
        -:  518:		}
        -:  519:		else
        -:  520:		{
    #####:  521:			players[i] = 0;
        -:  522:		}
        -:  523:	}
        -:  524:
    #####:  525:	return 0;
        -:  526:}
        -:  527:
       70:  528:int drawCard(int player, struct gameState *state)
        -:  529:{
        -:  530:	int count;
        -:  531:	int deckCounter;
       70:  532:	if (state->deckCount[player] <= 0){//Deck is empty
        -:  533:
        -:  534:		//Step 1 Shuffle the discard pile back into a deck
        -:  535:		int i;
        -:  536:		//Move discard to deck
       20:  537:		for (i = 0; i < state->discardCount[player]; i++){
    #####:  538:			state->deck[player][i] = state->discard[player][i];
    #####:  539:			state->discard[player][i] = -1;
        -:  540:		}
        -:  541:
       20:  542:		state->deckCount[player] = state->discardCount[player];
       20:  543:		state->discardCount[player] = 0;//Reset discard
        -:  544:
        -:  545:		//Shufffle the deck
       20:  546:		shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  547:
        -:  548:		if (DEBUG){//Debug statements
        -:  549:			printf("Deck count now: %d\n", state->deckCount[player]);
        -:  550:		}
        -:  551:
       20:  552:		state->discardCount[player] = 0;
        -:  553:
        -:  554:		//Step 2 Draw Card
       20:  555:		count = state->handCount[player];//Get current player's hand count
        -:  556:
        -:  557:		if (DEBUG){//Debug statements
        -:  558:			printf("Current hand count: %d\n", count);
        -:  559:		}
        -:  560:
       20:  561:		deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  562:
       20:  563:		if (deckCounter == 0)
       20:  564:			return -1;
        -:  565:
    #####:  566:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
    #####:  567:		state->deckCount[player]--;
    #####:  568:		state->handCount[player]++;//Increment hand count
        -:  569:	}
        -:  570:
        -:  571:	else{
       50:  572:		int count = state->handCount[player];//Get current hand count for player
        -:  573:		int deckCounter;
        -:  574:		if (DEBUG){//Debug statements
        -:  575:			printf("Current hand count: %d\n", count);
        -:  576:		}
        -:  577:
       50:  578:		deckCounter = state->deckCount[player];//Create holder for the deck count
       50:  579:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
       50:  580:		state->deckCount[player]--;
       50:  581:		state->handCount[player]++;//Increment hand count
        -:  582:	}
        -:  583:
       50:  584:	return 0;
        -:  585:}
        -:  586:
    #####:  587:int getCost(int cardNumber)
        -:  588:{
    #####:  589:	switch (cardNumber)
        -:  590:	{
        -:  591:	case curse:
    #####:  592:		return 0;
        -:  593:	case estate:
    #####:  594:		return 2;
        -:  595:	case duchy:
    #####:  596:		return 5;
        -:  597:	case province:
    #####:  598:		return 8;
        -:  599:	case copper:
    #####:  600:		return 0;
        -:  601:	case silver:
    #####:  602:		return 3;
        -:  603:	case gold:
    #####:  604:		return 6;
        -:  605:	case adventurer:
    #####:  606:		return 6;
        -:  607:	case council_room:
    #####:  608:		return 5;
        -:  609:	case feast:
    #####:  610:		return 4;
        -:  611:	case gardens:
    #####:  612:		return 4;
        -:  613:	case mine:
    #####:  614:		return 5;
        -:  615:	case remodel:
    #####:  616:		return 4;
        -:  617:	case smithy:
    #####:  618:		return 4;
        -:  619:	case village:
    #####:  620:		return 3;
        -:  621:	case baron:
    #####:  622:		return 4;
        -:  623:	case great_hall:
    #####:  624:		return 3;
        -:  625:	case minion:
    #####:  626:		return 5;
        -:  627:	case steward:
    #####:  628:		return 3;
        -:  629:	case tribute:
    #####:  630:		return 5;
        -:  631:	case ambassador:
    #####:  632:		return 3;
        -:  633:	case cutpurse:
    #####:  634:		return 4;
        -:  635:	case embargo:
    #####:  636:		return 2;
        -:  637:	case outpost:
    #####:  638:		return 5;
        -:  639:	case salvager:
    #####:  640:		return 4;
        -:  641:	case sea_hag:
    #####:  642:		return 4;
        -:  643:	case treasure_map:
    #####:  644:		return 4;
        -:  645:	}
        -:  646:
    #####:  647:	return -1;
        -:  648:}
        -:  649:
    #####:  650:void playAdventurer(struct gameState *state, int currentPlayer)
        -:  651:// Reveal cards from deck until 2 Treasure cards are found.  Put those Treasure cards in the hand and discard the rest.
        -:  652:{
    #####:  653:	int drawntreasure = 0;
        -:  654:	int temphand[MAX_HAND];
        -:  655:	int cardDrawn;
    #####:  656:	int z = 0; // this is the counter for the temp hand
        -:  657:
    #####:  658:	while (drawntreasure < 2){
    #####:  659:		if (state->deckCount[currentPlayer] < 1){//if the deck is empty we need to shuffle discard and add to deck
    #####:  660:			shuffle(currentPlayer, state);
        -:  661:		}
    #####:  662:		drawCard(currentPlayer, state);
    #####:  663:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer] - 1];//top card of hand is most recently drawn card.
    #####:  664:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
    #####:  665:			drawntreasure++;
        -:  666:		else{
    #####:  667:			temphand[z] = cardDrawn;
    #####:  668:			state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####:  669:			z++;
        -:  670:		}
        -:  671:	}
    #####:  672:	while (z - 1 >= 0){
    #####:  673:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; // discard all cards in play that have been drawn
    #####:  674:		z = z - 1;
        -:  675:	}
    #####:  676:}
        -:  677:
    #####:  678:int playRemodel(struct gameState *state, int currentPlayer, int choice1, int choice2, int handPos)
        -:  679://Trash a card in the hand, and gain a card costing up to $2 more than the trashed card
        -:  680:{
        -:  681:	int i;
    #####:  682:	int j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  683:
    #####:  684:	if ((getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2))
        -:  685:	{
    #####:  686:		return -1;
        -:  687:	}
        -:  688:
    #####:  689:	gainCard(choice2, state, 0, currentPlayer);
        -:  690:
        -:  691:	//discard card from hand
    #####:  692:	discardCard(handPos, currentPlayer, state, 0);
        -:  693:
        -:  694:	//discard trashed card
    #####:  695:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  696:	{
    #####:  697:		if (state->hand[currentPlayer][i] == j)
        -:  698:		{
    #####:  699:			discardCard(i, currentPlayer, state, 0);
    #####:  700:			break;
        -:  701:		}
        -:  702:	}
        -:  703:
    #####:  704:	return 0;
        -:  705:}
        -:  706:
    #####:  707:void playSmithy(struct gameState *state, int currentPlayer, int handPos)
        -:  708:// Draw 3 cards
        -:  709:{
        -:  710:	int i;
    #####:  711:	for (i = 0; i < 3; i++)
        -:  712:	{
    #####:  713:		drawCard(currentPlayer, state);
        -:  714:	}
        -:  715:
        -:  716:	//discard card from hand
    #####:  717:	discardCard(handPos, currentPlayer, state, 0);
    #####:  718:}
        -:  719:
    #####:  720:void playBaron(struct gameState *state, int currentPlayer, int choice1, int handPos)
        -:  721://Add a buy.  OPTION:  Discard an Estate card and gain $4.  Otherwise, gain an Estate card.
        -:  722:{
    #####:  723:	state->numBuys++;//Increase buys by 1!
    #####:  724:	if (choice1 > 0){//Boolean true or going to discard an estate
    #####:  725:		int p = 0;//Iterator for hand!
    #####:  726:		int card_not_discarded = 1;//Flag for discard set!
    #####:  727:		while (card_not_discarded){
    #####:  728:			if (state->hand[currentPlayer][p] == estate){ //Found an estate card!
    #####:  729:				state->coins += 4;//Add 4 coins to the amount of coins
    #####:  730:				state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  731:				state->discardCount[currentPlayer]++;
    #####:  732:				for (; p < state->handCount[currentPlayer]; p++){
    #####:  733:					state->hand[currentPlayer][p] = state->hand[currentPlayer][p + 1];
        -:  734:				}
    #####:  735:				state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  736:				state->handCount[currentPlayer]--;
    #####:  737:				card_not_discarded = 0;//Exit the loop
        -:  738:			}
    #####:  739:			else if (p > state->handCount[currentPlayer]){
        -:  740:				if (DEBUG) {
        -:  741:					printf("No estate cards in your hand, invalid choice\n");
        -:  742:					printf("Must gain an estate if there are any\n");
        -:  743:				}
    #####:  744:				if (supplyCount(estate, state) > 0){
    #####:  745:					gainCard(estate, state, 1, currentPlayer);
    #####:  746:					state->supplyCount[estate]--;//Decrement estates
    #####:  747:					if (supplyCount(estate, state) == 0){
    #####:  748:						isGameOver(state);
        -:  749:					}
        -:  750:				}
    #####:  751:				card_not_discarded = 0;//Exit the loop
        -:  752:			}
        -:  753:
        -:  754:			else{
    #####:  755:				p++;//Next card
        -:  756:			}
        -:  757:		}
        -:  758:	}
        -:  759:
        -:  760:	else{
    #####:  761:		if (supplyCount(estate, state) > 0){
    #####:  762:			gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  763:			state->supplyCount[estate]--;//Decrement Estates
    #####:  764:			if (supplyCount(estate, state) == 0){
    #####:  765:				isGameOver(state);
        -:  766:			}
        -:  767:		}
        -:  768:	}
    #####:  769:}
        -:  770:
    #####:  771:int playTreasureMap(struct gameState *state, int currentPlayer, int handPos)
        -:  772://Trashing two treasure map cards from the hand = four gold on top of the deck.
        -:  773:{
        -:  774:	int i;
        -:  775:	int index;
        -:  776:
        -:  777:	//search hand for another treasure_map
    #####:  778:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  779:	{
    #####:  780:		if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -:  781:		{
    #####:  782:			index = i;
    #####:  783:			break;
        -:  784:		}
        -:  785:	}
    #####:  786:	if (index > -1)
        -:  787:	{
        -:  788:		//trash both treasure cards
    #####:  789:		discardCard(handPos, currentPlayer, state, 1);
    #####:  790:		discardCard(index, currentPlayer, state, 1);
        -:  791:
        -:  792:		//gain 4 Gold cards
    #####:  793:		for (i = 0; i < 4; i++)
        -:  794:		{
    #####:  795:			gainCard(gold, state, 1, currentPlayer);
        -:  796:		}
        -:  797:
        -:  798:		//return success
    #####:  799:		return 1;
        -:  800:	}
        -:  801:
        -:  802:	//no second treasure_map found in hand
    #####:  803:	return -1;
        -:  804:}
        -:  805:
    #####:  806:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  807:{
        -:  808:	int i;
        -:  809:	int j;
        -:  810:	int k;
        -:  811:	//int x;  //Unused after while loop removed from feast.
    #####:  812:	int currentPlayer = whoseTurn(state);
    #####:  813:	int nextPlayer = currentPlayer + 1;
        -:  814:	int temphand[MAX_HAND];
        -:  815:
    #####:  816:	int tributeRevealedCards[2] = { -1, -1 };
        -:  817:
    #####:  818:	if (nextPlayer > (state->numPlayers - 1)){
    #####:  819:		nextPlayer = 0;
        -:  820:	}
        -:  821:
        -:  822:	//uses switch to select card and perform actions
    #####:  823:	switch (card)
        -:  824:	{
        -:  825:	case adventurer:
        -:  826:
    #####:  827:		playAdventurer(state, currentPlayer);
    #####:  828:		return 0;
        -:  829:
        -:  830:	case council_room:
        -:  831:		//+4 Cards
    #####:  832:		for (i = 0; i < 4; i++)
        -:  833:		{
    #####:  834:			drawCard(currentPlayer, state);
        -:  835:		}
        -:  836:
        -:  837:		//+1 Buy
    #####:  838:		state->numBuys++;
        -:  839:
        -:  840:		//Each other player draws a card
    #####:  841:		for (i = 0; i < state->numPlayers; i++)
        -:  842:		{
    #####:  843:			if (i != currentPlayer)
        -:  844:			{
    #####:  845:				drawCard(i, state);
        -:  846:			}
        -:  847:		}
        -:  848:
        -:  849:		//put played card in played card pile
    #####:  850:		discardCard(handPos, currentPlayer, state, 0);
        -:  851:
    #####:  852:		return 0;
        -:  853:
        -:  854:	case feast:
        -:  855:		//gain card with cost up to 5
        -:  856:		//Backup hand
    #####:  857:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  858:			temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  859:			state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  860:		}
        -:  861:		//Backup hand
        -:  862:
        -:  863:		//Update Coins for Buy
    #####:  864:		updateCoins(currentPlayer, state, 5);
        -:  865://		x = 1;//Condition to loop on
        -:  866://		while (x == 1) {//Buy one card
    #####:  867:			if (supplyCount(choice1, state) <= 0){
        -:  868:				if (DEBUG)
        -:  869:					printf("None of that card left, sorry!\n");
        -:  870:
        -:  871:				if (DEBUG){
        -:  872:					printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  873:				}
        -:  874:			}
    #####:  875:			else if (state->coins < getCost(choice1)){
    #####:  876:				printf("That card is too expensive!\n");
        -:  877:
        -:  878:				if (DEBUG){
        -:  879:					printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  880:				}
        -:  881:			}
        -:  882:			else{
        -:  883:
        -:  884:				if (DEBUG){
        -:  885:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  886:				}
        -:  887:
    #####:  888:				gainCard(choice1, state, 0, currentPlayer);//Gain the card
        -:  889://				x = 0;//No more buying cards
        -:  890:
        -:  891:				if (DEBUG){
        -:  892:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  893:				}
        -:  894:
        -:  895:			}
        -:  896://		}
        -:  897:
        -:  898:		//Reset Hand
    #####:  899:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  900:			state->hand[currentPlayer][i] = temphand[i];
    #####:  901:			temphand[i] = -1;
        -:  902:		}
        -:  903:		//Reset Hand
        -:  904:
    #####:  905:		return 0;
        -:  906:
        -:  907:	case gardens:
    #####:  908:		return -1;
        -:  909:
        -:  910:	case mine:
    #####:  911:		j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  912:
    #####:  913:		if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  914:		{
    #####:  915:			return -1;
        -:  916:		}
        -:  917:
    #####:  918:		if (choice2 > treasure_map || choice2 < curse)
        -:  919:		{
    #####:  920:			return -1;
        -:  921:		}
        -:  922:
    #####:  923:		if ((getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2))
        -:  924:		{
    #####:  925:			return -1;
        -:  926:		}
        -:  927:
    #####:  928:		gainCard(choice2, state, 2, currentPlayer);
        -:  929:
        -:  930:		//discard card from hand
    #####:  931:		discardCard(handPos, currentPlayer, state, 0);
        -:  932:
        -:  933:		//discard trashed card
    #####:  934:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  935:		{
    #####:  936:			if (state->hand[currentPlayer][i] == j)
        -:  937:			{
    #####:  938:				discardCard(i, currentPlayer, state, 0);
    #####:  939:				break;
        -:  940:			}
        -:  941:		}
        -:  942:
    #####:  943:		return 0;
        -:  944:
        -:  945:	case remodel:
        -:  946:
    #####:  947:		return playRemodel(state, currentPlayer, choice1, choice2, handPos);
        -:  948:
        -:  949:	case smithy:
        -:  950:
    #####:  951:		playSmithy(state, currentPlayer, handPos);
    #####:  952:		return 0;
        -:  953:
        -:  954:	case village:
        -:  955:		//+1 Card
    #####:  956:		drawCard(currentPlayer, state);
        -:  957:
        -:  958:		//+2 Actions
    #####:  959:		state->numActions = state->numActions + 2;
        -:  960:
        -:  961:		//discard played card from hand
    #####:  962:		discardCard(handPos, currentPlayer, state, 0);
    #####:  963:		return 0;
        -:  964:
        -:  965:	case baron:
        -:  966:
    #####:  967:		playBaron(state, currentPlayer, choice1, handPos);
    #####:  968:		return 0;
        -:  969:
        -:  970:	case great_hall:
        -:  971:		//+1 Card
    #####:  972:		drawCard(currentPlayer, state);
        -:  973:
        -:  974:		//+1 Actions
    #####:  975:		state->numActions++;
        -:  976:
        -:  977:		//discard card from hand
    #####:  978:		discardCard(handPos, currentPlayer, state, 0);
    #####:  979:		return 0;
        -:  980:
        -:  981:	case minion:
        -:  982:		//+1 action
    #####:  983:		state->numActions++;
        -:  984:
        -:  985:		//discard card from hand
    #####:  986:		discardCard(handPos, currentPlayer, state, 0);
        -:  987:
    #####:  988:		if (choice1)		//+2 coins
        -:  989:		{
    #####:  990:			state->coins = state->coins + 2;
        -:  991:		}
        -:  992:
    #####:  993:		else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  994:		{
        -:  995:			//discard hand
    #####:  996:			while (numHandCards(state) > 0)
        -:  997:			{
    #####:  998:				discardCard(handPos, currentPlayer, state, 0);
        -:  999:			}
        -: 1000:
        -: 1001:			//draw 4
    #####: 1002:			for (i = 0; i < 4; i++)
        -: 1003:			{
    #####: 1004:				drawCard(currentPlayer, state);
        -: 1005:			}
        -: 1006:
        -: 1007:			//other players discard hand and redraw if hand size > 4
    #####: 1008:			for (i = 0; i < state->numPlayers; i++)
        -: 1009:			{
    #####: 1010:				if (i != currentPlayer)
        -: 1011:				{
    #####: 1012:					if (state->handCount[i] > 4)
        -: 1013:					{
        -: 1014:						//discard hand
    #####: 1015:						while (state->handCount[i] > 0)
        -: 1016:						{
    #####: 1017:							discardCard(handPos, i, state, 0);
        -: 1018:						}
        -: 1019:
        -: 1020:						//draw 4
    #####: 1021:						for (j = 0; j < 4; j++)
        -: 1022:						{
    #####: 1023:							drawCard(i, state);
        -: 1024:						}
        -: 1025:					}
        -: 1026:				}
        -: 1027:			}
        -: 1028:
        -: 1029:		}
    #####: 1030:		return 0;
        -: 1031:
        -: 1032:	case steward:
    #####: 1033:		if (choice1 == 1)
        -: 1034:		{
        -: 1035:			//+2 cards
    #####: 1036:			drawCard(currentPlayer, state);
    #####: 1037:			drawCard(currentPlayer, state);
        -: 1038:		}
    #####: 1039:		else if (choice1 == 2)
        -: 1040:		{
        -: 1041:			//+2 coins
    #####: 1042:			state->coins = state->coins + 2;
        -: 1043:		}
        -: 1044:		else
        -: 1045:		{
        -: 1046:			//trash 2 cards in hand
    #####: 1047:			discardCard(choice2, currentPlayer, state, 1);
    #####: 1048:			discardCard(choice3, currentPlayer, state, 1);
        -: 1049:		}
        -: 1050:
        -: 1051:		//discard card from hand
    #####: 1052:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1053:		return 0;
        -: 1054:
        -: 1055:	case tribute:
    #####: 1056:		if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####: 1057:			if (state->deckCount[nextPlayer] > 0){
    #####: 1058:				tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1059:				state->deckCount[nextPlayer]--;
        -: 1060:			}
    #####: 1061:			else if (state->discardCount[nextPlayer] > 0){
    #####: 1062:				tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer] - 1];
    #####: 1063:				state->discardCount[nextPlayer]--;
        -: 1064:			}
        -: 1065:			else{
        -: 1066:				//No Card to Reveal
        -: 1067:				if (DEBUG){
        -: 1068:					printf("No cards to reveal\n");
        -: 1069:				}
        -: 1070:			}
        -: 1071:		}
        -: 1072:
        -: 1073:		else{
    #####: 1074:			if (state->deckCount[nextPlayer] == 0){
    #####: 1075:				for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####: 1076:					state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1077:					state->deckCount[nextPlayer]++;
    #####: 1078:					state->discard[nextPlayer][i] = -1;
    #####: 1079:					state->discardCount[nextPlayer]--;
        -: 1080:				}
        -: 1081:
    #####: 1082:				shuffle(nextPlayer, state);//Shuffle the deck
        -: 1083:			}
    #####: 1084:			tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1085:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1086:			state->deckCount[nextPlayer]--;
    #####: 1087:			tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1088:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1089:			state->deckCount[nextPlayer]--;
        -: 1090:		}
        -: 1091:
    #####: 1092:		if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
    #####: 1093:			state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1094:			state->playedCardCount++;
    #####: 1095:			tributeRevealedCards[1] = -1;
        -: 1096:		}
        -: 1097:
    #####: 1098:		for (i = 0; i <= 2; i++){
    #####: 1099:			if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
    #####: 1100:				state->coins += 2;
        -: 1101:			}
        -: 1102:
    #####: 1103:			else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
    #####: 1104:				drawCard(currentPlayer, state);
    #####: 1105:				drawCard(currentPlayer, state);
        -: 1106:			}
        -: 1107:			else{//Action Card
    #####: 1108:				state->numActions = state->numActions + 2;
        -: 1109:			}
        -: 1110:		}
        -: 1111:
    #####: 1112:		return 0;
        -: 1113:
        -: 1114:	case ambassador:
    #####: 1115:		j = 0;		//used to check if player has enough cards to discard
        -: 1116:
    #####: 1117:		if (choice2 > 2 || choice2 < 0)
        -: 1118:		{
    #####: 1119:			return -1;
        -: 1120:		}
        -: 1121:
    #####: 1122:		if (choice1 == handPos)
        -: 1123:		{
    #####: 1124:			return -1;
        -: 1125:		}
        -: 1126:
    #####: 1127:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1128:		{
    #####: 1129:			if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1130:			{
    #####: 1131:				j++;
        -: 1132:			}
        -: 1133:		}
    #####: 1134:		if (j < choice2)
        -: 1135:		{
    #####: 1136:			return -1;
        -: 1137:		}
        -: 1138:
        -: 1139:		if (DEBUG)
        -: 1140:			printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1141:
        -: 1142:		//increase supply count for choosen card by amount being discarded
    #####: 1143:		state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1144:
        -: 1145:		//each other player gains a copy of revealed card
    #####: 1146:		for (i = 0; i < state->numPlayers; i++)
        -: 1147:		{
    #####: 1148:			if (i != currentPlayer)
        -: 1149:			{
    #####: 1150:				gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1151:			}
        -: 1152:		}
        -: 1153:
        -: 1154:		//discard played card from hand
    #####: 1155:		discardCard(handPos, currentPlayer, state, 0);
        -: 1156:
        -: 1157:		//trash copies of cards returned to supply
    #####: 1158:		for (j = 0; j < choice2; j++)
        -: 1159:		{
    #####: 1160:			for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1161:			{
    #####: 1162:				if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1163:				{
    #####: 1164:					discardCard(i, currentPlayer, state, 1);
    #####: 1165:					break;
        -: 1166:				}
        -: 1167:			}
        -: 1168:		}
        -: 1169:
    #####: 1170:		return 0;
        -: 1171:
        -: 1172:	case cutpurse:
        -: 1173:
    #####: 1174:		updateCoins(currentPlayer, state, 2);
    #####: 1175:		for (i = 0; i < state->numPlayers; i++)
        -: 1176:		{
    #####: 1177:			if (i != currentPlayer)
        -: 1178:			{
    #####: 1179:				for (j = 0; j < state->handCount[i]; j++)
        -: 1180:				{
    #####: 1181:					if (state->hand[i][j] == copper)
        -: 1182:					{
    #####: 1183:						discardCard(j, i, state, 0);
    #####: 1184:						break;
        -: 1185:					}
    #####: 1186:					if (j == state->handCount[i])
        -: 1187:					{
    #####: 1188:						for (k = 0; k < state->handCount[i]; k++)
        -: 1189:						{
        -: 1190:							if (DEBUG)
        -: 1191:								printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1192:						}
    #####: 1193:						break;
        -: 1194:					}
        -: 1195:				}
        -: 1196:
        -: 1197:			}
        -: 1198:
        -: 1199:		}
        -: 1200:
        -: 1201:		//discard played card from hand
    #####: 1202:		discardCard(handPos, currentPlayer, state, 0);
        -: 1203:
    #####: 1204:		return 0;
        -: 1205:
        -: 1206:
        -: 1207:	case embargo:
        -: 1208:		//+2 Coins
    #####: 1209:		state->coins = state->coins + 2;
        -: 1210:
        -: 1211:		//see if selected pile is in play
    #####: 1212:		if (state->supplyCount[choice1] == -1)
        -: 1213:		{
    #####: 1214:			return -1;
        -: 1215:		}
        -: 1216:
        -: 1217:		//add embargo token to selected supply pile
    #####: 1218:		state->embargoTokens[choice1]++;
        -: 1219:
        -: 1220:		//trash card
    #####: 1221:		discardCard(handPos, currentPlayer, state, 1);
    #####: 1222:		return 0;
        -: 1223:
        -: 1224:	case outpost:
        -: 1225:		//set outpost flag
    #####: 1226:		state->outpostPlayed++;
        -: 1227:
        -: 1228:		//discard card
    #####: 1229:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1230:		return 0;
        -: 1231:
        -: 1232:	case salvager:
        -: 1233:		//+1 buy
    #####: 1234:		state->numBuys++;
        -: 1235:
    #####: 1236:		if (choice1)
        -: 1237:		{
        -: 1238:			//gain coins equal to trashed card
    #####: 1239:			state->coins = state->coins + getCost(handCard(choice1, state));
        -: 1240:			//trash card
    #####: 1241:			discardCard(choice1, currentPlayer, state, 1);
        -: 1242:		}
        -: 1243:
        -: 1244:		//discard card
    #####: 1245:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1246:		return 0;
        -: 1247:
        -: 1248:	case sea_hag:
    #####: 1249:		for (i = 0; i < state->numPlayers; i++){
    #####: 1250:			if (i != currentPlayer){
    #####: 1251:				state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1252:				state->discardCount[i]++;
    #####: 1253:				state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1254:			}
        -: 1255:		}
    #####: 1256:		return 0;
        -: 1257:
        -: 1258:	case treasure_map:
        -: 1259:
    #####: 1260:		return playTreasureMap(state, currentPlayer, handPos);
        -: 1261:	}
    #####: 1262:	return -1;
        -: 1263:}
        -: 1264:
    #####: 1265:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1266:{
        -: 1267:
        -: 1268:	//if card is not trashed, added to Played pile 
    #####: 1269:	if (trashFlag < 1)
        -: 1270:	{
        -: 1271:		//add card to played pile
    #####: 1272:		state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
    #####: 1273:		state->playedCardCount++;
        -: 1274:	}
        -: 1275:
        -: 1276:	//set played card to -1
    #####: 1277:	state->hand[currentPlayer][handPos] = -1;
        -: 1278:
        -: 1279:	//remove card from player's hand
    #####: 1280:	if (handPos == (state->handCount[currentPlayer] - 1)) 	//last card in hand array is played
        -: 1281:	{
        -: 1282:		//reduce number of cards in hand
    #####: 1283:		state->handCount[currentPlayer]--;
        -: 1284:	}
    #####: 1285:	else if (state->handCount[currentPlayer] == 1) //only one card in hand
        -: 1286:	{
        -: 1287:		//reduce number of cards in hand
    #####: 1288:		state->handCount[currentPlayer]--;
        -: 1289:	}
        -: 1290:	else
        -: 1291:	{
        -: 1292:		//replace discarded card with last card in hand
    #####: 1293:		state->hand[currentPlayer][handPos] = state->hand[currentPlayer][(state->handCount[currentPlayer] - 1)];
        -: 1294:		//set last card to -1
    #####: 1295:		state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1296:		//reduce number of cards in hand
    #####: 1297:		state->handCount[currentPlayer]--;
        -: 1298:	}
        -: 1299:
    #####: 1300:	return 0;
        -: 1301:}
        -: 1302:
    #####: 1303:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1304:{
        -: 1305:	//Note: supplyPos is enum of choosen card
        -: 1306:
        -: 1307:	//check if supply pile is empty (0) or card is not used in game (-1)
    #####: 1308:	if (supplyCount(supplyPos, state) < 1)
        -: 1309:	{
    #####: 1310:		return -1;
        -: 1311:	}
        -: 1312:
        -: 1313:	//added card for [whoseTurn] current player:
        -: 1314:	// toFlag = 0 : add to discard
        -: 1315:	// toFlag = 1 : add to deck
        -: 1316:	// toFlag = 2 : add to hand
        -: 1317:
    #####: 1318:	if (toFlag == 1)
        -: 1319:	{
    #####: 1320:		state->deck[player][state->deckCount[player]] = supplyPos;
    #####: 1321:		state->deckCount[player]++;
        -: 1322:	}
    #####: 1323:	else if (toFlag == 2)
        -: 1324:	{
    #####: 1325:		state->hand[player][state->handCount[player]] = supplyPos;
    #####: 1326:		state->handCount[player]++;
        -: 1327:	}
        -: 1328:	else
        -: 1329:	{
    #####: 1330:		state->discard[player][state->discardCount[player]] = supplyPos;
    #####: 1331:		state->discardCount[player]++;
        -: 1332:	}
        -: 1333:
        -: 1334:	//decrease number in supply pile
    #####: 1335:	state->supplyCount[supplyPos]--;
        -: 1336:
    #####: 1337:	return 0;
        -: 1338:}
        -: 1339:
       14: 1340:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1341:{
        -: 1342:	int i;
        -: 1343:
        -: 1344:	//reset coin count
       14: 1345:	state->coins = 0;
        -: 1346:
        -: 1347:	//add coins for each Treasure card in player's hand
       64: 1348:	for (i = 0; i < state->handCount[player]; i++)
        -: 1349:	{
       50: 1350:		if (state->hand[player][i] == copper)
        -: 1351:		{
       34: 1352:			state->coins += 1;
        -: 1353:		}
       16: 1354:		else if (state->hand[player][i] == silver)
        -: 1355:		{
    #####: 1356:			state->coins += 2;
        -: 1357:		}
       16: 1358:		else if (state->hand[player][i] == gold)
        -: 1359:		{
    #####: 1360:			state->coins += 3;
        -: 1361:		}
        -: 1362:	}
        -: 1363:
        -: 1364:	//add bonus
       14: 1365:	state->coins += bonus;
        -: 1366:
       14: 1367:	return 0;
        -: 1368:}
        -: 1369:
        -: 1370:
        -: 1371://end of dominion.c
File 'dominion.c'
Lines executed:26.93% of 557
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
      434:    8:int compare(const void* a, const void* b) {
      434:    9:	if (*(int*)a > *(int*)b)
    #####:   10:		return 1;
      434:   11:	if (*(int*)a < *(int*)b)
      155:   12:		return -1;
      279:   13:	return 0;
        -:   14:}
        -:   15:
       20:   16:struct gameState* newGame() {
       20:   17:	struct gameState* g = malloc(sizeof(struct gameState));
       20:   18:	return g;
        -:   19:}
        -:   20:
       77:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:	int k8, int k9, int k10) {
       77:   23:	int* k = malloc(10 * sizeof(int));
       77:   24:	k[0] = k1;
       77:   25:	k[1] = k2;
       77:   26:	k[2] = k3;
       77:   27:	k[3] = k4;
       77:   28:	k[4] = k5;
       77:   29:	k[5] = k6;
       77:   30:	k[6] = k7;
       77:   31:	k[7] = k8;
       77:   32:	k[8] = k9;
       77:   33:	k[9] = k10;
       77:   34:	return k;
        -:   35:}
        -:   36:
       77:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		struct gameState *state) {
        -:   39:
        -:   40:	int i;
        -:   41:	int j;
        -:   42:	int it;
        -:   43:	//set up random number generator
       77:   44:	SelectStream(1);
       77:   45:	PutSeed((long)randomSeed);
        -:   46:
        -:   47:	//check number of players
       77:   48:	if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:	{
    #####:   50:		return -1;
        -:   51:	}
        -:   52:
        -:   53:	//set number of players
       77:   54:	state->numPlayers = numPlayers;
        -:   55:
        -:   56:	//check selected kingdom cards are different
      274:   57:	for (i = 0; i < 10; i++)
        -:   58:	{
     2612:   59:		for (j = 0; j < 10; j++)
        -:   60:		{
     2415:   61:			if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:			{
       67:   63:				return -1;
        -:   64:			}
        -:   65:		}
        -:   66:	}
        -:   67:
        -:   68:
        -:   69:	//initialize supply
        -:   70:	///////////////////////////////
        -:   71:
        -:   72:	//set number of Curse cards
       10:   73:	if (numPlayers == 2)
        -:   74:	{
        2:   75:		state->supplyCount[curse] = 10;
        -:   76:	}
        8:   77:	else if (numPlayers == 3)
        -:   78:	{
        5:   79:		state->supplyCount[curse] = 20;
        -:   80:	}
        -:   81:	else
        -:   82:	{
        3:   83:		state->supplyCount[curse] = 30;
        -:   84:	}
        -:   85:
        -:   86:	//set number of Victory cards
       10:   87:	if (numPlayers == 2)
        -:   88:	{
        2:   89:		state->supplyCount[estate] = 8;
        2:   90:		state->supplyCount[duchy] = 8;
        2:   91:		state->supplyCount[province] = 8;
        -:   92:	}
        -:   93:	else
        -:   94:	{
        8:   95:		state->supplyCount[estate] = 12;
        8:   96:		state->supplyCount[duchy] = 12;
        8:   97:		state->supplyCount[province] = 12;
        -:   98:	}
        -:   99:
        -:  100:	//set number of Treasure cards
       10:  101:	state->supplyCount[copper] = 60 - (7 * numPlayers);
       10:  102:	state->supplyCount[silver] = 40;
       10:  103:	state->supplyCount[gold] = 30;
        -:  104:
        -:  105:	//set number of Kingdom cards
      210:  106:	for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:	{
     1650:  108:		for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:		{
     1550:  110:			if (kingdomCards[j] == i)
        -:  111:			{
        -:  112:				//check if card is a 'Victory' Kingdom card
      100:  113:				if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:				{
       14:  115:					if (numPlayers == 2){
    #####:  116:						state->supplyCount[i] = 8;
        -:  117:					}
        7:  118:					else{ state->supplyCount[i] = 12; }
        -:  119:				}
        -:  120:				else
        -:  121:				{
       93:  122:					state->supplyCount[i] = 10;
        -:  123:				}
      100:  124:				break;
        -:  125:			}
        -:  126:			else    //card is not in the set choosen for the game
        -:  127:			{
     1450:  128:				state->supplyCount[i] = -1;
        -:  129:			}
        -:  130:		}
        -:  131:
        -:  132:	}
        -:  133:
        -:  134:	////////////////////////
        -:  135:	//supply intilization complete
        -:  136:
        -:  137:	//set player decks
       41:  138:	for (i = 0; i < numPlayers; i++)
        -:  139:	{
       31:  140:		state->deckCount[i] = 0;
      124:  141:		for (j = 0; j < 3; j++)
        -:  142:		{
       93:  143:			state->deck[i][j] = estate;
       93:  144:			state->deckCount[i]++;
        -:  145:		}
      248:  146:		for (j = 3; j < 10; j++)
        -:  147:		{
      217:  148:			state->deck[i][j] = copper;
      217:  149:			state->deckCount[i]++;
        -:  150:		}
        -:  151:	}
        -:  152:
        -:  153:	//shuffle player decks
       41:  154:	for (i = 0; i < numPlayers; i++)
        -:  155:	{
       31:  156:		if (shuffle(i, state) < 0)
        -:  157:		{
    #####:  158:			return -1;
        -:  159:		}
        -:  160:	}
        -:  161:
        -:  162:	//draw player hands
       41:  163:	for (i = 0; i < numPlayers; i++)
        -:  164:	{
        -:  165:		//initialize hand size to zero
       31:  166:		state->handCount[i] = 0;
       31:  167:		state->discardCount[i] = 0;
        -:  168:		//draw 5 cards
        -:  169:		// for (j = 0; j < 5; j++)
        -:  170:		//	{
        -:  171:		//	  drawCard(i, state);
        -:  172:		//	}
        -:  173:	}
        -:  174:
        -:  175:	//set embargo tokens to 0 for all supply piles
      280:  176:	for (i = 0; i <= treasure_map; i++)
        -:  177:	{
      270:  178:		state->embargoTokens[i] = 0;
        -:  179:	}
        -:  180:
        -:  181:	//initialize first player's turn
       10:  182:	state->outpostPlayed = 0;
       10:  183:	state->phase = 0;
       10:  184:	state->numActions = 1;
       10:  185:	state->numBuys = 1;
       10:  186:	state->playedCardCount = 0;
       10:  187:	state->whoseTurn = 0;
       10:  188:	state->handCount[state->whoseTurn] = 0;
        -:  189:	//int it; move to top
        -:  190:
        -:  191:	//Moved draw cards to here, only drawing at the start of a turn
       60:  192:	for (it = 0; it < 5; it++){
       50:  193:		drawCard(state->whoseTurn, state);
        -:  194:	}
        -:  195:
       10:  196:	updateCoins(state->whoseTurn, state, 0);
        -:  197:
       10:  198:	return 0;
        -:  199:}
        -:  200:
       61:  201:int shuffle(int player, struct gameState *state) {
        -:  202:
        -:  203:
        -:  204:	int newDeck[MAX_DECK];
       61:  205:	int newDeckPos = 0;
        -:  206:	int card;
        -:  207:	int i;
        -:  208:
       61:  209:	if (state->deckCount[player] < 1)
       30:  210:		return -1;
       31:  211:	qsort((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
        -:  212:	/* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
      372:  214:	while (state->deckCount[player] > 0) {
      310:  215:		card = floor(Random() * state->deckCount[player]);
      310:  216:		newDeck[newDeckPos] = state->deck[player][card];
      310:  217:		newDeckPos++;
      981:  218:		for (i = card; i < state->deckCount[player] - 1; i++) {
      671:  219:			state->deck[player][i] = state->deck[player][i + 1];
        -:  220:		}
      310:  221:		state->deckCount[player]--;
        -:  222:	}
      341:  223:	for (i = 0; i < newDeckPos; i++) {
      310:  224:		state->deck[player][i] = newDeck[i];
      310:  225:		state->deckCount[player]++;
        -:  226:	}
        -:  227:
       31:  228:	return 0;
        -:  229:}
        -:  230:
        3:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state)
        -:  232:{
        -:  233:	int card;
        3:  234:	int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:	//check if it is the right phase
        3:  237:	if (state->phase != 0)
        -:  238:	{
    #####:  239:		return -1;
        -:  240:	}
        -:  241:
        -:  242:	//check if player has enough actions
        3:  243:	if (state->numActions < 1)
        -:  244:	{
        3:  245:		return -1;
        -:  246:	}
        -:  247:
        -:  248:	//get card played
    #####:  249:	card = handCard(handPos, state);
        -:  250:
        -:  251:	//check if selected card is an action
    #####:  252:	if (card < adventurer || card > treasure_map)
        -:  253:	{
    #####:  254:		return -1;
        -:  255:	}
        -:  256:
        -:  257:	//play card
    #####:  258:	if (cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0)
        -:  259:	{
    #####:  260:		return -1;
        -:  261:	}
        -:  262:
        -:  263:	//reduce number of actions
    #####:  264:	state->numActions--;
        -:  265:
        -:  266:	//update coins (Treasure cards may be added with card draws)
    #####:  267:	updateCoins(state->whoseTurn, state, coin_bonus);
        -:  268:
    #####:  269:	return 0;
        -:  270:}
        -:  271:
        1:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:	int who;
        -:  274:	if (DEBUG){
        -:  275:		printf("Entering buyCard...\n");
        -:  276:	}
        -:  277:
        -:  278:	// I don't know what to do about the phase thing.
        -:  279:
        1:  280:	who = state->whoseTurn;
        -:  281:
        1:  282:	if (state->numBuys < 1){
        -:  283:		if (DEBUG)
        -:  284:			printf("You do not have any buys left\n");
        1:  285:		return -1;
        -:  286:	}
    #####:  287:	else if (supplyCount(supplyPos, state) < 1){
        -:  288:		if (DEBUG)
        -:  289:			printf("There are not any of that type of card left\n");
    #####:  290:		return -1;
        -:  291:	}
    #####:  292:	else if (state->coins < getCost(supplyPos)){
        -:  293:		if (DEBUG)
        -:  294:			printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  295:		return -1;
        -:  296:	}
        -:  297:	else {
    #####:  298:		state->phase = 1;
        -:  299:		//state->supplyCount[supplyPos]--;
    #####:  300:		gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  301:
    #####:  302:		state->coins = (state->coins) - (getCost(supplyPos));
    #####:  303:		state->numBuys--;
        -:  304:		if (DEBUG)
        -:  305:			printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  306:	}
        -:  307:
        -:  308:	//state->discard[who][state->discardCount[who]] = supplyPos;
        -:  309:	//state->discardCount[who]++;
        -:  310:
    #####:  311:	return 0;
        -:  312:}
        -:  313:
    #####:  314:int numHandCards(struct gameState *state) {
    #####:  315:	return state->handCount[whoseTurn(state)];
        -:  316:}
        -:  317:
    #####:  318:int handCard(int handPos, struct gameState *state) {
    #####:  319:	int currentPlayer = whoseTurn(state);
    #####:  320:	return state->hand[currentPlayer][handPos];
        -:  321:}
        -:  322:
    #####:  323:int supplyCount(int card, struct gameState *state) {
    #####:  324:	return state->supplyCount[card];
        -:  325:}
        -:  326:
    #####:  327:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  328:	int i;
    #####:  329:	int count = 0;
        -:  330:
    #####:  331:	for (i = 0; i < state->deckCount[player]; i++)
        -:  332:	{
    #####:  333:		if (state->deck[player][i] == card) count++;
        -:  334:	}
        -:  335:
    #####:  336:	for (i = 0; i < state->handCount[player]; i++)
        -:  337:	{
    #####:  338:		if (state->hand[player][i] == card) count++;
        -:  339:	}
        -:  340:
    #####:  341:	for (i = 0; i < state->discardCount[player]; i++)
        -:  342:	{
    #####:  343:		if (state->discard[player][i] == card) count++;
        -:  344:	}
        -:  345:
    #####:  346:	return count;
        -:  347:}
        -:  348:
        6:  349:int whoseTurn(struct gameState *state) {
        6:  350:	return state->whoseTurn;
        -:  351:}
        -:  352:
        6:  353:int endTurn(struct gameState *state) {
        -:  354:	int k;
        -:  355:	int i;
        6:  356:	int currentPlayer = whoseTurn(state);
        -:  357:
        -:  358:	//Discard hand
        6:  359:	for (i = 0; i < state->handCount[currentPlayer]; i++){
    #####:  360:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  361:		state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  362:	}
        6:  363:	state->handCount[currentPlayer] = 0;//Reset hand count
        -:  364:
        -:  365:	//Code for determining the player
        6:  366:	if (currentPlayer < (state->numPlayers - 1)){
    #####:  367:		state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  368:	}
        -:  369:	else{
        6:  370:		state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  371:	}
        -:  372:
        6:  373:	state->outpostPlayed = 0;
        6:  374:	state->phase = 0;
        6:  375:	state->numActions = 1;
        6:  376:	state->coins = 0;
        6:  377:	state->numBuys = 1;
        6:  378:	state->playedCardCount = 0;
        6:  379:	state->handCount[state->whoseTurn] = 0;
        -:  380:
        -:  381:	//int k; move to top
        -:  382:	//Next player draws hand
       36:  383:	for (k = 0; k < 5; k++){
       30:  384:		drawCard(state->whoseTurn, state);//Draw a card
        -:  385:	}
        -:  386:
        -:  387:	//Update money
        6:  388:	updateCoins(state->whoseTurn, state, 0);
        -:  389:
        6:  390:	return 0;
        -:  391:}
        -:  392:
    #####:  393:int isGameOver(struct gameState *state) {
        -:  394:	int i;
        -:  395:	int j;
        -:  396:
        -:  397:	//if stack of Province cards is empty, the game ends
    #####:  398:	if (state->supplyCount[province] == 0)
        -:  399:	{
    #####:  400:		return 1;
        -:  401:	}
        -:  402:
        -:  403:	//if three supply pile are at 0, the game ends
    #####:  404:	j = 0;
    #####:  405:	for (i = 0; i < 25; i++)
        -:  406:	{
    #####:  407:		if (state->supplyCount[i] == 0)
        -:  408:		{
    #####:  409:			j++;
        -:  410:		}
        -:  411:	}
    #####:  412:	if (j >= 3)
        -:  413:	{
    #####:  414:		return 1;
        -:  415:	}
        -:  416:
    #####:  417:	return 0;
        -:  418:}
        -:  419:
    #####:  420:int scoreFor(int player, struct gameState *state) {
        -:  421:
        -:  422:	int i;
    #####:  423:	int score = 0;
        -:  424:	//score from hand
    #####:  425:	for (i = 0; i < state->handCount[player]; i++)
        -:  426:	{
    #####:  427:		if (state->hand[player][i] == curse) { score = score - 1; };
    #####:  428:		if (state->hand[player][i] == estate) { score = score + 1; };
    #####:  429:		if (state->hand[player][i] == duchy) { score = score + 3; };
    #####:  430:		if (state->hand[player][i] == province) { score = score + 6; };
    #####:  431:		if (state->hand[player][i] == great_hall) { score = score + 1; };
    #####:  432:		if (state->hand[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  433:	}
        -:  434:
        -:  435:	//score from discard
    #####:  436:	for (i = 0; i < state->discardCount[player]; i++)
        -:  437:	{
    #####:  438:		if (state->discard[player][i] == curse) { score = score - 1; };
    #####:  439:		if (state->discard[player][i] == estate) { score = score + 1; };
    #####:  440:		if (state->discard[player][i] == duchy) { score = score + 3; };
    #####:  441:		if (state->discard[player][i] == province) { score = score + 6; };
    #####:  442:		if (state->discard[player][i] == great_hall) { score = score + 1; };
    #####:  443:		if (state->discard[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  444:	}
        -:  445:
        -:  446:	//score from deck
    #####:  447:	for (i = 0; i < state->discardCount[player]; i++)
        -:  448:	{
    #####:  449:		if (state->deck[player][i] == curse) { score = score - 1; };
    #####:  450:		if (state->deck[player][i] == estate) { score = score + 1; };
    #####:  451:		if (state->deck[player][i] == duchy) { score = score + 3; };
    #####:  452:		if (state->deck[player][i] == province) { score = score + 6; };
    #####:  453:		if (state->deck[player][i] == great_hall) { score = score + 1; };
    #####:  454:		if (state->deck[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  455:	}
        -:  456:
    #####:  457:	return score;
        -:  458:}
        -:  459:
    #####:  460:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  461:	int i;
        -:  462:	int j;
        -:  463:	int highScore;
        -:  464:	int currentPlayer;
        -:  465:
        -:  466:	//get score for each player
    #####:  467:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  468:	{
        -:  469:		//set unused player scores to -9999
    #####:  470:		if (i >= state->numPlayers)
        -:  471:		{
    #####:  472:			players[i] = -9999;
        -:  473:		}
        -:  474:		else
        -:  475:		{
    #####:  476:			players[i] = scoreFor(i, state);
        -:  477:		}
        -:  478:	}
        -:  479:
        -:  480:	//find highest score
    #####:  481:	j = 0;
    #####:  482:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  483:	{
    #####:  484:		if (players[i] > players[j])
        -:  485:		{
    #####:  486:			j = i;
        -:  487:		}
        -:  488:	}
    #####:  489:	highScore = players[j];
        -:  490:
        -:  491:	//add 1 to players who had less turns
    #####:  492:	currentPlayer = whoseTurn(state);
    #####:  493:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  494:	{
    #####:  495:		if (players[i] == highScore && i > currentPlayer)
        -:  496:		{
    #####:  497:			players[i]++;
        -:  498:		}
        -:  499:	}
        -:  500:
        -:  501:	//find new highest score
    #####:  502:	j = 0;
    #####:  503:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  504:	{
    #####:  505:		if (players[i] > players[j])
        -:  506:		{
    #####:  507:			j = i;
        -:  508:		}
        -:  509:	}
    #####:  510:	highScore = players[j];
        -:  511:
        -:  512:	//set winners in array to 1 and rest to 0
    #####:  513:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  514:	{
    #####:  515:		if (players[i] == highScore)
        -:  516:		{
    #####:  517:			players[i] = 1;
        -:  518:		}
        -:  519:		else
        -:  520:		{
    #####:  521:			players[i] = 0;
        -:  522:		}
        -:  523:	}
        -:  524:
    #####:  525:	return 0;
        -:  526:}
        -:  527:
       80:  528:int drawCard(int player, struct gameState *state)
        -:  529:{
        -:  530:	int count;
        -:  531:	int deckCounter;
       80:  532:	if (state->deckCount[player] <= 0){//Deck is empty
        -:  533:
        -:  534:		//Step 1 Shuffle the discard pile back into a deck
        -:  535:		int i;
        -:  536:		//Move discard to deck
       30:  537:		for (i = 0; i < state->discardCount[player]; i++){
    #####:  538:			state->deck[player][i] = state->discard[player][i];
    #####:  539:			state->discard[player][i] = -1;
        -:  540:		}
        -:  541:
       30:  542:		state->deckCount[player] = state->discardCount[player];
       30:  543:		state->discardCount[player] = 0;//Reset discard
        -:  544:
        -:  545:		//Shufffle the deck
       30:  546:		shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  547:
        -:  548:		if (DEBUG){//Debug statements
        -:  549:			printf("Deck count now: %d\n", state->deckCount[player]);
        -:  550:		}
        -:  551:
       30:  552:		state->discardCount[player] = 0;
        -:  553:
        -:  554:		//Step 2 Draw Card
       30:  555:		count = state->handCount[player];//Get current player's hand count
        -:  556:
        -:  557:		if (DEBUG){//Debug statements
        -:  558:			printf("Current hand count: %d\n", count);
        -:  559:		}
        -:  560:
       30:  561:		deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  562:
       30:  563:		if (deckCounter == 0)
       30:  564:			return -1;
        -:  565:
    #####:  566:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
    #####:  567:		state->deckCount[player]--;
    #####:  568:		state->handCount[player]++;//Increment hand count
        -:  569:	}
        -:  570:
        -:  571:	else{
       50:  572:		int count = state->handCount[player];//Get current hand count for player
        -:  573:		int deckCounter;
        -:  574:		if (DEBUG){//Debug statements
        -:  575:			printf("Current hand count: %d\n", count);
        -:  576:		}
        -:  577:
       50:  578:		deckCounter = state->deckCount[player];//Create holder for the deck count
       50:  579:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
       50:  580:		state->deckCount[player]--;
       50:  581:		state->handCount[player]++;//Increment hand count
        -:  582:	}
        -:  583:
       50:  584:	return 0;
        -:  585:}
        -:  586:
    #####:  587:int getCost(int cardNumber)
        -:  588:{
    #####:  589:	switch (cardNumber)
        -:  590:	{
        -:  591:	case curse:
    #####:  592:		return 0;
        -:  593:	case estate:
    #####:  594:		return 2;
        -:  595:	case duchy:
    #####:  596:		return 5;
        -:  597:	case province:
    #####:  598:		return 8;
        -:  599:	case copper:
    #####:  600:		return 0;
        -:  601:	case silver:
    #####:  602:		return 3;
        -:  603:	case gold:
    #####:  604:		return 6;
        -:  605:	case adventurer:
    #####:  606:		return 6;
        -:  607:	case council_room:
    #####:  608:		return 5;
        -:  609:	case feast:
    #####:  610:		return 4;
        -:  611:	case gardens:
    #####:  612:		return 4;
        -:  613:	case mine:
    #####:  614:		return 5;
        -:  615:	case remodel:
    #####:  616:		return 4;
        -:  617:	case smithy:
    #####:  618:		return 4;
        -:  619:	case village:
    #####:  620:		return 3;
        -:  621:	case baron:
    #####:  622:		return 4;
        -:  623:	case great_hall:
    #####:  624:		return 3;
        -:  625:	case minion:
    #####:  626:		return 5;
        -:  627:	case steward:
    #####:  628:		return 3;
        -:  629:	case tribute:
    #####:  630:		return 5;
        -:  631:	case ambassador:
    #####:  632:		return 3;
        -:  633:	case cutpurse:
    #####:  634:		return 4;
        -:  635:	case embargo:
    #####:  636:		return 2;
        -:  637:	case outpost:
    #####:  638:		return 5;
        -:  639:	case salvager:
    #####:  640:		return 4;
        -:  641:	case sea_hag:
    #####:  642:		return 4;
        -:  643:	case treasure_map:
    #####:  644:		return 4;
        -:  645:	}
        -:  646:
    #####:  647:	return -1;
        -:  648:}
        -:  649:
    #####:  650:void playAdventurer(struct gameState *state, int currentPlayer)
        -:  651:// Reveal cards from deck until 2 Treasure cards are found.  Put those Treasure cards in the hand and discard the rest.
        -:  652:{
    #####:  653:	int drawntreasure = 0;
        -:  654:	int temphand[MAX_HAND];
        -:  655:	int cardDrawn;
    #####:  656:	int z = 0; // this is the counter for the temp hand
        -:  657:
    #####:  658:	while (drawntreasure < 2){
    #####:  659:		if (state->deckCount[currentPlayer] < 1){//if the deck is empty we need to shuffle discard and add to deck
    #####:  660:			shuffle(currentPlayer, state);
        -:  661:		}
    #####:  662:		drawCard(currentPlayer, state);
    #####:  663:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer] - 1];//top card of hand is most recently drawn card.
    #####:  664:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
    #####:  665:			drawntreasure++;
        -:  666:		else{
    #####:  667:			temphand[z] = cardDrawn;
    #####:  668:			state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####:  669:			z++;
        -:  670:		}
        -:  671:	}
    #####:  672:	while (z - 1 >= 0){
    #####:  673:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; // discard all cards in play that have been drawn
    #####:  674:		z = z - 1;
        -:  675:	}
    #####:  676:}
        -:  677:
    #####:  678:int playRemodel(struct gameState *state, int currentPlayer, int choice1, int choice2, int handPos)
        -:  679://Trash a card in the hand, and gain a card costing up to $2 more than the trashed card
        -:  680:{
        -:  681:	int i;
    #####:  682:	int j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  683:
    #####:  684:	if ((getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2))
        -:  685:	{
    #####:  686:		return -1;
        -:  687:	}
        -:  688:
    #####:  689:	gainCard(choice2, state, 0, currentPlayer);
        -:  690:
        -:  691:	//discard card from hand
    #####:  692:	discardCard(handPos, currentPlayer, state, 0);
        -:  693:
        -:  694:	//discard trashed card
    #####:  695:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  696:	{
    #####:  697:		if (state->hand[currentPlayer][i] == j)
        -:  698:		{
    #####:  699:			discardCard(i, currentPlayer, state, 0);
    #####:  700:			break;
        -:  701:		}
        -:  702:	}
        -:  703:
    #####:  704:	return 0;
        -:  705:}
        -:  706:
    #####:  707:void playSmithy(struct gameState *state, int currentPlayer, int handPos)
        -:  708:// Draw 3 cards
        -:  709:{
        -:  710:	int i;
    #####:  711:	for (i = 0; i < 3; i++)
        -:  712:	{
    #####:  713:		drawCard(currentPlayer, state);
        -:  714:	}
        -:  715:
        -:  716:	//discard card from hand
    #####:  717:	discardCard(handPos, currentPlayer, state, 0);
    #####:  718:}
        -:  719:
    #####:  720:void playBaron(struct gameState *state, int currentPlayer, int choice1, int handPos)
        -:  721://Add a buy.  OPTION:  Discard an Estate card and gain $4.  Otherwise, gain an Estate card.
        -:  722:{
    #####:  723:	state->numBuys++;//Increase buys by 1!
    #####:  724:	if (choice1 > 0){//Boolean true or going to discard an estate
    #####:  725:		int p = 0;//Iterator for hand!
    #####:  726:		int card_not_discarded = 1;//Flag for discard set!
    #####:  727:		while (card_not_discarded){
    #####:  728:			if (state->hand[currentPlayer][p] == estate){ //Found an estate card!
    #####:  729:				state->coins += 4;//Add 4 coins to the amount of coins
    #####:  730:				state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  731:				state->discardCount[currentPlayer]++;
    #####:  732:				for (; p < state->handCount[currentPlayer]; p++){
    #####:  733:					state->hand[currentPlayer][p] = state->hand[currentPlayer][p + 1];
        -:  734:				}
    #####:  735:				state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  736:				state->handCount[currentPlayer]--;
    #####:  737:				card_not_discarded = 0;//Exit the loop
        -:  738:			}
    #####:  739:			else if (p > state->handCount[currentPlayer]){
        -:  740:				if (DEBUG) {
        -:  741:					printf("No estate cards in your hand, invalid choice\n");
        -:  742:					printf("Must gain an estate if there are any\n");
        -:  743:				}
    #####:  744:				if (supplyCount(estate, state) > 0){
    #####:  745:					gainCard(estate, state, 1, currentPlayer);
    #####:  746:					state->supplyCount[estate]--;//Decrement estates
    #####:  747:					if (supplyCount(estate, state) == 0){
    #####:  748:						isGameOver(state);
        -:  749:					}
        -:  750:				}
    #####:  751:				card_not_discarded = 0;//Exit the loop
        -:  752:			}
        -:  753:
        -:  754:			else{
    #####:  755:				p++;//Next card
        -:  756:			}
        -:  757:		}
        -:  758:	}
        -:  759:
        -:  760:	else{
    #####:  761:		if (supplyCount(estate, state) > 0){
    #####:  762:			gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  763:			state->supplyCount[estate]--;//Decrement Estates
    #####:  764:			if (supplyCount(estate, state) == 0){
    #####:  765:				isGameOver(state);
        -:  766:			}
        -:  767:		}
        -:  768:	}
    #####:  769:}
        -:  770:
    #####:  771:int playTreasureMap(struct gameState *state, int currentPlayer, int handPos)
        -:  772://Trashing two treasure map cards from the hand = four gold on top of the deck.
        -:  773:{
        -:  774:	int i;
        -:  775:	int index;
        -:  776:
        -:  777:	//search hand for another treasure_map
    #####:  778:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  779:	{
    #####:  780:		if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -:  781:		{
    #####:  782:			index = i;
    #####:  783:			break;
        -:  784:		}
        -:  785:	}
    #####:  786:	if (index > -1)
        -:  787:	{
        -:  788:		//trash both treasure cards
    #####:  789:		discardCard(handPos, currentPlayer, state, 1);
    #####:  790:		discardCard(index, currentPlayer, state, 1);
        -:  791:
        -:  792:		//gain 4 Gold cards
    #####:  793:		for (i = 0; i < 4; i++)
        -:  794:		{
    #####:  795:			gainCard(gold, state, 1, currentPlayer);
        -:  796:		}
        -:  797:
        -:  798:		//return success
    #####:  799:		return 1;
        -:  800:	}
        -:  801:
        -:  802:	//no second treasure_map found in hand
    #####:  803:	return -1;
        -:  804:}
        -:  805:
    #####:  806:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  807:{
        -:  808:	int i;
        -:  809:	int j;
        -:  810:	int k;
        -:  811:	//int x;  //Unused after while loop removed from feast.
    #####:  812:	int currentPlayer = whoseTurn(state);
    #####:  813:	int nextPlayer = currentPlayer + 1;
        -:  814:	int temphand[MAX_HAND];
        -:  815:
    #####:  816:	int tributeRevealedCards[2] = { -1, -1 };
        -:  817:
    #####:  818:	if (nextPlayer > (state->numPlayers - 1)){
    #####:  819:		nextPlayer = 0;
        -:  820:	}
        -:  821:
        -:  822:	//uses switch to select card and perform actions
    #####:  823:	switch (card)
        -:  824:	{
        -:  825:	case adventurer:
        -:  826:
    #####:  827:		playAdventurer(state, currentPlayer);
    #####:  828:		return 0;
        -:  829:
        -:  830:	case council_room:
        -:  831:		//+4 Cards
    #####:  832:		for (i = 0; i < 4; i++)
        -:  833:		{
    #####:  834:			drawCard(currentPlayer, state);
        -:  835:		}
        -:  836:
        -:  837:		//+1 Buy
    #####:  838:		state->numBuys++;
        -:  839:
        -:  840:		//Each other player draws a card
    #####:  841:		for (i = 0; i < state->numPlayers; i++)
        -:  842:		{
    #####:  843:			if (i != currentPlayer)
        -:  844:			{
    #####:  845:				drawCard(i, state);
        -:  846:			}
        -:  847:		}
        -:  848:
        -:  849:		//put played card in played card pile
    #####:  850:		discardCard(handPos, currentPlayer, state, 0);
        -:  851:
    #####:  852:		return 0;
        -:  853:
        -:  854:	case feast:
        -:  855:		//gain card with cost up to 5
        -:  856:		//Backup hand
    #####:  857:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  858:			temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  859:			state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  860:		}
        -:  861:		//Backup hand
        -:  862:
        -:  863:		//Update Coins for Buy
    #####:  864:		updateCoins(currentPlayer, state, 5);
        -:  865://		x = 1;//Condition to loop on
        -:  866://		while (x == 1) {//Buy one card
    #####:  867:			if (supplyCount(choice1, state) <= 0){
        -:  868:				if (DEBUG)
        -:  869:					printf("None of that card left, sorry!\n");
        -:  870:
        -:  871:				if (DEBUG){
        -:  872:					printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  873:				}
        -:  874:			}
    #####:  875:			else if (state->coins < getCost(choice1)){
    #####:  876:				printf("That card is too expensive!\n");
        -:  877:
        -:  878:				if (DEBUG){
        -:  879:					printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  880:				}
        -:  881:			}
        -:  882:			else{
        -:  883:
        -:  884:				if (DEBUG){
        -:  885:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  886:				}
        -:  887:
    #####:  888:				gainCard(choice1, state, 0, currentPlayer);//Gain the card
        -:  889://				x = 0;//No more buying cards
        -:  890:
        -:  891:				if (DEBUG){
        -:  892:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  893:				}
        -:  894:
        -:  895:			}
        -:  896://		}
        -:  897:
        -:  898:		//Reset Hand
    #####:  899:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  900:			state->hand[currentPlayer][i] = temphand[i];
    #####:  901:			temphand[i] = -1;
        -:  902:		}
        -:  903:		//Reset Hand
        -:  904:
    #####:  905:		return 0;
        -:  906:
        -:  907:	case gardens:
    #####:  908:		return -1;
        -:  909:
        -:  910:	case mine:
    #####:  911:		j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  912:
    #####:  913:		if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  914:		{
    #####:  915:			return -1;
        -:  916:		}
        -:  917:
    #####:  918:		if (choice2 > treasure_map || choice2 < curse)
        -:  919:		{
    #####:  920:			return -1;
        -:  921:		}
        -:  922:
    #####:  923:		if ((getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2))
        -:  924:		{
    #####:  925:			return -1;
        -:  926:		}
        -:  927:
    #####:  928:		gainCard(choice2, state, 2, currentPlayer);
        -:  929:
        -:  930:		//discard card from hand
    #####:  931:		discardCard(handPos, currentPlayer, state, 0);
        -:  932:
        -:  933:		//discard trashed card
    #####:  934:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  935:		{
    #####:  936:			if (state->hand[currentPlayer][i] == j)
        -:  937:			{
    #####:  938:				discardCard(i, currentPlayer, state, 0);
    #####:  939:				break;
        -:  940:			}
        -:  941:		}
        -:  942:
    #####:  943:		return 0;
        -:  944:
        -:  945:	case remodel:
        -:  946:
    #####:  947:		return playRemodel(state, currentPlayer, choice1, choice2, handPos);
        -:  948:
        -:  949:	case smithy:
        -:  950:
    #####:  951:		playSmithy(state, currentPlayer, handPos);
    #####:  952:		return 0;
        -:  953:
        -:  954:	case village:
        -:  955:		//+1 Card
    #####:  956:		drawCard(currentPlayer, state);
        -:  957:
        -:  958:		//+2 Actions
    #####:  959:		state->numActions = state->numActions + 2;
        -:  960:
        -:  961:		//discard played card from hand
    #####:  962:		discardCard(handPos, currentPlayer, state, 0);
    #####:  963:		return 0;
        -:  964:
        -:  965:	case baron:
        -:  966:
    #####:  967:		playBaron(state, currentPlayer, choice1, handPos);
    #####:  968:		return 0;
        -:  969:
        -:  970:	case great_hall:
        -:  971:		//+1 Card
    #####:  972:		drawCard(currentPlayer, state);
        -:  973:
        -:  974:		//+1 Actions
    #####:  975:		state->numActions++;
        -:  976:
        -:  977:		//discard card from hand
    #####:  978:		discardCard(handPos, currentPlayer, state, 0);
    #####:  979:		return 0;
        -:  980:
        -:  981:	case minion:
        -:  982:		//+1 action
    #####:  983:		state->numActions++;
        -:  984:
        -:  985:		//discard card from hand
    #####:  986:		discardCard(handPos, currentPlayer, state, 0);
        -:  987:
    #####:  988:		if (choice1)		//+2 coins
        -:  989:		{
    #####:  990:			state->coins = state->coins + 2;
        -:  991:		}
        -:  992:
    #####:  993:		else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  994:		{
        -:  995:			//discard hand
    #####:  996:			while (numHandCards(state) > 0)
        -:  997:			{
    #####:  998:				discardCard(handPos, currentPlayer, state, 0);
        -:  999:			}
        -: 1000:
        -: 1001:			//draw 4
    #####: 1002:			for (i = 0; i < 4; i++)
        -: 1003:			{
    #####: 1004:				drawCard(currentPlayer, state);
        -: 1005:			}
        -: 1006:
        -: 1007:			//other players discard hand and redraw if hand size > 4
    #####: 1008:			for (i = 0; i < state->numPlayers; i++)
        -: 1009:			{
    #####: 1010:				if (i != currentPlayer)
        -: 1011:				{
    #####: 1012:					if (state->handCount[i] > 4)
        -: 1013:					{
        -: 1014:						//discard hand
    #####: 1015:						while (state->handCount[i] > 0)
        -: 1016:						{
    #####: 1017:							discardCard(handPos, i, state, 0);
        -: 1018:						}
        -: 1019:
        -: 1020:						//draw 4
    #####: 1021:						for (j = 0; j < 4; j++)
        -: 1022:						{
    #####: 1023:							drawCard(i, state);
        -: 1024:						}
        -: 1025:					}
        -: 1026:				}
        -: 1027:			}
        -: 1028:
        -: 1029:		}
    #####: 1030:		return 0;
        -: 1031:
        -: 1032:	case steward:
    #####: 1033:		if (choice1 == 1)
        -: 1034:		{
        -: 1035:			//+2 cards
    #####: 1036:			drawCard(currentPlayer, state);
    #####: 1037:			drawCard(currentPlayer, state);
        -: 1038:		}
    #####: 1039:		else if (choice1 == 2)
        -: 1040:		{
        -: 1041:			//+2 coins
    #####: 1042:			state->coins = state->coins + 2;
        -: 1043:		}
        -: 1044:		else
        -: 1045:		{
        -: 1046:			//trash 2 cards in hand
    #####: 1047:			discardCard(choice2, currentPlayer, state, 1);
    #####: 1048:			discardCard(choice3, currentPlayer, state, 1);
        -: 1049:		}
        -: 1050:
        -: 1051:		//discard card from hand
    #####: 1052:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1053:		return 0;
        -: 1054:
        -: 1055:	case tribute:
    #####: 1056:		if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####: 1057:			if (state->deckCount[nextPlayer] > 0){
    #####: 1058:				tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1059:				state->deckCount[nextPlayer]--;
        -: 1060:			}
    #####: 1061:			else if (state->discardCount[nextPlayer] > 0){
    #####: 1062:				tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer] - 1];
    #####: 1063:				state->discardCount[nextPlayer]--;
        -: 1064:			}
        -: 1065:			else{
        -: 1066:				//No Card to Reveal
        -: 1067:				if (DEBUG){
        -: 1068:					printf("No cards to reveal\n");
        -: 1069:				}
        -: 1070:			}
        -: 1071:		}
        -: 1072:
        -: 1073:		else{
    #####: 1074:			if (state->deckCount[nextPlayer] == 0){
    #####: 1075:				for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####: 1076:					state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1077:					state->deckCount[nextPlayer]++;
    #####: 1078:					state->discard[nextPlayer][i] = -1;
    #####: 1079:					state->discardCount[nextPlayer]--;
        -: 1080:				}
        -: 1081:
    #####: 1082:				shuffle(nextPlayer, state);//Shuffle the deck
        -: 1083:			}
    #####: 1084:			tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1085:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1086:			state->deckCount[nextPlayer]--;
    #####: 1087:			tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1088:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1089:			state->deckCount[nextPlayer]--;
        -: 1090:		}
        -: 1091:
    #####: 1092:		if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
    #####: 1093:			state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1094:			state->playedCardCount++;
    #####: 1095:			tributeRevealedCards[1] = -1;
        -: 1096:		}
        -: 1097:
    #####: 1098:		for (i = 0; i <= 2; i++){
    #####: 1099:			if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
    #####: 1100:				state->coins += 2;
        -: 1101:			}
        -: 1102:
    #####: 1103:			else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
    #####: 1104:				drawCard(currentPlayer, state);
    #####: 1105:				drawCard(currentPlayer, state);
        -: 1106:			}
        -: 1107:			else{//Action Card
    #####: 1108:				state->numActions = state->numActions + 2;
        -: 1109:			}
        -: 1110:		}
        -: 1111:
    #####: 1112:		return 0;
        -: 1113:
        -: 1114:	case ambassador:
    #####: 1115:		j = 0;		//used to check if player has enough cards to discard
        -: 1116:
    #####: 1117:		if (choice2 > 2 || choice2 < 0)
        -: 1118:		{
    #####: 1119:			return -1;
        -: 1120:		}
        -: 1121:
    #####: 1122:		if (choice1 == handPos)
        -: 1123:		{
    #####: 1124:			return -1;
        -: 1125:		}
        -: 1126:
    #####: 1127:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1128:		{
    #####: 1129:			if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1130:			{
    #####: 1131:				j++;
        -: 1132:			}
        -: 1133:		}
    #####: 1134:		if (j < choice2)
        -: 1135:		{
    #####: 1136:			return -1;
        -: 1137:		}
        -: 1138:
        -: 1139:		if (DEBUG)
        -: 1140:			printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1141:
        -: 1142:		//increase supply count for choosen card by amount being discarded
    #####: 1143:		state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1144:
        -: 1145:		//each other player gains a copy of revealed card
    #####: 1146:		for (i = 0; i < state->numPlayers; i++)
        -: 1147:		{
    #####: 1148:			if (i != currentPlayer)
        -: 1149:			{
    #####: 1150:				gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1151:			}
        -: 1152:		}
        -: 1153:
        -: 1154:		//discard played card from hand
    #####: 1155:		discardCard(handPos, currentPlayer, state, 0);
        -: 1156:
        -: 1157:		//trash copies of cards returned to supply
    #####: 1158:		for (j = 0; j < choice2; j++)
        -: 1159:		{
    #####: 1160:			for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1161:			{
    #####: 1162:				if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1163:				{
    #####: 1164:					discardCard(i, currentPlayer, state, 1);
    #####: 1165:					break;
        -: 1166:				}
        -: 1167:			}
        -: 1168:		}
        -: 1169:
    #####: 1170:		return 0;
        -: 1171:
        -: 1172:	case cutpurse:
        -: 1173:
    #####: 1174:		updateCoins(currentPlayer, state, 2);
    #####: 1175:		for (i = 0; i < state->numPlayers; i++)
        -: 1176:		{
    #####: 1177:			if (i != currentPlayer)
        -: 1178:			{
    #####: 1179:				for (j = 0; j < state->handCount[i]; j++)
        -: 1180:				{
    #####: 1181:					if (state->hand[i][j] == copper)
        -: 1182:					{
    #####: 1183:						discardCard(j, i, state, 0);
    #####: 1184:						break;
        -: 1185:					}
    #####: 1186:					if (j == state->handCount[i])
        -: 1187:					{
    #####: 1188:						for (k = 0; k < state->handCount[i]; k++)
        -: 1189:						{
        -: 1190:							if (DEBUG)
        -: 1191:								printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1192:						}
    #####: 1193:						break;
        -: 1194:					}
        -: 1195:				}
        -: 1196:
        -: 1197:			}
        -: 1198:
        -: 1199:		}
        -: 1200:
        -: 1201:		//discard played card from hand
    #####: 1202:		discardCard(handPos, currentPlayer, state, 0);
        -: 1203:
    #####: 1204:		return 0;
        -: 1205:
        -: 1206:
        -: 1207:	case embargo:
        -: 1208:		//+2 Coins
    #####: 1209:		state->coins = state->coins + 2;
        -: 1210:
        -: 1211:		//see if selected pile is in play
    #####: 1212:		if (state->supplyCount[choice1] == -1)
        -: 1213:		{
    #####: 1214:			return -1;
        -: 1215:		}
        -: 1216:
        -: 1217:		//add embargo token to selected supply pile
    #####: 1218:		state->embargoTokens[choice1]++;
        -: 1219:
        -: 1220:		//trash card
    #####: 1221:		discardCard(handPos, currentPlayer, state, 1);
    #####: 1222:		return 0;
        -: 1223:
        -: 1224:	case outpost:
        -: 1225:		//set outpost flag
    #####: 1226:		state->outpostPlayed++;
        -: 1227:
        -: 1228:		//discard card
    #####: 1229:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1230:		return 0;
        -: 1231:
        -: 1232:	case salvager:
        -: 1233:		//+1 buy
    #####: 1234:		state->numBuys++;
        -: 1235:
    #####: 1236:		if (choice1)
        -: 1237:		{
        -: 1238:			//gain coins equal to trashed card
    #####: 1239:			state->coins = state->coins + getCost(handCard(choice1, state));
        -: 1240:			//trash card
    #####: 1241:			discardCard(choice1, currentPlayer, state, 1);
        -: 1242:		}
        -: 1243:
        -: 1244:		//discard card
    #####: 1245:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1246:		return 0;
        -: 1247:
        -: 1248:	case sea_hag:
    #####: 1249:		for (i = 0; i < state->numPlayers; i++){
    #####: 1250:			if (i != currentPlayer){
    #####: 1251:				state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1252:				state->discardCount[i]++;
    #####: 1253:				state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1254:			}
        -: 1255:		}
    #####: 1256:		return 0;
        -: 1257:
        -: 1258:	case treasure_map:
        -: 1259:
    #####: 1260:		return playTreasureMap(state, currentPlayer, handPos);
        -: 1261:	}
    #####: 1262:	return -1;
        -: 1263:}
        -: 1264:
    #####: 1265:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1266:{
        -: 1267:
        -: 1268:	//if card is not trashed, added to Played pile 
    #####: 1269:	if (trashFlag < 1)
        -: 1270:	{
        -: 1271:		//add card to played pile
    #####: 1272:		state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
    #####: 1273:		state->playedCardCount++;
        -: 1274:	}
        -: 1275:
        -: 1276:	//set played card to -1
    #####: 1277:	state->hand[currentPlayer][handPos] = -1;
        -: 1278:
        -: 1279:	//remove card from player's hand
    #####: 1280:	if (handPos == (state->handCount[currentPlayer] - 1)) 	//last card in hand array is played
        -: 1281:	{
        -: 1282:		//reduce number of cards in hand
    #####: 1283:		state->handCount[currentPlayer]--;
        -: 1284:	}
    #####: 1285:	else if (state->handCount[currentPlayer] == 1) //only one card in hand
        -: 1286:	{
        -: 1287:		//reduce number of cards in hand
    #####: 1288:		state->handCount[currentPlayer]--;
        -: 1289:	}
        -: 1290:	else
        -: 1291:	{
        -: 1292:		//replace discarded card with last card in hand
    #####: 1293:		state->hand[currentPlayer][handPos] = state->hand[currentPlayer][(state->handCount[currentPlayer] - 1)];
        -: 1294:		//set last card to -1
    #####: 1295:		state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1296:		//reduce number of cards in hand
    #####: 1297:		state->handCount[currentPlayer]--;
        -: 1298:	}
        -: 1299:
    #####: 1300:	return 0;
        -: 1301:}
        -: 1302:
    #####: 1303:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1304:{
        -: 1305:	//Note: supplyPos is enum of choosen card
        -: 1306:
        -: 1307:	//check if supply pile is empty (0) or card is not used in game (-1)
    #####: 1308:	if (supplyCount(supplyPos, state) < 1)
        -: 1309:	{
    #####: 1310:		return -1;
        -: 1311:	}
        -: 1312:
        -: 1313:	//added card for [whoseTurn] current player:
        -: 1314:	// toFlag = 0 : add to discard
        -: 1315:	// toFlag = 1 : add to deck
        -: 1316:	// toFlag = 2 : add to hand
        -: 1317:
    #####: 1318:	if (toFlag == 1)
        -: 1319:	{
    #####: 1320:		state->deck[player][state->deckCount[player]] = supplyPos;
    #####: 1321:		state->deckCount[player]++;
        -: 1322:	}
    #####: 1323:	else if (toFlag == 2)
        -: 1324:	{
    #####: 1325:		state->hand[player][state->handCount[player]] = supplyPos;
    #####: 1326:		state->handCount[player]++;
        -: 1327:	}
        -: 1328:	else
        -: 1329:	{
    #####: 1330:		state->discard[player][state->discardCount[player]] = supplyPos;
    #####: 1331:		state->discardCount[player]++;
        -: 1332:	}
        -: 1333:
        -: 1334:	//decrease number in supply pile
    #####: 1335:	state->supplyCount[supplyPos]--;
        -: 1336:
    #####: 1337:	return 0;
        -: 1338:}
        -: 1339:
       16: 1340:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1341:{
        -: 1342:	int i;
        -: 1343:
        -: 1344:	//reset coin count
       16: 1345:	state->coins = 0;
        -: 1346:
        -: 1347:	//add coins for each Treasure card in player's hand
       66: 1348:	for (i = 0; i < state->handCount[player]; i++)
        -: 1349:	{
       50: 1350:		if (state->hand[player][i] == copper)
        -: 1351:		{
       32: 1352:			state->coins += 1;
        -: 1353:		}
       18: 1354:		else if (state->hand[player][i] == silver)
        -: 1355:		{
    #####: 1356:			state->coins += 2;
        -: 1357:		}
       18: 1358:		else if (state->hand[player][i] == gold)
        -: 1359:		{
    #####: 1360:			state->coins += 3;
        -: 1361:		}
        -: 1362:	}
        -: 1363:
        -: 1364:	//add bonus
       16: 1365:	state->coins += bonus;
        -: 1366:
       16: 1367:	return 0;
        -: 1368:}
        -: 1369:
        -: 1370:
        -: 1371://end of dominion.c
File 'dominion.c'
Lines executed:27.11% of 557
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
      462:    8:int compare(const void* a, const void* b) {
      462:    9:	if (*(int*)a > *(int*)b)
    #####:   10:		return 1;
      462:   11:	if (*(int*)a < *(int*)b)
      165:   12:		return -1;
      297:   13:	return 0;
        -:   14:}
        -:   15:
       20:   16:struct gameState* newGame() {
       20:   17:	struct gameState* g = malloc(sizeof(struct gameState));
       20:   18:	return g;
        -:   19:}
        -:   20:
      127:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:	int k8, int k9, int k10) {
      127:   23:	int* k = malloc(10 * sizeof(int));
      127:   24:	k[0] = k1;
      127:   25:	k[1] = k2;
      127:   26:	k[2] = k3;
      127:   27:	k[3] = k4;
      127:   28:	k[4] = k5;
      127:   29:	k[5] = k6;
      127:   30:	k[6] = k7;
      127:   31:	k[7] = k8;
      127:   32:	k[8] = k9;
      127:   33:	k[9] = k10;
      127:   34:	return k;
        -:   35:}
        -:   36:
      127:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		struct gameState *state) {
        -:   39:
        -:   40:	int i;
        -:   41:	int j;
        -:   42:	int it;
        -:   43:	//set up random number generator
      127:   44:	SelectStream(1);
      127:   45:	PutSeed((long)randomSeed);
        -:   46:
        -:   47:	//check number of players
      127:   48:	if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:	{
    #####:   50:		return -1;
        -:   51:	}
        -:   52:
        -:   53:	//set number of players
      127:   54:	state->numPlayers = numPlayers;
        -:   55:
        -:   56:	//check selected kingdom cards are different
      422:   57:	for (i = 0; i < 10; i++)
        -:   58:	{
     3992:   59:		for (j = 0; j < 10; j++)
        -:   60:		{
     3697:   61:			if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:			{
      117:   63:				return -1;
        -:   64:			}
        -:   65:		}
        -:   66:	}
        -:   67:
        -:   68:
        -:   69:	//initialize supply
        -:   70:	///////////////////////////////
        -:   71:
        -:   72:	//set number of Curse cards
       10:   73:	if (numPlayers == 2)
        -:   74:	{
        2:   75:		state->supplyCount[curse] = 10;
        -:   76:	}
        8:   77:	else if (numPlayers == 3)
        -:   78:	{
        3:   79:		state->supplyCount[curse] = 20;
        -:   80:	}
        -:   81:	else
        -:   82:	{
        5:   83:		state->supplyCount[curse] = 30;
        -:   84:	}
        -:   85:
        -:   86:	//set number of Victory cards
       10:   87:	if (numPlayers == 2)
        -:   88:	{
        2:   89:		state->supplyCount[estate] = 8;
        2:   90:		state->supplyCount[duchy] = 8;
        2:   91:		state->supplyCount[province] = 8;
        -:   92:	}
        -:   93:	else
        -:   94:	{
        8:   95:		state->supplyCount[estate] = 12;
        8:   96:		state->supplyCount[duchy] = 12;
        8:   97:		state->supplyCount[province] = 12;
        -:   98:	}
        -:   99:
        -:  100:	//set number of Treasure cards
       10:  101:	state->supplyCount[copper] = 60 - (7 * numPlayers);
       10:  102:	state->supplyCount[silver] = 40;
       10:  103:	state->supplyCount[gold] = 30;
        -:  104:
        -:  105:	//set number of Kingdom cards
      210:  106:	for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:	{
     1650:  108:		for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:		{
     1550:  110:			if (kingdomCards[j] == i)
        -:  111:			{
        -:  112:				//check if card is a 'Victory' Kingdom card
      100:  113:				if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:				{
       18:  115:					if (numPlayers == 2){
        2:  116:						state->supplyCount[i] = 8;
        -:  117:					}
        7:  118:					else{ state->supplyCount[i] = 12; }
        -:  119:				}
        -:  120:				else
        -:  121:				{
       91:  122:					state->supplyCount[i] = 10;
        -:  123:				}
      100:  124:				break;
        -:  125:			}
        -:  126:			else    //card is not in the set choosen for the game
        -:  127:			{
     1450:  128:				state->supplyCount[i] = -1;
        -:  129:			}
        -:  130:		}
        -:  131:
        -:  132:	}
        -:  133:
        -:  134:	////////////////////////
        -:  135:	//supply intilization complete
        -:  136:
        -:  137:	//set player decks
       43:  138:	for (i = 0; i < numPlayers; i++)
        -:  139:	{
       33:  140:		state->deckCount[i] = 0;
      132:  141:		for (j = 0; j < 3; j++)
        -:  142:		{
       99:  143:			state->deck[i][j] = estate;
       99:  144:			state->deckCount[i]++;
        -:  145:		}
      264:  146:		for (j = 3; j < 10; j++)
        -:  147:		{
      231:  148:			state->deck[i][j] = copper;
      231:  149:			state->deckCount[i]++;
        -:  150:		}
        -:  151:	}
        -:  152:
        -:  153:	//shuffle player decks
       43:  154:	for (i = 0; i < numPlayers; i++)
        -:  155:	{
       33:  156:		if (shuffle(i, state) < 0)
        -:  157:		{
    #####:  158:			return -1;
        -:  159:		}
        -:  160:	}
        -:  161:
        -:  162:	//draw player hands
       43:  163:	for (i = 0; i < numPlayers; i++)
        -:  164:	{
        -:  165:		//initialize hand size to zero
       33:  166:		state->handCount[i] = 0;
       33:  167:		state->discardCount[i] = 0;
        -:  168:		//draw 5 cards
        -:  169:		// for (j = 0; j < 5; j++)
        -:  170:		//	{
        -:  171:		//	  drawCard(i, state);
        -:  172:		//	}
        -:  173:	}
        -:  174:
        -:  175:	//set embargo tokens to 0 for all supply piles
      280:  176:	for (i = 0; i <= treasure_map; i++)
        -:  177:	{
      270:  178:		state->embargoTokens[i] = 0;
        -:  179:	}
        -:  180:
        -:  181:	//initialize first player's turn
       10:  182:	state->outpostPlayed = 0;
       10:  183:	state->phase = 0;
       10:  184:	state->numActions = 1;
       10:  185:	state->numBuys = 1;
       10:  186:	state->playedCardCount = 0;
       10:  187:	state->whoseTurn = 0;
       10:  188:	state->handCount[state->whoseTurn] = 0;
        -:  189:	//int it; move to top
        -:  190:
        -:  191:	//Moved draw cards to here, only drawing at the start of a turn
       60:  192:	for (it = 0; it < 5; it++){
       50:  193:		drawCard(state->whoseTurn, state);
        -:  194:	}
        -:  195:
       10:  196:	updateCoins(state->whoseTurn, state, 0);
        -:  197:
       10:  198:	return 0;
        -:  199:}
        -:  200:
       48:  201:int shuffle(int player, struct gameState *state) {
        -:  202:
        -:  203:
        -:  204:	int newDeck[MAX_DECK];
       48:  205:	int newDeckPos = 0;
        -:  206:	int card;
        -:  207:	int i;
        -:  208:
       48:  209:	if (state->deckCount[player] < 1)
       15:  210:		return -1;
       33:  211:	qsort((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
        -:  212:	/* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
      396:  214:	while (state->deckCount[player] > 0) {
      330:  215:		card = floor(Random() * state->deckCount[player]);
      330:  216:		newDeck[newDeckPos] = state->deck[player][card];
      330:  217:		newDeckPos++;
     1050:  218:		for (i = card; i < state->deckCount[player] - 1; i++) {
      720:  219:			state->deck[player][i] = state->deck[player][i + 1];
        -:  220:		}
      330:  221:		state->deckCount[player]--;
        -:  222:	}
      363:  223:	for (i = 0; i < newDeckPos; i++) {
      330:  224:		state->deck[player][i] = newDeck[i];
      330:  225:		state->deckCount[player]++;
        -:  226:	}
        -:  227:
       33:  228:	return 0;
        -:  229:}
        -:  230:
        4:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state)
        -:  232:{
        -:  233:	int card;
        4:  234:	int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:	//check if it is the right phase
        4:  237:	if (state->phase != 0)
        -:  238:	{
    #####:  239:		return -1;
        -:  240:	}
        -:  241:
        -:  242:	//check if player has enough actions
        4:  243:	if (state->numActions < 1)
        -:  244:	{
        4:  245:		return -1;
        -:  246:	}
        -:  247:
        -:  248:	//get card played
    #####:  249:	card = handCard(handPos, state);
        -:  250:
        -:  251:	//check if selected card is an action
    #####:  252:	if (card < adventurer || card > treasure_map)
        -:  253:	{
    #####:  254:		return -1;
        -:  255:	}
        -:  256:
        -:  257:	//play card
    #####:  258:	if (cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0)
        -:  259:	{
    #####:  260:		return -1;
        -:  261:	}
        -:  262:
        -:  263:	//reduce number of actions
    #####:  264:	state->numActions--;
        -:  265:
        -:  266:	//update coins (Treasure cards may be added with card draws)
    #####:  267:	updateCoins(state->whoseTurn, state, coin_bonus);
        -:  268:
    #####:  269:	return 0;
        -:  270:}
        -:  271:
        3:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:	int who;
        -:  274:	if (DEBUG){
        -:  275:		printf("Entering buyCard...\n");
        -:  276:	}
        -:  277:
        -:  278:	// I don't know what to do about the phase thing.
        -:  279:
        3:  280:	who = state->whoseTurn;
        -:  281:
        3:  282:	if (state->numBuys < 1){
        -:  283:		if (DEBUG)
        -:  284:			printf("You do not have any buys left\n");
        3:  285:		return -1;
        -:  286:	}
    #####:  287:	else if (supplyCount(supplyPos, state) < 1){
        -:  288:		if (DEBUG)
        -:  289:			printf("There are not any of that type of card left\n");
    #####:  290:		return -1;
        -:  291:	}
    #####:  292:	else if (state->coins < getCost(supplyPos)){
        -:  293:		if (DEBUG)
        -:  294:			printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  295:		return -1;
        -:  296:	}
        -:  297:	else {
    #####:  298:		state->phase = 1;
        -:  299:		//state->supplyCount[supplyPos]--;
    #####:  300:		gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  301:
    #####:  302:		state->coins = (state->coins) - (getCost(supplyPos));
    #####:  303:		state->numBuys--;
        -:  304:		if (DEBUG)
        -:  305:			printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  306:	}
        -:  307:
        -:  308:	//state->discard[who][state->discardCount[who]] = supplyPos;
        -:  309:	//state->discardCount[who]++;
        -:  310:
    #####:  311:	return 0;
        -:  312:}
        -:  313:
    #####:  314:int numHandCards(struct gameState *state) {
    #####:  315:	return state->handCount[whoseTurn(state)];
        -:  316:}
        -:  317:
    #####:  318:int handCard(int handPos, struct gameState *state) {
    #####:  319:	int currentPlayer = whoseTurn(state);
    #####:  320:	return state->hand[currentPlayer][handPos];
        -:  321:}
        -:  322:
    #####:  323:int supplyCount(int card, struct gameState *state) {
    #####:  324:	return state->supplyCount[card];
        -:  325:}
        -:  326:
    #####:  327:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  328:	int i;
    #####:  329:	int count = 0;
        -:  330:
    #####:  331:	for (i = 0; i < state->deckCount[player]; i++)
        -:  332:	{
    #####:  333:		if (state->deck[player][i] == card) count++;
        -:  334:	}
        -:  335:
    #####:  336:	for (i = 0; i < state->handCount[player]; i++)
        -:  337:	{
    #####:  338:		if (state->hand[player][i] == card) count++;
        -:  339:	}
        -:  340:
    #####:  341:	for (i = 0; i < state->discardCount[player]; i++)
        -:  342:	{
    #####:  343:		if (state->discard[player][i] == card) count++;
        -:  344:	}
        -:  345:
    #####:  346:	return count;
        -:  347:}
        -:  348:
        3:  349:int whoseTurn(struct gameState *state) {
        3:  350:	return state->whoseTurn;
        -:  351:}
        -:  352:
        3:  353:int endTurn(struct gameState *state) {
        -:  354:	int k;
        -:  355:	int i;
        3:  356:	int currentPlayer = whoseTurn(state);
        -:  357:
        -:  358:	//Discard hand
        3:  359:	for (i = 0; i < state->handCount[currentPlayer]; i++){
    #####:  360:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  361:		state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  362:	}
        3:  363:	state->handCount[currentPlayer] = 0;//Reset hand count
        -:  364:
        -:  365:	//Code for determining the player
        3:  366:	if (currentPlayer < (state->numPlayers - 1)){
    #####:  367:		state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  368:	}
        -:  369:	else{
        3:  370:		state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  371:	}
        -:  372:
        3:  373:	state->outpostPlayed = 0;
        3:  374:	state->phase = 0;
        3:  375:	state->numActions = 1;
        3:  376:	state->coins = 0;
        3:  377:	state->numBuys = 1;
        3:  378:	state->playedCardCount = 0;
        3:  379:	state->handCount[state->whoseTurn] = 0;
        -:  380:
        -:  381:	//int k; move to top
        -:  382:	//Next player draws hand
       18:  383:	for (k = 0; k < 5; k++){
       15:  384:		drawCard(state->whoseTurn, state);//Draw a card
        -:  385:	}
        -:  386:
        -:  387:	//Update money
        3:  388:	updateCoins(state->whoseTurn, state, 0);
        -:  389:
        3:  390:	return 0;
        -:  391:}
        -:  392:
    #####:  393:int isGameOver(struct gameState *state) {
        -:  394:	int i;
        -:  395:	int j;
        -:  396:
        -:  397:	//if stack of Province cards is empty, the game ends
    #####:  398:	if (state->supplyCount[province] == 0)
        -:  399:	{
    #####:  400:		return 1;
        -:  401:	}
        -:  402:
        -:  403:	//if three supply pile are at 0, the game ends
    #####:  404:	j = 0;
    #####:  405:	for (i = 0; i < 25; i++)
        -:  406:	{
    #####:  407:		if (state->supplyCount[i] == 0)
        -:  408:		{
    #####:  409:			j++;
        -:  410:		}
        -:  411:	}
    #####:  412:	if (j >= 3)
        -:  413:	{
    #####:  414:		return 1;
        -:  415:	}
        -:  416:
    #####:  417:	return 0;
        -:  418:}
        -:  419:
    #####:  420:int scoreFor(int player, struct gameState *state) {
        -:  421:
        -:  422:	int i;
    #####:  423:	int score = 0;
        -:  424:	//score from hand
    #####:  425:	for (i = 0; i < state->handCount[player]; i++)
        -:  426:	{
    #####:  427:		if (state->hand[player][i] == curse) { score = score - 1; };
    #####:  428:		if (state->hand[player][i] == estate) { score = score + 1; };
    #####:  429:		if (state->hand[player][i] == duchy) { score = score + 3; };
    #####:  430:		if (state->hand[player][i] == province) { score = score + 6; };
    #####:  431:		if (state->hand[player][i] == great_hall) { score = score + 1; };
    #####:  432:		if (state->hand[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  433:	}
        -:  434:
        -:  435:	//score from discard
    #####:  436:	for (i = 0; i < state->discardCount[player]; i++)
        -:  437:	{
    #####:  438:		if (state->discard[player][i] == curse) { score = score - 1; };
    #####:  439:		if (state->discard[player][i] == estate) { score = score + 1; };
    #####:  440:		if (state->discard[player][i] == duchy) { score = score + 3; };
    #####:  441:		if (state->discard[player][i] == province) { score = score + 6; };
    #####:  442:		if (state->discard[player][i] == great_hall) { score = score + 1; };
    #####:  443:		if (state->discard[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  444:	}
        -:  445:
        -:  446:	//score from deck
    #####:  447:	for (i = 0; i < state->discardCount[player]; i++)
        -:  448:	{
    #####:  449:		if (state->deck[player][i] == curse) { score = score - 1; };
    #####:  450:		if (state->deck[player][i] == estate) { score = score + 1; };
    #####:  451:		if (state->deck[player][i] == duchy) { score = score + 3; };
    #####:  452:		if (state->deck[player][i] == province) { score = score + 6; };
    #####:  453:		if (state->deck[player][i] == great_hall) { score = score + 1; };
    #####:  454:		if (state->deck[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  455:	}
        -:  456:
    #####:  457:	return score;
        -:  458:}
        -:  459:
    #####:  460:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  461:	int i;
        -:  462:	int j;
        -:  463:	int highScore;
        -:  464:	int currentPlayer;
        -:  465:
        -:  466:	//get score for each player
    #####:  467:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  468:	{
        -:  469:		//set unused player scores to -9999
    #####:  470:		if (i >= state->numPlayers)
        -:  471:		{
    #####:  472:			players[i] = -9999;
        -:  473:		}
        -:  474:		else
        -:  475:		{
    #####:  476:			players[i] = scoreFor(i, state);
        -:  477:		}
        -:  478:	}
        -:  479:
        -:  480:	//find highest score
    #####:  481:	j = 0;
    #####:  482:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  483:	{
    #####:  484:		if (players[i] > players[j])
        -:  485:		{
    #####:  486:			j = i;
        -:  487:		}
        -:  488:	}
    #####:  489:	highScore = players[j];
        -:  490:
        -:  491:	//add 1 to players who had less turns
    #####:  492:	currentPlayer = whoseTurn(state);
    #####:  493:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  494:	{
    #####:  495:		if (players[i] == highScore && i > currentPlayer)
        -:  496:		{
    #####:  497:			players[i]++;
        -:  498:		}
        -:  499:	}
        -:  500:
        -:  501:	//find new highest score
    #####:  502:	j = 0;
    #####:  503:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  504:	{
    #####:  505:		if (players[i] > players[j])
        -:  506:		{
    #####:  507:			j = i;
        -:  508:		}
        -:  509:	}
    #####:  510:	highScore = players[j];
        -:  511:
        -:  512:	//set winners in array to 1 and rest to 0
    #####:  513:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  514:	{
    #####:  515:		if (players[i] == highScore)
        -:  516:		{
    #####:  517:			players[i] = 1;
        -:  518:		}
        -:  519:		else
        -:  520:		{
    #####:  521:			players[i] = 0;
        -:  522:		}
        -:  523:	}
        -:  524:
    #####:  525:	return 0;
        -:  526:}
        -:  527:
       65:  528:int drawCard(int player, struct gameState *state)
        -:  529:{
        -:  530:	int count;
        -:  531:	int deckCounter;
       65:  532:	if (state->deckCount[player] <= 0){//Deck is empty
        -:  533:
        -:  534:		//Step 1 Shuffle the discard pile back into a deck
        -:  535:		int i;
        -:  536:		//Move discard to deck
       15:  537:		for (i = 0; i < state->discardCount[player]; i++){
    #####:  538:			state->deck[player][i] = state->discard[player][i];
    #####:  539:			state->discard[player][i] = -1;
        -:  540:		}
        -:  541:
       15:  542:		state->deckCount[player] = state->discardCount[player];
       15:  543:		state->discardCount[player] = 0;//Reset discard
        -:  544:
        -:  545:		//Shufffle the deck
       15:  546:		shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  547:
        -:  548:		if (DEBUG){//Debug statements
        -:  549:			printf("Deck count now: %d\n", state->deckCount[player]);
        -:  550:		}
        -:  551:
       15:  552:		state->discardCount[player] = 0;
        -:  553:
        -:  554:		//Step 2 Draw Card
       15:  555:		count = state->handCount[player];//Get current player's hand count
        -:  556:
        -:  557:		if (DEBUG){//Debug statements
        -:  558:			printf("Current hand count: %d\n", count);
        -:  559:		}
        -:  560:
       15:  561:		deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  562:
       15:  563:		if (deckCounter == 0)
       15:  564:			return -1;
        -:  565:
    #####:  566:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
    #####:  567:		state->deckCount[player]--;
    #####:  568:		state->handCount[player]++;//Increment hand count
        -:  569:	}
        -:  570:
        -:  571:	else{
       50:  572:		int count = state->handCount[player];//Get current hand count for player
        -:  573:		int deckCounter;
        -:  574:		if (DEBUG){//Debug statements
        -:  575:			printf("Current hand count: %d\n", count);
        -:  576:		}
        -:  577:
       50:  578:		deckCounter = state->deckCount[player];//Create holder for the deck count
       50:  579:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
       50:  580:		state->deckCount[player]--;
       50:  581:		state->handCount[player]++;//Increment hand count
        -:  582:	}
        -:  583:
       50:  584:	return 0;
        -:  585:}
        -:  586:
    #####:  587:int getCost(int cardNumber)
        -:  588:{
    #####:  589:	switch (cardNumber)
        -:  590:	{
        -:  591:	case curse:
    #####:  592:		return 0;
        -:  593:	case estate:
    #####:  594:		return 2;
        -:  595:	case duchy:
    #####:  596:		return 5;
        -:  597:	case province:
    #####:  598:		return 8;
        -:  599:	case copper:
    #####:  600:		return 0;
        -:  601:	case silver:
    #####:  602:		return 3;
        -:  603:	case gold:
    #####:  604:		return 6;
        -:  605:	case adventurer:
    #####:  606:		return 6;
        -:  607:	case council_room:
    #####:  608:		return 5;
        -:  609:	case feast:
    #####:  610:		return 4;
        -:  611:	case gardens:
    #####:  612:		return 4;
        -:  613:	case mine:
    #####:  614:		return 5;
        -:  615:	case remodel:
    #####:  616:		return 4;
        -:  617:	case smithy:
    #####:  618:		return 4;
        -:  619:	case village:
    #####:  620:		return 3;
        -:  621:	case baron:
    #####:  622:		return 4;
        -:  623:	case great_hall:
    #####:  624:		return 3;
        -:  625:	case minion:
    #####:  626:		return 5;
        -:  627:	case steward:
    #####:  628:		return 3;
        -:  629:	case tribute:
    #####:  630:		return 5;
        -:  631:	case ambassador:
    #####:  632:		return 3;
        -:  633:	case cutpurse:
    #####:  634:		return 4;
        -:  635:	case embargo:
    #####:  636:		return 2;
        -:  637:	case outpost:
    #####:  638:		return 5;
        -:  639:	case salvager:
    #####:  640:		return 4;
        -:  641:	case sea_hag:
    #####:  642:		return 4;
        -:  643:	case treasure_map:
    #####:  644:		return 4;
        -:  645:	}
        -:  646:
    #####:  647:	return -1;
        -:  648:}
        -:  649:
    #####:  650:void playAdventurer(struct gameState *state, int currentPlayer)
        -:  651:// Reveal cards from deck until 2 Treasure cards are found.  Put those Treasure cards in the hand and discard the rest.
        -:  652:{
    #####:  653:	int drawntreasure = 0;
        -:  654:	int temphand[MAX_HAND];
        -:  655:	int cardDrawn;
    #####:  656:	int z = 0; // this is the counter for the temp hand
        -:  657:
    #####:  658:	while (drawntreasure < 2){
    #####:  659:		if (state->deckCount[currentPlayer] < 1){//if the deck is empty we need to shuffle discard and add to deck
    #####:  660:			shuffle(currentPlayer, state);
        -:  661:		}
    #####:  662:		drawCard(currentPlayer, state);
    #####:  663:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer] - 1];//top card of hand is most recently drawn card.
    #####:  664:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
    #####:  665:			drawntreasure++;
        -:  666:		else{
    #####:  667:			temphand[z] = cardDrawn;
    #####:  668:			state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####:  669:			z++;
        -:  670:		}
        -:  671:	}
    #####:  672:	while (z - 1 >= 0){
    #####:  673:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; // discard all cards in play that have been drawn
    #####:  674:		z = z - 1;
        -:  675:	}
    #####:  676:}
        -:  677:
    #####:  678:int playRemodel(struct gameState *state, int currentPlayer, int choice1, int choice2, int handPos)
        -:  679://Trash a card in the hand, and gain a card costing up to $2 more than the trashed card
        -:  680:{
        -:  681:	int i;
    #####:  682:	int j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  683:
    #####:  684:	if ((getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2))
        -:  685:	{
    #####:  686:		return -1;
        -:  687:	}
        -:  688:
    #####:  689:	gainCard(choice2, state, 0, currentPlayer);
        -:  690:
        -:  691:	//discard card from hand
    #####:  692:	discardCard(handPos, currentPlayer, state, 0);
        -:  693:
        -:  694:	//discard trashed card
    #####:  695:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  696:	{
    #####:  697:		if (state->hand[currentPlayer][i] == j)
        -:  698:		{
    #####:  699:			discardCard(i, currentPlayer, state, 0);
    #####:  700:			break;
        -:  701:		}
        -:  702:	}
        -:  703:
    #####:  704:	return 0;
        -:  705:}
        -:  706:
    #####:  707:void playSmithy(struct gameState *state, int currentPlayer, int handPos)
        -:  708:// Draw 3 cards
        -:  709:{
        -:  710:	int i;
    #####:  711:	for (i = 0; i < 3; i++)
        -:  712:	{
    #####:  713:		drawCard(currentPlayer, state);
        -:  714:	}
        -:  715:
        -:  716:	//discard card from hand
    #####:  717:	discardCard(handPos, currentPlayer, state, 0);
    #####:  718:}
        -:  719:
    #####:  720:void playBaron(struct gameState *state, int currentPlayer, int choice1, int handPos)
        -:  721://Add a buy.  OPTION:  Discard an Estate card and gain $4.  Otherwise, gain an Estate card.
        -:  722:{
    #####:  723:	state->numBuys++;//Increase buys by 1!
    #####:  724:	if (choice1 > 0){//Boolean true or going to discard an estate
    #####:  725:		int p = 0;//Iterator for hand!
    #####:  726:		int card_not_discarded = 1;//Flag for discard set!
    #####:  727:		while (card_not_discarded){
    #####:  728:			if (state->hand[currentPlayer][p] == estate){ //Found an estate card!
    #####:  729:				state->coins += 4;//Add 4 coins to the amount of coins
    #####:  730:				state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  731:				state->discardCount[currentPlayer]++;
    #####:  732:				for (; p < state->handCount[currentPlayer]; p++){
    #####:  733:					state->hand[currentPlayer][p] = state->hand[currentPlayer][p + 1];
        -:  734:				}
    #####:  735:				state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  736:				state->handCount[currentPlayer]--;
    #####:  737:				card_not_discarded = 0;//Exit the loop
        -:  738:			}
    #####:  739:			else if (p > state->handCount[currentPlayer]){
        -:  740:				if (DEBUG) {
        -:  741:					printf("No estate cards in your hand, invalid choice\n");
        -:  742:					printf("Must gain an estate if there are any\n");
        -:  743:				}
    #####:  744:				if (supplyCount(estate, state) > 0){
    #####:  745:					gainCard(estate, state, 1, currentPlayer);
    #####:  746:					state->supplyCount[estate]--;//Decrement estates
    #####:  747:					if (supplyCount(estate, state) == 0){
    #####:  748:						isGameOver(state);
        -:  749:					}
        -:  750:				}
    #####:  751:				card_not_discarded = 0;//Exit the loop
        -:  752:			}
        -:  753:
        -:  754:			else{
    #####:  755:				p++;//Next card
        -:  756:			}
        -:  757:		}
        -:  758:	}
        -:  759:
        -:  760:	else{
    #####:  761:		if (supplyCount(estate, state) > 0){
    #####:  762:			gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  763:			state->supplyCount[estate]--;//Decrement Estates
    #####:  764:			if (supplyCount(estate, state) == 0){
    #####:  765:				isGameOver(state);
        -:  766:			}
        -:  767:		}
        -:  768:	}
    #####:  769:}
        -:  770:
    #####:  771:int playTreasureMap(struct gameState *state, int currentPlayer, int handPos)
        -:  772://Trashing two treasure map cards from the hand = four gold on top of the deck.
        -:  773:{
        -:  774:	int i;
        -:  775:	int index;
        -:  776:
        -:  777:	//search hand for another treasure_map
    #####:  778:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  779:	{
    #####:  780:		if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -:  781:		{
    #####:  782:			index = i;
    #####:  783:			break;
        -:  784:		}
        -:  785:	}
    #####:  786:	if (index > -1)
        -:  787:	{
        -:  788:		//trash both treasure cards
    #####:  789:		discardCard(handPos, currentPlayer, state, 1);
    #####:  790:		discardCard(index, currentPlayer, state, 1);
        -:  791:
        -:  792:		//gain 4 Gold cards
    #####:  793:		for (i = 0; i < 4; i++)
        -:  794:		{
    #####:  795:			gainCard(gold, state, 1, currentPlayer);
        -:  796:		}
        -:  797:
        -:  798:		//return success
    #####:  799:		return 1;
        -:  800:	}
        -:  801:
        -:  802:	//no second treasure_map found in hand
    #####:  803:	return -1;
        -:  804:}
        -:  805:
    #####:  806:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  807:{
        -:  808:	int i;
        -:  809:	int j;
        -:  810:	int k;
        -:  811:	//int x;  //Unused after while loop removed from feast.
    #####:  812:	int currentPlayer = whoseTurn(state);
    #####:  813:	int nextPlayer = currentPlayer + 1;
        -:  814:	int temphand[MAX_HAND];
        -:  815:
    #####:  816:	int tributeRevealedCards[2] = { -1, -1 };
        -:  817:
    #####:  818:	if (nextPlayer > (state->numPlayers - 1)){
    #####:  819:		nextPlayer = 0;
        -:  820:	}
        -:  821:
        -:  822:	//uses switch to select card and perform actions
    #####:  823:	switch (card)
        -:  824:	{
        -:  825:	case adventurer:
        -:  826:
    #####:  827:		playAdventurer(state, currentPlayer);
    #####:  828:		return 0;
        -:  829:
        -:  830:	case council_room:
        -:  831:		//+4 Cards
    #####:  832:		for (i = 0; i < 4; i++)
        -:  833:		{
    #####:  834:			drawCard(currentPlayer, state);
        -:  835:		}
        -:  836:
        -:  837:		//+1 Buy
    #####:  838:		state->numBuys++;
        -:  839:
        -:  840:		//Each other player draws a card
    #####:  841:		for (i = 0; i < state->numPlayers; i++)
        -:  842:		{
    #####:  843:			if (i != currentPlayer)
        -:  844:			{
    #####:  845:				drawCard(i, state);
        -:  846:			}
        -:  847:		}
        -:  848:
        -:  849:		//put played card in played card pile
    #####:  850:		discardCard(handPos, currentPlayer, state, 0);
        -:  851:
    #####:  852:		return 0;
        -:  853:
        -:  854:	case feast:
        -:  855:		//gain card with cost up to 5
        -:  856:		//Backup hand
    #####:  857:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  858:			temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  859:			state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  860:		}
        -:  861:		//Backup hand
        -:  862:
        -:  863:		//Update Coins for Buy
    #####:  864:		updateCoins(currentPlayer, state, 5);
        -:  865://		x = 1;//Condition to loop on
        -:  866://		while (x == 1) {//Buy one card
    #####:  867:			if (supplyCount(choice1, state) <= 0){
        -:  868:				if (DEBUG)
        -:  869:					printf("None of that card left, sorry!\n");
        -:  870:
        -:  871:				if (DEBUG){
        -:  872:					printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  873:				}
        -:  874:			}
    #####:  875:			else if (state->coins < getCost(choice1)){
    #####:  876:				printf("That card is too expensive!\n");
        -:  877:
        -:  878:				if (DEBUG){
        -:  879:					printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  880:				}
        -:  881:			}
        -:  882:			else{
        -:  883:
        -:  884:				if (DEBUG){
        -:  885:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  886:				}
        -:  887:
    #####:  888:				gainCard(choice1, state, 0, currentPlayer);//Gain the card
        -:  889://				x = 0;//No more buying cards
        -:  890:
        -:  891:				if (DEBUG){
        -:  892:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  893:				}
        -:  894:
        -:  895:			}
        -:  896://		}
        -:  897:
        -:  898:		//Reset Hand
    #####:  899:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  900:			state->hand[currentPlayer][i] = temphand[i];
    #####:  901:			temphand[i] = -1;
        -:  902:		}
        -:  903:		//Reset Hand
        -:  904:
    #####:  905:		return 0;
        -:  906:
        -:  907:	case gardens:
    #####:  908:		return -1;
        -:  909:
        -:  910:	case mine:
    #####:  911:		j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  912:
    #####:  913:		if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  914:		{
    #####:  915:			return -1;
        -:  916:		}
        -:  917:
    #####:  918:		if (choice2 > treasure_map || choice2 < curse)
        -:  919:		{
    #####:  920:			return -1;
        -:  921:		}
        -:  922:
    #####:  923:		if ((getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2))
        -:  924:		{
    #####:  925:			return -1;
        -:  926:		}
        -:  927:
    #####:  928:		gainCard(choice2, state, 2, currentPlayer);
        -:  929:
        -:  930:		//discard card from hand
    #####:  931:		discardCard(handPos, currentPlayer, state, 0);
        -:  932:
        -:  933:		//discard trashed card
    #####:  934:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  935:		{
    #####:  936:			if (state->hand[currentPlayer][i] == j)
        -:  937:			{
    #####:  938:				discardCard(i, currentPlayer, state, 0);
    #####:  939:				break;
        -:  940:			}
        -:  941:		}
        -:  942:
    #####:  943:		return 0;
        -:  944:
        -:  945:	case remodel:
        -:  946:
    #####:  947:		return playRemodel(state, currentPlayer, choice1, choice2, handPos);
        -:  948:
        -:  949:	case smithy:
        -:  950:
    #####:  951:		playSmithy(state, currentPlayer, handPos);
    #####:  952:		return 0;
        -:  953:
        -:  954:	case village:
        -:  955:		//+1 Card
    #####:  956:		drawCard(currentPlayer, state);
        -:  957:
        -:  958:		//+2 Actions
    #####:  959:		state->numActions = state->numActions + 2;
        -:  960:
        -:  961:		//discard played card from hand
    #####:  962:		discardCard(handPos, currentPlayer, state, 0);
    #####:  963:		return 0;
        -:  964:
        -:  965:	case baron:
        -:  966:
    #####:  967:		playBaron(state, currentPlayer, choice1, handPos);
    #####:  968:		return 0;
        -:  969:
        -:  970:	case great_hall:
        -:  971:		//+1 Card
    #####:  972:		drawCard(currentPlayer, state);
        -:  973:
        -:  974:		//+1 Actions
    #####:  975:		state->numActions++;
        -:  976:
        -:  977:		//discard card from hand
    #####:  978:		discardCard(handPos, currentPlayer, state, 0);
    #####:  979:		return 0;
        -:  980:
        -:  981:	case minion:
        -:  982:		//+1 action
    #####:  983:		state->numActions++;
        -:  984:
        -:  985:		//discard card from hand
    #####:  986:		discardCard(handPos, currentPlayer, state, 0);
        -:  987:
    #####:  988:		if (choice1)		//+2 coins
        -:  989:		{
    #####:  990:			state->coins = state->coins + 2;
        -:  991:		}
        -:  992:
    #####:  993:		else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  994:		{
        -:  995:			//discard hand
    #####:  996:			while (numHandCards(state) > 0)
        -:  997:			{
    #####:  998:				discardCard(handPos, currentPlayer, state, 0);
        -:  999:			}
        -: 1000:
        -: 1001:			//draw 4
    #####: 1002:			for (i = 0; i < 4; i++)
        -: 1003:			{
    #####: 1004:				drawCard(currentPlayer, state);
        -: 1005:			}
        -: 1006:
        -: 1007:			//other players discard hand and redraw if hand size > 4
    #####: 1008:			for (i = 0; i < state->numPlayers; i++)
        -: 1009:			{
    #####: 1010:				if (i != currentPlayer)
        -: 1011:				{
    #####: 1012:					if (state->handCount[i] > 4)
        -: 1013:					{
        -: 1014:						//discard hand
    #####: 1015:						while (state->handCount[i] > 0)
        -: 1016:						{
    #####: 1017:							discardCard(handPos, i, state, 0);
        -: 1018:						}
        -: 1019:
        -: 1020:						//draw 4
    #####: 1021:						for (j = 0; j < 4; j++)
        -: 1022:						{
    #####: 1023:							drawCard(i, state);
        -: 1024:						}
        -: 1025:					}
        -: 1026:				}
        -: 1027:			}
        -: 1028:
        -: 1029:		}
    #####: 1030:		return 0;
        -: 1031:
        -: 1032:	case steward:
    #####: 1033:		if (choice1 == 1)
        -: 1034:		{
        -: 1035:			//+2 cards
    #####: 1036:			drawCard(currentPlayer, state);
    #####: 1037:			drawCard(currentPlayer, state);
        -: 1038:		}
    #####: 1039:		else if (choice1 == 2)
        -: 1040:		{
        -: 1041:			//+2 coins
    #####: 1042:			state->coins = state->coins + 2;
        -: 1043:		}
        -: 1044:		else
        -: 1045:		{
        -: 1046:			//trash 2 cards in hand
    #####: 1047:			discardCard(choice2, currentPlayer, state, 1);
    #####: 1048:			discardCard(choice3, currentPlayer, state, 1);
        -: 1049:		}
        -: 1050:
        -: 1051:		//discard card from hand
    #####: 1052:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1053:		return 0;
        -: 1054:
        -: 1055:	case tribute:
    #####: 1056:		if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####: 1057:			if (state->deckCount[nextPlayer] > 0){
    #####: 1058:				tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1059:				state->deckCount[nextPlayer]--;
        -: 1060:			}
    #####: 1061:			else if (state->discardCount[nextPlayer] > 0){
    #####: 1062:				tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer] - 1];
    #####: 1063:				state->discardCount[nextPlayer]--;
        -: 1064:			}
        -: 1065:			else{
        -: 1066:				//No Card to Reveal
        -: 1067:				if (DEBUG){
        -: 1068:					printf("No cards to reveal\n");
        -: 1069:				}
        -: 1070:			}
        -: 1071:		}
        -: 1072:
        -: 1073:		else{
    #####: 1074:			if (state->deckCount[nextPlayer] == 0){
    #####: 1075:				for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####: 1076:					state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1077:					state->deckCount[nextPlayer]++;
    #####: 1078:					state->discard[nextPlayer][i] = -1;
    #####: 1079:					state->discardCount[nextPlayer]--;
        -: 1080:				}
        -: 1081:
    #####: 1082:				shuffle(nextPlayer, state);//Shuffle the deck
        -: 1083:			}
    #####: 1084:			tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1085:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1086:			state->deckCount[nextPlayer]--;
    #####: 1087:			tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1088:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1089:			state->deckCount[nextPlayer]--;
        -: 1090:		}
        -: 1091:
    #####: 1092:		if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
    #####: 1093:			state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1094:			state->playedCardCount++;
    #####: 1095:			tributeRevealedCards[1] = -1;
        -: 1096:		}
        -: 1097:
    #####: 1098:		for (i = 0; i <= 2; i++){
    #####: 1099:			if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
    #####: 1100:				state->coins += 2;
        -: 1101:			}
        -: 1102:
    #####: 1103:			else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
    #####: 1104:				drawCard(currentPlayer, state);
    #####: 1105:				drawCard(currentPlayer, state);
        -: 1106:			}
        -: 1107:			else{//Action Card
    #####: 1108:				state->numActions = state->numActions + 2;
        -: 1109:			}
        -: 1110:		}
        -: 1111:
    #####: 1112:		return 0;
        -: 1113:
        -: 1114:	case ambassador:
    #####: 1115:		j = 0;		//used to check if player has enough cards to discard
        -: 1116:
    #####: 1117:		if (choice2 > 2 || choice2 < 0)
        -: 1118:		{
    #####: 1119:			return -1;
        -: 1120:		}
        -: 1121:
    #####: 1122:		if (choice1 == handPos)
        -: 1123:		{
    #####: 1124:			return -1;
        -: 1125:		}
        -: 1126:
    #####: 1127:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1128:		{
    #####: 1129:			if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1130:			{
    #####: 1131:				j++;
        -: 1132:			}
        -: 1133:		}
    #####: 1134:		if (j < choice2)
        -: 1135:		{
    #####: 1136:			return -1;
        -: 1137:		}
        -: 1138:
        -: 1139:		if (DEBUG)
        -: 1140:			printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1141:
        -: 1142:		//increase supply count for choosen card by amount being discarded
    #####: 1143:		state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1144:
        -: 1145:		//each other player gains a copy of revealed card
    #####: 1146:		for (i = 0; i < state->numPlayers; i++)
        -: 1147:		{
    #####: 1148:			if (i != currentPlayer)
        -: 1149:			{
    #####: 1150:				gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1151:			}
        -: 1152:		}
        -: 1153:
        -: 1154:		//discard played card from hand
    #####: 1155:		discardCard(handPos, currentPlayer, state, 0);
        -: 1156:
        -: 1157:		//trash copies of cards returned to supply
    #####: 1158:		for (j = 0; j < choice2; j++)
        -: 1159:		{
    #####: 1160:			for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1161:			{
    #####: 1162:				if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1163:				{
    #####: 1164:					discardCard(i, currentPlayer, state, 1);
    #####: 1165:					break;
        -: 1166:				}
        -: 1167:			}
        -: 1168:		}
        -: 1169:
    #####: 1170:		return 0;
        -: 1171:
        -: 1172:	case cutpurse:
        -: 1173:
    #####: 1174:		updateCoins(currentPlayer, state, 2);
    #####: 1175:		for (i = 0; i < state->numPlayers; i++)
        -: 1176:		{
    #####: 1177:			if (i != currentPlayer)
        -: 1178:			{
    #####: 1179:				for (j = 0; j < state->handCount[i]; j++)
        -: 1180:				{
    #####: 1181:					if (state->hand[i][j] == copper)
        -: 1182:					{
    #####: 1183:						discardCard(j, i, state, 0);
    #####: 1184:						break;
        -: 1185:					}
    #####: 1186:					if (j == state->handCount[i])
        -: 1187:					{
    #####: 1188:						for (k = 0; k < state->handCount[i]; k++)
        -: 1189:						{
        -: 1190:							if (DEBUG)
        -: 1191:								printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1192:						}
    #####: 1193:						break;
        -: 1194:					}
        -: 1195:				}
        -: 1196:
        -: 1197:			}
        -: 1198:
        -: 1199:		}
        -: 1200:
        -: 1201:		//discard played card from hand
    #####: 1202:		discardCard(handPos, currentPlayer, state, 0);
        -: 1203:
    #####: 1204:		return 0;
        -: 1205:
        -: 1206:
        -: 1207:	case embargo:
        -: 1208:		//+2 Coins
    #####: 1209:		state->coins = state->coins + 2;
        -: 1210:
        -: 1211:		//see if selected pile is in play
    #####: 1212:		if (state->supplyCount[choice1] == -1)
        -: 1213:		{
    #####: 1214:			return -1;
        -: 1215:		}
        -: 1216:
        -: 1217:		//add embargo token to selected supply pile
    #####: 1218:		state->embargoTokens[choice1]++;
        -: 1219:
        -: 1220:		//trash card
    #####: 1221:		discardCard(handPos, currentPlayer, state, 1);
    #####: 1222:		return 0;
        -: 1223:
        -: 1224:	case outpost:
        -: 1225:		//set outpost flag
    #####: 1226:		state->outpostPlayed++;
        -: 1227:
        -: 1228:		//discard card
    #####: 1229:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1230:		return 0;
        -: 1231:
        -: 1232:	case salvager:
        -: 1233:		//+1 buy
    #####: 1234:		state->numBuys++;
        -: 1235:
    #####: 1236:		if (choice1)
        -: 1237:		{
        -: 1238:			//gain coins equal to trashed card
    #####: 1239:			state->coins = state->coins + getCost(handCard(choice1, state));
        -: 1240:			//trash card
    #####: 1241:			discardCard(choice1, currentPlayer, state, 1);
        -: 1242:		}
        -: 1243:
        -: 1244:		//discard card
    #####: 1245:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1246:		return 0;
        -: 1247:
        -: 1248:	case sea_hag:
    #####: 1249:		for (i = 0; i < state->numPlayers; i++){
    #####: 1250:			if (i != currentPlayer){
    #####: 1251:				state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1252:				state->discardCount[i]++;
    #####: 1253:				state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1254:			}
        -: 1255:		}
    #####: 1256:		return 0;
        -: 1257:
        -: 1258:	case treasure_map:
        -: 1259:
    #####: 1260:		return playTreasureMap(state, currentPlayer, handPos);
        -: 1261:	}
    #####: 1262:	return -1;
        -: 1263:}
        -: 1264:
    #####: 1265:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1266:{
        -: 1267:
        -: 1268:	//if card is not trashed, added to Played pile 
    #####: 1269:	if (trashFlag < 1)
        -: 1270:	{
        -: 1271:		//add card to played pile
    #####: 1272:		state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
    #####: 1273:		state->playedCardCount++;
        -: 1274:	}
        -: 1275:
        -: 1276:	//set played card to -1
    #####: 1277:	state->hand[currentPlayer][handPos] = -1;
        -: 1278:
        -: 1279:	//remove card from player's hand
    #####: 1280:	if (handPos == (state->handCount[currentPlayer] - 1)) 	//last card in hand array is played
        -: 1281:	{
        -: 1282:		//reduce number of cards in hand
    #####: 1283:		state->handCount[currentPlayer]--;
        -: 1284:	}
    #####: 1285:	else if (state->handCount[currentPlayer] == 1) //only one card in hand
        -: 1286:	{
        -: 1287:		//reduce number of cards in hand
    #####: 1288:		state->handCount[currentPlayer]--;
        -: 1289:	}
        -: 1290:	else
        -: 1291:	{
        -: 1292:		//replace discarded card with last card in hand
    #####: 1293:		state->hand[currentPlayer][handPos] = state->hand[currentPlayer][(state->handCount[currentPlayer] - 1)];
        -: 1294:		//set last card to -1
    #####: 1295:		state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1296:		//reduce number of cards in hand
    #####: 1297:		state->handCount[currentPlayer]--;
        -: 1298:	}
        -: 1299:
    #####: 1300:	return 0;
        -: 1301:}
        -: 1302:
    #####: 1303:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1304:{
        -: 1305:	//Note: supplyPos is enum of choosen card
        -: 1306:
        -: 1307:	//check if supply pile is empty (0) or card is not used in game (-1)
    #####: 1308:	if (supplyCount(supplyPos, state) < 1)
        -: 1309:	{
    #####: 1310:		return -1;
        -: 1311:	}
        -: 1312:
        -: 1313:	//added card for [whoseTurn] current player:
        -: 1314:	// toFlag = 0 : add to discard
        -: 1315:	// toFlag = 1 : add to deck
        -: 1316:	// toFlag = 2 : add to hand
        -: 1317:
    #####: 1318:	if (toFlag == 1)
        -: 1319:	{
    #####: 1320:		state->deck[player][state->deckCount[player]] = supplyPos;
    #####: 1321:		state->deckCount[player]++;
        -: 1322:	}
    #####: 1323:	else if (toFlag == 2)
        -: 1324:	{
    #####: 1325:		state->hand[player][state->handCount[player]] = supplyPos;
    #####: 1326:		state->handCount[player]++;
        -: 1327:	}
        -: 1328:	else
        -: 1329:	{
    #####: 1330:		state->discard[player][state->discardCount[player]] = supplyPos;
    #####: 1331:		state->discardCount[player]++;
        -: 1332:	}
        -: 1333:
        -: 1334:	//decrease number in supply pile
    #####: 1335:	state->supplyCount[supplyPos]--;
        -: 1336:
    #####: 1337:	return 0;
        -: 1338:}
        -: 1339:
       13: 1340:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1341:{
        -: 1342:	int i;
        -: 1343:
        -: 1344:	//reset coin count
       13: 1345:	state->coins = 0;
        -: 1346:
        -: 1347:	//add coins for each Treasure card in player's hand
       63: 1348:	for (i = 0; i < state->handCount[player]; i++)
        -: 1349:	{
       50: 1350:		if (state->hand[player][i] == copper)
        -: 1351:		{
       31: 1352:			state->coins += 1;
        -: 1353:		}
       19: 1354:		else if (state->hand[player][i] == silver)
        -: 1355:		{
    #####: 1356:			state->coins += 2;
        -: 1357:		}
       19: 1358:		else if (state->hand[player][i] == gold)
        -: 1359:		{
    #####: 1360:			state->coins += 3;
        -: 1361:		}
        -: 1362:	}
        -: 1363:
        -: 1364:	//add bonus
       13: 1365:	state->coins += bonus;
        -: 1366:
       13: 1367:	return 0;
        -: 1368:}
        -: 1369:
        -: 1370:
        -: 1371://end of dominion.c
File 'dominion.c'
Lines executed:27.11% of 557
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
      378:    8:int compare(const void* a, const void* b) {
      378:    9:	if (*(int*)a > *(int*)b)
    #####:   10:		return 1;
      378:   11:	if (*(int*)a < *(int*)b)
      135:   12:		return -1;
      243:   13:	return 0;
        -:   14:}
        -:   15:
       20:   16:struct gameState* newGame() {
       20:   17:	struct gameState* g = malloc(sizeof(struct gameState));
       20:   18:	return g;
        -:   19:}
        -:   20:
      143:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:	int k8, int k9, int k10) {
      143:   23:	int* k = malloc(10 * sizeof(int));
      143:   24:	k[0] = k1;
      143:   25:	k[1] = k2;
      143:   26:	k[2] = k3;
      143:   27:	k[3] = k4;
      143:   28:	k[4] = k5;
      143:   29:	k[5] = k6;
      143:   30:	k[6] = k7;
      143:   31:	k[7] = k8;
      143:   32:	k[8] = k9;
      143:   33:	k[9] = k10;
      143:   34:	return k;
        -:   35:}
        -:   36:
      143:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		struct gameState *state) {
        -:   39:
        -:   40:	int i;
        -:   41:	int j;
        -:   42:	int it;
        -:   43:	//set up random number generator
      143:   44:	SelectStream(1);
      143:   45:	PutSeed((long)randomSeed);
        -:   46:
        -:   47:	//check number of players
      143:   48:	if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:	{
    #####:   50:		return -1;
        -:   51:	}
        -:   52:
        -:   53:	//set number of players
      143:   54:	state->numPlayers = numPlayers;
        -:   55:
        -:   56:	//check selected kingdom cards are different
      446:   57:	for (i = 0; i < 10; i++)
        -:   58:	{
     4167:   59:		for (j = 0; j < 10; j++)
        -:   60:		{
     3864:   61:			if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:			{
      133:   63:				return -1;
        -:   64:			}
        -:   65:		}
        -:   66:	}
        -:   67:
        -:   68:
        -:   69:	//initialize supply
        -:   70:	///////////////////////////////
        -:   71:
        -:   72:	//set number of Curse cards
       10:   73:	if (numPlayers == 2)
        -:   74:	{
        5:   75:		state->supplyCount[curse] = 10;
        -:   76:	}
        5:   77:	else if (numPlayers == 3)
        -:   78:	{
        3:   79:		state->supplyCount[curse] = 20;
        -:   80:	}
        -:   81:	else
        -:   82:	{
        2:   83:		state->supplyCount[curse] = 30;
        -:   84:	}
        -:   85:
        -:   86:	//set number of Victory cards
       10:   87:	if (numPlayers == 2)
        -:   88:	{
        5:   89:		state->supplyCount[estate] = 8;
        5:   90:		state->supplyCount[duchy] = 8;
        5:   91:		state->supplyCount[province] = 8;
        -:   92:	}
        -:   93:	else
        -:   94:	{
        5:   95:		state->supplyCount[estate] = 12;
        5:   96:		state->supplyCount[duchy] = 12;
        5:   97:		state->supplyCount[province] = 12;
        -:   98:	}
        -:   99:
        -:  100:	//set number of Treasure cards
       10:  101:	state->supplyCount[copper] = 60 - (7 * numPlayers);
       10:  102:	state->supplyCount[silver] = 40;
       10:  103:	state->supplyCount[gold] = 30;
        -:  104:
        -:  105:	//set number of Kingdom cards
      210:  106:	for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:	{
     1650:  108:		for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:		{
     1550:  110:			if (kingdomCards[j] == i)
        -:  111:			{
        -:  112:				//check if card is a 'Victory' Kingdom card
      100:  113:				if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:				{
       18:  115:					if (numPlayers == 2){
        4:  116:						state->supplyCount[i] = 8;
        -:  117:					}
        5:  118:					else{ state->supplyCount[i] = 12; }
        -:  119:				}
        -:  120:				else
        -:  121:				{
       91:  122:					state->supplyCount[i] = 10;
        -:  123:				}
      100:  124:				break;
        -:  125:			}
        -:  126:			else    //card is not in the set choosen for the game
        -:  127:			{
     1450:  128:				state->supplyCount[i] = -1;
        -:  129:			}
        -:  130:		}
        -:  131:
        -:  132:	}
        -:  133:
        -:  134:	////////////////////////
        -:  135:	//supply intilization complete
        -:  136:
        -:  137:	//set player decks
       37:  138:	for (i = 0; i < numPlayers; i++)
        -:  139:	{
       27:  140:		state->deckCount[i] = 0;
      108:  141:		for (j = 0; j < 3; j++)
        -:  142:		{
       81:  143:			state->deck[i][j] = estate;
       81:  144:			state->deckCount[i]++;
        -:  145:		}
      216:  146:		for (j = 3; j < 10; j++)
        -:  147:		{
      189:  148:			state->deck[i][j] = copper;
      189:  149:			state->deckCount[i]++;
        -:  150:		}
        -:  151:	}
        -:  152:
        -:  153:	//shuffle player decks
       37:  154:	for (i = 0; i < numPlayers; i++)
        -:  155:	{
       27:  156:		if (shuffle(i, state) < 0)
        -:  157:		{
    #####:  158:			return -1;
        -:  159:		}
        -:  160:	}
        -:  161:
        -:  162:	//draw player hands
       37:  163:	for (i = 0; i < numPlayers; i++)
        -:  164:	{
        -:  165:		//initialize hand size to zero
       27:  166:		state->handCount[i] = 0;
       27:  167:		state->discardCount[i] = 0;
        -:  168:		//draw 5 cards
        -:  169:		// for (j = 0; j < 5; j++)
        -:  170:		//	{
        -:  171:		//	  drawCard(i, state);
        -:  172:		//	}
        -:  173:	}
        -:  174:
        -:  175:	//set embargo tokens to 0 for all supply piles
      280:  176:	for (i = 0; i <= treasure_map; i++)
        -:  177:	{
      270:  178:		state->embargoTokens[i] = 0;
        -:  179:	}
        -:  180:
        -:  181:	//initialize first player's turn
       10:  182:	state->outpostPlayed = 0;
       10:  183:	state->phase = 0;
       10:  184:	state->numActions = 1;
       10:  185:	state->numBuys = 1;
       10:  186:	state->playedCardCount = 0;
       10:  187:	state->whoseTurn = 0;
       10:  188:	state->handCount[state->whoseTurn] = 0;
        -:  189:	//int it; move to top
        -:  190:
        -:  191:	//Moved draw cards to here, only drawing at the start of a turn
       60:  192:	for (it = 0; it < 5; it++){
       50:  193:		drawCard(state->whoseTurn, state);
        -:  194:	}
        -:  195:
       10:  196:	updateCoins(state->whoseTurn, state, 0);
        -:  197:
       10:  198:	return 0;
        -:  199:}
        -:  200:
       42:  201:int shuffle(int player, struct gameState *state) {
        -:  202:
        -:  203:
        -:  204:	int newDeck[MAX_DECK];
       42:  205:	int newDeckPos = 0;
        -:  206:	int card;
        -:  207:	int i;
        -:  208:
       42:  209:	if (state->deckCount[player] < 1)
       15:  210:		return -1;
       27:  211:	qsort((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
        -:  212:	/* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
      324:  214:	while (state->deckCount[player] > 0) {
      270:  215:		card = floor(Random() * state->deckCount[player]);
      270:  216:		newDeck[newDeckPos] = state->deck[player][card];
      270:  217:		newDeckPos++;
      907:  218:		for (i = card; i < state->deckCount[player] - 1; i++) {
      637:  219:			state->deck[player][i] = state->deck[player][i + 1];
        -:  220:		}
      270:  221:		state->deckCount[player]--;
        -:  222:	}
      297:  223:	for (i = 0; i < newDeckPos; i++) {
      270:  224:		state->deck[player][i] = newDeck[i];
      270:  225:		state->deckCount[player]++;
        -:  226:	}
        -:  227:
       27:  228:	return 0;
        -:  229:}
        -:  230:
        5:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state)
        -:  232:{
        -:  233:	int card;
        5:  234:	int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:	//check if it is the right phase
        5:  237:	if (state->phase != 0)
        -:  238:	{
    #####:  239:		return -1;
        -:  240:	}
        -:  241:
        -:  242:	//check if player has enough actions
        5:  243:	if (state->numActions < 1)
        -:  244:	{
        5:  245:		return -1;
        -:  246:	}
        -:  247:
        -:  248:	//get card played
    #####:  249:	card = handCard(handPos, state);
        -:  250:
        -:  251:	//check if selected card is an action
    #####:  252:	if (card < adventurer || card > treasure_map)
        -:  253:	{
    #####:  254:		return -1;
        -:  255:	}
        -:  256:
        -:  257:	//play card
    #####:  258:	if (cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0)
        -:  259:	{
    #####:  260:		return -1;
        -:  261:	}
        -:  262:
        -:  263:	//reduce number of actions
    #####:  264:	state->numActions--;
        -:  265:
        -:  266:	//update coins (Treasure cards may be added with card draws)
    #####:  267:	updateCoins(state->whoseTurn, state, coin_bonus);
        -:  268:
    #####:  269:	return 0;
        -:  270:}
        -:  271:
        2:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:	int who;
        -:  274:	if (DEBUG){
        -:  275:		printf("Entering buyCard...\n");
        -:  276:	}
        -:  277:
        -:  278:	// I don't know what to do about the phase thing.
        -:  279:
        2:  280:	who = state->whoseTurn;
        -:  281:
        2:  282:	if (state->numBuys < 1){
        -:  283:		if (DEBUG)
        -:  284:			printf("You do not have any buys left\n");
        2:  285:		return -1;
        -:  286:	}
    #####:  287:	else if (supplyCount(supplyPos, state) < 1){
        -:  288:		if (DEBUG)
        -:  289:			printf("There are not any of that type of card left\n");
    #####:  290:		return -1;
        -:  291:	}
    #####:  292:	else if (state->coins < getCost(supplyPos)){
        -:  293:		if (DEBUG)
        -:  294:			printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  295:		return -1;
        -:  296:	}
        -:  297:	else {
    #####:  298:		state->phase = 1;
        -:  299:		//state->supplyCount[supplyPos]--;
    #####:  300:		gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  301:
    #####:  302:		state->coins = (state->coins) - (getCost(supplyPos));
    #####:  303:		state->numBuys--;
        -:  304:		if (DEBUG)
        -:  305:			printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  306:	}
        -:  307:
        -:  308:	//state->discard[who][state->discardCount[who]] = supplyPos;
        -:  309:	//state->discardCount[who]++;
        -:  310:
    #####:  311:	return 0;
        -:  312:}
        -:  313:
    #####:  314:int numHandCards(struct gameState *state) {
    #####:  315:	return state->handCount[whoseTurn(state)];
        -:  316:}
        -:  317:
    #####:  318:int handCard(int handPos, struct gameState *state) {
    #####:  319:	int currentPlayer = whoseTurn(state);
    #####:  320:	return state->hand[currentPlayer][handPos];
        -:  321:}
        -:  322:
    #####:  323:int supplyCount(int card, struct gameState *state) {
    #####:  324:	return state->supplyCount[card];
        -:  325:}
        -:  326:
    #####:  327:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  328:	int i;
    #####:  329:	int count = 0;
        -:  330:
    #####:  331:	for (i = 0; i < state->deckCount[player]; i++)
        -:  332:	{
    #####:  333:		if (state->deck[player][i] == card) count++;
        -:  334:	}
        -:  335:
    #####:  336:	for (i = 0; i < state->handCount[player]; i++)
        -:  337:	{
    #####:  338:		if (state->hand[player][i] == card) count++;
        -:  339:	}
        -:  340:
    #####:  341:	for (i = 0; i < state->discardCount[player]; i++)
        -:  342:	{
    #####:  343:		if (state->discard[player][i] == card) count++;
        -:  344:	}
        -:  345:
    #####:  346:	return count;
        -:  347:}
        -:  348:
        3:  349:int whoseTurn(struct gameState *state) {
        3:  350:	return state->whoseTurn;
        -:  351:}
        -:  352:
        3:  353:int endTurn(struct gameState *state) {
        -:  354:	int k;
        -:  355:	int i;
        3:  356:	int currentPlayer = whoseTurn(state);
        -:  357:
        -:  358:	//Discard hand
        3:  359:	for (i = 0; i < state->handCount[currentPlayer]; i++){
    #####:  360:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  361:		state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  362:	}
        3:  363:	state->handCount[currentPlayer] = 0;//Reset hand count
        -:  364:
        -:  365:	//Code for determining the player
        3:  366:	if (currentPlayer < (state->numPlayers - 1)){
    #####:  367:		state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  368:	}
        -:  369:	else{
        3:  370:		state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  371:	}
        -:  372:
        3:  373:	state->outpostPlayed = 0;
        3:  374:	state->phase = 0;
        3:  375:	state->numActions = 1;
        3:  376:	state->coins = 0;
        3:  377:	state->numBuys = 1;
        3:  378:	state->playedCardCount = 0;
        3:  379:	state->handCount[state->whoseTurn] = 0;
        -:  380:
        -:  381:	//int k; move to top
        -:  382:	//Next player draws hand
       18:  383:	for (k = 0; k < 5; k++){
       15:  384:		drawCard(state->whoseTurn, state);//Draw a card
        -:  385:	}
        -:  386:
        -:  387:	//Update money
        3:  388:	updateCoins(state->whoseTurn, state, 0);
        -:  389:
        3:  390:	return 0;
        -:  391:}
        -:  392:
    #####:  393:int isGameOver(struct gameState *state) {
        -:  394:	int i;
        -:  395:	int j;
        -:  396:
        -:  397:	//if stack of Province cards is empty, the game ends
    #####:  398:	if (state->supplyCount[province] == 0)
        -:  399:	{
    #####:  400:		return 1;
        -:  401:	}
        -:  402:
        -:  403:	//if three supply pile are at 0, the game ends
    #####:  404:	j = 0;
    #####:  405:	for (i = 0; i < 25; i++)
        -:  406:	{
    #####:  407:		if (state->supplyCount[i] == 0)
        -:  408:		{
    #####:  409:			j++;
        -:  410:		}
        -:  411:	}
    #####:  412:	if (j >= 3)
        -:  413:	{
    #####:  414:		return 1;
        -:  415:	}
        -:  416:
    #####:  417:	return 0;
        -:  418:}
        -:  419:
    #####:  420:int scoreFor(int player, struct gameState *state) {
        -:  421:
        -:  422:	int i;
    #####:  423:	int score = 0;
        -:  424:	//score from hand
    #####:  425:	for (i = 0; i < state->handCount[player]; i++)
        -:  426:	{
    #####:  427:		if (state->hand[player][i] == curse) { score = score - 1; };
    #####:  428:		if (state->hand[player][i] == estate) { score = score + 1; };
    #####:  429:		if (state->hand[player][i] == duchy) { score = score + 3; };
    #####:  430:		if (state->hand[player][i] == province) { score = score + 6; };
    #####:  431:		if (state->hand[player][i] == great_hall) { score = score + 1; };
    #####:  432:		if (state->hand[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  433:	}
        -:  434:
        -:  435:	//score from discard
    #####:  436:	for (i = 0; i < state->discardCount[player]; i++)
        -:  437:	{
    #####:  438:		if (state->discard[player][i] == curse) { score = score - 1; };
    #####:  439:		if (state->discard[player][i] == estate) { score = score + 1; };
    #####:  440:		if (state->discard[player][i] == duchy) { score = score + 3; };
    #####:  441:		if (state->discard[player][i] == province) { score = score + 6; };
    #####:  442:		if (state->discard[player][i] == great_hall) { score = score + 1; };
    #####:  443:		if (state->discard[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  444:	}
        -:  445:
        -:  446:	//score from deck
    #####:  447:	for (i = 0; i < state->discardCount[player]; i++)
        -:  448:	{
    #####:  449:		if (state->deck[player][i] == curse) { score = score - 1; };
    #####:  450:		if (state->deck[player][i] == estate) { score = score + 1; };
    #####:  451:		if (state->deck[player][i] == duchy) { score = score + 3; };
    #####:  452:		if (state->deck[player][i] == province) { score = score + 6; };
    #####:  453:		if (state->deck[player][i] == great_hall) { score = score + 1; };
    #####:  454:		if (state->deck[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  455:	}
        -:  456:
    #####:  457:	return score;
        -:  458:}
        -:  459:
    #####:  460:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  461:	int i;
        -:  462:	int j;
        -:  463:	int highScore;
        -:  464:	int currentPlayer;
        -:  465:
        -:  466:	//get score for each player
    #####:  467:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  468:	{
        -:  469:		//set unused player scores to -9999
    #####:  470:		if (i >= state->numPlayers)
        -:  471:		{
    #####:  472:			players[i] = -9999;
        -:  473:		}
        -:  474:		else
        -:  475:		{
    #####:  476:			players[i] = scoreFor(i, state);
        -:  477:		}
        -:  478:	}
        -:  479:
        -:  480:	//find highest score
    #####:  481:	j = 0;
    #####:  482:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  483:	{
    #####:  484:		if (players[i] > players[j])
        -:  485:		{
    #####:  486:			j = i;
        -:  487:		}
        -:  488:	}
    #####:  489:	highScore = players[j];
        -:  490:
        -:  491:	//add 1 to players who had less turns
    #####:  492:	currentPlayer = whoseTurn(state);
    #####:  493:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  494:	{
    #####:  495:		if (players[i] == highScore && i > currentPlayer)
        -:  496:		{
    #####:  497:			players[i]++;
        -:  498:		}
        -:  499:	}
        -:  500:
        -:  501:	//find new highest score
    #####:  502:	j = 0;
    #####:  503:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  504:	{
    #####:  505:		if (players[i] > players[j])
        -:  506:		{
    #####:  507:			j = i;
        -:  508:		}
        -:  509:	}
    #####:  510:	highScore = players[j];
        -:  511:
        -:  512:	//set winners in array to 1 and rest to 0
    #####:  513:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  514:	{
    #####:  515:		if (players[i] == highScore)
        -:  516:		{
    #####:  517:			players[i] = 1;
        -:  518:		}
        -:  519:		else
        -:  520:		{
    #####:  521:			players[i] = 0;
        -:  522:		}
        -:  523:	}
        -:  524:
    #####:  525:	return 0;
        -:  526:}
        -:  527:
       65:  528:int drawCard(int player, struct gameState *state)
        -:  529:{
        -:  530:	int count;
        -:  531:	int deckCounter;
       65:  532:	if (state->deckCount[player] <= 0){//Deck is empty
        -:  533:
        -:  534:		//Step 1 Shuffle the discard pile back into a deck
        -:  535:		int i;
        -:  536:		//Move discard to deck
       15:  537:		for (i = 0; i < state->discardCount[player]; i++){
    #####:  538:			state->deck[player][i] = state->discard[player][i];
    #####:  539:			state->discard[player][i] = -1;
        -:  540:		}
        -:  541:
       15:  542:		state->deckCount[player] = state->discardCount[player];
       15:  543:		state->discardCount[player] = 0;//Reset discard
        -:  544:
        -:  545:		//Shufffle the deck
       15:  546:		shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  547:
        -:  548:		if (DEBUG){//Debug statements
        -:  549:			printf("Deck count now: %d\n", state->deckCount[player]);
        -:  550:		}
        -:  551:
       15:  552:		state->discardCount[player] = 0;
        -:  553:
        -:  554:		//Step 2 Draw Card
       15:  555:		count = state->handCount[player];//Get current player's hand count
        -:  556:
        -:  557:		if (DEBUG){//Debug statements
        -:  558:			printf("Current hand count: %d\n", count);
        -:  559:		}
        -:  560:
       15:  561:		deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  562:
       15:  563:		if (deckCounter == 0)
       15:  564:			return -1;
        -:  565:
    #####:  566:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
    #####:  567:		state->deckCount[player]--;
    #####:  568:		state->handCount[player]++;//Increment hand count
        -:  569:	}
        -:  570:
        -:  571:	else{
       50:  572:		int count = state->handCount[player];//Get current hand count for player
        -:  573:		int deckCounter;
        -:  574:		if (DEBUG){//Debug statements
        -:  575:			printf("Current hand count: %d\n", count);
        -:  576:		}
        -:  577:
       50:  578:		deckCounter = state->deckCount[player];//Create holder for the deck count
       50:  579:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
       50:  580:		state->deckCount[player]--;
       50:  581:		state->handCount[player]++;//Increment hand count
        -:  582:	}
        -:  583:
       50:  584:	return 0;
        -:  585:}
        -:  586:
    #####:  587:int getCost(int cardNumber)
        -:  588:{
    #####:  589:	switch (cardNumber)
        -:  590:	{
        -:  591:	case curse:
    #####:  592:		return 0;
        -:  593:	case estate:
    #####:  594:		return 2;
        -:  595:	case duchy:
    #####:  596:		return 5;
        -:  597:	case province:
    #####:  598:		return 8;
        -:  599:	case copper:
    #####:  600:		return 0;
        -:  601:	case silver:
    #####:  602:		return 3;
        -:  603:	case gold:
    #####:  604:		return 6;
        -:  605:	case adventurer:
    #####:  606:		return 6;
        -:  607:	case council_room:
    #####:  608:		return 5;
        -:  609:	case feast:
    #####:  610:		return 4;
        -:  611:	case gardens:
    #####:  612:		return 4;
        -:  613:	case mine:
    #####:  614:		return 5;
        -:  615:	case remodel:
    #####:  616:		return 4;
        -:  617:	case smithy:
    #####:  618:		return 4;
        -:  619:	case village:
    #####:  620:		return 3;
        -:  621:	case baron:
    #####:  622:		return 4;
        -:  623:	case great_hall:
    #####:  624:		return 3;
        -:  625:	case minion:
    #####:  626:		return 5;
        -:  627:	case steward:
    #####:  628:		return 3;
        -:  629:	case tribute:
    #####:  630:		return 5;
        -:  631:	case ambassador:
    #####:  632:		return 3;
        -:  633:	case cutpurse:
    #####:  634:		return 4;
        -:  635:	case embargo:
    #####:  636:		return 2;
        -:  637:	case outpost:
    #####:  638:		return 5;
        -:  639:	case salvager:
    #####:  640:		return 4;
        -:  641:	case sea_hag:
    #####:  642:		return 4;
        -:  643:	case treasure_map:
    #####:  644:		return 4;
        -:  645:	}
        -:  646:
    #####:  647:	return -1;
        -:  648:}
        -:  649:
    #####:  650:void playAdventurer(struct gameState *state, int currentPlayer)
        -:  651:// Reveal cards from deck until 2 Treasure cards are found.  Put those Treasure cards in the hand and discard the rest.
        -:  652:{
    #####:  653:	int drawntreasure = 0;
        -:  654:	int temphand[MAX_HAND];
        -:  655:	int cardDrawn;
    #####:  656:	int z = 0; // this is the counter for the temp hand
        -:  657:
    #####:  658:	while (drawntreasure < 2){
    #####:  659:		if (state->deckCount[currentPlayer] < 1){//if the deck is empty we need to shuffle discard and add to deck
    #####:  660:			shuffle(currentPlayer, state);
        -:  661:		}
    #####:  662:		drawCard(currentPlayer, state);
    #####:  663:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer] - 1];//top card of hand is most recently drawn card.
    #####:  664:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
    #####:  665:			drawntreasure++;
        -:  666:		else{
    #####:  667:			temphand[z] = cardDrawn;
    #####:  668:			state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####:  669:			z++;
        -:  670:		}
        -:  671:	}
    #####:  672:	while (z - 1 >= 0){
    #####:  673:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; // discard all cards in play that have been drawn
    #####:  674:		z = z - 1;
        -:  675:	}
    #####:  676:}
        -:  677:
    #####:  678:int playRemodel(struct gameState *state, int currentPlayer, int choice1, int choice2, int handPos)
        -:  679://Trash a card in the hand, and gain a card costing up to $2 more than the trashed card
        -:  680:{
        -:  681:	int i;
    #####:  682:	int j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  683:
    #####:  684:	if ((getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2))
        -:  685:	{
    #####:  686:		return -1;
        -:  687:	}
        -:  688:
    #####:  689:	gainCard(choice2, state, 0, currentPlayer);
        -:  690:
        -:  691:	//discard card from hand
    #####:  692:	discardCard(handPos, currentPlayer, state, 0);
        -:  693:
        -:  694:	//discard trashed card
    #####:  695:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  696:	{
    #####:  697:		if (state->hand[currentPlayer][i] == j)
        -:  698:		{
    #####:  699:			discardCard(i, currentPlayer, state, 0);
    #####:  700:			break;
        -:  701:		}
        -:  702:	}
        -:  703:
    #####:  704:	return 0;
        -:  705:}
        -:  706:
    #####:  707:void playSmithy(struct gameState *state, int currentPlayer, int handPos)
        -:  708:// Draw 3 cards
        -:  709:{
        -:  710:	int i;
    #####:  711:	for (i = 0; i < 3; i++)
        -:  712:	{
    #####:  713:		drawCard(currentPlayer, state);
        -:  714:	}
        -:  715:
        -:  716:	//discard card from hand
    #####:  717:	discardCard(handPos, currentPlayer, state, 0);
    #####:  718:}
        -:  719:
    #####:  720:void playBaron(struct gameState *state, int currentPlayer, int choice1, int handPos)
        -:  721://Add a buy.  OPTION:  Discard an Estate card and gain $4.  Otherwise, gain an Estate card.
        -:  722:{
    #####:  723:	state->numBuys++;//Increase buys by 1!
    #####:  724:	if (choice1 > 0){//Boolean true or going to discard an estate
    #####:  725:		int p = 0;//Iterator for hand!
    #####:  726:		int card_not_discarded = 1;//Flag for discard set!
    #####:  727:		while (card_not_discarded){
    #####:  728:			if (state->hand[currentPlayer][p] == estate){ //Found an estate card!
    #####:  729:				state->coins += 4;//Add 4 coins to the amount of coins
    #####:  730:				state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  731:				state->discardCount[currentPlayer]++;
    #####:  732:				for (; p < state->handCount[currentPlayer]; p++){
    #####:  733:					state->hand[currentPlayer][p] = state->hand[currentPlayer][p + 1];
        -:  734:				}
    #####:  735:				state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  736:				state->handCount[currentPlayer]--;
    #####:  737:				card_not_discarded = 0;//Exit the loop
        -:  738:			}
    #####:  739:			else if (p > state->handCount[currentPlayer]){
        -:  740:				if (DEBUG) {
        -:  741:					printf("No estate cards in your hand, invalid choice\n");
        -:  742:					printf("Must gain an estate if there are any\n");
        -:  743:				}
    #####:  744:				if (supplyCount(estate, state) > 0){
    #####:  745:					gainCard(estate, state, 1, currentPlayer);
    #####:  746:					state->supplyCount[estate]--;//Decrement estates
    #####:  747:					if (supplyCount(estate, state) == 0){
    #####:  748:						isGameOver(state);
        -:  749:					}
        -:  750:				}
    #####:  751:				card_not_discarded = 0;//Exit the loop
        -:  752:			}
        -:  753:
        -:  754:			else{
    #####:  755:				p++;//Next card
        -:  756:			}
        -:  757:		}
        -:  758:	}
        -:  759:
        -:  760:	else{
    #####:  761:		if (supplyCount(estate, state) > 0){
    #####:  762:			gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  763:			state->supplyCount[estate]--;//Decrement Estates
    #####:  764:			if (supplyCount(estate, state) == 0){
    #####:  765:				isGameOver(state);
        -:  766:			}
        -:  767:		}
        -:  768:	}
    #####:  769:}
        -:  770:
    #####:  771:int playTreasureMap(struct gameState *state, int currentPlayer, int handPos)
        -:  772://Trashing two treasure map cards from the hand = four gold on top of the deck.
        -:  773:{
        -:  774:	int i;
        -:  775:	int index;
        -:  776:
        -:  777:	//search hand for another treasure_map
    #####:  778:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  779:	{
    #####:  780:		if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -:  781:		{
    #####:  782:			index = i;
    #####:  783:			break;
        -:  784:		}
        -:  785:	}
    #####:  786:	if (index > -1)
        -:  787:	{
        -:  788:		//trash both treasure cards
    #####:  789:		discardCard(handPos, currentPlayer, state, 1);
    #####:  790:		discardCard(index, currentPlayer, state, 1);
        -:  791:
        -:  792:		//gain 4 Gold cards
    #####:  793:		for (i = 0; i < 4; i++)
        -:  794:		{
    #####:  795:			gainCard(gold, state, 1, currentPlayer);
        -:  796:		}
        -:  797:
        -:  798:		//return success
    #####:  799:		return 1;
        -:  800:	}
        -:  801:
        -:  802:	//no second treasure_map found in hand
    #####:  803:	return -1;
        -:  804:}
        -:  805:
    #####:  806:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  807:{
        -:  808:	int i;
        -:  809:	int j;
        -:  810:	int k;
        -:  811:	//int x;  //Unused after while loop removed from feast.
    #####:  812:	int currentPlayer = whoseTurn(state);
    #####:  813:	int nextPlayer = currentPlayer + 1;
        -:  814:	int temphand[MAX_HAND];
        -:  815:
    #####:  816:	int tributeRevealedCards[2] = { -1, -1 };
        -:  817:
    #####:  818:	if (nextPlayer > (state->numPlayers - 1)){
    #####:  819:		nextPlayer = 0;
        -:  820:	}
        -:  821:
        -:  822:	//uses switch to select card and perform actions
    #####:  823:	switch (card)
        -:  824:	{
        -:  825:	case adventurer:
        -:  826:
    #####:  827:		playAdventurer(state, currentPlayer);
    #####:  828:		return 0;
        -:  829:
        -:  830:	case council_room:
        -:  831:		//+4 Cards
    #####:  832:		for (i = 0; i < 4; i++)
        -:  833:		{
    #####:  834:			drawCard(currentPlayer, state);
        -:  835:		}
        -:  836:
        -:  837:		//+1 Buy
    #####:  838:		state->numBuys++;
        -:  839:
        -:  840:		//Each other player draws a card
    #####:  841:		for (i = 0; i < state->numPlayers; i++)
        -:  842:		{
    #####:  843:			if (i != currentPlayer)
        -:  844:			{
    #####:  845:				drawCard(i, state);
        -:  846:			}
        -:  847:		}
        -:  848:
        -:  849:		//put played card in played card pile
    #####:  850:		discardCard(handPos, currentPlayer, state, 0);
        -:  851:
    #####:  852:		return 0;
        -:  853:
        -:  854:	case feast:
        -:  855:		//gain card with cost up to 5
        -:  856:		//Backup hand
    #####:  857:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  858:			temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  859:			state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  860:		}
        -:  861:		//Backup hand
        -:  862:
        -:  863:		//Update Coins for Buy
    #####:  864:		updateCoins(currentPlayer, state, 5);
        -:  865://		x = 1;//Condition to loop on
        -:  866://		while (x == 1) {//Buy one card
    #####:  867:			if (supplyCount(choice1, state) <= 0){
        -:  868:				if (DEBUG)
        -:  869:					printf("None of that card left, sorry!\n");
        -:  870:
        -:  871:				if (DEBUG){
        -:  872:					printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  873:				}
        -:  874:			}
    #####:  875:			else if (state->coins < getCost(choice1)){
    #####:  876:				printf("That card is too expensive!\n");
        -:  877:
        -:  878:				if (DEBUG){
        -:  879:					printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  880:				}
        -:  881:			}
        -:  882:			else{
        -:  883:
        -:  884:				if (DEBUG){
        -:  885:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  886:				}
        -:  887:
    #####:  888:				gainCard(choice1, state, 0, currentPlayer);//Gain the card
        -:  889://				x = 0;//No more buying cards
        -:  890:
        -:  891:				if (DEBUG){
        -:  892:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  893:				}
        -:  894:
        -:  895:			}
        -:  896://		}
        -:  897:
        -:  898:		//Reset Hand
    #####:  899:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  900:			state->hand[currentPlayer][i] = temphand[i];
    #####:  901:			temphand[i] = -1;
        -:  902:		}
        -:  903:		//Reset Hand
        -:  904:
    #####:  905:		return 0;
        -:  906:
        -:  907:	case gardens:
    #####:  908:		return -1;
        -:  909:
        -:  910:	case mine:
    #####:  911:		j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  912:
    #####:  913:		if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  914:		{
    #####:  915:			return -1;
        -:  916:		}
        -:  917:
    #####:  918:		if (choice2 > treasure_map || choice2 < curse)
        -:  919:		{
    #####:  920:			return -1;
        -:  921:		}
        -:  922:
    #####:  923:		if ((getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2))
        -:  924:		{
    #####:  925:			return -1;
        -:  926:		}
        -:  927:
    #####:  928:		gainCard(choice2, state, 2, currentPlayer);
        -:  929:
        -:  930:		//discard card from hand
    #####:  931:		discardCard(handPos, currentPlayer, state, 0);
        -:  932:
        -:  933:		//discard trashed card
    #####:  934:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  935:		{
    #####:  936:			if (state->hand[currentPlayer][i] == j)
        -:  937:			{
    #####:  938:				discardCard(i, currentPlayer, state, 0);
    #####:  939:				break;
        -:  940:			}
        -:  941:		}
        -:  942:
    #####:  943:		return 0;
        -:  944:
        -:  945:	case remodel:
        -:  946:
    #####:  947:		return playRemodel(state, currentPlayer, choice1, choice2, handPos);
        -:  948:
        -:  949:	case smithy:
        -:  950:
    #####:  951:		playSmithy(state, currentPlayer, handPos);
    #####:  952:		return 0;
        -:  953:
        -:  954:	case village:
        -:  955:		//+1 Card
    #####:  956:		drawCard(currentPlayer, state);
        -:  957:
        -:  958:		//+2 Actions
    #####:  959:		state->numActions = state->numActions + 2;
        -:  960:
        -:  961:		//discard played card from hand
    #####:  962:		discardCard(handPos, currentPlayer, state, 0);
    #####:  963:		return 0;
        -:  964:
        -:  965:	case baron:
        -:  966:
    #####:  967:		playBaron(state, currentPlayer, choice1, handPos);
    #####:  968:		return 0;
        -:  969:
        -:  970:	case great_hall:
        -:  971:		//+1 Card
    #####:  972:		drawCard(currentPlayer, state);
        -:  973:
        -:  974:		//+1 Actions
    #####:  975:		state->numActions++;
        -:  976:
        -:  977:		//discard card from hand
    #####:  978:		discardCard(handPos, currentPlayer, state, 0);
    #####:  979:		return 0;
        -:  980:
        -:  981:	case minion:
        -:  982:		//+1 action
    #####:  983:		state->numActions++;
        -:  984:
        -:  985:		//discard card from hand
    #####:  986:		discardCard(handPos, currentPlayer, state, 0);
        -:  987:
    #####:  988:		if (choice1)		//+2 coins
        -:  989:		{
    #####:  990:			state->coins = state->coins + 2;
        -:  991:		}
        -:  992:
    #####:  993:		else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  994:		{
        -:  995:			//discard hand
    #####:  996:			while (numHandCards(state) > 0)
        -:  997:			{
    #####:  998:				discardCard(handPos, currentPlayer, state, 0);
        -:  999:			}
        -: 1000:
        -: 1001:			//draw 4
    #####: 1002:			for (i = 0; i < 4; i++)
        -: 1003:			{
    #####: 1004:				drawCard(currentPlayer, state);
        -: 1005:			}
        -: 1006:
        -: 1007:			//other players discard hand and redraw if hand size > 4
    #####: 1008:			for (i = 0; i < state->numPlayers; i++)
        -: 1009:			{
    #####: 1010:				if (i != currentPlayer)
        -: 1011:				{
    #####: 1012:					if (state->handCount[i] > 4)
        -: 1013:					{
        -: 1014:						//discard hand
    #####: 1015:						while (state->handCount[i] > 0)
        -: 1016:						{
    #####: 1017:							discardCard(handPos, i, state, 0);
        -: 1018:						}
        -: 1019:
        -: 1020:						//draw 4
    #####: 1021:						for (j = 0; j < 4; j++)
        -: 1022:						{
    #####: 1023:							drawCard(i, state);
        -: 1024:						}
        -: 1025:					}
        -: 1026:				}
        -: 1027:			}
        -: 1028:
        -: 1029:		}
    #####: 1030:		return 0;
        -: 1031:
        -: 1032:	case steward:
    #####: 1033:		if (choice1 == 1)
        -: 1034:		{
        -: 1035:			//+2 cards
    #####: 1036:			drawCard(currentPlayer, state);
    #####: 1037:			drawCard(currentPlayer, state);
        -: 1038:		}
    #####: 1039:		else if (choice1 == 2)
        -: 1040:		{
        -: 1041:			//+2 coins
    #####: 1042:			state->coins = state->coins + 2;
        -: 1043:		}
        -: 1044:		else
        -: 1045:		{
        -: 1046:			//trash 2 cards in hand
    #####: 1047:			discardCard(choice2, currentPlayer, state, 1);
    #####: 1048:			discardCard(choice3, currentPlayer, state, 1);
        -: 1049:		}
        -: 1050:
        -: 1051:		//discard card from hand
    #####: 1052:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1053:		return 0;
        -: 1054:
        -: 1055:	case tribute:
    #####: 1056:		if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####: 1057:			if (state->deckCount[nextPlayer] > 0){
    #####: 1058:				tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1059:				state->deckCount[nextPlayer]--;
        -: 1060:			}
    #####: 1061:			else if (state->discardCount[nextPlayer] > 0){
    #####: 1062:				tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer] - 1];
    #####: 1063:				state->discardCount[nextPlayer]--;
        -: 1064:			}
        -: 1065:			else{
        -: 1066:				//No Card to Reveal
        -: 1067:				if (DEBUG){
        -: 1068:					printf("No cards to reveal\n");
        -: 1069:				}
        -: 1070:			}
        -: 1071:		}
        -: 1072:
        -: 1073:		else{
    #####: 1074:			if (state->deckCount[nextPlayer] == 0){
    #####: 1075:				for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####: 1076:					state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1077:					state->deckCount[nextPlayer]++;
    #####: 1078:					state->discard[nextPlayer][i] = -1;
    #####: 1079:					state->discardCount[nextPlayer]--;
        -: 1080:				}
        -: 1081:
    #####: 1082:				shuffle(nextPlayer, state);//Shuffle the deck
        -: 1083:			}
    #####: 1084:			tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1085:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1086:			state->deckCount[nextPlayer]--;
    #####: 1087:			tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1088:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1089:			state->deckCount[nextPlayer]--;
        -: 1090:		}
        -: 1091:
    #####: 1092:		if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
    #####: 1093:			state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1094:			state->playedCardCount++;
    #####: 1095:			tributeRevealedCards[1] = -1;
        -: 1096:		}
        -: 1097:
    #####: 1098:		for (i = 0; i <= 2; i++){
    #####: 1099:			if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
    #####: 1100:				state->coins += 2;
        -: 1101:			}
        -: 1102:
    #####: 1103:			else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
    #####: 1104:				drawCard(currentPlayer, state);
    #####: 1105:				drawCard(currentPlayer, state);
        -: 1106:			}
        -: 1107:			else{//Action Card
    #####: 1108:				state->numActions = state->numActions + 2;
        -: 1109:			}
        -: 1110:		}
        -: 1111:
    #####: 1112:		return 0;
        -: 1113:
        -: 1114:	case ambassador:
    #####: 1115:		j = 0;		//used to check if player has enough cards to discard
        -: 1116:
    #####: 1117:		if (choice2 > 2 || choice2 < 0)
        -: 1118:		{
    #####: 1119:			return -1;
        -: 1120:		}
        -: 1121:
    #####: 1122:		if (choice1 == handPos)
        -: 1123:		{
    #####: 1124:			return -1;
        -: 1125:		}
        -: 1126:
    #####: 1127:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1128:		{
    #####: 1129:			if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1130:			{
    #####: 1131:				j++;
        -: 1132:			}
        -: 1133:		}
    #####: 1134:		if (j < choice2)
        -: 1135:		{
    #####: 1136:			return -1;
        -: 1137:		}
        -: 1138:
        -: 1139:		if (DEBUG)
        -: 1140:			printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1141:
        -: 1142:		//increase supply count for choosen card by amount being discarded
    #####: 1143:		state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1144:
        -: 1145:		//each other player gains a copy of revealed card
    #####: 1146:		for (i = 0; i < state->numPlayers; i++)
        -: 1147:		{
    #####: 1148:			if (i != currentPlayer)
        -: 1149:			{
    #####: 1150:				gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1151:			}
        -: 1152:		}
        -: 1153:
        -: 1154:		//discard played card from hand
    #####: 1155:		discardCard(handPos, currentPlayer, state, 0);
        -: 1156:
        -: 1157:		//trash copies of cards returned to supply
    #####: 1158:		for (j = 0; j < choice2; j++)
        -: 1159:		{
    #####: 1160:			for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1161:			{
    #####: 1162:				if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1163:				{
    #####: 1164:					discardCard(i, currentPlayer, state, 1);
    #####: 1165:					break;
        -: 1166:				}
        -: 1167:			}
        -: 1168:		}
        -: 1169:
    #####: 1170:		return 0;
        -: 1171:
        -: 1172:	case cutpurse:
        -: 1173:
    #####: 1174:		updateCoins(currentPlayer, state, 2);
    #####: 1175:		for (i = 0; i < state->numPlayers; i++)
        -: 1176:		{
    #####: 1177:			if (i != currentPlayer)
        -: 1178:			{
    #####: 1179:				for (j = 0; j < state->handCount[i]; j++)
        -: 1180:				{
    #####: 1181:					if (state->hand[i][j] == copper)
        -: 1182:					{
    #####: 1183:						discardCard(j, i, state, 0);
    #####: 1184:						break;
        -: 1185:					}
    #####: 1186:					if (j == state->handCount[i])
        -: 1187:					{
    #####: 1188:						for (k = 0; k < state->handCount[i]; k++)
        -: 1189:						{
        -: 1190:							if (DEBUG)
        -: 1191:								printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1192:						}
    #####: 1193:						break;
        -: 1194:					}
        -: 1195:				}
        -: 1196:
        -: 1197:			}
        -: 1198:
        -: 1199:		}
        -: 1200:
        -: 1201:		//discard played card from hand
    #####: 1202:		discardCard(handPos, currentPlayer, state, 0);
        -: 1203:
    #####: 1204:		return 0;
        -: 1205:
        -: 1206:
        -: 1207:	case embargo:
        -: 1208:		//+2 Coins
    #####: 1209:		state->coins = state->coins + 2;
        -: 1210:
        -: 1211:		//see if selected pile is in play
    #####: 1212:		if (state->supplyCount[choice1] == -1)
        -: 1213:		{
    #####: 1214:			return -1;
        -: 1215:		}
        -: 1216:
        -: 1217:		//add embargo token to selected supply pile
    #####: 1218:		state->embargoTokens[choice1]++;
        -: 1219:
        -: 1220:		//trash card
    #####: 1221:		discardCard(handPos, currentPlayer, state, 1);
    #####: 1222:		return 0;
        -: 1223:
        -: 1224:	case outpost:
        -: 1225:		//set outpost flag
    #####: 1226:		state->outpostPlayed++;
        -: 1227:
        -: 1228:		//discard card
    #####: 1229:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1230:		return 0;
        -: 1231:
        -: 1232:	case salvager:
        -: 1233:		//+1 buy
    #####: 1234:		state->numBuys++;
        -: 1235:
    #####: 1236:		if (choice1)
        -: 1237:		{
        -: 1238:			//gain coins equal to trashed card
    #####: 1239:			state->coins = state->coins + getCost(handCard(choice1, state));
        -: 1240:			//trash card
    #####: 1241:			discardCard(choice1, currentPlayer, state, 1);
        -: 1242:		}
        -: 1243:
        -: 1244:		//discard card
    #####: 1245:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1246:		return 0;
        -: 1247:
        -: 1248:	case sea_hag:
    #####: 1249:		for (i = 0; i < state->numPlayers; i++){
    #####: 1250:			if (i != currentPlayer){
    #####: 1251:				state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1252:				state->discardCount[i]++;
    #####: 1253:				state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1254:			}
        -: 1255:		}
    #####: 1256:		return 0;
        -: 1257:
        -: 1258:	case treasure_map:
        -: 1259:
    #####: 1260:		return playTreasureMap(state, currentPlayer, handPos);
        -: 1261:	}
    #####: 1262:	return -1;
        -: 1263:}
        -: 1264:
    #####: 1265:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1266:{
        -: 1267:
        -: 1268:	//if card is not trashed, added to Played pile 
    #####: 1269:	if (trashFlag < 1)
        -: 1270:	{
        -: 1271:		//add card to played pile
    #####: 1272:		state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
    #####: 1273:		state->playedCardCount++;
        -: 1274:	}
        -: 1275:
        -: 1276:	//set played card to -1
    #####: 1277:	state->hand[currentPlayer][handPos] = -1;
        -: 1278:
        -: 1279:	//remove card from player's hand
    #####: 1280:	if (handPos == (state->handCount[currentPlayer] - 1)) 	//last card in hand array is played
        -: 1281:	{
        -: 1282:		//reduce number of cards in hand
    #####: 1283:		state->handCount[currentPlayer]--;
        -: 1284:	}
    #####: 1285:	else if (state->handCount[currentPlayer] == 1) //only one card in hand
        -: 1286:	{
        -: 1287:		//reduce number of cards in hand
    #####: 1288:		state->handCount[currentPlayer]--;
        -: 1289:	}
        -: 1290:	else
        -: 1291:	{
        -: 1292:		//replace discarded card with last card in hand
    #####: 1293:		state->hand[currentPlayer][handPos] = state->hand[currentPlayer][(state->handCount[currentPlayer] - 1)];
        -: 1294:		//set last card to -1
    #####: 1295:		state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1296:		//reduce number of cards in hand
    #####: 1297:		state->handCount[currentPlayer]--;
        -: 1298:	}
        -: 1299:
    #####: 1300:	return 0;
        -: 1301:}
        -: 1302:
    #####: 1303:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1304:{
        -: 1305:	//Note: supplyPos is enum of choosen card
        -: 1306:
        -: 1307:	//check if supply pile is empty (0) or card is not used in game (-1)
    #####: 1308:	if (supplyCount(supplyPos, state) < 1)
        -: 1309:	{
    #####: 1310:		return -1;
        -: 1311:	}
        -: 1312:
        -: 1313:	//added card for [whoseTurn] current player:
        -: 1314:	// toFlag = 0 : add to discard
        -: 1315:	// toFlag = 1 : add to deck
        -: 1316:	// toFlag = 2 : add to hand
        -: 1317:
    #####: 1318:	if (toFlag == 1)
        -: 1319:	{
    #####: 1320:		state->deck[player][state->deckCount[player]] = supplyPos;
    #####: 1321:		state->deckCount[player]++;
        -: 1322:	}
    #####: 1323:	else if (toFlag == 2)
        -: 1324:	{
    #####: 1325:		state->hand[player][state->handCount[player]] = supplyPos;
    #####: 1326:		state->handCount[player]++;
        -: 1327:	}
        -: 1328:	else
        -: 1329:	{
    #####: 1330:		state->discard[player][state->discardCount[player]] = supplyPos;
    #####: 1331:		state->discardCount[player]++;
        -: 1332:	}
        -: 1333:
        -: 1334:	//decrease number in supply pile
    #####: 1335:	state->supplyCount[supplyPos]--;
        -: 1336:
    #####: 1337:	return 0;
        -: 1338:}
        -: 1339:
       13: 1340:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1341:{
        -: 1342:	int i;
        -: 1343:
        -: 1344:	//reset coin count
       13: 1345:	state->coins = 0;
        -: 1346:
        -: 1347:	//add coins for each Treasure card in player's hand
       63: 1348:	for (i = 0; i < state->handCount[player]; i++)
        -: 1349:	{
       50: 1350:		if (state->hand[player][i] == copper)
        -: 1351:		{
       37: 1352:			state->coins += 1;
        -: 1353:		}
       13: 1354:		else if (state->hand[player][i] == silver)
        -: 1355:		{
    #####: 1356:			state->coins += 2;
        -: 1357:		}
       13: 1358:		else if (state->hand[player][i] == gold)
        -: 1359:		{
    #####: 1360:			state->coins += 3;
        -: 1361:		}
        -: 1362:	}
        -: 1363:
        -: 1364:	//add bonus
       13: 1365:	state->coins += bonus;
        -: 1366:
       13: 1367:	return 0;
        -: 1368:}
        -: 1369:
        -: 1370:
        -: 1371://end of dominion.c
File 'dominion.c'
Lines executed:30.52% of 557
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
      434:    8:int compare(const void* a, const void* b) {
      434:    9:	if (*(int*)a > *(int*)b)
    #####:   10:		return 1;
      434:   11:	if (*(int*)a < *(int*)b)
      155:   12:		return -1;
      279:   13:	return 0;
        -:   14:}
        -:   15:
       20:   16:struct gameState* newGame() {
       20:   17:	struct gameState* g = malloc(sizeof(struct gameState));
       20:   18:	return g;
        -:   19:}
        -:   20:
      105:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:	int k8, int k9, int k10) {
      105:   23:	int* k = malloc(10 * sizeof(int));
      105:   24:	k[0] = k1;
      105:   25:	k[1] = k2;
      105:   26:	k[2] = k3;
      105:   27:	k[3] = k4;
      105:   28:	k[4] = k5;
      105:   29:	k[5] = k6;
      105:   30:	k[6] = k7;
      105:   31:	k[7] = k8;
      105:   32:	k[8] = k9;
      105:   33:	k[9] = k10;
      105:   34:	return k;
        -:   35:}
        -:   36:
      105:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		struct gameState *state) {
        -:   39:
        -:   40:	int i;
        -:   41:	int j;
        -:   42:	int it;
        -:   43:	//set up random number generator
      105:   44:	SelectStream(1);
      105:   45:	PutSeed((long)randomSeed);
        -:   46:
        -:   47:	//check number of players
      105:   48:	if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:	{
    #####:   50:		return -1;
        -:   51:	}
        -:   52:
        -:   53:	//set number of players
      105:   54:	state->numPlayers = numPlayers;
        -:   55:
        -:   56:	//check selected kingdom cards are different
      348:   57:	for (i = 0; i < 10; i++)
        -:   58:	{
     3319:   59:		for (j = 0; j < 10; j++)
        -:   60:		{
     3076:   61:			if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:			{
       95:   63:				return -1;
        -:   64:			}
        -:   65:		}
        -:   66:	}
        -:   67:
        -:   68:
        -:   69:	//initialize supply
        -:   70:	///////////////////////////////
        -:   71:
        -:   72:	//set number of Curse cards
       10:   73:	if (numPlayers == 2)
        -:   74:	{
        2:   75:		state->supplyCount[curse] = 10;
        -:   76:	}
        8:   77:	else if (numPlayers == 3)
        -:   78:	{
        5:   79:		state->supplyCount[curse] = 20;
        -:   80:	}
        -:   81:	else
        -:   82:	{
        3:   83:		state->supplyCount[curse] = 30;
        -:   84:	}
        -:   85:
        -:   86:	//set number of Victory cards
       10:   87:	if (numPlayers == 2)
        -:   88:	{
        2:   89:		state->supplyCount[estate] = 8;
        2:   90:		state->supplyCount[duchy] = 8;
        2:   91:		state->supplyCount[province] = 8;
        -:   92:	}
        -:   93:	else
        -:   94:	{
        8:   95:		state->supplyCount[estate] = 12;
        8:   96:		state->supplyCount[duchy] = 12;
        8:   97:		state->supplyCount[province] = 12;
        -:   98:	}
        -:   99:
        -:  100:	//set number of Treasure cards
       10:  101:	state->supplyCount[copper] = 60 - (7 * numPlayers);
       10:  102:	state->supplyCount[silver] = 40;
       10:  103:	state->supplyCount[gold] = 30;
        -:  104:
        -:  105:	//set number of Kingdom cards
      210:  106:	for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:	{
     1650:  108:		for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:		{
     1550:  110:			if (kingdomCards[j] == i)
        -:  111:			{
        -:  112:				//check if card is a 'Victory' Kingdom card
      100:  113:				if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:				{
       28:  115:					if (numPlayers == 2){
        4:  116:						state->supplyCount[i] = 8;
        -:  117:					}
       10:  118:					else{ state->supplyCount[i] = 12; }
        -:  119:				}
        -:  120:				else
        -:  121:				{
       86:  122:					state->supplyCount[i] = 10;
        -:  123:				}
      100:  124:				break;
        -:  125:			}
        -:  126:			else    //card is not in the set choosen for the game
        -:  127:			{
     1450:  128:				state->supplyCount[i] = -1;
        -:  129:			}
        -:  130:		}
        -:  131:
        -:  132:	}
        -:  133:
        -:  134:	////////////////////////
        -:  135:	//supply intilization complete
        -:  136:
        -:  137:	//set player decks
       41:  138:	for (i = 0; i < numPlayers; i++)
        -:  139:	{
       31:  140:		state->deckCount[i] = 0;
      124:  141:		for (j = 0; j < 3; j++)
        -:  142:		{
       93:  143:			state->deck[i][j] = estate;
       93:  144:			state->deckCount[i]++;
        -:  145:		}
      248:  146:		for (j = 3; j < 10; j++)
        -:  147:		{
      217:  148:			state->deck[i][j] = copper;
      217:  149:			state->deckCount[i]++;
        -:  150:		}
        -:  151:	}
        -:  152:
        -:  153:	//shuffle player decks
       41:  154:	for (i = 0; i < numPlayers; i++)
        -:  155:	{
       31:  156:		if (shuffle(i, state) < 0)
        -:  157:		{
    #####:  158:			return -1;
        -:  159:		}
        -:  160:	}
        -:  161:
        -:  162:	//draw player hands
       41:  163:	for (i = 0; i < numPlayers; i++)
        -:  164:	{
        -:  165:		//initialize hand size to zero
       31:  166:		state->handCount[i] = 0;
       31:  167:		state->discardCount[i] = 0;
        -:  168:		//draw 5 cards
        -:  169:		// for (j = 0; j < 5; j++)
        -:  170:		//	{
        -:  171:		//	  drawCard(i, state);
        -:  172:		//	}
        -:  173:	}
        -:  174:
        -:  175:	//set embargo tokens to 0 for all supply piles
      280:  176:	for (i = 0; i <= treasure_map; i++)
        -:  177:	{
      270:  178:		state->embargoTokens[i] = 0;
        -:  179:	}
        -:  180:
        -:  181:	//initialize first player's turn
       10:  182:	state->outpostPlayed = 0;
       10:  183:	state->phase = 0;
       10:  184:	state->numActions = 1;
       10:  185:	state->numBuys = 1;
       10:  186:	state->playedCardCount = 0;
       10:  187:	state->whoseTurn = 0;
       10:  188:	state->handCount[state->whoseTurn] = 0;
        -:  189:	//int it; move to top
        -:  190:
        -:  191:	//Moved draw cards to here, only drawing at the start of a turn
       60:  192:	for (it = 0; it < 5; it++){
       50:  193:		drawCard(state->whoseTurn, state);
        -:  194:	}
        -:  195:
       10:  196:	updateCoins(state->whoseTurn, state, 0);
        -:  197:
       10:  198:	return 0;
        -:  199:}
        -:  200:
       31:  201:int shuffle(int player, struct gameState *state) {
        -:  202:
        -:  203:
        -:  204:	int newDeck[MAX_DECK];
       31:  205:	int newDeckPos = 0;
        -:  206:	int card;
        -:  207:	int i;
        -:  208:
       31:  209:	if (state->deckCount[player] < 1)
    #####:  210:		return -1;
       31:  211:	qsort((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
        -:  212:	/* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
      372:  214:	while (state->deckCount[player] > 0) {
      310:  215:		card = floor(Random() * state->deckCount[player]);
      310:  216:		newDeck[newDeckPos] = state->deck[player][card];
      310:  217:		newDeckPos++;
      981:  218:		for (i = card; i < state->deckCount[player] - 1; i++) {
      671:  219:			state->deck[player][i] = state->deck[player][i + 1];
        -:  220:		}
      310:  221:		state->deckCount[player]--;
        -:  222:	}
      341:  223:	for (i = 0; i < newDeckPos; i++) {
      310:  224:		state->deck[player][i] = newDeck[i];
      310:  225:		state->deckCount[player]++;
        -:  226:	}
        -:  227:
       31:  228:	return 0;
        -:  229:}
        -:  230:
        1:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state)
        -:  232:{
        -:  233:	int card;
        1:  234:	int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:	//check if it is the right phase
        1:  237:	if (state->phase != 0)
        -:  238:	{
    #####:  239:		return -1;
        -:  240:	}
        -:  241:
        -:  242:	//check if player has enough actions
        1:  243:	if (state->numActions < 1)
        -:  244:	{
    #####:  245:		return -1;
        -:  246:	}
        -:  247:
        -:  248:	//get card played
        1:  249:	card = handCard(handPos, state);
        -:  250:
        -:  251:	//check if selected card is an action
        1:  252:	if (card < adventurer || card > treasure_map)
        -:  253:	{
        1:  254:		return -1;
        -:  255:	}
        -:  256:
        -:  257:	//play card
    #####:  258:	if (cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0)
        -:  259:	{
    #####:  260:		return -1;
        -:  261:	}
        -:  262:
        -:  263:	//reduce number of actions
    #####:  264:	state->numActions--;
        -:  265:
        -:  266:	//update coins (Treasure cards may be added with card draws)
    #####:  267:	updateCoins(state->whoseTurn, state, coin_bonus);
        -:  268:
    #####:  269:	return 0;
        -:  270:}
        -:  271:
        3:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:	int who;
        -:  274:	if (DEBUG){
        -:  275:		printf("Entering buyCard...\n");
        -:  276:	}
        -:  277:
        -:  278:	// I don't know what to do about the phase thing.
        -:  279:
        3:  280:	who = state->whoseTurn;
        -:  281:
        3:  282:	if (state->numBuys < 1){
        -:  283:		if (DEBUG)
        -:  284:			printf("You do not have any buys left\n");
    #####:  285:		return -1;
        -:  286:	}
        3:  287:	else if (supplyCount(supplyPos, state) < 1){
        -:  288:		if (DEBUG)
        -:  289:			printf("There are not any of that type of card left\n");
    #####:  290:		return -1;
        -:  291:	}
        3:  292:	else if (state->coins < getCost(supplyPos)){
        -:  293:		if (DEBUG)
        -:  294:			printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
        2:  295:		return -1;
        -:  296:	}
        -:  297:	else {
        1:  298:		state->phase = 1;
        -:  299:		//state->supplyCount[supplyPos]--;
        1:  300:		gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  301:
        1:  302:		state->coins = (state->coins) - (getCost(supplyPos));
        1:  303:		state->numBuys--;
        -:  304:		if (DEBUG)
        -:  305:			printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  306:	}
        -:  307:
        -:  308:	//state->discard[who][state->discardCount[who]] = supplyPos;
        -:  309:	//state->discardCount[who]++;
        -:  310:
        1:  311:	return 0;
        -:  312:}
        -:  313:
    #####:  314:int numHandCards(struct gameState *state) {
    #####:  315:	return state->handCount[whoseTurn(state)];
        -:  316:}
        -:  317:
        1:  318:int handCard(int handPos, struct gameState *state) {
        1:  319:	int currentPlayer = whoseTurn(state);
        1:  320:	return state->hand[currentPlayer][handPos];
        -:  321:}
        -:  322:
        4:  323:int supplyCount(int card, struct gameState *state) {
        4:  324:	return state->supplyCount[card];
        -:  325:}
        -:  326:
    #####:  327:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  328:	int i;
    #####:  329:	int count = 0;
        -:  330:
    #####:  331:	for (i = 0; i < state->deckCount[player]; i++)
        -:  332:	{
    #####:  333:		if (state->deck[player][i] == card) count++;
        -:  334:	}
        -:  335:
    #####:  336:	for (i = 0; i < state->handCount[player]; i++)
        -:  337:	{
    #####:  338:		if (state->hand[player][i] == card) count++;
        -:  339:	}
        -:  340:
    #####:  341:	for (i = 0; i < state->discardCount[player]; i++)
        -:  342:	{
    #####:  343:		if (state->discard[player][i] == card) count++;
        -:  344:	}
        -:  345:
    #####:  346:	return count;
        -:  347:}
        -:  348:
        7:  349:int whoseTurn(struct gameState *state) {
        7:  350:	return state->whoseTurn;
        -:  351:}
        -:  352:
        6:  353:int endTurn(struct gameState *state) {
        -:  354:	int k;
        -:  355:	int i;
        6:  356:	int currentPlayer = whoseTurn(state);
        -:  357:
        -:  358:	//Discard hand
       36:  359:	for (i = 0; i < state->handCount[currentPlayer]; i++){
       30:  360:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
       30:  361:		state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  362:	}
        6:  363:	state->handCount[currentPlayer] = 0;//Reset hand count
        -:  364:
        -:  365:	//Code for determining the player
        6:  366:	if (currentPlayer < (state->numPlayers - 1)){
        6:  367:		state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  368:	}
        -:  369:	else{
    #####:  370:		state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  371:	}
        -:  372:
        6:  373:	state->outpostPlayed = 0;
        6:  374:	state->phase = 0;
        6:  375:	state->numActions = 1;
        6:  376:	state->coins = 0;
        6:  377:	state->numBuys = 1;
        6:  378:	state->playedCardCount = 0;
        6:  379:	state->handCount[state->whoseTurn] = 0;
        -:  380:
        -:  381:	//int k; move to top
        -:  382:	//Next player draws hand
       36:  383:	for (k = 0; k < 5; k++){
       30:  384:		drawCard(state->whoseTurn, state);//Draw a card
        -:  385:	}
        -:  386:
        -:  387:	//Update money
        6:  388:	updateCoins(state->whoseTurn, state, 0);
        -:  389:
        6:  390:	return 0;
        -:  391:}
        -:  392:
    #####:  393:int isGameOver(struct gameState *state) {
        -:  394:	int i;
        -:  395:	int j;
        -:  396:
        -:  397:	//if stack of Province cards is empty, the game ends
    #####:  398:	if (state->supplyCount[province] == 0)
        -:  399:	{
    #####:  400:		return 1;
        -:  401:	}
        -:  402:
        -:  403:	//if three supply pile are at 0, the game ends
    #####:  404:	j = 0;
    #####:  405:	for (i = 0; i < 25; i++)
        -:  406:	{
    #####:  407:		if (state->supplyCount[i] == 0)
        -:  408:		{
    #####:  409:			j++;
        -:  410:		}
        -:  411:	}
    #####:  412:	if (j >= 3)
        -:  413:	{
    #####:  414:		return 1;
        -:  415:	}
        -:  416:
    #####:  417:	return 0;
        -:  418:}
        -:  419:
    #####:  420:int scoreFor(int player, struct gameState *state) {
        -:  421:
        -:  422:	int i;
    #####:  423:	int score = 0;
        -:  424:	//score from hand
    #####:  425:	for (i = 0; i < state->handCount[player]; i++)
        -:  426:	{
    #####:  427:		if (state->hand[player][i] == curse) { score = score - 1; };
    #####:  428:		if (state->hand[player][i] == estate) { score = score + 1; };
    #####:  429:		if (state->hand[player][i] == duchy) { score = score + 3; };
    #####:  430:		if (state->hand[player][i] == province) { score = score + 6; };
    #####:  431:		if (state->hand[player][i] == great_hall) { score = score + 1; };
    #####:  432:		if (state->hand[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  433:	}
        -:  434:
        -:  435:	//score from discard
    #####:  436:	for (i = 0; i < state->discardCount[player]; i++)
        -:  437:	{
    #####:  438:		if (state->discard[player][i] == curse) { score = score - 1; };
    #####:  439:		if (state->discard[player][i] == estate) { score = score + 1; };
    #####:  440:		if (state->discard[player][i] == duchy) { score = score + 3; };
    #####:  441:		if (state->discard[player][i] == province) { score = score + 6; };
    #####:  442:		if (state->discard[player][i] == great_hall) { score = score + 1; };
    #####:  443:		if (state->discard[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  444:	}
        -:  445:
        -:  446:	//score from deck
    #####:  447:	for (i = 0; i < state->discardCount[player]; i++)
        -:  448:	{
    #####:  449:		if (state->deck[player][i] == curse) { score = score - 1; };
    #####:  450:		if (state->deck[player][i] == estate) { score = score + 1; };
    #####:  451:		if (state->deck[player][i] == duchy) { score = score + 3; };
    #####:  452:		if (state->deck[player][i] == province) { score = score + 6; };
    #####:  453:		if (state->deck[player][i] == great_hall) { score = score + 1; };
    #####:  454:		if (state->deck[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  455:	}
        -:  456:
    #####:  457:	return score;
        -:  458:}
        -:  459:
    #####:  460:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  461:	int i;
        -:  462:	int j;
        -:  463:	int highScore;
        -:  464:	int currentPlayer;
        -:  465:
        -:  466:	//get score for each player
    #####:  467:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  468:	{
        -:  469:		//set unused player scores to -9999
    #####:  470:		if (i >= state->numPlayers)
        -:  471:		{
    #####:  472:			players[i] = -9999;
        -:  473:		}
        -:  474:		else
        -:  475:		{
    #####:  476:			players[i] = scoreFor(i, state);
        -:  477:		}
        -:  478:	}
        -:  479:
        -:  480:	//find highest score
    #####:  481:	j = 0;
    #####:  482:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  483:	{
    #####:  484:		if (players[i] > players[j])
        -:  485:		{
    #####:  486:			j = i;
        -:  487:		}
        -:  488:	}
    #####:  489:	highScore = players[j];
        -:  490:
        -:  491:	//add 1 to players who had less turns
    #####:  492:	currentPlayer = whoseTurn(state);
    #####:  493:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  494:	{
    #####:  495:		if (players[i] == highScore && i > currentPlayer)
        -:  496:		{
    #####:  497:			players[i]++;
        -:  498:		}
        -:  499:	}
        -:  500:
        -:  501:	//find new highest score
    #####:  502:	j = 0;
    #####:  503:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  504:	{
    #####:  505:		if (players[i] > players[j])
        -:  506:		{
    #####:  507:			j = i;
        -:  508:		}
        -:  509:	}
    #####:  510:	highScore = players[j];
        -:  511:
        -:  512:	//set winners in array to 1 and rest to 0
    #####:  513:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  514:	{
    #####:  515:		if (players[i] == highScore)
        -:  516:		{
    #####:  517:			players[i] = 1;
        -:  518:		}
        -:  519:		else
        -:  520:		{
    #####:  521:			players[i] = 0;
        -:  522:		}
        -:  523:	}
        -:  524:
    #####:  525:	return 0;
        -:  526:}
        -:  527:
       80:  528:int drawCard(int player, struct gameState *state)
        -:  529:{
        -:  530:	int count;
        -:  531:	int deckCounter;
       80:  532:	if (state->deckCount[player] <= 0){//Deck is empty
        -:  533:
        -:  534:		//Step 1 Shuffle the discard pile back into a deck
        -:  535:		int i;
        -:  536:		//Move discard to deck
    #####:  537:		for (i = 0; i < state->discardCount[player]; i++){
    #####:  538:			state->deck[player][i] = state->discard[player][i];
    #####:  539:			state->discard[player][i] = -1;
        -:  540:		}
        -:  541:
    #####:  542:		state->deckCount[player] = state->discardCount[player];
    #####:  543:		state->discardCount[player] = 0;//Reset discard
        -:  544:
        -:  545:		//Shufffle the deck
    #####:  546:		shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  547:
        -:  548:		if (DEBUG){//Debug statements
        -:  549:			printf("Deck count now: %d\n", state->deckCount[player]);
        -:  550:		}
        -:  551:
    #####:  552:		state->discardCount[player] = 0;
        -:  553:
        -:  554:		//Step 2 Draw Card
    #####:  555:		count = state->handCount[player];//Get current player's hand count
        -:  556:
        -:  557:		if (DEBUG){//Debug statements
        -:  558:			printf("Current hand count: %d\n", count);
        -:  559:		}
        -:  560:
    #####:  561:		deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  562:
    #####:  563:		if (deckCounter == 0)
    #####:  564:			return -1;
        -:  565:
    #####:  566:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
    #####:  567:		state->deckCount[player]--;
    #####:  568:		state->handCount[player]++;//Increment hand count
        -:  569:	}
        -:  570:
        -:  571:	else{
       80:  572:		int count = state->handCount[player];//Get current hand count for player
        -:  573:		int deckCounter;
        -:  574:		if (DEBUG){//Debug statements
        -:  575:			printf("Current hand count: %d\n", count);
        -:  576:		}
        -:  577:
       80:  578:		deckCounter = state->deckCount[player];//Create holder for the deck count
       80:  579:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
       80:  580:		state->deckCount[player]--;
       80:  581:		state->handCount[player]++;//Increment hand count
        -:  582:	}
        -:  583:
       80:  584:	return 0;
        -:  585:}
        -:  586:
        4:  587:int getCost(int cardNumber)
        -:  588:{
        4:  589:	switch (cardNumber)
        -:  590:	{
        -:  591:	case curse:
    #####:  592:		return 0;
        -:  593:	case estate:
    #####:  594:		return 2;
        -:  595:	case duchy:
        1:  596:		return 5;
        -:  597:	case province:
    #####:  598:		return 8;
        -:  599:	case copper:
    #####:  600:		return 0;
        -:  601:	case silver:
    #####:  602:		return 3;
        -:  603:	case gold:
    #####:  604:		return 6;
        -:  605:	case adventurer:
    #####:  606:		return 6;
        -:  607:	case council_room:
        1:  608:		return 5;
        -:  609:	case feast:
    #####:  610:		return 4;
        -:  611:	case gardens:
    #####:  612:		return 4;
        -:  613:	case mine:
    #####:  614:		return 5;
        -:  615:	case remodel:
    #####:  616:		return 4;
        -:  617:	case smithy:
    #####:  618:		return 4;
        -:  619:	case village:
    #####:  620:		return 3;
        -:  621:	case baron:
    #####:  622:		return 4;
        -:  623:	case great_hall:
    #####:  624:		return 3;
        -:  625:	case minion:
    #####:  626:		return 5;
        -:  627:	case steward:
        2:  628:		return 3;
        -:  629:	case tribute:
    #####:  630:		return 5;
        -:  631:	case ambassador:
    #####:  632:		return 3;
        -:  633:	case cutpurse:
    #####:  634:		return 4;
        -:  635:	case embargo:
    #####:  636:		return 2;
        -:  637:	case outpost:
    #####:  638:		return 5;
        -:  639:	case salvager:
    #####:  640:		return 4;
        -:  641:	case sea_hag:
    #####:  642:		return 4;
        -:  643:	case treasure_map:
    #####:  644:		return 4;
        -:  645:	}
        -:  646:
    #####:  647:	return -1;
        -:  648:}
        -:  649:
    #####:  650:void playAdventurer(struct gameState *state, int currentPlayer)
        -:  651:// Reveal cards from deck until 2 Treasure cards are found.  Put those Treasure cards in the hand and discard the rest.
        -:  652:{
    #####:  653:	int drawntreasure = 0;
        -:  654:	int temphand[MAX_HAND];
        -:  655:	int cardDrawn;
    #####:  656:	int z = 0; // this is the counter for the temp hand
        -:  657:
    #####:  658:	while (drawntreasure < 2){
    #####:  659:		if (state->deckCount[currentPlayer] < 1){//if the deck is empty we need to shuffle discard and add to deck
    #####:  660:			shuffle(currentPlayer, state);
        -:  661:		}
    #####:  662:		drawCard(currentPlayer, state);
    #####:  663:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer] - 1];//top card of hand is most recently drawn card.
    #####:  664:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
    #####:  665:			drawntreasure++;
        -:  666:		else{
    #####:  667:			temphand[z] = cardDrawn;
    #####:  668:			state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####:  669:			z++;
        -:  670:		}
        -:  671:	}
    #####:  672:	while (z - 1 >= 0){
    #####:  673:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; // discard all cards in play that have been drawn
    #####:  674:		z = z - 1;
        -:  675:	}
    #####:  676:}
        -:  677:
    #####:  678:int playRemodel(struct gameState *state, int currentPlayer, int choice1, int choice2, int handPos)
        -:  679://Trash a card in the hand, and gain a card costing up to $2 more than the trashed card
        -:  680:{
        -:  681:	int i;
    #####:  682:	int j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  683:
    #####:  684:	if ((getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2))
        -:  685:	{
    #####:  686:		return -1;
        -:  687:	}
        -:  688:
    #####:  689:	gainCard(choice2, state, 0, currentPlayer);
        -:  690:
        -:  691:	//discard card from hand
    #####:  692:	discardCard(handPos, currentPlayer, state, 0);
        -:  693:
        -:  694:	//discard trashed card
    #####:  695:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  696:	{
    #####:  697:		if (state->hand[currentPlayer][i] == j)
        -:  698:		{
    #####:  699:			discardCard(i, currentPlayer, state, 0);
    #####:  700:			break;
        -:  701:		}
        -:  702:	}
        -:  703:
    #####:  704:	return 0;
        -:  705:}
        -:  706:
    #####:  707:void playSmithy(struct gameState *state, int currentPlayer, int handPos)
        -:  708:// Draw 3 cards
        -:  709:{
        -:  710:	int i;
    #####:  711:	for (i = 0; i < 3; i++)
        -:  712:	{
    #####:  713:		drawCard(currentPlayer, state);
        -:  714:	}
        -:  715:
        -:  716:	//discard card from hand
    #####:  717:	discardCard(handPos, currentPlayer, state, 0);
    #####:  718:}
        -:  719:
    #####:  720:void playBaron(struct gameState *state, int currentPlayer, int choice1, int handPos)
        -:  721://Add a buy.  OPTION:  Discard an Estate card and gain $4.  Otherwise, gain an Estate card.
        -:  722:{
    #####:  723:	state->numBuys++;//Increase buys by 1!
    #####:  724:	if (choice1 > 0){//Boolean true or going to discard an estate
    #####:  725:		int p = 0;//Iterator for hand!
    #####:  726:		int card_not_discarded = 1;//Flag for discard set!
    #####:  727:		while (card_not_discarded){
    #####:  728:			if (state->hand[currentPlayer][p] == estate){ //Found an estate card!
    #####:  729:				state->coins += 4;//Add 4 coins to the amount of coins
    #####:  730:				state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  731:				state->discardCount[currentPlayer]++;
    #####:  732:				for (; p < state->handCount[currentPlayer]; p++){
    #####:  733:					state->hand[currentPlayer][p] = state->hand[currentPlayer][p + 1];
        -:  734:				}
    #####:  735:				state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  736:				state->handCount[currentPlayer]--;
    #####:  737:				card_not_discarded = 0;//Exit the loop
        -:  738:			}
    #####:  739:			else if (p > state->handCount[currentPlayer]){
        -:  740:				if (DEBUG) {
        -:  741:					printf("No estate cards in your hand, invalid choice\n");
        -:  742:					printf("Must gain an estate if there are any\n");
        -:  743:				}
    #####:  744:				if (supplyCount(estate, state) > 0){
    #####:  745:					gainCard(estate, state, 1, currentPlayer);
    #####:  746:					state->supplyCount[estate]--;//Decrement estates
    #####:  747:					if (supplyCount(estate, state) == 0){
    #####:  748:						isGameOver(state);
        -:  749:					}
        -:  750:				}
    #####:  751:				card_not_discarded = 0;//Exit the loop
        -:  752:			}
        -:  753:
        -:  754:			else{
    #####:  755:				p++;//Next card
        -:  756:			}
        -:  757:		}
        -:  758:	}
        -:  759:
        -:  760:	else{
    #####:  761:		if (supplyCount(estate, state) > 0){
    #####:  762:			gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  763:			state->supplyCount[estate]--;//Decrement Estates
    #####:  764:			if (supplyCount(estate, state) == 0){
    #####:  765:				isGameOver(state);
        -:  766:			}
        -:  767:		}
        -:  768:	}
    #####:  769:}
        -:  770:
    #####:  771:int playTreasureMap(struct gameState *state, int currentPlayer, int handPos)
        -:  772://Trashing two treasure map cards from the hand = four gold on top of the deck.
        -:  773:{
        -:  774:	int i;
        -:  775:	int index;
        -:  776:
        -:  777:	//search hand for another treasure_map
    #####:  778:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  779:	{
    #####:  780:		if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -:  781:		{
    #####:  782:			index = i;
    #####:  783:			break;
        -:  784:		}
        -:  785:	}
    #####:  786:	if (index > -1)
        -:  787:	{
        -:  788:		//trash both treasure cards
    #####:  789:		discardCard(handPos, currentPlayer, state, 1);
    #####:  790:		discardCard(index, currentPlayer, state, 1);
        -:  791:
        -:  792:		//gain 4 Gold cards
    #####:  793:		for (i = 0; i < 4; i++)
        -:  794:		{
    #####:  795:			gainCard(gold, state, 1, currentPlayer);
        -:  796:		}
        -:  797:
        -:  798:		//return success
    #####:  799:		return 1;
        -:  800:	}
        -:  801:
        -:  802:	//no second treasure_map found in hand
    #####:  803:	return -1;
        -:  804:}
        -:  805:
    #####:  806:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  807:{
        -:  808:	int i;
        -:  809:	int j;
        -:  810:	int k;
        -:  811:	//int x;  //Unused after while loop removed from feast.
    #####:  812:	int currentPlayer = whoseTurn(state);
    #####:  813:	int nextPlayer = currentPlayer + 1;
        -:  814:	int temphand[MAX_HAND];
        -:  815:
    #####:  816:	int tributeRevealedCards[2] = { -1, -1 };
        -:  817:
    #####:  818:	if (nextPlayer > (state->numPlayers - 1)){
    #####:  819:		nextPlayer = 0;
        -:  820:	}
        -:  821:
        -:  822:	//uses switch to select card and perform actions
    #####:  823:	switch (card)
        -:  824:	{
        -:  825:	case adventurer:
        -:  826:
    #####:  827:		playAdventurer(state, currentPlayer);
    #####:  828:		return 0;
        -:  829:
        -:  830:	case council_room:
        -:  831:		//+4 Cards
    #####:  832:		for (i = 0; i < 4; i++)
        -:  833:		{
    #####:  834:			drawCard(currentPlayer, state);
        -:  835:		}
        -:  836:
        -:  837:		//+1 Buy
    #####:  838:		state->numBuys++;
        -:  839:
        -:  840:		//Each other player draws a card
    #####:  841:		for (i = 0; i < state->numPlayers; i++)
        -:  842:		{
    #####:  843:			if (i != currentPlayer)
        -:  844:			{
    #####:  845:				drawCard(i, state);
        -:  846:			}
        -:  847:		}
        -:  848:
        -:  849:		//put played card in played card pile
    #####:  850:		discardCard(handPos, currentPlayer, state, 0);
        -:  851:
    #####:  852:		return 0;
        -:  853:
        -:  854:	case feast:
        -:  855:		//gain card with cost up to 5
        -:  856:		//Backup hand
    #####:  857:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  858:			temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  859:			state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  860:		}
        -:  861:		//Backup hand
        -:  862:
        -:  863:		//Update Coins for Buy
    #####:  864:		updateCoins(currentPlayer, state, 5);
        -:  865://		x = 1;//Condition to loop on
        -:  866://		while (x == 1) {//Buy one card
    #####:  867:			if (supplyCount(choice1, state) <= 0){
        -:  868:				if (DEBUG)
        -:  869:					printf("None of that card left, sorry!\n");
        -:  870:
        -:  871:				if (DEBUG){
        -:  872:					printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  873:				}
        -:  874:			}
    #####:  875:			else if (state->coins < getCost(choice1)){
    #####:  876:				printf("That card is too expensive!\n");
        -:  877:
        -:  878:				if (DEBUG){
        -:  879:					printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  880:				}
        -:  881:			}
        -:  882:			else{
        -:  883:
        -:  884:				if (DEBUG){
        -:  885:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  886:				}
        -:  887:
    #####:  888:				gainCard(choice1, state, 0, currentPlayer);//Gain the card
        -:  889://				x = 0;//No more buying cards
        -:  890:
        -:  891:				if (DEBUG){
        -:  892:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  893:				}
        -:  894:
        -:  895:			}
        -:  896://		}
        -:  897:
        -:  898:		//Reset Hand
    #####:  899:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  900:			state->hand[currentPlayer][i] = temphand[i];
    #####:  901:			temphand[i] = -1;
        -:  902:		}
        -:  903:		//Reset Hand
        -:  904:
    #####:  905:		return 0;
        -:  906:
        -:  907:	case gardens:
    #####:  908:		return -1;
        -:  909:
        -:  910:	case mine:
    #####:  911:		j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  912:
    #####:  913:		if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  914:		{
    #####:  915:			return -1;
        -:  916:		}
        -:  917:
    #####:  918:		if (choice2 > treasure_map || choice2 < curse)
        -:  919:		{
    #####:  920:			return -1;
        -:  921:		}
        -:  922:
    #####:  923:		if ((getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2))
        -:  924:		{
    #####:  925:			return -1;
        -:  926:		}
        -:  927:
    #####:  928:		gainCard(choice2, state, 2, currentPlayer);
        -:  929:
        -:  930:		//discard card from hand
    #####:  931:		discardCard(handPos, currentPlayer, state, 0);
        -:  932:
        -:  933:		//discard trashed card
    #####:  934:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  935:		{
    #####:  936:			if (state->hand[currentPlayer][i] == j)
        -:  937:			{
    #####:  938:				discardCard(i, currentPlayer, state, 0);
    #####:  939:				break;
        -:  940:			}
        -:  941:		}
        -:  942:
    #####:  943:		return 0;
        -:  944:
        -:  945:	case remodel:
        -:  946:
    #####:  947:		return playRemodel(state, currentPlayer, choice1, choice2, handPos);
        -:  948:
        -:  949:	case smithy:
        -:  950:
    #####:  951:		playSmithy(state, currentPlayer, handPos);
    #####:  952:		return 0;
        -:  953:
        -:  954:	case village:
        -:  955:		//+1 Card
    #####:  956:		drawCard(currentPlayer, state);
        -:  957:
        -:  958:		//+2 Actions
    #####:  959:		state->numActions = state->numActions + 2;
        -:  960:
        -:  961:		//discard played card from hand
    #####:  962:		discardCard(handPos, currentPlayer, state, 0);
    #####:  963:		return 0;
        -:  964:
        -:  965:	case baron:
        -:  966:
    #####:  967:		playBaron(state, currentPlayer, choice1, handPos);
    #####:  968:		return 0;
        -:  969:
        -:  970:	case great_hall:
        -:  971:		//+1 Card
    #####:  972:		drawCard(currentPlayer, state);
        -:  973:
        -:  974:		//+1 Actions
    #####:  975:		state->numActions++;
        -:  976:
        -:  977:		//discard card from hand
    #####:  978:		discardCard(handPos, currentPlayer, state, 0);
    #####:  979:		return 0;
        -:  980:
        -:  981:	case minion:
        -:  982:		//+1 action
    #####:  983:		state->numActions++;
        -:  984:
        -:  985:		//discard card from hand
    #####:  986:		discardCard(handPos, currentPlayer, state, 0);
        -:  987:
    #####:  988:		if (choice1)		//+2 coins
        -:  989:		{
    #####:  990:			state->coins = state->coins + 2;
        -:  991:		}
        -:  992:
    #####:  993:		else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  994:		{
        -:  995:			//discard hand
    #####:  996:			while (numHandCards(state) > 0)
        -:  997:			{
    #####:  998:				discardCard(handPos, currentPlayer, state, 0);
        -:  999:			}
        -: 1000:
        -: 1001:			//draw 4
    #####: 1002:			for (i = 0; i < 4; i++)
        -: 1003:			{
    #####: 1004:				drawCard(currentPlayer, state);
        -: 1005:			}
        -: 1006:
        -: 1007:			//other players discard hand and redraw if hand size > 4
    #####: 1008:			for (i = 0; i < state->numPlayers; i++)
        -: 1009:			{
    #####: 1010:				if (i != currentPlayer)
        -: 1011:				{
    #####: 1012:					if (state->handCount[i] > 4)
        -: 1013:					{
        -: 1014:						//discard hand
    #####: 1015:						while (state->handCount[i] > 0)
        -: 1016:						{
    #####: 1017:							discardCard(handPos, i, state, 0);
        -: 1018:						}
        -: 1019:
        -: 1020:						//draw 4
    #####: 1021:						for (j = 0; j < 4; j++)
        -: 1022:						{
    #####: 1023:							drawCard(i, state);
        -: 1024:						}
        -: 1025:					}
        -: 1026:				}
        -: 1027:			}
        -: 1028:
        -: 1029:		}
    #####: 1030:		return 0;
        -: 1031:
        -: 1032:	case steward:
    #####: 1033:		if (choice1 == 1)
        -: 1034:		{
        -: 1035:			//+2 cards
    #####: 1036:			drawCard(currentPlayer, state);
    #####: 1037:			drawCard(currentPlayer, state);
        -: 1038:		}
    #####: 1039:		else if (choice1 == 2)
        -: 1040:		{
        -: 1041:			//+2 coins
    #####: 1042:			state->coins = state->coins + 2;
        -: 1043:		}
        -: 1044:		else
        -: 1045:		{
        -: 1046:			//trash 2 cards in hand
    #####: 1047:			discardCard(choice2, currentPlayer, state, 1);
    #####: 1048:			discardCard(choice3, currentPlayer, state, 1);
        -: 1049:		}
        -: 1050:
        -: 1051:		//discard card from hand
    #####: 1052:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1053:		return 0;
        -: 1054:
        -: 1055:	case tribute:
    #####: 1056:		if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####: 1057:			if (state->deckCount[nextPlayer] > 0){
    #####: 1058:				tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1059:				state->deckCount[nextPlayer]--;
        -: 1060:			}
    #####: 1061:			else if (state->discardCount[nextPlayer] > 0){
    #####: 1062:				tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer] - 1];
    #####: 1063:				state->discardCount[nextPlayer]--;
        -: 1064:			}
        -: 1065:			else{
        -: 1066:				//No Card to Reveal
        -: 1067:				if (DEBUG){
        -: 1068:					printf("No cards to reveal\n");
        -: 1069:				}
        -: 1070:			}
        -: 1071:		}
        -: 1072:
        -: 1073:		else{
    #####: 1074:			if (state->deckCount[nextPlayer] == 0){
    #####: 1075:				for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####: 1076:					state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1077:					state->deckCount[nextPlayer]++;
    #####: 1078:					state->discard[nextPlayer][i] = -1;
    #####: 1079:					state->discardCount[nextPlayer]--;
        -: 1080:				}
        -: 1081:
    #####: 1082:				shuffle(nextPlayer, state);//Shuffle the deck
        -: 1083:			}
    #####: 1084:			tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1085:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1086:			state->deckCount[nextPlayer]--;
    #####: 1087:			tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1088:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1089:			state->deckCount[nextPlayer]--;
        -: 1090:		}
        -: 1091:
    #####: 1092:		if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
    #####: 1093:			state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1094:			state->playedCardCount++;
    #####: 1095:			tributeRevealedCards[1] = -1;
        -: 1096:		}
        -: 1097:
    #####: 1098:		for (i = 0; i <= 2; i++){
    #####: 1099:			if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
    #####: 1100:				state->coins += 2;
        -: 1101:			}
        -: 1102:
    #####: 1103:			else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
    #####: 1104:				drawCard(currentPlayer, state);
    #####: 1105:				drawCard(currentPlayer, state);
        -: 1106:			}
        -: 1107:			else{//Action Card
    #####: 1108:				state->numActions = state->numActions + 2;
        -: 1109:			}
        -: 1110:		}
        -: 1111:
    #####: 1112:		return 0;
        -: 1113:
        -: 1114:	case ambassador:
    #####: 1115:		j = 0;		//used to check if player has enough cards to discard
        -: 1116:
    #####: 1117:		if (choice2 > 2 || choice2 < 0)
        -: 1118:		{
    #####: 1119:			return -1;
        -: 1120:		}
        -: 1121:
    #####: 1122:		if (choice1 == handPos)
        -: 1123:		{
    #####: 1124:			return -1;
        -: 1125:		}
        -: 1126:
    #####: 1127:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1128:		{
    #####: 1129:			if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1130:			{
    #####: 1131:				j++;
        -: 1132:			}
        -: 1133:		}
    #####: 1134:		if (j < choice2)
        -: 1135:		{
    #####: 1136:			return -1;
        -: 1137:		}
        -: 1138:
        -: 1139:		if (DEBUG)
        -: 1140:			printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1141:
        -: 1142:		//increase supply count for choosen card by amount being discarded
    #####: 1143:		state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1144:
        -: 1145:		//each other player gains a copy of revealed card
    #####: 1146:		for (i = 0; i < state->numPlayers; i++)
        -: 1147:		{
    #####: 1148:			if (i != currentPlayer)
        -: 1149:			{
    #####: 1150:				gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1151:			}
        -: 1152:		}
        -: 1153:
        -: 1154:		//discard played card from hand
    #####: 1155:		discardCard(handPos, currentPlayer, state, 0);
        -: 1156:
        -: 1157:		//trash copies of cards returned to supply
    #####: 1158:		for (j = 0; j < choice2; j++)
        -: 1159:		{
    #####: 1160:			for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1161:			{
    #####: 1162:				if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1163:				{
    #####: 1164:					discardCard(i, currentPlayer, state, 1);
    #####: 1165:					break;
        -: 1166:				}
        -: 1167:			}
        -: 1168:		}
        -: 1169:
    #####: 1170:		return 0;
        -: 1171:
        -: 1172:	case cutpurse:
        -: 1173:
    #####: 1174:		updateCoins(currentPlayer, state, 2);
    #####: 1175:		for (i = 0; i < state->numPlayers; i++)
        -: 1176:		{
    #####: 1177:			if (i != currentPlayer)
        -: 1178:			{
    #####: 1179:				for (j = 0; j < state->handCount[i]; j++)
        -: 1180:				{
    #####: 1181:					if (state->hand[i][j] == copper)
        -: 1182:					{
    #####: 1183:						discardCard(j, i, state, 0);
    #####: 1184:						break;
        -: 1185:					}
    #####: 1186:					if (j == state->handCount[i])
        -: 1187:					{
    #####: 1188:						for (k = 0; k < state->handCount[i]; k++)
        -: 1189:						{
        -: 1190:							if (DEBUG)
        -: 1191:								printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1192:						}
    #####: 1193:						break;
        -: 1194:					}
        -: 1195:				}
        -: 1196:
        -: 1197:			}
        -: 1198:
        -: 1199:		}
        -: 1200:
        -: 1201:		//discard played card from hand
    #####: 1202:		discardCard(handPos, currentPlayer, state, 0);
        -: 1203:
    #####: 1204:		return 0;
        -: 1205:
        -: 1206:
        -: 1207:	case embargo:
        -: 1208:		//+2 Coins
    #####: 1209:		state->coins = state->coins + 2;
        -: 1210:
        -: 1211:		//see if selected pile is in play
    #####: 1212:		if (state->supplyCount[choice1] == -1)
        -: 1213:		{
    #####: 1214:			return -1;
        -: 1215:		}
        -: 1216:
        -: 1217:		//add embargo token to selected supply pile
    #####: 1218:		state->embargoTokens[choice1]++;
        -: 1219:
        -: 1220:		//trash card
    #####: 1221:		discardCard(handPos, currentPlayer, state, 1);
    #####: 1222:		return 0;
        -: 1223:
        -: 1224:	case outpost:
        -: 1225:		//set outpost flag
    #####: 1226:		state->outpostPlayed++;
        -: 1227:
        -: 1228:		//discard card
    #####: 1229:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1230:		return 0;
        -: 1231:
        -: 1232:	case salvager:
        -: 1233:		//+1 buy
    #####: 1234:		state->numBuys++;
        -: 1235:
    #####: 1236:		if (choice1)
        -: 1237:		{
        -: 1238:			//gain coins equal to trashed card
    #####: 1239:			state->coins = state->coins + getCost(handCard(choice1, state));
        -: 1240:			//trash card
    #####: 1241:			discardCard(choice1, currentPlayer, state, 1);
        -: 1242:		}
        -: 1243:
        -: 1244:		//discard card
    #####: 1245:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1246:		return 0;
        -: 1247:
        -: 1248:	case sea_hag:
    #####: 1249:		for (i = 0; i < state->numPlayers; i++){
    #####: 1250:			if (i != currentPlayer){
    #####: 1251:				state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1252:				state->discardCount[i]++;
    #####: 1253:				state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1254:			}
        -: 1255:		}
    #####: 1256:		return 0;
        -: 1257:
        -: 1258:	case treasure_map:
        -: 1259:
    #####: 1260:		return playTreasureMap(state, currentPlayer, handPos);
        -: 1261:	}
    #####: 1262:	return -1;
        -: 1263:}
        -: 1264:
    #####: 1265:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1266:{
        -: 1267:
        -: 1268:	//if card is not trashed, added to Played pile 
    #####: 1269:	if (trashFlag < 1)
        -: 1270:	{
        -: 1271:		//add card to played pile
    #####: 1272:		state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
    #####: 1273:		state->playedCardCount++;
        -: 1274:	}
        -: 1275:
        -: 1276:	//set played card to -1
    #####: 1277:	state->hand[currentPlayer][handPos] = -1;
        -: 1278:
        -: 1279:	//remove card from player's hand
    #####: 1280:	if (handPos == (state->handCount[currentPlayer] - 1)) 	//last card in hand array is played
        -: 1281:	{
        -: 1282:		//reduce number of cards in hand
    #####: 1283:		state->handCount[currentPlayer]--;
        -: 1284:	}
    #####: 1285:	else if (state->handCount[currentPlayer] == 1) //only one card in hand
        -: 1286:	{
        -: 1287:		//reduce number of cards in hand
    #####: 1288:		state->handCount[currentPlayer]--;
        -: 1289:	}
        -: 1290:	else
        -: 1291:	{
        -: 1292:		//replace discarded card with last card in hand
    #####: 1293:		state->hand[currentPlayer][handPos] = state->hand[currentPlayer][(state->handCount[currentPlayer] - 1)];
        -: 1294:		//set last card to -1
    #####: 1295:		state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1296:		//reduce number of cards in hand
    #####: 1297:		state->handCount[currentPlayer]--;
        -: 1298:	}
        -: 1299:
    #####: 1300:	return 0;
        -: 1301:}
        -: 1302:
        1: 1303:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1304:{
        -: 1305:	//Note: supplyPos is enum of choosen card
        -: 1306:
        -: 1307:	//check if supply pile is empty (0) or card is not used in game (-1)
        1: 1308:	if (supplyCount(supplyPos, state) < 1)
        -: 1309:	{
    #####: 1310:		return -1;
        -: 1311:	}
        -: 1312:
        -: 1313:	//added card for [whoseTurn] current player:
        -: 1314:	// toFlag = 0 : add to discard
        -: 1315:	// toFlag = 1 : add to deck
        -: 1316:	// toFlag = 2 : add to hand
        -: 1317:
        1: 1318:	if (toFlag == 1)
        -: 1319:	{
    #####: 1320:		state->deck[player][state->deckCount[player]] = supplyPos;
    #####: 1321:		state->deckCount[player]++;
        -: 1322:	}
        1: 1323:	else if (toFlag == 2)
        -: 1324:	{
    #####: 1325:		state->hand[player][state->handCount[player]] = supplyPos;
    #####: 1326:		state->handCount[player]++;
        -: 1327:	}
        -: 1328:	else
        -: 1329:	{
        1: 1330:		state->discard[player][state->discardCount[player]] = supplyPos;
        1: 1331:		state->discardCount[player]++;
        -: 1332:	}
        -: 1333:
        -: 1334:	//decrease number in supply pile
        1: 1335:	state->supplyCount[supplyPos]--;
        -: 1336:
        1: 1337:	return 0;
        -: 1338:}
        -: 1339:
       16: 1340:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1341:{
        -: 1342:	int i;
        -: 1343:
        -: 1344:	//reset coin count
       16: 1345:	state->coins = 0;
        -: 1346:
        -: 1347:	//add coins for each Treasure card in player's hand
       96: 1348:	for (i = 0; i < state->handCount[player]; i++)
        -: 1349:	{
       80: 1350:		if (state->hand[player][i] == copper)
        -: 1351:		{
       56: 1352:			state->coins += 1;
        -: 1353:		}
       24: 1354:		else if (state->hand[player][i] == silver)
        -: 1355:		{
    #####: 1356:			state->coins += 2;
        -: 1357:		}
       24: 1358:		else if (state->hand[player][i] == gold)
        -: 1359:		{
    #####: 1360:			state->coins += 3;
        -: 1361:		}
        -: 1362:	}
        -: 1363:
        -: 1364:	//add bonus
       16: 1365:	state->coins += bonus;
        -: 1366:
       16: 1367:	return 0;
        -: 1368:}
        -: 1369:
        -: 1370:
        -: 1371://end of dominion.c
File 'dominion.c'
Lines executed:60.32% of 557
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
     4840:    8:int compare(const void* a, const void* b) {
     4840:    9:	if (*(int*)a > *(int*)b)
     1820:   10:		return 1;
     3020:   11:	if (*(int*)a < *(int*)b)
     1453:   12:		return -1;
     1567:   13:	return 0;
        -:   14:}
        -:   15:
        2:   16:struct gameState* newGame() {
        2:   17:	struct gameState* g = malloc(sizeof(struct gameState));
        2:   18:	return g;
        -:   19:}
        -:   20:
        7:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:	int k8, int k9, int k10) {
        7:   23:	int* k = malloc(10 * sizeof(int));
        7:   24:	k[0] = k1;
        7:   25:	k[1] = k2;
        7:   26:	k[2] = k3;
        7:   27:	k[3] = k4;
        7:   28:	k[4] = k5;
        7:   29:	k[5] = k6;
        7:   30:	k[6] = k7;
        7:   31:	k[7] = k8;
        7:   32:	k[8] = k9;
        7:   33:	k[9] = k10;
        7:   34:	return k;
        -:   35:}
        -:   36:
        7:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		struct gameState *state) {
        -:   39:
        -:   40:	int i;
        -:   41:	int j;
        -:   42:	int it;
        -:   43:	//set up random number generator
        7:   44:	SelectStream(1);
        7:   45:	PutSeed((long)randomSeed);
        -:   46:
        -:   47:	//check number of players
        7:   48:	if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:	{
    #####:   50:		return -1;
        -:   51:	}
        -:   52:
        -:   53:	//set number of players
        7:   54:	state->numPlayers = numPlayers;
        -:   55:
        -:   56:	//check selected kingdom cards are different
       25:   57:	for (i = 0; i < 10; i++)
        -:   58:	{
      238:   59:		for (j = 0; j < 10; j++)
        -:   60:		{
      220:   61:			if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:			{
        6:   63:				return -1;
        -:   64:			}
        -:   65:		}
        -:   66:	}
        -:   67:
        -:   68:
        -:   69:	//initialize supply
        -:   70:	///////////////////////////////
        -:   71:
        -:   72:	//set number of Curse cards
        1:   73:	if (numPlayers == 2)
        -:   74:	{
    #####:   75:		state->supplyCount[curse] = 10;
        -:   76:	}
        1:   77:	else if (numPlayers == 3)
        -:   78:	{
    #####:   79:		state->supplyCount[curse] = 20;
        -:   80:	}
        -:   81:	else
        -:   82:	{
        1:   83:		state->supplyCount[curse] = 30;
        -:   84:	}
        -:   85:
        -:   86:	//set number of Victory cards
        1:   87:	if (numPlayers == 2)
        -:   88:	{
    #####:   89:		state->supplyCount[estate] = 8;
    #####:   90:		state->supplyCount[duchy] = 8;
    #####:   91:		state->supplyCount[province] = 8;
        -:   92:	}
        -:   93:	else
        -:   94:	{
        1:   95:		state->supplyCount[estate] = 12;
        1:   96:		state->supplyCount[duchy] = 12;
        1:   97:		state->supplyCount[province] = 12;
        -:   98:	}
        -:   99:
        -:  100:	//set number of Treasure cards
        1:  101:	state->supplyCount[copper] = 60 - (7 * numPlayers);
        1:  102:	state->supplyCount[silver] = 40;
        1:  103:	state->supplyCount[gold] = 30;
        -:  104:
        -:  105:	//set number of Kingdom cards
       21:  106:	for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:	{
      165:  108:		for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:		{
      155:  110:			if (kingdomCards[j] == i)
        -:  111:			{
        -:  112:				//check if card is a 'Victory' Kingdom card
       10:  113:				if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:				{
        4:  115:					if (numPlayers == 2){
    #####:  116:						state->supplyCount[i] = 8;
        -:  117:					}
        2:  118:					else{ state->supplyCount[i] = 12; }
        -:  119:				}
        -:  120:				else
        -:  121:				{
        8:  122:					state->supplyCount[i] = 10;
        -:  123:				}
       10:  124:				break;
        -:  125:			}
        -:  126:			else    //card is not in the set choosen for the game
        -:  127:			{
      145:  128:				state->supplyCount[i] = -1;
        -:  129:			}
        -:  130:		}
        -:  131:
        -:  132:	}
        -:  133:
        -:  134:	////////////////////////
        -:  135:	//supply intilization complete
        -:  136:
        -:  137:	//set player decks
        5:  138:	for (i = 0; i < numPlayers; i++)
        -:  139:	{
        4:  140:		state->deckCount[i] = 0;
       16:  141:		for (j = 0; j < 3; j++)
        -:  142:		{
       12:  143:			state->deck[i][j] = estate;
       12:  144:			state->deckCount[i]++;
        -:  145:		}
       32:  146:		for (j = 3; j < 10; j++)
        -:  147:		{
       28:  148:			state->deck[i][j] = copper;
       28:  149:			state->deckCount[i]++;
        -:  150:		}
        -:  151:	}
        -:  152:
        -:  153:	//shuffle player decks
        5:  154:	for (i = 0; i < numPlayers; i++)
        -:  155:	{
        4:  156:		if (shuffle(i, state) < 0)
        -:  157:		{
    #####:  158:			return -1;
        -:  159:		}
        -:  160:	}
        -:  161:
        -:  162:	//draw player hands
        5:  163:	for (i = 0; i < numPlayers; i++)
        -:  164:	{
        -:  165:		//initialize hand size to zero
        4:  166:		state->handCount[i] = 0;
        4:  167:		state->discardCount[i] = 0;
        -:  168:		//draw 5 cards
        -:  169:		// for (j = 0; j < 5; j++)
        -:  170:		//	{
        -:  171:		//	  drawCard(i, state);
        -:  172:		//	}
        -:  173:	}
        -:  174:
        -:  175:	//set embargo tokens to 0 for all supply piles
       28:  176:	for (i = 0; i <= treasure_map; i++)
        -:  177:	{
       27:  178:		state->embargoTokens[i] = 0;
        -:  179:	}
        -:  180:
        -:  181:	//initialize first player's turn
        1:  182:	state->outpostPlayed = 0;
        1:  183:	state->phase = 0;
        1:  184:	state->numActions = 1;
        1:  185:	state->numBuys = 1;
        1:  186:	state->playedCardCount = 0;
        1:  187:	state->whoseTurn = 0;
        1:  188:	state->handCount[state->whoseTurn] = 0;
        -:  189:	//int it; move to top
        -:  190:
        -:  191:	//Moved draw cards to here, only drawing at the start of a turn
        6:  192:	for (it = 0; it < 5; it++){
        5:  193:		drawCard(state->whoseTurn, state);
        -:  194:	}
        -:  195:
        1:  196:	updateCoins(state->whoseTurn, state, 0);
        -:  197:
        1:  198:	return 0;
        -:  199:}
        -:  200:
      197:  201:int shuffle(int player, struct gameState *state) {
        -:  202:
        -:  203:
        -:  204:	int newDeck[MAX_DECK];
      197:  205:	int newDeckPos = 0;
        -:  206:	int card;
        -:  207:	int i;
        -:  208:
      197:  209:	if (state->deckCount[player] < 1)
    #####:  210:		return -1;
      197:  211:	qsort((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
        -:  212:	/* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
     2773:  214:	while (state->deckCount[player] > 0) {
     2379:  215:		card = floor(Random() * state->deckCount[player]);
     2379:  216:		newDeck[newDeckPos] = state->deck[player][card];
     2379:  217:		newDeckPos++;
    10714:  218:		for (i = card; i < state->deckCount[player] - 1; i++) {
     8335:  219:			state->deck[player][i] = state->deck[player][i + 1];
        -:  220:		}
     2379:  221:		state->deckCount[player]--;
        -:  222:	}
     2576:  223:	for (i = 0; i < newDeckPos; i++) {
     2379:  224:		state->deck[player][i] = newDeck[i];
     2379:  225:		state->deckCount[player]++;
        -:  226:	}
        -:  227:
      197:  228:	return 0;
        -:  229:}
        -:  230:
      453:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state)
        -:  232:{
        -:  233:	int card;
      453:  234:	int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:	//check if it is the right phase
      453:  237:	if (state->phase != 0)
        -:  238:	{
       92:  239:		return -1;
        -:  240:	}
        -:  241:
        -:  242:	//check if player has enough actions
      361:  243:	if (state->numActions < 1)
        -:  244:	{
       31:  245:		return -1;
        -:  246:	}
        -:  247:
        -:  248:	//get card played
      330:  249:	card = handCard(handPos, state);
        -:  250:
        -:  251:	//check if selected card is an action
      330:  252:	if (card < adventurer || card > treasure_map)
        -:  253:	{
      270:  254:		return -1;
        -:  255:	}
        -:  256:
        -:  257:	//play card
       60:  258:	if (cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0)
        -:  259:	{
       14:  260:		return -1;
        -:  261:	}
        -:  262:
        -:  263:	//reduce number of actions
       46:  264:	state->numActions--;
        -:  265:
        -:  266:	//update coins (Treasure cards may be added with card draws)
       46:  267:	updateCoins(state->whoseTurn, state, coin_bonus);
        -:  268:
       46:  269:	return 0;
        -:  270:}
        -:  271:
      479:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:	int who;
        -:  274:	if (DEBUG){
        -:  275:		printf("Entering buyCard...\n");
        -:  276:	}
        -:  277:
        -:  278:	// I don't know what to do about the phase thing.
        -:  279:
      479:  280:	who = state->whoseTurn;
        -:  281:
      479:  282:	if (state->numBuys < 1){
        -:  283:		if (DEBUG)
        -:  284:			printf("You do not have any buys left\n");
       89:  285:		return -1;
        -:  286:	}
      390:  287:	else if (supplyCount(supplyPos, state) < 1){
        -:  288:		if (DEBUG)
        -:  289:			printf("There are not any of that type of card left\n");
      160:  290:		return -1;
        -:  291:	}
      230:  292:	else if (state->coins < getCost(supplyPos)){
        -:  293:		if (DEBUG)
        -:  294:			printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
      125:  295:		return -1;
        -:  296:	}
        -:  297:	else {
      105:  298:		state->phase = 1;
        -:  299:		//state->supplyCount[supplyPos]--;
      105:  300:		gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  301:
      105:  302:		state->coins = (state->coins) - (getCost(supplyPos));
      105:  303:		state->numBuys--;
        -:  304:		if (DEBUG)
        -:  305:			printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  306:	}
        -:  307:
        -:  308:	//state->discard[who][state->discardCount[who]] = supplyPos;
        -:  309:	//state->discardCount[who]++;
        -:  310:
      105:  311:	return 0;
        -:  312:}
        -:  313:
    #####:  314:int numHandCards(struct gameState *state) {
    #####:  315:	return state->handCount[whoseTurn(state)];
        -:  316:}
        -:  317:
      330:  318:int handCard(int handPos, struct gameState *state) {
      330:  319:	int currentPlayer = whoseTurn(state);
      330:  320:	return state->hand[currentPlayer][handPos];
        -:  321:}
        -:  322:
      526:  323:int supplyCount(int card, struct gameState *state) {
      526:  324:	return state->supplyCount[card];
        -:  325:}
        -:  326:
    #####:  327:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  328:	int i;
    #####:  329:	int count = 0;
        -:  330:
    #####:  331:	for (i = 0; i < state->deckCount[player]; i++)
        -:  332:	{
    #####:  333:		if (state->deck[player][i] == card) count++;
        -:  334:	}
        -:  335:
    #####:  336:	for (i = 0; i < state->handCount[player]; i++)
        -:  337:	{
    #####:  338:		if (state->hand[player][i] == card) count++;
        -:  339:	}
        -:  340:
    #####:  341:	for (i = 0; i < state->discardCount[player]; i++)
        -:  342:	{
    #####:  343:		if (state->discard[player][i] == card) count++;
        -:  344:	}
        -:  345:
    #####:  346:	return count;
        -:  347:}
        -:  348:
      846:  349:int whoseTurn(struct gameState *state) {
      846:  350:	return state->whoseTurn;
        -:  351:}
        -:  352:
      456:  353:int endTurn(struct gameState *state) {
        -:  354:	int k;
        -:  355:	int i;
      456:  356:	int currentPlayer = whoseTurn(state);
        -:  357:
        -:  358:	//Discard hand
     2700:  359:	for (i = 0; i < state->handCount[currentPlayer]; i++){
     2244:  360:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
     2244:  361:		state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  362:	}
      456:  363:	state->handCount[currentPlayer] = 0;//Reset hand count
        -:  364:
        -:  365:	//Code for determining the player
      456:  366:	if (currentPlayer < (state->numPlayers - 1)){
      342:  367:		state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  368:	}
        -:  369:	else{
      114:  370:		state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  371:	}
        -:  372:
      456:  373:	state->outpostPlayed = 0;
      456:  374:	state->phase = 0;
      456:  375:	state->numActions = 1;
      456:  376:	state->coins = 0;
      456:  377:	state->numBuys = 1;
      456:  378:	state->playedCardCount = 0;
      456:  379:	state->handCount[state->whoseTurn] = 0;
        -:  380:
        -:  381:	//int k; move to top
        -:  382:	//Next player draws hand
     2736:  383:	for (k = 0; k < 5; k++){
     2280:  384:		drawCard(state->whoseTurn, state);//Draw a card
        -:  385:	}
        -:  386:
        -:  387:	//Update money
      456:  388:	updateCoins(state->whoseTurn, state, 0);
        -:  389:
      456:  390:	return 0;
        -:  391:}
        -:  392:
     1389:  393:int isGameOver(struct gameState *state) {
        -:  394:	int i;
        -:  395:	int j;
        -:  396:
        -:  397:	//if stack of Province cards is empty, the game ends
     1389:  398:	if (state->supplyCount[province] == 0)
        -:  399:	{
    #####:  400:		return 1;
        -:  401:	}
        -:  402:
        -:  403:	//if three supply pile are at 0, the game ends
     1389:  404:	j = 0;
    36114:  405:	for (i = 0; i < 25; i++)
        -:  406:	{
    34725:  407:		if (state->supplyCount[i] == 0)
        -:  408:		{
     1028:  409:			j++;
        -:  410:		}
        -:  411:	}
     1389:  412:	if (j >= 3)
        -:  413:	{
        1:  414:		return 1;
        -:  415:	}
        -:  416:
     1388:  417:	return 0;
        -:  418:}
        -:  419:
    #####:  420:int scoreFor(int player, struct gameState *state) {
        -:  421:
        -:  422:	int i;
    #####:  423:	int score = 0;
        -:  424:	//score from hand
    #####:  425:	for (i = 0; i < state->handCount[player]; i++)
        -:  426:	{
    #####:  427:		if (state->hand[player][i] == curse) { score = score - 1; };
    #####:  428:		if (state->hand[player][i] == estate) { score = score + 1; };
    #####:  429:		if (state->hand[player][i] == duchy) { score = score + 3; };
    #####:  430:		if (state->hand[player][i] == province) { score = score + 6; };
    #####:  431:		if (state->hand[player][i] == great_hall) { score = score + 1; };
    #####:  432:		if (state->hand[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  433:	}
        -:  434:
        -:  435:	//score from discard
    #####:  436:	for (i = 0; i < state->discardCount[player]; i++)
        -:  437:	{
    #####:  438:		if (state->discard[player][i] == curse) { score = score - 1; };
    #####:  439:		if (state->discard[player][i] == estate) { score = score + 1; };
    #####:  440:		if (state->discard[player][i] == duchy) { score = score + 3; };
    #####:  441:		if (state->discard[player][i] == province) { score = score + 6; };
    #####:  442:		if (state->discard[player][i] == great_hall) { score = score + 1; };
    #####:  443:		if (state->discard[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  444:	}
        -:  445:
        -:  446:	//score from deck
    #####:  447:	for (i = 0; i < state->discardCount[player]; i++)
        -:  448:	{
    #####:  449:		if (state->deck[player][i] == curse) { score = score - 1; };
    #####:  450:		if (state->deck[player][i] == estate) { score = score + 1; };
    #####:  451:		if (state->deck[player][i] == duchy) { score = score + 3; };
    #####:  452:		if (state->deck[player][i] == province) { score = score + 6; };
    #####:  453:		if (state->deck[player][i] == great_hall) { score = score + 1; };
    #####:  454:		if (state->deck[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  455:	}
        -:  456:
    #####:  457:	return score;
        -:  458:}
        -:  459:
    #####:  460:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  461:	int i;
        -:  462:	int j;
        -:  463:	int highScore;
        -:  464:	int currentPlayer;
        -:  465:
        -:  466:	//get score for each player
    #####:  467:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  468:	{
        -:  469:		//set unused player scores to -9999
    #####:  470:		if (i >= state->numPlayers)
        -:  471:		{
    #####:  472:			players[i] = -9999;
        -:  473:		}
        -:  474:		else
        -:  475:		{
    #####:  476:			players[i] = scoreFor(i, state);
        -:  477:		}
        -:  478:	}
        -:  479:
        -:  480:	//find highest score
    #####:  481:	j = 0;
    #####:  482:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  483:	{
    #####:  484:		if (players[i] > players[j])
        -:  485:		{
    #####:  486:			j = i;
        -:  487:		}
        -:  488:	}
    #####:  489:	highScore = players[j];
        -:  490:
        -:  491:	//add 1 to players who had less turns
    #####:  492:	currentPlayer = whoseTurn(state);
    #####:  493:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  494:	{
    #####:  495:		if (players[i] == highScore && i > currentPlayer)
        -:  496:		{
    #####:  497:			players[i]++;
        -:  498:		}
        -:  499:	}
        -:  500:
        -:  501:	//find new highest score
    #####:  502:	j = 0;
    #####:  503:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  504:	{
    #####:  505:		if (players[i] > players[j])
        -:  506:		{
    #####:  507:			j = i;
        -:  508:		}
        -:  509:	}
    #####:  510:	highScore = players[j];
        -:  511:
        -:  512:	//set winners in array to 1 and rest to 0
    #####:  513:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  514:	{
    #####:  515:		if (players[i] == highScore)
        -:  516:		{
    #####:  517:			players[i] = 1;
        -:  518:		}
        -:  519:		else
        -:  520:		{
    #####:  521:			players[i] = 0;
        -:  522:		}
        -:  523:	}
        -:  524:
    #####:  525:	return 0;
        -:  526:}
        -:  527:
     2300:  528:int drawCard(int player, struct gameState *state)
        -:  529:{
        -:  530:	int count;
        -:  531:	int deckCounter;
     2300:  532:	if (state->deckCount[player] <= 0){//Deck is empty
        -:  533:
        -:  534:		//Step 1 Shuffle the discard pile back into a deck
        -:  535:		int i;
        -:  536:		//Move discard to deck
     2532:  537:		for (i = 0; i < state->discardCount[player]; i++){
     2339:  538:			state->deck[player][i] = state->discard[player][i];
     2339:  539:			state->discard[player][i] = -1;
        -:  540:		}
        -:  541:
      193:  542:		state->deckCount[player] = state->discardCount[player];
      193:  543:		state->discardCount[player] = 0;//Reset discard
        -:  544:
        -:  545:		//Shufffle the deck
      193:  546:		shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  547:
        -:  548:		if (DEBUG){//Debug statements
        -:  549:			printf("Deck count now: %d\n", state->deckCount[player]);
        -:  550:		}
        -:  551:
      193:  552:		state->discardCount[player] = 0;
        -:  553:
        -:  554:		//Step 2 Draw Card
      193:  555:		count = state->handCount[player];//Get current player's hand count
        -:  556:
        -:  557:		if (DEBUG){//Debug statements
        -:  558:			printf("Current hand count: %d\n", count);
        -:  559:		}
        -:  560:
      193:  561:		deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  562:
      193:  563:		if (deckCounter == 0)
    #####:  564:			return -1;
        -:  565:
      193:  566:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
      193:  567:		state->deckCount[player]--;
      193:  568:		state->handCount[player]++;//Increment hand count
        -:  569:	}
        -:  570:
        -:  571:	else{
     2107:  572:		int count = state->handCount[player];//Get current hand count for player
        -:  573:		int deckCounter;
        -:  574:		if (DEBUG){//Debug statements
        -:  575:			printf("Current hand count: %d\n", count);
        -:  576:		}
        -:  577:
     2107:  578:		deckCounter = state->deckCount[player];//Create holder for the deck count
     2107:  579:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
     2107:  580:		state->deckCount[player]--;
     2107:  581:		state->handCount[player]++;//Increment hand count
        -:  582:	}
        -:  583:
     2300:  584:	return 0;
        -:  585:}
        -:  586:
      335:  587:int getCost(int cardNumber)
        -:  588:{
      335:  589:	switch (cardNumber)
        -:  590:	{
        -:  591:	case curse:
       24:  592:		return 0;
        -:  593:	case estate:
       15:  594:		return 2;
        -:  595:	case duchy:
       13:  596:		return 5;
        -:  597:	case province:
       21:  598:		return 8;
        -:  599:	case copper:
       10:  600:		return 0;
        -:  601:	case silver:
       22:  602:		return 3;
        -:  603:	case gold:
       13:  604:		return 6;
        -:  605:	case adventurer:
       11:  606:		return 6;
        -:  607:	case council_room:
    #####:  608:		return 5;
        -:  609:	case feast:
    #####:  610:		return 4;
        -:  611:	case gardens:
       29:  612:		return 4;
        -:  613:	case mine:
       30:  614:		return 5;
        -:  615:	case remodel:
    #####:  616:		return 4;
        -:  617:	case smithy:
    #####:  618:		return 4;
        -:  619:	case village:
    #####:  620:		return 3;
        -:  621:	case baron:
       16:  622:		return 4;
        -:  623:	case great_hall:
       16:  624:		return 3;
        -:  625:	case minion:
       17:  626:		return 5;
        -:  627:	case steward:
       24:  628:		return 3;
        -:  629:	case tribute:
       19:  630:		return 5;
        -:  631:	case ambassador:
    #####:  632:		return 3;
        -:  633:	case cutpurse:
    #####:  634:		return 4;
        -:  635:	case embargo:
    #####:  636:		return 2;
        -:  637:	case outpost:
    #####:  638:		return 5;
        -:  639:	case salvager:
    #####:  640:		return 4;
        -:  641:	case sea_hag:
       23:  642:		return 4;
        -:  643:	case treasure_map:
       32:  644:		return 4;
        -:  645:	}
        -:  646:
    #####:  647:	return -1;
        -:  648:}
        -:  649:
        2:  650:void playAdventurer(struct gameState *state, int currentPlayer)
        -:  651:// Reveal cards from deck until 2 Treasure cards are found.  Put those Treasure cards in the hand and discard the rest.
        -:  652:{
        2:  653:	int drawntreasure = 0;
        -:  654:	int temphand[MAX_HAND];
        -:  655:	int cardDrawn;
        2:  656:	int z = 0; // this is the counter for the temp hand
        -:  657:
       10:  658:	while (drawntreasure < 2){
        6:  659:		if (state->deckCount[currentPlayer] < 1){//if the deck is empty we need to shuffle discard and add to deck
    #####:  660:			shuffle(currentPlayer, state);
        -:  661:		}
        6:  662:		drawCard(currentPlayer, state);
        6:  663:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer] - 1];//top card of hand is most recently drawn card.
        6:  664:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
        4:  665:			drawntreasure++;
        -:  666:		else{
        2:  667:			temphand[z] = cardDrawn;
        2:  668:			state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
        2:  669:			z++;
        -:  670:		}
        -:  671:	}
        6:  672:	while (z - 1 >= 0){
        2:  673:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; // discard all cards in play that have been drawn
        2:  674:		z = z - 1;
        -:  675:	}
        2:  676:}
        -:  677:
    #####:  678:int playRemodel(struct gameState *state, int currentPlayer, int choice1, int choice2, int handPos)
        -:  679://Trash a card in the hand, and gain a card costing up to $2 more than the trashed card
        -:  680:{
        -:  681:	int i;
    #####:  682:	int j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  683:
    #####:  684:	if ((getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2))
        -:  685:	{
    #####:  686:		return -1;
        -:  687:	}
        -:  688:
    #####:  689:	gainCard(choice2, state, 0, currentPlayer);
        -:  690:
        -:  691:	//discard card from hand
    #####:  692:	discardCard(handPos, currentPlayer, state, 0);
        -:  693:
        -:  694:	//discard trashed card
    #####:  695:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  696:	{
    #####:  697:		if (state->hand[currentPlayer][i] == j)
        -:  698:		{
    #####:  699:			discardCard(i, currentPlayer, state, 0);
    #####:  700:			break;
        -:  701:		}
        -:  702:	}
        -:  703:
    #####:  704:	return 0;
        -:  705:}
        -:  706:
    #####:  707:void playSmithy(struct gameState *state, int currentPlayer, int handPos)
        -:  708:// Draw 3 cards
        -:  709:{
        -:  710:	int i;
    #####:  711:	for (i = 0; i < 3; i++)
        -:  712:	{
    #####:  713:		drawCard(currentPlayer, state);
        -:  714:	}
        -:  715:
        -:  716:	//discard card from hand
    #####:  717:	discardCard(handPos, currentPlayer, state, 0);
    #####:  718:}
        -:  719:
        5:  720:void playBaron(struct gameState *state, int currentPlayer, int choice1, int handPos)
        -:  721://Add a buy.  OPTION:  Discard an Estate card and gain $4.  Otherwise, gain an Estate card.
        -:  722:{
        5:  723:	state->numBuys++;//Increase buys by 1!
        5:  724:	if (choice1 > 0){//Boolean true or going to discard an estate
        5:  725:		int p = 0;//Iterator for hand!
        5:  726:		int card_not_discarded = 1;//Flag for discard set!
       26:  727:		while (card_not_discarded){
       16:  728:			if (state->hand[currentPlayer][p] == estate){ //Found an estate card!
        4:  729:				state->coins += 4;//Add 4 coins to the amount of coins
        4:  730:				state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
        4:  731:				state->discardCount[currentPlayer]++;
       19:  732:				for (; p < state->handCount[currentPlayer]; p++){
       15:  733:					state->hand[currentPlayer][p] = state->hand[currentPlayer][p + 1];
        -:  734:				}
        4:  735:				state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
        4:  736:				state->handCount[currentPlayer]--;
        4:  737:				card_not_discarded = 0;//Exit the loop
        -:  738:			}
       12:  739:			else if (p > state->handCount[currentPlayer]){
        -:  740:				if (DEBUG) {
        -:  741:					printf("No estate cards in your hand, invalid choice\n");
        -:  742:					printf("Must gain an estate if there are any\n");
        -:  743:				}
        1:  744:				if (supplyCount(estate, state) > 0){
        1:  745:					gainCard(estate, state, 1, currentPlayer);
        1:  746:					state->supplyCount[estate]--;//Decrement estates
        1:  747:					if (supplyCount(estate, state) == 0){
    #####:  748:						isGameOver(state);
        -:  749:					}
        -:  750:				}
        1:  751:				card_not_discarded = 0;//Exit the loop
        -:  752:			}
        -:  753:
        -:  754:			else{
       11:  755:				p++;//Next card
        -:  756:			}
        -:  757:		}
        -:  758:	}
        -:  759:
        -:  760:	else{
    #####:  761:		if (supplyCount(estate, state) > 0){
    #####:  762:			gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  763:			state->supplyCount[estate]--;//Decrement Estates
    #####:  764:			if (supplyCount(estate, state) == 0){
    #####:  765:				isGameOver(state);
        -:  766:			}
        -:  767:		}
        -:  768:	}
        5:  769:}
        -:  770:
        7:  771:int playTreasureMap(struct gameState *state, int currentPlayer, int handPos)
        -:  772://Trashing two treasure map cards from the hand = four gold on top of the deck.
        -:  773:{
        -:  774:	int i;
        -:  775:	int index;
        -:  776:
        -:  777:	//search hand for another treasure_map
       42:  778:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  779:	{
       35:  780:		if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -:  781:		{
    #####:  782:			index = i;
    #####:  783:			break;
        -:  784:		}
        -:  785:	}
        7:  786:	if (index > -1)
        -:  787:	{
        -:  788:		//trash both treasure cards
        7:  789:		discardCard(handPos, currentPlayer, state, 1);
        7:  790:		discardCard(index, currentPlayer, state, 1);
        -:  791:
        -:  792:		//gain 4 Gold cards
       35:  793:		for (i = 0; i < 4; i++)
        -:  794:		{
       28:  795:			gainCard(gold, state, 1, currentPlayer);
        -:  796:		}
        -:  797:
        -:  798:		//return success
        7:  799:		return 1;
        -:  800:	}
        -:  801:
        -:  802:	//no second treasure_map found in hand
    #####:  803:	return -1;
        -:  804:}
        -:  805:
       60:  806:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  807:{
        -:  808:	int i;
        -:  809:	int j;
        -:  810:	int k;
        -:  811:	//int x;  //Unused after while loop removed from feast.
       60:  812:	int currentPlayer = whoseTurn(state);
       60:  813:	int nextPlayer = currentPlayer + 1;
        -:  814:	int temphand[MAX_HAND];
        -:  815:
       60:  816:	int tributeRevealedCards[2] = { -1, -1 };
        -:  817:
       60:  818:	if (nextPlayer > (state->numPlayers - 1)){
       17:  819:		nextPlayer = 0;
        -:  820:	}
        -:  821:
        -:  822:	//uses switch to select card and perform actions
       60:  823:	switch (card)
        -:  824:	{
        -:  825:	case adventurer:
        -:  826:
        2:  827:		playAdventurer(state, currentPlayer);
        2:  828:		return 0;
        -:  829:
        -:  830:	case council_room:
        -:  831:		//+4 Cards
    #####:  832:		for (i = 0; i < 4; i++)
        -:  833:		{
    #####:  834:			drawCard(currentPlayer, state);
        -:  835:		}
        -:  836:
        -:  837:		//+1 Buy
    #####:  838:		state->numBuys++;
        -:  839:
        -:  840:		//Each other player draws a card
    #####:  841:		for (i = 0; i < state->numPlayers; i++)
        -:  842:		{
    #####:  843:			if (i != currentPlayer)
        -:  844:			{
    #####:  845:				drawCard(i, state);
        -:  846:			}
        -:  847:		}
        -:  848:
        -:  849:		//put played card in played card pile
    #####:  850:		discardCard(handPos, currentPlayer, state, 0);
        -:  851:
    #####:  852:		return 0;
        -:  853:
        -:  854:	case feast:
        -:  855:		//gain card with cost up to 5
        -:  856:		//Backup hand
    #####:  857:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  858:			temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  859:			state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  860:		}
        -:  861:		//Backup hand
        -:  862:
        -:  863:		//Update Coins for Buy
    #####:  864:		updateCoins(currentPlayer, state, 5);
        -:  865://		x = 1;//Condition to loop on
        -:  866://		while (x == 1) {//Buy one card
    #####:  867:			if (supplyCount(choice1, state) <= 0){
        -:  868:				if (DEBUG)
        -:  869:					printf("None of that card left, sorry!\n");
        -:  870:
        -:  871:				if (DEBUG){
        -:  872:					printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  873:				}
        -:  874:			}
    #####:  875:			else if (state->coins < getCost(choice1)){
    #####:  876:				printf("That card is too expensive!\n");
        -:  877:
        -:  878:				if (DEBUG){
        -:  879:					printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  880:				}
        -:  881:			}
        -:  882:			else{
        -:  883:
        -:  884:				if (DEBUG){
        -:  885:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  886:				}
        -:  887:
    #####:  888:				gainCard(choice1, state, 0, currentPlayer);//Gain the card
        -:  889://				x = 0;//No more buying cards
        -:  890:
        -:  891:				if (DEBUG){
        -:  892:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  893:				}
        -:  894:
        -:  895:			}
        -:  896://		}
        -:  897:
        -:  898:		//Reset Hand
    #####:  899:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  900:			state->hand[currentPlayer][i] = temphand[i];
    #####:  901:			temphand[i] = -1;
        -:  902:		}
        -:  903:		//Reset Hand
        -:  904:
    #####:  905:		return 0;
        -:  906:
        -:  907:	case gardens:
       13:  908:		return -1;
        -:  909:
        -:  910:	case mine:
        1:  911:		j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  912:
        1:  913:		if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  914:		{
        1:  915:			return -1;
        -:  916:		}
        -:  917:
    #####:  918:		if (choice2 > treasure_map || choice2 < curse)
        -:  919:		{
    #####:  920:			return -1;
        -:  921:		}
        -:  922:
    #####:  923:		if ((getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2))
        -:  924:		{
    #####:  925:			return -1;
        -:  926:		}
        -:  927:
    #####:  928:		gainCard(choice2, state, 2, currentPlayer);
        -:  929:
        -:  930:		//discard card from hand
    #####:  931:		discardCard(handPos, currentPlayer, state, 0);
        -:  932:
        -:  933:		//discard trashed card
    #####:  934:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  935:		{
    #####:  936:			if (state->hand[currentPlayer][i] == j)
        -:  937:			{
    #####:  938:				discardCard(i, currentPlayer, state, 0);
    #####:  939:				break;
        -:  940:			}
        -:  941:		}
        -:  942:
    #####:  943:		return 0;
        -:  944:
        -:  945:	case remodel:
        -:  946:
    #####:  947:		return playRemodel(state, currentPlayer, choice1, choice2, handPos);
        -:  948:
        -:  949:	case smithy:
        -:  950:
    #####:  951:		playSmithy(state, currentPlayer, handPos);
    #####:  952:		return 0;
        -:  953:
        -:  954:	case village:
        -:  955:		//+1 Card
    #####:  956:		drawCard(currentPlayer, state);
        -:  957:
        -:  958:		//+2 Actions
    #####:  959:		state->numActions = state->numActions + 2;
        -:  960:
        -:  961:		//discard played card from hand
    #####:  962:		discardCard(handPos, currentPlayer, state, 0);
    #####:  963:		return 0;
        -:  964:
        -:  965:	case baron:
        -:  966:
        5:  967:		playBaron(state, currentPlayer, choice1, handPos);
        5:  968:		return 0;
        -:  969:
        -:  970:	case great_hall:
        -:  971:		//+1 Card
        5:  972:		drawCard(currentPlayer, state);
        -:  973:
        -:  974:		//+1 Actions
        5:  975:		state->numActions++;
        -:  976:
        -:  977:		//discard card from hand
        5:  978:		discardCard(handPos, currentPlayer, state, 0);
        5:  979:		return 0;
        -:  980:
        -:  981:	case minion:
        -:  982:		//+1 action
        2:  983:		state->numActions++;
        -:  984:
        -:  985:		//discard card from hand
        2:  986:		discardCard(handPos, currentPlayer, state, 0);
        -:  987:
        2:  988:		if (choice1)		//+2 coins
        -:  989:		{
        2:  990:			state->coins = state->coins + 2;
        -:  991:		}
        -:  992:
    #####:  993:		else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  994:		{
        -:  995:			//discard hand
    #####:  996:			while (numHandCards(state) > 0)
        -:  997:			{
    #####:  998:				discardCard(handPos, currentPlayer, state, 0);
        -:  999:			}
        -: 1000:
        -: 1001:			//draw 4
    #####: 1002:			for (i = 0; i < 4; i++)
        -: 1003:			{
    #####: 1004:				drawCard(currentPlayer, state);
        -: 1005:			}
        -: 1006:
        -: 1007:			//other players discard hand and redraw if hand size > 4
    #####: 1008:			for (i = 0; i < state->numPlayers; i++)
        -: 1009:			{
    #####: 1010:				if (i != currentPlayer)
        -: 1011:				{
    #####: 1012:					if (state->handCount[i] > 4)
        -: 1013:					{
        -: 1014:						//discard hand
    #####: 1015:						while (state->handCount[i] > 0)
        -: 1016:						{
    #####: 1017:							discardCard(handPos, i, state, 0);
        -: 1018:						}
        -: 1019:
        -: 1020:						//draw 4
    #####: 1021:						for (j = 0; j < 4; j++)
        -: 1022:						{
    #####: 1023:							drawCard(i, state);
        -: 1024:						}
        -: 1025:					}
        -: 1026:				}
        -: 1027:			}
        -: 1028:
        -: 1029:		}
        2: 1030:		return 0;
        -: 1031:
        -: 1032:	case steward:
       10: 1033:		if (choice1 == 1)
        -: 1034:		{
        -: 1035:			//+2 cards
        1: 1036:			drawCard(currentPlayer, state);
        1: 1037:			drawCard(currentPlayer, state);
        -: 1038:		}
        9: 1039:		else if (choice1 == 2)
        -: 1040:		{
        -: 1041:			//+2 coins
        2: 1042:			state->coins = state->coins + 2;
        -: 1043:		}
        -: 1044:		else
        -: 1045:		{
        -: 1046:			//trash 2 cards in hand
        7: 1047:			discardCard(choice2, currentPlayer, state, 1);
        7: 1048:			discardCard(choice3, currentPlayer, state, 1);
        -: 1049:		}
        -: 1050:
        -: 1051:		//discard card from hand
       10: 1052:		discardCard(handPos, currentPlayer, state, 0);
       10: 1053:		return 0;
        -: 1054:
        -: 1055:	case tribute:
        6: 1056:		if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####: 1057:			if (state->deckCount[nextPlayer] > 0){
    #####: 1058:				tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1059:				state->deckCount[nextPlayer]--;
        -: 1060:			}
    #####: 1061:			else if (state->discardCount[nextPlayer] > 0){
    #####: 1062:				tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer] - 1];
    #####: 1063:				state->discardCount[nextPlayer]--;
        -: 1064:			}
        -: 1065:			else{
        -: 1066:				//No Card to Reveal
        -: 1067:				if (DEBUG){
        -: 1068:					printf("No cards to reveal\n");
        -: 1069:				}
        -: 1070:			}
        -: 1071:		}
        -: 1072:
        -: 1073:		else{
        6: 1074:			if (state->deckCount[nextPlayer] == 0){
    #####: 1075:				for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####: 1076:					state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1077:					state->deckCount[nextPlayer]++;
    #####: 1078:					state->discard[nextPlayer][i] = -1;
    #####: 1079:					state->discardCount[nextPlayer]--;
        -: 1080:				}
        -: 1081:
    #####: 1082:				shuffle(nextPlayer, state);//Shuffle the deck
        -: 1083:			}
        6: 1084:			tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
        6: 1085:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
        6: 1086:			state->deckCount[nextPlayer]--;
        6: 1087:			tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
        6: 1088:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
        6: 1089:			state->deckCount[nextPlayer]--;
        -: 1090:		}
        -: 1091:
        6: 1092:		if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
        2: 1093:			state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
        2: 1094:			state->playedCardCount++;
        2: 1095:			tributeRevealedCards[1] = -1;
        -: 1096:		}
        -: 1097:
       24: 1098:		for (i = 0; i <= 2; i++){
       18: 1099:			if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
       10: 1100:				state->coins += 2;
        -: 1101:			}
        -: 1102:
        8: 1103:			else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
        1: 1104:				drawCard(currentPlayer, state);
        1: 1105:				drawCard(currentPlayer, state);
        -: 1106:			}
        -: 1107:			else{//Action Card
        7: 1108:				state->numActions = state->numActions + 2;
        -: 1109:			}
        -: 1110:		}
        -: 1111:
        6: 1112:		return 0;
        -: 1113:
        -: 1114:	case ambassador:
    #####: 1115:		j = 0;		//used to check if player has enough cards to discard
        -: 1116:
    #####: 1117:		if (choice2 > 2 || choice2 < 0)
        -: 1118:		{
    #####: 1119:			return -1;
        -: 1120:		}
        -: 1121:
    #####: 1122:		if (choice1 == handPos)
        -: 1123:		{
    #####: 1124:			return -1;
        -: 1125:		}
        -: 1126:
    #####: 1127:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1128:		{
    #####: 1129:			if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1130:			{
    #####: 1131:				j++;
        -: 1132:			}
        -: 1133:		}
    #####: 1134:		if (j < choice2)
        -: 1135:		{
    #####: 1136:			return -1;
        -: 1137:		}
        -: 1138:
        -: 1139:		if (DEBUG)
        -: 1140:			printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1141:
        -: 1142:		//increase supply count for choosen card by amount being discarded
    #####: 1143:		state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1144:
        -: 1145:		//each other player gains a copy of revealed card
    #####: 1146:		for (i = 0; i < state->numPlayers; i++)
        -: 1147:		{
    #####: 1148:			if (i != currentPlayer)
        -: 1149:			{
    #####: 1150:				gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1151:			}
        -: 1152:		}
        -: 1153:
        -: 1154:		//discard played card from hand
    #####: 1155:		discardCard(handPos, currentPlayer, state, 0);
        -: 1156:
        -: 1157:		//trash copies of cards returned to supply
    #####: 1158:		for (j = 0; j < choice2; j++)
        -: 1159:		{
    #####: 1160:			for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1161:			{
    #####: 1162:				if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1163:				{
    #####: 1164:					discardCard(i, currentPlayer, state, 1);
    #####: 1165:					break;
        -: 1166:				}
        -: 1167:			}
        -: 1168:		}
        -: 1169:
    #####: 1170:		return 0;
        -: 1171:
        -: 1172:	case cutpurse:
        -: 1173:
    #####: 1174:		updateCoins(currentPlayer, state, 2);
    #####: 1175:		for (i = 0; i < state->numPlayers; i++)
        -: 1176:		{
    #####: 1177:			if (i != currentPlayer)
        -: 1178:			{
    #####: 1179:				for (j = 0; j < state->handCount[i]; j++)
        -: 1180:				{
    #####: 1181:					if (state->hand[i][j] == copper)
        -: 1182:					{
    #####: 1183:						discardCard(j, i, state, 0);
    #####: 1184:						break;
        -: 1185:					}
    #####: 1186:					if (j == state->handCount[i])
        -: 1187:					{
    #####: 1188:						for (k = 0; k < state->handCount[i]; k++)
        -: 1189:						{
        -: 1190:							if (DEBUG)
        -: 1191:								printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1192:						}
    #####: 1193:						break;
        -: 1194:					}
        -: 1195:				}
        -: 1196:
        -: 1197:			}
        -: 1198:
        -: 1199:		}
        -: 1200:
        -: 1201:		//discard played card from hand
    #####: 1202:		discardCard(handPos, currentPlayer, state, 0);
        -: 1203:
    #####: 1204:		return 0;
        -: 1205:
        -: 1206:
        -: 1207:	case embargo:
        -: 1208:		//+2 Coins
    #####: 1209:		state->coins = state->coins + 2;
        -: 1210:
        -: 1211:		//see if selected pile is in play
    #####: 1212:		if (state->supplyCount[choice1] == -1)
        -: 1213:		{
    #####: 1214:			return -1;
        -: 1215:		}
        -: 1216:
        -: 1217:		//add embargo token to selected supply pile
    #####: 1218:		state->embargoTokens[choice1]++;
        -: 1219:
        -: 1220:		//trash card
    #####: 1221:		discardCard(handPos, currentPlayer, state, 1);
    #####: 1222:		return 0;
        -: 1223:
        -: 1224:	case outpost:
        -: 1225:		//set outpost flag
    #####: 1226:		state->outpostPlayed++;
        -: 1227:
        -: 1228:		//discard card
    #####: 1229:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1230:		return 0;
        -: 1231:
        -: 1232:	case salvager:
        -: 1233:		//+1 buy
    #####: 1234:		state->numBuys++;
        -: 1235:
    #####: 1236:		if (choice1)
        -: 1237:		{
        -: 1238:			//gain coins equal to trashed card
    #####: 1239:			state->coins = state->coins + getCost(handCard(choice1, state));
        -: 1240:			//trash card
    #####: 1241:			discardCard(choice1, currentPlayer, state, 1);
        -: 1242:		}
        -: 1243:
        -: 1244:		//discard card
    #####: 1245:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1246:		return 0;
        -: 1247:
        -: 1248:	case sea_hag:
       45: 1249:		for (i = 0; i < state->numPlayers; i++){
       36: 1250:			if (i != currentPlayer){
       27: 1251:				state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
       27: 1252:				state->discardCount[i]++;
       27: 1253:				state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1254:			}
        -: 1255:		}
        9: 1256:		return 0;
        -: 1257:
        -: 1258:	case treasure_map:
        -: 1259:
        7: 1260:		return playTreasureMap(state, currentPlayer, handPos);
        -: 1261:	}
    #####: 1262:	return -1;
        -: 1263:}
        -: 1264:
       45: 1265:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1266:{
        -: 1267:
        -: 1268:	//if card is not trashed, added to Played pile 
       45: 1269:	if (trashFlag < 1)
        -: 1270:	{
        -: 1271:		//add card to played pile
       17: 1272:		state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
       17: 1273:		state->playedCardCount++;
        -: 1274:	}
        -: 1275:
        -: 1276:	//set played card to -1
       45: 1277:	state->hand[currentPlayer][handPos] = -1;
        -: 1278:
        -: 1279:	//remove card from player's hand
       45: 1280:	if (handPos == (state->handCount[currentPlayer] - 1)) 	//last card in hand array is played
        -: 1281:	{
        -: 1282:		//reduce number of cards in hand
        4: 1283:		state->handCount[currentPlayer]--;
        -: 1284:	}
       41: 1285:	else if (state->handCount[currentPlayer] == 1) //only one card in hand
        -: 1286:	{
        -: 1287:		//reduce number of cards in hand
    #####: 1288:		state->handCount[currentPlayer]--;
        -: 1289:	}
        -: 1290:	else
        -: 1291:	{
        -: 1292:		//replace discarded card with last card in hand
       41: 1293:		state->hand[currentPlayer][handPos] = state->hand[currentPlayer][(state->handCount[currentPlayer] - 1)];
        -: 1294:		//set last card to -1
       41: 1295:		state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1296:		//reduce number of cards in hand
       41: 1297:		state->handCount[currentPlayer]--;
        -: 1298:	}
        -: 1299:
       45: 1300:	return 0;
        -: 1301:}
        -: 1302:
      134: 1303:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1304:{
        -: 1305:	//Note: supplyPos is enum of choosen card
        -: 1306:
        -: 1307:	//check if supply pile is empty (0) or card is not used in game (-1)
      134: 1308:	if (supplyCount(supplyPos, state) < 1)
        -: 1309:	{
        1: 1310:		return -1;
        -: 1311:	}
        -: 1312:
        -: 1313:	//added card for [whoseTurn] current player:
        -: 1314:	// toFlag = 0 : add to discard
        -: 1315:	// toFlag = 1 : add to deck
        -: 1316:	// toFlag = 2 : add to hand
        -: 1317:
      133: 1318:	if (toFlag == 1)
        -: 1319:	{
       28: 1320:		state->deck[player][state->deckCount[player]] = supplyPos;
       28: 1321:		state->deckCount[player]++;
        -: 1322:	}
      105: 1323:	else if (toFlag == 2)
        -: 1324:	{
    #####: 1325:		state->hand[player][state->handCount[player]] = supplyPos;
    #####: 1326:		state->handCount[player]++;
        -: 1327:	}
        -: 1328:	else
        -: 1329:	{
      105: 1330:		state->discard[player][state->discardCount[player]] = supplyPos;
      105: 1331:		state->discardCount[player]++;
        -: 1332:	}
        -: 1333:
        -: 1334:	//decrease number in supply pile
      133: 1335:	state->supplyCount[supplyPos]--;
        -: 1336:
      133: 1337:	return 0;
        -: 1338:}
        -: 1339:
      503: 1340:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1341:{
        -: 1342:	int i;
        -: 1343:
        -: 1344:	//reset coin count
      503: 1345:	state->coins = 0;
        -: 1346:
        -: 1347:	//add coins for each Treasure card in player's hand
     2982: 1348:	for (i = 0; i < state->handCount[player]; i++)
        -: 1349:	{
     2479: 1350:		if (state->hand[player][i] == copper)
        -: 1351:		{
      963: 1352:			state->coins += 1;
        -: 1353:		}
     1516: 1354:		else if (state->hand[player][i] == silver)
        -: 1355:		{
       58: 1356:			state->coins += 2;
        -: 1357:		}
     1458: 1358:		else if (state->hand[player][i] == gold)
        -: 1359:		{
      403: 1360:			state->coins += 3;
        -: 1361:		}
        -: 1362:	}
        -: 1363:
        -: 1364:	//add bonus
      503: 1365:	state->coins += bonus;
        -: 1366:
      503: 1367:	return 0;
        -: 1368:}
        -: 1369:
        -: 1370:
        -: 1371://end of dominion.c
File 'dominion.c'
Lines executed:53.50% of 557
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
     1550:    8:int compare(const void* a, const void* b) {
     1550:    9:	if (*(int*)a > *(int*)b)
      584:   10:		return 1;
      966:   11:	if (*(int*)a < *(int*)b)
      521:   12:		return -1;
      445:   13:	return 0;
        -:   14:}
        -:   15:
        2:   16:struct gameState* newGame() {
        2:   17:	struct gameState* g = malloc(sizeof(struct gameState));
        2:   18:	return g;
        -:   19:}
        -:   20:
        1:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:	int k8, int k9, int k10) {
        1:   23:	int* k = malloc(10 * sizeof(int));
        1:   24:	k[0] = k1;
        1:   25:	k[1] = k2;
        1:   26:	k[2] = k3;
        1:   27:	k[3] = k4;
        1:   28:	k[4] = k5;
        1:   29:	k[5] = k6;
        1:   30:	k[6] = k7;
        1:   31:	k[7] = k8;
        1:   32:	k[8] = k9;
        1:   33:	k[9] = k10;
        1:   34:	return k;
        -:   35:}
        -:   36:
        1:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		struct gameState *state) {
        -:   39:
        -:   40:	int i;
        -:   41:	int j;
        -:   42:	int it;
        -:   43:	//set up random number generator
        1:   44:	SelectStream(1);
        1:   45:	PutSeed((long)randomSeed);
        -:   46:
        -:   47:	//check number of players
        1:   48:	if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:	{
    #####:   50:		return -1;
        -:   51:	}
        -:   52:
        -:   53:	//set number of players
        1:   54:	state->numPlayers = numPlayers;
        -:   55:
        -:   56:	//check selected kingdom cards are different
       11:   57:	for (i = 0; i < 10; i++)
        -:   58:	{
      110:   59:		for (j = 0; j < 10; j++)
        -:   60:		{
      100:   61:			if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:			{
    #####:   63:				return -1;
        -:   64:			}
        -:   65:		}
        -:   66:	}
        -:   67:
        -:   68:
        -:   69:	//initialize supply
        -:   70:	///////////////////////////////
        -:   71:
        -:   72:	//set number of Curse cards
        1:   73:	if (numPlayers == 2)
        -:   74:	{
    #####:   75:		state->supplyCount[curse] = 10;
        -:   76:	}
        1:   77:	else if (numPlayers == 3)
        -:   78:	{
    #####:   79:		state->supplyCount[curse] = 20;
        -:   80:	}
        -:   81:	else
        -:   82:	{
        1:   83:		state->supplyCount[curse] = 30;
        -:   84:	}
        -:   85:
        -:   86:	//set number of Victory cards
        1:   87:	if (numPlayers == 2)
        -:   88:	{
    #####:   89:		state->supplyCount[estate] = 8;
    #####:   90:		state->supplyCount[duchy] = 8;
    #####:   91:		state->supplyCount[province] = 8;
        -:   92:	}
        -:   93:	else
        -:   94:	{
        1:   95:		state->supplyCount[estate] = 12;
        1:   96:		state->supplyCount[duchy] = 12;
        1:   97:		state->supplyCount[province] = 12;
        -:   98:	}
        -:   99:
        -:  100:	//set number of Treasure cards
        1:  101:	state->supplyCount[copper] = 60 - (7 * numPlayers);
        1:  102:	state->supplyCount[silver] = 40;
        1:  103:	state->supplyCount[gold] = 30;
        -:  104:
        -:  105:	//set number of Kingdom cards
       21:  106:	for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:	{
      165:  108:		for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:		{
      155:  110:			if (kingdomCards[j] == i)
        -:  111:			{
        -:  112:				//check if card is a 'Victory' Kingdom card
       10:  113:				if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:				{
        4:  115:					if (numPlayers == 2){
    #####:  116:						state->supplyCount[i] = 8;
        -:  117:					}
        2:  118:					else{ state->supplyCount[i] = 12; }
        -:  119:				}
        -:  120:				else
        -:  121:				{
        8:  122:					state->supplyCount[i] = 10;
        -:  123:				}
       10:  124:				break;
        -:  125:			}
        -:  126:			else    //card is not in the set choosen for the game
        -:  127:			{
      145:  128:				state->supplyCount[i] = -1;
        -:  129:			}
        -:  130:		}
        -:  131:
        -:  132:	}
        -:  133:
        -:  134:	////////////////////////
        -:  135:	//supply intilization complete
        -:  136:
        -:  137:	//set player decks
        5:  138:	for (i = 0; i < numPlayers; i++)
        -:  139:	{
        4:  140:		state->deckCount[i] = 0;
       16:  141:		for (j = 0; j < 3; j++)
        -:  142:		{
       12:  143:			state->deck[i][j] = estate;
       12:  144:			state->deckCount[i]++;
        -:  145:		}
       32:  146:		for (j = 3; j < 10; j++)
        -:  147:		{
       28:  148:			state->deck[i][j] = copper;
       28:  149:			state->deckCount[i]++;
        -:  150:		}
        -:  151:	}
        -:  152:
        -:  153:	//shuffle player decks
        5:  154:	for (i = 0; i < numPlayers; i++)
        -:  155:	{
        4:  156:		if (shuffle(i, state) < 0)
        -:  157:		{
    #####:  158:			return -1;
        -:  159:		}
        -:  160:	}
        -:  161:
        -:  162:	//draw player hands
        5:  163:	for (i = 0; i < numPlayers; i++)
        -:  164:	{
        -:  165:		//initialize hand size to zero
        4:  166:		state->handCount[i] = 0;
        4:  167:		state->discardCount[i] = 0;
        -:  168:		//draw 5 cards
        -:  169:		// for (j = 0; j < 5; j++)
        -:  170:		//	{
        -:  171:		//	  drawCard(i, state);
        -:  172:		//	}
        -:  173:	}
        -:  174:
        -:  175:	//set embargo tokens to 0 for all supply piles
       28:  176:	for (i = 0; i <= treasure_map; i++)
        -:  177:	{
       27:  178:		state->embargoTokens[i] = 0;
        -:  179:	}
        -:  180:
        -:  181:	//initialize first player's turn
        1:  182:	state->outpostPlayed = 0;
        1:  183:	state->phase = 0;
        1:  184:	state->numActions = 1;
        1:  185:	state->numBuys = 1;
        1:  186:	state->playedCardCount = 0;
        1:  187:	state->whoseTurn = 0;
        1:  188:	state->handCount[state->whoseTurn] = 0;
        -:  189:	//int it; move to top
        -:  190:
        -:  191:	//Moved draw cards to here, only drawing at the start of a turn
        6:  192:	for (it = 0; it < 5; it++){
        5:  193:		drawCard(state->whoseTurn, state);
        -:  194:	}
        -:  195:
        1:  196:	updateCoins(state->whoseTurn, state, 0);
        -:  197:
        1:  198:	return 0;
        -:  199:}
        -:  200:
       65:  201:int shuffle(int player, struct gameState *state) {
        -:  202:
        -:  203:
        -:  204:	int newDeck[MAX_DECK];
       65:  205:	int newDeckPos = 0;
        -:  206:	int card;
        -:  207:	int i;
        -:  208:
       65:  209:	if (state->deckCount[player] < 1)
        2:  210:		return -1;
       63:  211:	qsort((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
        -:  212:	/* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
      854:  214:	while (state->deckCount[player] > 0) {
      728:  215:		card = floor(Random() * state->deckCount[player]);
      728:  216:		newDeck[newDeckPos] = state->deck[player][card];
      728:  217:		newDeckPos++;
     3017:  218:		for (i = card; i < state->deckCount[player] - 1; i++) {
     2289:  219:			state->deck[player][i] = state->deck[player][i + 1];
        -:  220:		}
      728:  221:		state->deckCount[player]--;
        -:  222:	}
      791:  223:	for (i = 0; i < newDeckPos; i++) {
      728:  224:		state->deck[player][i] = newDeck[i];
      728:  225:		state->deckCount[player]++;
        -:  226:	}
        -:  227:
       63:  228:	return 0;
        -:  229:}
        -:  230:
      518:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state)
        -:  232:{
        -:  233:	int card;
      518:  234:	int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:	//check if it is the right phase
      518:  237:	if (state->phase != 0)
        -:  238:	{
       80:  239:		return -1;
        -:  240:	}
        -:  241:
        -:  242:	//check if player has enough actions
      438:  243:	if (state->numActions < 1)
        -:  244:	{
       45:  245:		return -1;
        -:  246:	}
        -:  247:
        -:  248:	//get card played
      393:  249:	card = handCard(handPos, state);
        -:  250:
        -:  251:	//check if selected card is an action
      393:  252:	if (card < adventurer || card > treasure_map)
        -:  253:	{
      338:  254:		return -1;
        -:  255:	}
        -:  256:
        -:  257:	//play card
       55:  258:	if (cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0)
        -:  259:	{
        8:  260:		return -1;
        -:  261:	}
        -:  262:
        -:  263:	//reduce number of actions
       47:  264:	state->numActions--;
        -:  265:
        -:  266:	//update coins (Treasure cards may be added with card draws)
       47:  267:	updateCoins(state->whoseTurn, state, coin_bonus);
        -:  268:
       47:  269:	return 0;
        -:  270:}
        -:  271:
      461:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:	int who;
        -:  274:	if (DEBUG){
        -:  275:		printf("Entering buyCard...\n");
        -:  276:	}
        -:  277:
        -:  278:	// I don't know what to do about the phase thing.
        -:  279:
      461:  280:	who = state->whoseTurn;
        -:  281:
      461:  282:	if (state->numBuys < 1){
        -:  283:		if (DEBUG)
        -:  284:			printf("You do not have any buys left\n");
       91:  285:		return -1;
        -:  286:	}
      370:  287:	else if (supplyCount(supplyPos, state) < 1){
        -:  288:		if (DEBUG)
        -:  289:			printf("There are not any of that type of card left\n");
      138:  290:		return -1;
        -:  291:	}
      232:  292:	else if (state->coins < getCost(supplyPos)){
        -:  293:		if (DEBUG)
        -:  294:			printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
      139:  295:		return -1;
        -:  296:	}
        -:  297:	else {
       93:  298:		state->phase = 1;
        -:  299:		//state->supplyCount[supplyPos]--;
       93:  300:		gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  301:
       93:  302:		state->coins = (state->coins) - (getCost(supplyPos));
       93:  303:		state->numBuys--;
        -:  304:		if (DEBUG)
        -:  305:			printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  306:	}
        -:  307:
        -:  308:	//state->discard[who][state->discardCount[who]] = supplyPos;
        -:  309:	//state->discardCount[who]++;
        -:  310:
       93:  311:	return 0;
        -:  312:}
        -:  313:
    #####:  314:int numHandCards(struct gameState *state) {
    #####:  315:	return state->handCount[whoseTurn(state)];
        -:  316:}
        -:  317:
      393:  318:int handCard(int handPos, struct gameState *state) {
      393:  319:	int currentPlayer = whoseTurn(state);
      393:  320:	return state->hand[currentPlayer][handPos];
        -:  321:}
        -:  322:
      473:  323:int supplyCount(int card, struct gameState *state) {
      473:  324:	return state->supplyCount[card];
        -:  325:}
        -:  326:
    #####:  327:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  328:	int i;
    #####:  329:	int count = 0;
        -:  330:
    #####:  331:	for (i = 0; i < state->deckCount[player]; i++)
        -:  332:	{
    #####:  333:		if (state->deck[player][i] == card) count++;
        -:  334:	}
        -:  335:
    #####:  336:	for (i = 0; i < state->handCount[player]; i++)
        -:  337:	{
    #####:  338:		if (state->hand[player][i] == card) count++;
        -:  339:	}
        -:  340:
    #####:  341:	for (i = 0; i < state->discardCount[player]; i++)
        -:  342:	{
    #####:  343:		if (state->discard[player][i] == card) count++;
        -:  344:	}
        -:  345:
    #####:  346:	return count;
        -:  347:}
        -:  348:
      575:  349:int whoseTurn(struct gameState *state) {
      575:  350:	return state->whoseTurn;
        -:  351:}
        -:  352:
      127:  353:int endTurn(struct gameState *state) {
        -:  354:	int k;
        -:  355:	int i;
      127:  356:	int currentPlayer = whoseTurn(state);
        -:  357:
        -:  358:	//Discard hand
      712:  359:	for (i = 0; i < state->handCount[currentPlayer]; i++){
      585:  360:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
      585:  361:		state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  362:	}
      127:  363:	state->handCount[currentPlayer] = 0;//Reset hand count
        -:  364:
        -:  365:	//Code for determining the player
      127:  366:	if (currentPlayer < (state->numPlayers - 1)){
       96:  367:		state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  368:	}
        -:  369:	else{
       31:  370:		state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  371:	}
        -:  372:
      127:  373:	state->outpostPlayed = 0;
      127:  374:	state->phase = 0;
      127:  375:	state->numActions = 1;
      127:  376:	state->coins = 0;
      127:  377:	state->numBuys = 1;
      127:  378:	state->playedCardCount = 0;
      127:  379:	state->handCount[state->whoseTurn] = 0;
        -:  380:
        -:  381:	//int k; move to top
        -:  382:	//Next player draws hand
      762:  383:	for (k = 0; k < 5; k++){
      635:  384:		drawCard(state->whoseTurn, state);//Draw a card
        -:  385:	}
        -:  386:
        -:  387:	//Update money
      127:  388:	updateCoins(state->whoseTurn, state, 0);
        -:  389:
      127:  390:	return 0;
        -:  391:}
        -:  392:
     1462:  393:int isGameOver(struct gameState *state) {
        -:  394:	int i;
        -:  395:	int j;
        -:  396:
        -:  397:	//if stack of Province cards is empty, the game ends
     1462:  398:	if (state->supplyCount[province] == 0)
        -:  399:	{
    #####:  400:		return 1;
        -:  401:	}
        -:  402:
        -:  403:	//if three supply pile are at 0, the game ends
     1462:  404:	j = 0;
    38012:  405:	for (i = 0; i < 25; i++)
        -:  406:	{
    36550:  407:		if (state->supplyCount[i] == 0)
        -:  408:		{
      895:  409:			j++;
        -:  410:		}
        -:  411:	}
     1462:  412:	if (j >= 3)
        -:  413:	{
        1:  414:		return 1;
        -:  415:	}
        -:  416:
     1461:  417:	return 0;
        -:  418:}
        -:  419:
    #####:  420:int scoreFor(int player, struct gameState *state) {
        -:  421:
        -:  422:	int i;
    #####:  423:	int score = 0;
        -:  424:	//score from hand
    #####:  425:	for (i = 0; i < state->handCount[player]; i++)
        -:  426:	{
    #####:  427:		if (state->hand[player][i] == curse) { score = score - 1; };
    #####:  428:		if (state->hand[player][i] == estate) { score = score + 1; };
    #####:  429:		if (state->hand[player][i] == duchy) { score = score + 3; };
    #####:  430:		if (state->hand[player][i] == province) { score = score + 6; };
    #####:  431:		if (state->hand[player][i] == great_hall) { score = score + 1; };
    #####:  432:		if (state->hand[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  433:	}
        -:  434:
        -:  435:	//score from discard
    #####:  436:	for (i = 0; i < state->discardCount[player]; i++)
        -:  437:	{
    #####:  438:		if (state->discard[player][i] == curse) { score = score - 1; };
    #####:  439:		if (state->discard[player][i] == estate) { score = score + 1; };
    #####:  440:		if (state->discard[player][i] == duchy) { score = score + 3; };
    #####:  441:		if (state->discard[player][i] == province) { score = score + 6; };
    #####:  442:		if (state->discard[player][i] == great_hall) { score = score + 1; };
    #####:  443:		if (state->discard[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  444:	}
        -:  445:
        -:  446:	//score from deck
    #####:  447:	for (i = 0; i < state->discardCount[player]; i++)
        -:  448:	{
    #####:  449:		if (state->deck[player][i] == curse) { score = score - 1; };
    #####:  450:		if (state->deck[player][i] == estate) { score = score + 1; };
    #####:  451:		if (state->deck[player][i] == duchy) { score = score + 3; };
    #####:  452:		if (state->deck[player][i] == province) { score = score + 6; };
    #####:  453:		if (state->deck[player][i] == great_hall) { score = score + 1; };
    #####:  454:		if (state->deck[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  455:	}
        -:  456:
    #####:  457:	return score;
        -:  458:}
        -:  459:
    #####:  460:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  461:	int i;
        -:  462:	int j;
        -:  463:	int highScore;
        -:  464:	int currentPlayer;
        -:  465:
        -:  466:	//get score for each player
    #####:  467:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  468:	{
        -:  469:		//set unused player scores to -9999
    #####:  470:		if (i >= state->numPlayers)
        -:  471:		{
    #####:  472:			players[i] = -9999;
        -:  473:		}
        -:  474:		else
        -:  475:		{
    #####:  476:			players[i] = scoreFor(i, state);
        -:  477:		}
        -:  478:	}
        -:  479:
        -:  480:	//find highest score
    #####:  481:	j = 0;
    #####:  482:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  483:	{
    #####:  484:		if (players[i] > players[j])
        -:  485:		{
    #####:  486:			j = i;
        -:  487:		}
        -:  488:	}
    #####:  489:	highScore = players[j];
        -:  490:
        -:  491:	//add 1 to players who had less turns
    #####:  492:	currentPlayer = whoseTurn(state);
    #####:  493:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  494:	{
    #####:  495:		if (players[i] == highScore && i > currentPlayer)
        -:  496:		{
    #####:  497:			players[i]++;
        -:  498:		}
        -:  499:	}
        -:  500:
        -:  501:	//find new highest score
    #####:  502:	j = 0;
    #####:  503:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  504:	{
    #####:  505:		if (players[i] > players[j])
        -:  506:		{
    #####:  507:			j = i;
        -:  508:		}
        -:  509:	}
    #####:  510:	highScore = players[j];
        -:  511:
        -:  512:	//set winners in array to 1 and rest to 0
    #####:  513:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  514:	{
    #####:  515:		if (players[i] == highScore)
        -:  516:		{
    #####:  517:			players[i] = 1;
        -:  518:		}
        -:  519:		else
        -:  520:		{
    #####:  521:			players[i] = 0;
        -:  522:		}
        -:  523:	}
        -:  524:
    #####:  525:	return 0;
        -:  526:}
        -:  527:
      651:  528:int drawCard(int player, struct gameState *state)
        -:  529:{
        -:  530:	int count;
        -:  531:	int deckCounter;
      651:  532:	if (state->deckCount[player] <= 0){//Deck is empty
        -:  533:
        -:  534:		//Step 1 Shuffle the discard pile back into a deck
        -:  535:		int i;
        -:  536:		//Move discard to deck
      749:  537:		for (i = 0; i < state->discardCount[player]; i++){
      688:  538:			state->deck[player][i] = state->discard[player][i];
      688:  539:			state->discard[player][i] = -1;
        -:  540:		}
        -:  541:
       61:  542:		state->deckCount[player] = state->discardCount[player];
       61:  543:		state->discardCount[player] = 0;//Reset discard
        -:  544:
        -:  545:		//Shufffle the deck
       61:  546:		shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  547:
        -:  548:		if (DEBUG){//Debug statements
        -:  549:			printf("Deck count now: %d\n", state->deckCount[player]);
        -:  550:		}
        -:  551:
       61:  552:		state->discardCount[player] = 0;
        -:  553:
        -:  554:		//Step 2 Draw Card
       61:  555:		count = state->handCount[player];//Get current player's hand count
        -:  556:
        -:  557:		if (DEBUG){//Debug statements
        -:  558:			printf("Current hand count: %d\n", count);
        -:  559:		}
        -:  560:
       61:  561:		deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  562:
       61:  563:		if (deckCounter == 0)
        2:  564:			return -1;
        -:  565:
       59:  566:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
       59:  567:		state->deckCount[player]--;
       59:  568:		state->handCount[player]++;//Increment hand count
        -:  569:	}
        -:  570:
        -:  571:	else{
      590:  572:		int count = state->handCount[player];//Get current hand count for player
        -:  573:		int deckCounter;
        -:  574:		if (DEBUG){//Debug statements
        -:  575:			printf("Current hand count: %d\n", count);
        -:  576:		}
        -:  577:
      590:  578:		deckCounter = state->deckCount[player];//Create holder for the deck count
      590:  579:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
      590:  580:		state->deckCount[player]--;
      590:  581:		state->handCount[player]++;//Increment hand count
        -:  582:	}
        -:  583:
      649:  584:	return 0;
        -:  585:}
        -:  586:
      329:  587:int getCost(int cardNumber)
        -:  588:{
      329:  589:	switch (cardNumber)
        -:  590:	{
        -:  591:	case curse:
       34:  592:		return 0;
        -:  593:	case estate:
       17:  594:		return 2;
        -:  595:	case duchy:
       16:  596:		return 5;
        -:  597:	case province:
       14:  598:		return 8;
        -:  599:	case copper:
       18:  600:		return 0;
        -:  601:	case silver:
       30:  602:		return 3;
        -:  603:	case gold:
       19:  604:		return 6;
        -:  605:	case adventurer:
        7:  606:		return 6;
        -:  607:	case council_room:
       18:  608:		return 5;
        -:  609:	case feast:
    #####:  610:		return 4;
        -:  611:	case gardens:
       13:  612:		return 4;
        -:  613:	case mine:
    #####:  614:		return 5;
        -:  615:	case remodel:
       20:  616:		return 4;
        -:  617:	case smithy:
    #####:  618:		return 4;
        -:  619:	case village:
       23:  620:		return 3;
        -:  621:	case baron:
       16:  622:		return 4;
        -:  623:	case great_hall:
       21:  624:		return 3;
        -:  625:	case minion:
    #####:  626:		return 5;
        -:  627:	case steward:
       22:  628:		return 3;
        -:  629:	case tribute:
    #####:  630:		return 5;
        -:  631:	case ambassador:
    #####:  632:		return 3;
        -:  633:	case cutpurse:
    #####:  634:		return 4;
        -:  635:	case embargo:
       21:  636:		return 2;
        -:  637:	case outpost:
    #####:  638:		return 5;
        -:  639:	case salvager:
    #####:  640:		return 4;
        -:  641:	case sea_hag:
       19:  642:		return 4;
        -:  643:	case treasure_map:
        1:  644:		return 4;
        -:  645:	}
        -:  646:
    #####:  647:	return -1;
        -:  648:}
        -:  649:
    #####:  650:void playAdventurer(struct gameState *state, int currentPlayer)
        -:  651:// Reveal cards from deck until 2 Treasure cards are found.  Put those Treasure cards in the hand and discard the rest.
        -:  652:{
    #####:  653:	int drawntreasure = 0;
        -:  654:	int temphand[MAX_HAND];
        -:  655:	int cardDrawn;
    #####:  656:	int z = 0; // this is the counter for the temp hand
        -:  657:
    #####:  658:	while (drawntreasure < 2){
    #####:  659:		if (state->deckCount[currentPlayer] < 1){//if the deck is empty we need to shuffle discard and add to deck
    #####:  660:			shuffle(currentPlayer, state);
        -:  661:		}
    #####:  662:		drawCard(currentPlayer, state);
    #####:  663:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer] - 1];//top card of hand is most recently drawn card.
    #####:  664:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
    #####:  665:			drawntreasure++;
        -:  666:		else{
    #####:  667:			temphand[z] = cardDrawn;
    #####:  668:			state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####:  669:			z++;
        -:  670:		}
        -:  671:	}
    #####:  672:	while (z - 1 >= 0){
    #####:  673:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; // discard all cards in play that have been drawn
    #####:  674:		z = z - 1;
        -:  675:	}
    #####:  676:}
        -:  677:
        2:  678:int playRemodel(struct gameState *state, int currentPlayer, int choice1, int choice2, int handPos)
        -:  679://Trash a card in the hand, and gain a card costing up to $2 more than the trashed card
        -:  680:{
        -:  681:	int i;
        2:  682:	int j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  683:
        2:  684:	if ((getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2))
        -:  685:	{
    #####:  686:		return -1;
        -:  687:	}
        -:  688:
        2:  689:	gainCard(choice2, state, 0, currentPlayer);
        -:  690:
        -:  691:	//discard card from hand
        2:  692:	discardCard(handPos, currentPlayer, state, 0);
        -:  693:
        -:  694:	//discard trashed card
       10:  695:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  696:	{
        8:  697:		if (state->hand[currentPlayer][i] == j)
        -:  698:		{
    #####:  699:			discardCard(i, currentPlayer, state, 0);
    #####:  700:			break;
        -:  701:		}
        -:  702:	}
        -:  703:
        2:  704:	return 0;
        -:  705:}
        -:  706:
    #####:  707:void playSmithy(struct gameState *state, int currentPlayer, int handPos)
        -:  708:// Draw 3 cards
        -:  709:{
        -:  710:	int i;
    #####:  711:	for (i = 0; i < 3; i++)
        -:  712:	{
    #####:  713:		drawCard(currentPlayer, state);
        -:  714:	}
        -:  715:
        -:  716:	//discard card from hand
    #####:  717:	discardCard(handPos, currentPlayer, state, 0);
    #####:  718:}
        -:  719:
       14:  720:void playBaron(struct gameState *state, int currentPlayer, int choice1, int handPos)
        -:  721://Add a buy.  OPTION:  Discard an Estate card and gain $4.  Otherwise, gain an Estate card.
        -:  722:{
       14:  723:	state->numBuys++;//Increase buys by 1!
       14:  724:	if (choice1 > 0){//Boolean true or going to discard an estate
       14:  725:		int p = 0;//Iterator for hand!
       14:  726:		int card_not_discarded = 1;//Flag for discard set!
       72:  727:		while (card_not_discarded){
       44:  728:			if (state->hand[currentPlayer][p] == estate){ //Found an estate card!
       10:  729:				state->coins += 4;//Add 4 coins to the amount of coins
       10:  730:				state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
       10:  731:				state->discardCount[currentPlayer]++;
       54:  732:				for (; p < state->handCount[currentPlayer]; p++){
       44:  733:					state->hand[currentPlayer][p] = state->hand[currentPlayer][p + 1];
        -:  734:				}
       10:  735:				state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
       10:  736:				state->handCount[currentPlayer]--;
       10:  737:				card_not_discarded = 0;//Exit the loop
        -:  738:			}
       34:  739:			else if (p > state->handCount[currentPlayer]){
        -:  740:				if (DEBUG) {
        -:  741:					printf("No estate cards in your hand, invalid choice\n");
        -:  742:					printf("Must gain an estate if there are any\n");
        -:  743:				}
        4:  744:				if (supplyCount(estate, state) > 0){
        2:  745:					gainCard(estate, state, 1, currentPlayer);
        2:  746:					state->supplyCount[estate]--;//Decrement estates
        2:  747:					if (supplyCount(estate, state) == 0){
    #####:  748:						isGameOver(state);
        -:  749:					}
        -:  750:				}
        4:  751:				card_not_discarded = 0;//Exit the loop
        -:  752:			}
        -:  753:
        -:  754:			else{
       30:  755:				p++;//Next card
        -:  756:			}
        -:  757:		}
        -:  758:	}
        -:  759:
        -:  760:	else{
    #####:  761:		if (supplyCount(estate, state) > 0){
    #####:  762:			gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  763:			state->supplyCount[estate]--;//Decrement Estates
    #####:  764:			if (supplyCount(estate, state) == 0){
    #####:  765:				isGameOver(state);
        -:  766:			}
        -:  767:		}
        -:  768:	}
       14:  769:}
        -:  770:
    #####:  771:int playTreasureMap(struct gameState *state, int currentPlayer, int handPos)
        -:  772://Trashing two treasure map cards from the hand = four gold on top of the deck.
        -:  773:{
        -:  774:	int i;
        -:  775:	int index;
        -:  776:
        -:  777:	//search hand for another treasure_map
    #####:  778:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  779:	{
    #####:  780:		if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -:  781:		{
    #####:  782:			index = i;
    #####:  783:			break;
        -:  784:		}
        -:  785:	}
    #####:  786:	if (index > -1)
        -:  787:	{
        -:  788:		//trash both treasure cards
    #####:  789:		discardCard(handPos, currentPlayer, state, 1);
    #####:  790:		discardCard(index, currentPlayer, state, 1);
        -:  791:
        -:  792:		//gain 4 Gold cards
    #####:  793:		for (i = 0; i < 4; i++)
        -:  794:		{
    #####:  795:			gainCard(gold, state, 1, currentPlayer);
        -:  796:		}
        -:  797:
        -:  798:		//return success
    #####:  799:		return 1;
        -:  800:	}
        -:  801:
        -:  802:	//no second treasure_map found in hand
    #####:  803:	return -1;
        -:  804:}
        -:  805:
       55:  806:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  807:{
        -:  808:	int i;
        -:  809:	int j;
        -:  810:	int k;
        -:  811:	//int x;  //Unused after while loop removed from feast.
       55:  812:	int currentPlayer = whoseTurn(state);
       55:  813:	int nextPlayer = currentPlayer + 1;
        -:  814:	int temphand[MAX_HAND];
        -:  815:
       55:  816:	int tributeRevealedCards[2] = { -1, -1 };
        -:  817:
       55:  818:	if (nextPlayer > (state->numPlayers - 1)){
       14:  819:		nextPlayer = 0;
        -:  820:	}
        -:  821:
        -:  822:	//uses switch to select card and perform actions
       55:  823:	switch (card)
        -:  824:	{
        -:  825:	case adventurer:
        -:  826:
    #####:  827:		playAdventurer(state, currentPlayer);
    #####:  828:		return 0;
        -:  829:
        -:  830:	case council_room:
        -:  831:		//+4 Cards
    #####:  832:		for (i = 0; i < 4; i++)
        -:  833:		{
    #####:  834:			drawCard(currentPlayer, state);
        -:  835:		}
        -:  836:
        -:  837:		//+1 Buy
    #####:  838:		state->numBuys++;
        -:  839:
        -:  840:		//Each other player draws a card
    #####:  841:		for (i = 0; i < state->numPlayers; i++)
        -:  842:		{
    #####:  843:			if (i != currentPlayer)
        -:  844:			{
    #####:  845:				drawCard(i, state);
        -:  846:			}
        -:  847:		}
        -:  848:
        -:  849:		//put played card in played card pile
    #####:  850:		discardCard(handPos, currentPlayer, state, 0);
        -:  851:
    #####:  852:		return 0;
        -:  853:
        -:  854:	case feast:
        -:  855:		//gain card with cost up to 5
        -:  856:		//Backup hand
    #####:  857:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  858:			temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  859:			state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  860:		}
        -:  861:		//Backup hand
        -:  862:
        -:  863:		//Update Coins for Buy
    #####:  864:		updateCoins(currentPlayer, state, 5);
        -:  865://		x = 1;//Condition to loop on
        -:  866://		while (x == 1) {//Buy one card
    #####:  867:			if (supplyCount(choice1, state) <= 0){
        -:  868:				if (DEBUG)
        -:  869:					printf("None of that card left, sorry!\n");
        -:  870:
        -:  871:				if (DEBUG){
        -:  872:					printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  873:				}
        -:  874:			}
    #####:  875:			else if (state->coins < getCost(choice1)){
    #####:  876:				printf("That card is too expensive!\n");
        -:  877:
        -:  878:				if (DEBUG){
        -:  879:					printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  880:				}
        -:  881:			}
        -:  882:			else{
        -:  883:
        -:  884:				if (DEBUG){
        -:  885:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  886:				}
        -:  887:
    #####:  888:				gainCard(choice1, state, 0, currentPlayer);//Gain the card
        -:  889://				x = 0;//No more buying cards
        -:  890:
        -:  891:				if (DEBUG){
        -:  892:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  893:				}
        -:  894:
        -:  895:			}
        -:  896://		}
        -:  897:
        -:  898:		//Reset Hand
    #####:  899:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  900:			state->hand[currentPlayer][i] = temphand[i];
    #####:  901:			temphand[i] = -1;
        -:  902:		}
        -:  903:		//Reset Hand
        -:  904:
    #####:  905:		return 0;
        -:  906:
        -:  907:	case gardens:
        4:  908:		return -1;
        -:  909:
        -:  910:	case mine:
    #####:  911:		j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  912:
    #####:  913:		if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  914:		{
    #####:  915:			return -1;
        -:  916:		}
        -:  917:
    #####:  918:		if (choice2 > treasure_map || choice2 < curse)
        -:  919:		{
    #####:  920:			return -1;
        -:  921:		}
        -:  922:
    #####:  923:		if ((getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2))
        -:  924:		{
    #####:  925:			return -1;
        -:  926:		}
        -:  927:
    #####:  928:		gainCard(choice2, state, 2, currentPlayer);
        -:  929:
        -:  930:		//discard card from hand
    #####:  931:		discardCard(handPos, currentPlayer, state, 0);
        -:  932:
        -:  933:		//discard trashed card
    #####:  934:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  935:		{
    #####:  936:			if (state->hand[currentPlayer][i] == j)
        -:  937:			{
    #####:  938:				discardCard(i, currentPlayer, state, 0);
    #####:  939:				break;
        -:  940:			}
        -:  941:		}
        -:  942:
    #####:  943:		return 0;
        -:  944:
        -:  945:	case remodel:
        -:  946:
        2:  947:		return playRemodel(state, currentPlayer, choice1, choice2, handPos);
        -:  948:
        -:  949:	case smithy:
        -:  950:
    #####:  951:		playSmithy(state, currentPlayer, handPos);
    #####:  952:		return 0;
        -:  953:
        -:  954:	case village:
        -:  955:		//+1 Card
        6:  956:		drawCard(currentPlayer, state);
        -:  957:
        -:  958:		//+2 Actions
        6:  959:		state->numActions = state->numActions + 2;
        -:  960:
        -:  961:		//discard played card from hand
        6:  962:		discardCard(handPos, currentPlayer, state, 0);
        6:  963:		return 0;
        -:  964:
        -:  965:	case baron:
        -:  966:
       14:  967:		playBaron(state, currentPlayer, choice1, handPos);
       14:  968:		return 0;
        -:  969:
        -:  970:	case great_hall:
        -:  971:		//+1 Card
        5:  972:		drawCard(currentPlayer, state);
        -:  973:
        -:  974:		//+1 Actions
        5:  975:		state->numActions++;
        -:  976:
        -:  977:		//discard card from hand
        5:  978:		discardCard(handPos, currentPlayer, state, 0);
        5:  979:		return 0;
        -:  980:
        -:  981:	case minion:
        -:  982:		//+1 action
    #####:  983:		state->numActions++;
        -:  984:
        -:  985:		//discard card from hand
    #####:  986:		discardCard(handPos, currentPlayer, state, 0);
        -:  987:
    #####:  988:		if (choice1)		//+2 coins
        -:  989:		{
    #####:  990:			state->coins = state->coins + 2;
        -:  991:		}
        -:  992:
    #####:  993:		else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  994:		{
        -:  995:			//discard hand
    #####:  996:			while (numHandCards(state) > 0)
        -:  997:			{
    #####:  998:				discardCard(handPos, currentPlayer, state, 0);
        -:  999:			}
        -: 1000:
        -: 1001:			//draw 4
    #####: 1002:			for (i = 0; i < 4; i++)
        -: 1003:			{
    #####: 1004:				drawCard(currentPlayer, state);
        -: 1005:			}
        -: 1006:
        -: 1007:			//other players discard hand and redraw if hand size > 4
    #####: 1008:			for (i = 0; i < state->numPlayers; i++)
        -: 1009:			{
    #####: 1010:				if (i != currentPlayer)
        -: 1011:				{
    #####: 1012:					if (state->handCount[i] > 4)
        -: 1013:					{
        -: 1014:						//discard hand
    #####: 1015:						while (state->handCount[i] > 0)
        -: 1016:						{
    #####: 1017:							discardCard(handPos, i, state, 0);
        -: 1018:						}
        -: 1019:
        -: 1020:						//draw 4
    #####: 1021:						for (j = 0; j < 4; j++)
        -: 1022:						{
    #####: 1023:							drawCard(i, state);
        -: 1024:						}
        -: 1025:					}
        -: 1026:				}
        -: 1027:			}
        -: 1028:
        -: 1029:		}
    #####: 1030:		return 0;
        -: 1031:
        -: 1032:	case steward:
       10: 1033:		if (choice1 == 1)
        -: 1034:		{
        -: 1035:			//+2 cards
    #####: 1036:			drawCard(currentPlayer, state);
    #####: 1037:			drawCard(currentPlayer, state);
        -: 1038:		}
       10: 1039:		else if (choice1 == 2)
        -: 1040:		{
        -: 1041:			//+2 coins
        1: 1042:			state->coins = state->coins + 2;
        -: 1043:		}
        -: 1044:		else
        -: 1045:		{
        -: 1046:			//trash 2 cards in hand
        9: 1047:			discardCard(choice2, currentPlayer, state, 1);
        9: 1048:			discardCard(choice3, currentPlayer, state, 1);
        -: 1049:		}
        -: 1050:
        -: 1051:		//discard card from hand
       10: 1052:		discardCard(handPos, currentPlayer, state, 0);
       10: 1053:		return 0;
        -: 1054:
        -: 1055:	case tribute:
    #####: 1056:		if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####: 1057:			if (state->deckCount[nextPlayer] > 0){
    #####: 1058:				tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1059:				state->deckCount[nextPlayer]--;
        -: 1060:			}
    #####: 1061:			else if (state->discardCount[nextPlayer] > 0){
    #####: 1062:				tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer] - 1];
    #####: 1063:				state->discardCount[nextPlayer]--;
        -: 1064:			}
        -: 1065:			else{
        -: 1066:				//No Card to Reveal
        -: 1067:				if (DEBUG){
        -: 1068:					printf("No cards to reveal\n");
        -: 1069:				}
        -: 1070:			}
        -: 1071:		}
        -: 1072:
        -: 1073:		else{
    #####: 1074:			if (state->deckCount[nextPlayer] == 0){
    #####: 1075:				for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####: 1076:					state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1077:					state->deckCount[nextPlayer]++;
    #####: 1078:					state->discard[nextPlayer][i] = -1;
    #####: 1079:					state->discardCount[nextPlayer]--;
        -: 1080:				}
        -: 1081:
    #####: 1082:				shuffle(nextPlayer, state);//Shuffle the deck
        -: 1083:			}
    #####: 1084:			tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1085:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1086:			state->deckCount[nextPlayer]--;
    #####: 1087:			tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1088:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1089:			state->deckCount[nextPlayer]--;
        -: 1090:		}
        -: 1091:
    #####: 1092:		if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
    #####: 1093:			state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1094:			state->playedCardCount++;
    #####: 1095:			tributeRevealedCards[1] = -1;
        -: 1096:		}
        -: 1097:
    #####: 1098:		for (i = 0; i <= 2; i++){
    #####: 1099:			if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
    #####: 1100:				state->coins += 2;
        -: 1101:			}
        -: 1102:
    #####: 1103:			else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
    #####: 1104:				drawCard(currentPlayer, state);
    #####: 1105:				drawCard(currentPlayer, state);
        -: 1106:			}
        -: 1107:			else{//Action Card
    #####: 1108:				state->numActions = state->numActions + 2;
        -: 1109:			}
        -: 1110:		}
        -: 1111:
    #####: 1112:		return 0;
        -: 1113:
        -: 1114:	case ambassador:
    #####: 1115:		j = 0;		//used to check if player has enough cards to discard
        -: 1116:
    #####: 1117:		if (choice2 > 2 || choice2 < 0)
        -: 1118:		{
    #####: 1119:			return -1;
        -: 1120:		}
        -: 1121:
    #####: 1122:		if (choice1 == handPos)
        -: 1123:		{
    #####: 1124:			return -1;
        -: 1125:		}
        -: 1126:
    #####: 1127:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1128:		{
    #####: 1129:			if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1130:			{
    #####: 1131:				j++;
        -: 1132:			}
        -: 1133:		}
    #####: 1134:		if (j < choice2)
        -: 1135:		{
    #####: 1136:			return -1;
        -: 1137:		}
        -: 1138:
        -: 1139:		if (DEBUG)
        -: 1140:			printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1141:
        -: 1142:		//increase supply count for choosen card by amount being discarded
    #####: 1143:		state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1144:
        -: 1145:		//each other player gains a copy of revealed card
    #####: 1146:		for (i = 0; i < state->numPlayers; i++)
        -: 1147:		{
    #####: 1148:			if (i != currentPlayer)
        -: 1149:			{
    #####: 1150:				gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1151:			}
        -: 1152:		}
        -: 1153:
        -: 1154:		//discard played card from hand
    #####: 1155:		discardCard(handPos, currentPlayer, state, 0);
        -: 1156:
        -: 1157:		//trash copies of cards returned to supply
    #####: 1158:		for (j = 0; j < choice2; j++)
        -: 1159:		{
    #####: 1160:			for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1161:			{
    #####: 1162:				if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1163:				{
    #####: 1164:					discardCard(i, currentPlayer, state, 1);
    #####: 1165:					break;
        -: 1166:				}
        -: 1167:			}
        -: 1168:		}
        -: 1169:
    #####: 1170:		return 0;
        -: 1171:
        -: 1172:	case cutpurse:
        -: 1173:
    #####: 1174:		updateCoins(currentPlayer, state, 2);
    #####: 1175:		for (i = 0; i < state->numPlayers; i++)
        -: 1176:		{
    #####: 1177:			if (i != currentPlayer)
        -: 1178:			{
    #####: 1179:				for (j = 0; j < state->handCount[i]; j++)
        -: 1180:				{
    #####: 1181:					if (state->hand[i][j] == copper)
        -: 1182:					{
    #####: 1183:						discardCard(j, i, state, 0);
    #####: 1184:						break;
        -: 1185:					}
    #####: 1186:					if (j == state->handCount[i])
        -: 1187:					{
    #####: 1188:						for (k = 0; k < state->handCount[i]; k++)
        -: 1189:						{
        -: 1190:							if (DEBUG)
        -: 1191:								printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1192:						}
    #####: 1193:						break;
        -: 1194:					}
        -: 1195:				}
        -: 1196:
        -: 1197:			}
        -: 1198:
        -: 1199:		}
        -: 1200:
        -: 1201:		//discard played card from hand
    #####: 1202:		discardCard(handPos, currentPlayer, state, 0);
        -: 1203:
    #####: 1204:		return 0;
        -: 1205:
        -: 1206:
        -: 1207:	case embargo:
        -: 1208:		//+2 Coins
        7: 1209:		state->coins = state->coins + 2;
        -: 1210:
        -: 1211:		//see if selected pile is in play
        7: 1212:		if (state->supplyCount[choice1] == -1)
        -: 1213:		{
        4: 1214:			return -1;
        -: 1215:		}
        -: 1216:
        -: 1217:		//add embargo token to selected supply pile
        3: 1218:		state->embargoTokens[choice1]++;
        -: 1219:
        -: 1220:		//trash card
        3: 1221:		discardCard(handPos, currentPlayer, state, 1);
        3: 1222:		return 0;
        -: 1223:
        -: 1224:	case outpost:
        -: 1225:		//set outpost flag
    #####: 1226:		state->outpostPlayed++;
        -: 1227:
        -: 1228:		//discard card
    #####: 1229:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1230:		return 0;
        -: 1231:
        -: 1232:	case salvager:
        -: 1233:		//+1 buy
    #####: 1234:		state->numBuys++;
        -: 1235:
    #####: 1236:		if (choice1)
        -: 1237:		{
        -: 1238:			//gain coins equal to trashed card
    #####: 1239:			state->coins = state->coins + getCost(handCard(choice1, state));
        -: 1240:			//trash card
    #####: 1241:			discardCard(choice1, currentPlayer, state, 1);
        -: 1242:		}
        -: 1243:
        -: 1244:		//discard card
    #####: 1245:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1246:		return 0;
        -: 1247:
        -: 1248:	case sea_hag:
       35: 1249:		for (i = 0; i < state->numPlayers; i++){
       28: 1250:			if (i != currentPlayer){
       21: 1251:				state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
       21: 1252:				state->discardCount[i]++;
       21: 1253:				state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1254:			}
        -: 1255:		}
        7: 1256:		return 0;
        -: 1257:
        -: 1258:	case treasure_map:
        -: 1259:
    #####: 1260:		return playTreasureMap(state, currentPlayer, handPos);
        -: 1261:	}
    #####: 1262:	return -1;
        -: 1263:}
        -: 1264:
       44: 1265:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1266:{
        -: 1267:
        -: 1268:	//if card is not trashed, added to Played pile 
       44: 1269:	if (trashFlag < 1)
        -: 1270:	{
        -: 1271:		//add card to played pile
       23: 1272:		state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
       23: 1273:		state->playedCardCount++;
        -: 1274:	}
        -: 1275:
        -: 1276:	//set played card to -1
       44: 1277:	state->hand[currentPlayer][handPos] = -1;
        -: 1278:
        -: 1279:	//remove card from player's hand
       44: 1280:	if (handPos == (state->handCount[currentPlayer] - 1)) 	//last card in hand array is played
        -: 1281:	{
        -: 1282:		//reduce number of cards in hand
        2: 1283:		state->handCount[currentPlayer]--;
        -: 1284:	}
       42: 1285:	else if (state->handCount[currentPlayer] == 1) //only one card in hand
        -: 1286:	{
        -: 1287:		//reduce number of cards in hand
    #####: 1288:		state->handCount[currentPlayer]--;
        -: 1289:	}
        -: 1290:	else
        -: 1291:	{
        -: 1292:		//replace discarded card with last card in hand
       42: 1293:		state->hand[currentPlayer][handPos] = state->hand[currentPlayer][(state->handCount[currentPlayer] - 1)];
        -: 1294:		//set last card to -1
       42: 1295:		state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1296:		//reduce number of cards in hand
       42: 1297:		state->handCount[currentPlayer]--;
        -: 1298:	}
        -: 1299:
       44: 1300:	return 0;
        -: 1301:}
        -: 1302:
       97: 1303:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1304:{
        -: 1305:	//Note: supplyPos is enum of choosen card
        -: 1306:
        -: 1307:	//check if supply pile is empty (0) or card is not used in game (-1)
       97: 1308:	if (supplyCount(supplyPos, state) < 1)
        -: 1309:	{
        1: 1310:		return -1;
        -: 1311:	}
        -: 1312:
        -: 1313:	//added card for [whoseTurn] current player:
        -: 1314:	// toFlag = 0 : add to discard
        -: 1315:	// toFlag = 1 : add to deck
        -: 1316:	// toFlag = 2 : add to hand
        -: 1317:
       96: 1318:	if (toFlag == 1)
        -: 1319:	{
        2: 1320:		state->deck[player][state->deckCount[player]] = supplyPos;
        2: 1321:		state->deckCount[player]++;
        -: 1322:	}
       94: 1323:	else if (toFlag == 2)
        -: 1324:	{
    #####: 1325:		state->hand[player][state->handCount[player]] = supplyPos;
    #####: 1326:		state->handCount[player]++;
        -: 1327:	}
        -: 1328:	else
        -: 1329:	{
       94: 1330:		state->discard[player][state->discardCount[player]] = supplyPos;
       94: 1331:		state->discardCount[player]++;
        -: 1332:	}
        -: 1333:
        -: 1334:	//decrease number in supply pile
       96: 1335:	state->supplyCount[supplyPos]--;
        -: 1336:
       96: 1337:	return 0;
        -: 1338:}
        -: 1339:
      175: 1340:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1341:{
        -: 1342:	int i;
        -: 1343:
        -: 1344:	//reset coin count
      175: 1345:	state->coins = 0;
        -: 1346:
        -: 1347:	//add coins for each Treasure card in player's hand
     1000: 1348:	for (i = 0; i < state->handCount[player]; i++)
        -: 1349:	{
      825: 1350:		if (state->hand[player][i] == copper)
        -: 1351:		{
      362: 1352:			state->coins += 1;
        -: 1353:		}
      463: 1354:		else if (state->hand[player][i] == silver)
        -: 1355:		{
       59: 1356:			state->coins += 2;
        -: 1357:		}
      404: 1358:		else if (state->hand[player][i] == gold)
        -: 1359:		{
    #####: 1360:			state->coins += 3;
        -: 1361:		}
        -: 1362:	}
        -: 1363:
        -: 1364:	//add bonus
      175: 1365:	state->coins += bonus;
        -: 1366:
      175: 1367:	return 0;
        -: 1368:}
        -: 1369:
        -: 1370:
        -: 1371://end of dominion.c
File 'dominion.c'
Lines executed:53.32% of 557
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
     1181:    8:int compare(const void* a, const void* b) {
     1181:    9:	if (*(int*)a > *(int*)b)
      397:   10:		return 1;
      784:   11:	if (*(int*)a < *(int*)b)
      315:   12:		return -1;
      469:   13:	return 0;
        -:   14:}
        -:   15:
        2:   16:struct gameState* newGame() {
        2:   17:	struct gameState* g = malloc(sizeof(struct gameState));
        2:   18:	return g;
        -:   19:}
        -:   20:
        1:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:	int k8, int k9, int k10) {
        1:   23:	int* k = malloc(10 * sizeof(int));
        1:   24:	k[0] = k1;
        1:   25:	k[1] = k2;
        1:   26:	k[2] = k3;
        1:   27:	k[3] = k4;
        1:   28:	k[4] = k5;
        1:   29:	k[5] = k6;
        1:   30:	k[6] = k7;
        1:   31:	k[7] = k8;
        1:   32:	k[8] = k9;
        1:   33:	k[9] = k10;
        1:   34:	return k;
        -:   35:}
        -:   36:
        1:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		struct gameState *state) {
        -:   39:
        -:   40:	int i;
        -:   41:	int j;
        -:   42:	int it;
        -:   43:	//set up random number generator
        1:   44:	SelectStream(1);
        1:   45:	PutSeed((long)randomSeed);
        -:   46:
        -:   47:	//check number of players
        1:   48:	if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:	{
    #####:   50:		return -1;
        -:   51:	}
        -:   52:
        -:   53:	//set number of players
        1:   54:	state->numPlayers = numPlayers;
        -:   55:
        -:   56:	//check selected kingdom cards are different
       11:   57:	for (i = 0; i < 10; i++)
        -:   58:	{
      110:   59:		for (j = 0; j < 10; j++)
        -:   60:		{
      100:   61:			if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:			{
    #####:   63:				return -1;
        -:   64:			}
        -:   65:		}
        -:   66:	}
        -:   67:
        -:   68:
        -:   69:	//initialize supply
        -:   70:	///////////////////////////////
        -:   71:
        -:   72:	//set number of Curse cards
        1:   73:	if (numPlayers == 2)
        -:   74:	{
    #####:   75:		state->supplyCount[curse] = 10;
        -:   76:	}
        1:   77:	else if (numPlayers == 3)
        -:   78:	{
        1:   79:		state->supplyCount[curse] = 20;
        -:   80:	}
        -:   81:	else
        -:   82:	{
    #####:   83:		state->supplyCount[curse] = 30;
        -:   84:	}
        -:   85:
        -:   86:	//set number of Victory cards
        1:   87:	if (numPlayers == 2)
        -:   88:	{
    #####:   89:		state->supplyCount[estate] = 8;
    #####:   90:		state->supplyCount[duchy] = 8;
    #####:   91:		state->supplyCount[province] = 8;
        -:   92:	}
        -:   93:	else
        -:   94:	{
        1:   95:		state->supplyCount[estate] = 12;
        1:   96:		state->supplyCount[duchy] = 12;
        1:   97:		state->supplyCount[province] = 12;
        -:   98:	}
        -:   99:
        -:  100:	//set number of Treasure cards
        1:  101:	state->supplyCount[copper] = 60 - (7 * numPlayers);
        1:  102:	state->supplyCount[silver] = 40;
        1:  103:	state->supplyCount[gold] = 30;
        -:  104:
        -:  105:	//set number of Kingdom cards
       21:  106:	for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:	{
      165:  108:		for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:		{
      155:  110:			if (kingdomCards[j] == i)
        -:  111:			{
        -:  112:				//check if card is a 'Victory' Kingdom card
       10:  113:				if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:				{
        2:  115:					if (numPlayers == 2){
    #####:  116:						state->supplyCount[i] = 8;
        -:  117:					}
        1:  118:					else{ state->supplyCount[i] = 12; }
        -:  119:				}
        -:  120:				else
        -:  121:				{
        9:  122:					state->supplyCount[i] = 10;
        -:  123:				}
       10:  124:				break;
        -:  125:			}
        -:  126:			else    //card is not in the set choosen for the game
        -:  127:			{
      145:  128:				state->supplyCount[i] = -1;
        -:  129:			}
        -:  130:		}
        -:  131:
        -:  132:	}
        -:  133:
        -:  134:	////////////////////////
        -:  135:	//supply intilization complete
        -:  136:
        -:  137:	//set player decks
        4:  138:	for (i = 0; i < numPlayers; i++)
        -:  139:	{
        3:  140:		state->deckCount[i] = 0;
       12:  141:		for (j = 0; j < 3; j++)
        -:  142:		{
        9:  143:			state->deck[i][j] = estate;
        9:  144:			state->deckCount[i]++;
        -:  145:		}
       24:  146:		for (j = 3; j < 10; j++)
        -:  147:		{
       21:  148:			state->deck[i][j] = copper;
       21:  149:			state->deckCount[i]++;
        -:  150:		}
        -:  151:	}
        -:  152:
        -:  153:	//shuffle player decks
        4:  154:	for (i = 0; i < numPlayers; i++)
        -:  155:	{
        3:  156:		if (shuffle(i, state) < 0)
        -:  157:		{
    #####:  158:			return -1;
        -:  159:		}
        -:  160:	}
        -:  161:
        -:  162:	//draw player hands
        4:  163:	for (i = 0; i < numPlayers; i++)
        -:  164:	{
        -:  165:		//initialize hand size to zero
        3:  166:		state->handCount[i] = 0;
        3:  167:		state->discardCount[i] = 0;
        -:  168:		//draw 5 cards
        -:  169:		// for (j = 0; j < 5; j++)
        -:  170:		//	{
        -:  171:		//	  drawCard(i, state);
        -:  172:		//	}
        -:  173:	}
        -:  174:
        -:  175:	//set embargo tokens to 0 for all supply piles
       28:  176:	for (i = 0; i <= treasure_map; i++)
        -:  177:	{
       27:  178:		state->embargoTokens[i] = 0;
        -:  179:	}
        -:  180:
        -:  181:	//initialize first player's turn
        1:  182:	state->outpostPlayed = 0;
        1:  183:	state->phase = 0;
        1:  184:	state->numActions = 1;
        1:  185:	state->numBuys = 1;
        1:  186:	state->playedCardCount = 0;
        1:  187:	state->whoseTurn = 0;
        1:  188:	state->handCount[state->whoseTurn] = 0;
        -:  189:	//int it; move to top
        -:  190:
        -:  191:	//Moved draw cards to here, only drawing at the start of a turn
        6:  192:	for (it = 0; it < 5; it++){
        5:  193:		drawCard(state->whoseTurn, state);
        -:  194:	}
        -:  195:
        1:  196:	updateCoins(state->whoseTurn, state, 0);
        -:  197:
        1:  198:	return 0;
        -:  199:}
        -:  200:
       31:  201:int shuffle(int player, struct gameState *state) {
        -:  202:
        -:  203:
        -:  204:	int newDeck[MAX_DECK];
       31:  205:	int newDeckPos = 0;
        -:  206:	int card;
        -:  207:	int i;
        -:  208:
       31:  209:	if (state->deckCount[player] < 1)
    #####:  210:		return -1;
       31:  211:	qsort((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
        -:  212:	/* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
      617:  214:	while (state->deckCount[player] > 0) {
      555:  215:		card = floor(Random() * state->deckCount[player]);
      555:  216:		newDeck[newDeckPos] = state->deck[player][card];
      555:  217:		newDeckPos++;
     3302:  218:		for (i = card; i < state->deckCount[player] - 1; i++) {
     2747:  219:			state->deck[player][i] = state->deck[player][i + 1];
        -:  220:		}
      555:  221:		state->deckCount[player]--;
        -:  222:	}
      586:  223:	for (i = 0; i < newDeckPos; i++) {
      555:  224:		state->deck[player][i] = newDeck[i];
      555:  225:		state->deckCount[player]++;
        -:  226:	}
        -:  227:
       31:  228:	return 0;
        -:  229:}
        -:  230:
      597:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state)
        -:  232:{
        -:  233:	int card;
      597:  234:	int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:	//check if it is the right phase
      597:  237:	if (state->phase != 0)
        -:  238:	{
       76:  239:		return -1;
        -:  240:	}
        -:  241:
        -:  242:	//check if player has enough actions
      521:  243:	if (state->numActions < 1)
        -:  244:	{
        9:  245:		return -1;
        -:  246:	}
        -:  247:
        -:  248:	//get card played
      512:  249:	card = handCard(handPos, state);
        -:  250:
        -:  251:	//check if selected card is an action
      512:  252:	if (card < adventurer || card > treasure_map)
        -:  253:	{
      485:  254:		return -1;
        -:  255:	}
        -:  256:
        -:  257:	//play card
       27:  258:	if (cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0)
        -:  259:	{
        9:  260:		return -1;
        -:  261:	}
        -:  262:
        -:  263:	//reduce number of actions
       18:  264:	state->numActions--;
        -:  265:
        -:  266:	//update coins (Treasure cards may be added with card draws)
       18:  267:	updateCoins(state->whoseTurn, state, coin_bonus);
        -:  268:
       18:  269:	return 0;
        -:  270:}
        -:  271:
      559:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:	int who;
        -:  274:	if (DEBUG){
        -:  275:		printf("Entering buyCard...\n");
        -:  276:	}
        -:  277:
        -:  278:	// I don't know what to do about the phase thing.
        -:  279:
      559:  280:	who = state->whoseTurn;
        -:  281:
      559:  282:	if (state->numBuys < 1){
        -:  283:		if (DEBUG)
        -:  284:			printf("You do not have any buys left\n");
       80:  285:		return -1;
        -:  286:	}
      479:  287:	else if (supplyCount(supplyPos, state) < 1){
        -:  288:		if (DEBUG)
        -:  289:			printf("There are not any of that type of card left\n");
      176:  290:		return -1;
        -:  291:	}
      303:  292:	else if (state->coins < getCost(supplyPos)){
        -:  293:		if (DEBUG)
        -:  294:			printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
      219:  295:		return -1;
        -:  296:	}
        -:  297:	else {
       84:  298:		state->phase = 1;
        -:  299:		//state->supplyCount[supplyPos]--;
       84:  300:		gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  301:
       84:  302:		state->coins = (state->coins) - (getCost(supplyPos));
       84:  303:		state->numBuys--;
        -:  304:		if (DEBUG)
        -:  305:			printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  306:	}
        -:  307:
        -:  308:	//state->discard[who][state->discardCount[who]] = supplyPos;
        -:  309:	//state->discardCount[who]++;
        -:  310:
       84:  311:	return 0;
        -:  312:}
        -:  313:
    #####:  314:int numHandCards(struct gameState *state) {
    #####:  315:	return state->handCount[whoseTurn(state)];
        -:  316:}
        -:  317:
      513:  318:int handCard(int handPos, struct gameState *state) {
      513:  319:	int currentPlayer = whoseTurn(state);
      513:  320:	return state->hand[currentPlayer][handPos];
        -:  321:}
        -:  322:
      571:  323:int supplyCount(int card, struct gameState *state) {
      571:  324:	return state->supplyCount[card];
        -:  325:}
        -:  326:
    #####:  327:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  328:	int i;
    #####:  329:	int count = 0;
        -:  330:
    #####:  331:	for (i = 0; i < state->deckCount[player]; i++)
        -:  332:	{
    #####:  333:		if (state->deck[player][i] == card) count++;
        -:  334:	}
        -:  335:
    #####:  336:	for (i = 0; i < state->handCount[player]; i++)
        -:  337:	{
    #####:  338:		if (state->hand[player][i] == card) count++;
        -:  339:	}
        -:  340:
    #####:  341:	for (i = 0; i < state->discardCount[player]; i++)
        -:  342:	{
    #####:  343:		if (state->discard[player][i] == card) count++;
        -:  344:	}
        -:  345:
    #####:  346:	return count;
        -:  347:}
        -:  348:
      639:  349:int whoseTurn(struct gameState *state) {
      639:  350:	return state->whoseTurn;
        -:  351:}
        -:  352:
       99:  353:int endTurn(struct gameState *state) {
        -:  354:	int k;
        -:  355:	int i;
       99:  356:	int currentPlayer = whoseTurn(state);
        -:  357:
        -:  358:	//Discard hand
      581:  359:	for (i = 0; i < state->handCount[currentPlayer]; i++){
      482:  360:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
      482:  361:		state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  362:	}
       99:  363:	state->handCount[currentPlayer] = 0;//Reset hand count
        -:  364:
        -:  365:	//Code for determining the player
       99:  366:	if (currentPlayer < (state->numPlayers - 1)){
       66:  367:		state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  368:	}
        -:  369:	else{
       33:  370:		state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  371:	}
        -:  372:
       99:  373:	state->outpostPlayed = 0;
       99:  374:	state->phase = 0;
       99:  375:	state->numActions = 1;
       99:  376:	state->coins = 0;
       99:  377:	state->numBuys = 1;
       99:  378:	state->playedCardCount = 0;
       99:  379:	state->handCount[state->whoseTurn] = 0;
        -:  380:
        -:  381:	//int k; move to top
        -:  382:	//Next player draws hand
      594:  383:	for (k = 0; k < 5; k++){
      495:  384:		drawCard(state->whoseTurn, state);//Draw a card
        -:  385:	}
        -:  386:
        -:  387:	//Update money
       99:  388:	updateCoins(state->whoseTurn, state, 0);
        -:  389:
       99:  390:	return 0;
        -:  391:}
        -:  392:
     1759:  393:int isGameOver(struct gameState *state) {
        -:  394:	int i;
        -:  395:	int j;
        -:  396:
        -:  397:	//if stack of Province cards is empty, the game ends
     1759:  398:	if (state->supplyCount[province] == 0)
        -:  399:	{
    #####:  400:		return 1;
        -:  401:	}
        -:  402:
        -:  403:	//if three supply pile are at 0, the game ends
     1759:  404:	j = 0;
    45734:  405:	for (i = 0; i < 25; i++)
        -:  406:	{
    43975:  407:		if (state->supplyCount[i] == 0)
        -:  408:		{
      576:  409:			j++;
        -:  410:		}
        -:  411:	}
     1759:  412:	if (j >= 3)
        -:  413:	{
        1:  414:		return 1;
        -:  415:	}
        -:  416:
     1758:  417:	return 0;
        -:  418:}
        -:  419:
    #####:  420:int scoreFor(int player, struct gameState *state) {
        -:  421:
        -:  422:	int i;
    #####:  423:	int score = 0;
        -:  424:	//score from hand
    #####:  425:	for (i = 0; i < state->handCount[player]; i++)
        -:  426:	{
    #####:  427:		if (state->hand[player][i] == curse) { score = score - 1; };
    #####:  428:		if (state->hand[player][i] == estate) { score = score + 1; };
    #####:  429:		if (state->hand[player][i] == duchy) { score = score + 3; };
    #####:  430:		if (state->hand[player][i] == province) { score = score + 6; };
    #####:  431:		if (state->hand[player][i] == great_hall) { score = score + 1; };
    #####:  432:		if (state->hand[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  433:	}
        -:  434:
        -:  435:	//score from discard
    #####:  436:	for (i = 0; i < state->discardCount[player]; i++)
        -:  437:	{
    #####:  438:		if (state->discard[player][i] == curse) { score = score - 1; };
    #####:  439:		if (state->discard[player][i] == estate) { score = score + 1; };
    #####:  440:		if (state->discard[player][i] == duchy) { score = score + 3; };
    #####:  441:		if (state->discard[player][i] == province) { score = score + 6; };
    #####:  442:		if (state->discard[player][i] == great_hall) { score = score + 1; };
    #####:  443:		if (state->discard[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  444:	}
        -:  445:
        -:  446:	//score from deck
    #####:  447:	for (i = 0; i < state->discardCount[player]; i++)
        -:  448:	{
    #####:  449:		if (state->deck[player][i] == curse) { score = score - 1; };
    #####:  450:		if (state->deck[player][i] == estate) { score = score + 1; };
    #####:  451:		if (state->deck[player][i] == duchy) { score = score + 3; };
    #####:  452:		if (state->deck[player][i] == province) { score = score + 6; };
    #####:  453:		if (state->deck[player][i] == great_hall) { score = score + 1; };
    #####:  454:		if (state->deck[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  455:	}
        -:  456:
    #####:  457:	return score;
        -:  458:}
        -:  459:
    #####:  460:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  461:	int i;
        -:  462:	int j;
        -:  463:	int highScore;
        -:  464:	int currentPlayer;
        -:  465:
        -:  466:	//get score for each player
    #####:  467:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  468:	{
        -:  469:		//set unused player scores to -9999
    #####:  470:		if (i >= state->numPlayers)
        -:  471:		{
    #####:  472:			players[i] = -9999;
        -:  473:		}
        -:  474:		else
        -:  475:		{
    #####:  476:			players[i] = scoreFor(i, state);
        -:  477:		}
        -:  478:	}
        -:  479:
        -:  480:	//find highest score
    #####:  481:	j = 0;
    #####:  482:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  483:	{
    #####:  484:		if (players[i] > players[j])
        -:  485:		{
    #####:  486:			j = i;
        -:  487:		}
        -:  488:	}
    #####:  489:	highScore = players[j];
        -:  490:
        -:  491:	//add 1 to players who had less turns
    #####:  492:	currentPlayer = whoseTurn(state);
    #####:  493:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  494:	{
    #####:  495:		if (players[i] == highScore && i > currentPlayer)
        -:  496:		{
    #####:  497:			players[i]++;
        -:  498:		}
        -:  499:	}
        -:  500:
        -:  501:	//find new highest score
    #####:  502:	j = 0;
    #####:  503:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  504:	{
    #####:  505:		if (players[i] > players[j])
        -:  506:		{
    #####:  507:			j = i;
        -:  508:		}
        -:  509:	}
    #####:  510:	highScore = players[j];
        -:  511:
        -:  512:	//set winners in array to 1 and rest to 0
    #####:  513:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  514:	{
    #####:  515:		if (players[i] == highScore)
        -:  516:		{
    #####:  517:			players[i] = 1;
        -:  518:		}
        -:  519:		else
        -:  520:		{
    #####:  521:			players[i] = 0;
        -:  522:		}
        -:  523:	}
        -:  524:
    #####:  525:	return 0;
        -:  526:}
        -:  527:
      512:  528:int drawCard(int player, struct gameState *state)
        -:  529:{
        -:  530:	int count;
        -:  531:	int deckCounter;
      512:  532:	if (state->deckCount[player] <= 0){//Deck is empty
        -:  533:
        -:  534:		//Step 1 Shuffle the discard pile back into a deck
        -:  535:		int i;
        -:  536:		//Move discard to deck
      553:  537:		for (i = 0; i < state->discardCount[player]; i++){
      525:  538:			state->deck[player][i] = state->discard[player][i];
      525:  539:			state->discard[player][i] = -1;
        -:  540:		}
        -:  541:
       28:  542:		state->deckCount[player] = state->discardCount[player];
       28:  543:		state->discardCount[player] = 0;//Reset discard
        -:  544:
        -:  545:		//Shufffle the deck
       28:  546:		shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  547:
        -:  548:		if (DEBUG){//Debug statements
        -:  549:			printf("Deck count now: %d\n", state->deckCount[player]);
        -:  550:		}
        -:  551:
       28:  552:		state->discardCount[player] = 0;
        -:  553:
        -:  554:		//Step 2 Draw Card
       28:  555:		count = state->handCount[player];//Get current player's hand count
        -:  556:
        -:  557:		if (DEBUG){//Debug statements
        -:  558:			printf("Current hand count: %d\n", count);
        -:  559:		}
        -:  560:
       28:  561:		deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  562:
       28:  563:		if (deckCounter == 0)
    #####:  564:			return -1;
        -:  565:
       28:  566:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
       28:  567:		state->deckCount[player]--;
       28:  568:		state->handCount[player]++;//Increment hand count
        -:  569:	}
        -:  570:
        -:  571:	else{
      484:  572:		int count = state->handCount[player];//Get current hand count for player
        -:  573:		int deckCounter;
        -:  574:		if (DEBUG){//Debug statements
        -:  575:			printf("Current hand count: %d\n", count);
        -:  576:		}
        -:  577:
      484:  578:		deckCounter = state->deckCount[player];//Create holder for the deck count
      484:  579:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
      484:  580:		state->deckCount[player]--;
      484:  581:		state->handCount[player]++;//Increment hand count
        -:  582:	}
        -:  583:
      512:  584:	return 0;
        -:  585:}
        -:  586:
      388:  587:int getCost(int cardNumber)
        -:  588:{
      388:  589:	switch (cardNumber)
        -:  590:	{
        -:  591:	case curse:
       34:  592:		return 0;
        -:  593:	case estate:
       32:  594:		return 2;
        -:  595:	case duchy:
       20:  596:		return 5;
        -:  597:	case province:
       21:  598:		return 8;
        -:  599:	case copper:
       32:  600:		return 0;
        -:  601:	case silver:
       24:  602:		return 3;
        -:  603:	case gold:
       21:  604:		return 6;
        -:  605:	case adventurer:
       19:  606:		return 6;
        -:  607:	case council_room:
    #####:  608:		return 5;
        -:  609:	case feast:
    #####:  610:		return 4;
        -:  611:	case gardens:
    #####:  612:		return 4;
        -:  613:	case mine:
       16:  614:		return 5;
        -:  615:	case remodel:
       16:  616:		return 4;
        -:  617:	case smithy:
       20:  618:		return 4;
        -:  619:	case village:
    #####:  620:		return 3;
        -:  621:	case baron:
    #####:  622:		return 4;
        -:  623:	case great_hall:
       25:  624:		return 3;
        -:  625:	case minion:
    #####:  626:		return 5;
        -:  627:	case steward:
       19:  628:		return 3;
        -:  629:	case tribute:
    #####:  630:		return 5;
        -:  631:	case ambassador:
       23:  632:		return 3;
        -:  633:	case cutpurse:
    #####:  634:		return 4;
        -:  635:	case embargo:
       28:  636:		return 2;
        -:  637:	case outpost:
    #####:  638:		return 5;
        -:  639:	case salvager:
       25:  640:		return 4;
        -:  641:	case sea_hag:
    #####:  642:		return 4;
        -:  643:	case treasure_map:
       13:  644:		return 4;
        -:  645:	}
        -:  646:
    #####:  647:	return -1;
        -:  648:}
        -:  649:
    #####:  650:void playAdventurer(struct gameState *state, int currentPlayer)
        -:  651:// Reveal cards from deck until 2 Treasure cards are found.  Put those Treasure cards in the hand and discard the rest.
        -:  652:{
    #####:  653:	int drawntreasure = 0;
        -:  654:	int temphand[MAX_HAND];
        -:  655:	int cardDrawn;
    #####:  656:	int z = 0; // this is the counter for the temp hand
        -:  657:
    #####:  658:	while (drawntreasure < 2){
    #####:  659:		if (state->deckCount[currentPlayer] < 1){//if the deck is empty we need to shuffle discard and add to deck
    #####:  660:			shuffle(currentPlayer, state);
        -:  661:		}
    #####:  662:		drawCard(currentPlayer, state);
    #####:  663:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer] - 1];//top card of hand is most recently drawn card.
    #####:  664:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
    #####:  665:			drawntreasure++;
        -:  666:		else{
    #####:  667:			temphand[z] = cardDrawn;
    #####:  668:			state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####:  669:			z++;
        -:  670:		}
        -:  671:	}
    #####:  672:	while (z - 1 >= 0){
    #####:  673:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; // discard all cards in play that have been drawn
    #####:  674:		z = z - 1;
        -:  675:	}
    #####:  676:}
        -:  677:
    #####:  678:int playRemodel(struct gameState *state, int currentPlayer, int choice1, int choice2, int handPos)
        -:  679://Trash a card in the hand, and gain a card costing up to $2 more than the trashed card
        -:  680:{
        -:  681:	int i;
    #####:  682:	int j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  683:
    #####:  684:	if ((getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2))
        -:  685:	{
    #####:  686:		return -1;
        -:  687:	}
        -:  688:
    #####:  689:	gainCard(choice2, state, 0, currentPlayer);
        -:  690:
        -:  691:	//discard card from hand
    #####:  692:	discardCard(handPos, currentPlayer, state, 0);
        -:  693:
        -:  694:	//discard trashed card
    #####:  695:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  696:	{
    #####:  697:		if (state->hand[currentPlayer][i] == j)
        -:  698:		{
    #####:  699:			discardCard(i, currentPlayer, state, 0);
    #####:  700:			break;
        -:  701:		}
        -:  702:	}
        -:  703:
    #####:  704:	return 0;
        -:  705:}
        -:  706:
        2:  707:void playSmithy(struct gameState *state, int currentPlayer, int handPos)
        -:  708:// Draw 3 cards
        -:  709:{
        -:  710:	int i;
        8:  711:	for (i = 0; i < 3; i++)
        -:  712:	{
        6:  713:		drawCard(currentPlayer, state);
        -:  714:	}
        -:  715:
        -:  716:	//discard card from hand
        2:  717:	discardCard(handPos, currentPlayer, state, 0);
        2:  718:}
        -:  719:
    #####:  720:void playBaron(struct gameState *state, int currentPlayer, int choice1, int handPos)
        -:  721://Add a buy.  OPTION:  Discard an Estate card and gain $4.  Otherwise, gain an Estate card.
        -:  722:{
    #####:  723:	state->numBuys++;//Increase buys by 1!
    #####:  724:	if (choice1 > 0){//Boolean true or going to discard an estate
    #####:  725:		int p = 0;//Iterator for hand!
    #####:  726:		int card_not_discarded = 1;//Flag for discard set!
    #####:  727:		while (card_not_discarded){
    #####:  728:			if (state->hand[currentPlayer][p] == estate){ //Found an estate card!
    #####:  729:				state->coins += 4;//Add 4 coins to the amount of coins
    #####:  730:				state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  731:				state->discardCount[currentPlayer]++;
    #####:  732:				for (; p < state->handCount[currentPlayer]; p++){
    #####:  733:					state->hand[currentPlayer][p] = state->hand[currentPlayer][p + 1];
        -:  734:				}
    #####:  735:				state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  736:				state->handCount[currentPlayer]--;
    #####:  737:				card_not_discarded = 0;//Exit the loop
        -:  738:			}
    #####:  739:			else if (p > state->handCount[currentPlayer]){
        -:  740:				if (DEBUG) {
        -:  741:					printf("No estate cards in your hand, invalid choice\n");
        -:  742:					printf("Must gain an estate if there are any\n");
        -:  743:				}
    #####:  744:				if (supplyCount(estate, state) > 0){
    #####:  745:					gainCard(estate, state, 1, currentPlayer);
    #####:  746:					state->supplyCount[estate]--;//Decrement estates
    #####:  747:					if (supplyCount(estate, state) == 0){
    #####:  748:						isGameOver(state);
        -:  749:					}
        -:  750:				}
    #####:  751:				card_not_discarded = 0;//Exit the loop
        -:  752:			}
        -:  753:
        -:  754:			else{
    #####:  755:				p++;//Next card
        -:  756:			}
        -:  757:		}
        -:  758:	}
        -:  759:
        -:  760:	else{
    #####:  761:		if (supplyCount(estate, state) > 0){
    #####:  762:			gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  763:			state->supplyCount[estate]--;//Decrement Estates
    #####:  764:			if (supplyCount(estate, state) == 0){
    #####:  765:				isGameOver(state);
        -:  766:			}
        -:  767:		}
        -:  768:	}
    #####:  769:}
        -:  770:
        1:  771:int playTreasureMap(struct gameState *state, int currentPlayer, int handPos)
        -:  772://Trashing two treasure map cards from the hand = four gold on top of the deck.
        -:  773:{
        -:  774:	int i;
        -:  775:	int index;
        -:  776:
        -:  777:	//search hand for another treasure_map
        6:  778:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  779:	{
        5:  780:		if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -:  781:		{
    #####:  782:			index = i;
    #####:  783:			break;
        -:  784:		}
        -:  785:	}
        1:  786:	if (index > -1)
        -:  787:	{
        -:  788:		//trash both treasure cards
        1:  789:		discardCard(handPos, currentPlayer, state, 1);
        1:  790:		discardCard(index, currentPlayer, state, 1);
        -:  791:
        -:  792:		//gain 4 Gold cards
        5:  793:		for (i = 0; i < 4; i++)
        -:  794:		{
        4:  795:			gainCard(gold, state, 1, currentPlayer);
        -:  796:		}
        -:  797:
        -:  798:		//return success
        1:  799:		return 1;
        -:  800:	}
        -:  801:
        -:  802:	//no second treasure_map found in hand
    #####:  803:	return -1;
        -:  804:}
        -:  805:
       27:  806:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  807:{
        -:  808:	int i;
        -:  809:	int j;
        -:  810:	int k;
        -:  811:	//int x;  //Unused after while loop removed from feast.
       27:  812:	int currentPlayer = whoseTurn(state);
       27:  813:	int nextPlayer = currentPlayer + 1;
        -:  814:	int temphand[MAX_HAND];
        -:  815:
       27:  816:	int tributeRevealedCards[2] = { -1, -1 };
        -:  817:
       27:  818:	if (nextPlayer > (state->numPlayers - 1)){
        6:  819:		nextPlayer = 0;
        -:  820:	}
        -:  821:
        -:  822:	//uses switch to select card and perform actions
       27:  823:	switch (card)
        -:  824:	{
        -:  825:	case adventurer:
        -:  826:
    #####:  827:		playAdventurer(state, currentPlayer);
    #####:  828:		return 0;
        -:  829:
        -:  830:	case council_room:
        -:  831:		//+4 Cards
    #####:  832:		for (i = 0; i < 4; i++)
        -:  833:		{
    #####:  834:			drawCard(currentPlayer, state);
        -:  835:		}
        -:  836:
        -:  837:		//+1 Buy
    #####:  838:		state->numBuys++;
        -:  839:
        -:  840:		//Each other player draws a card
    #####:  841:		for (i = 0; i < state->numPlayers; i++)
        -:  842:		{
    #####:  843:			if (i != currentPlayer)
        -:  844:			{
    #####:  845:				drawCard(i, state);
        -:  846:			}
        -:  847:		}
        -:  848:
        -:  849:		//put played card in played card pile
    #####:  850:		discardCard(handPos, currentPlayer, state, 0);
        -:  851:
    #####:  852:		return 0;
        -:  853:
        -:  854:	case feast:
        -:  855:		//gain card with cost up to 5
        -:  856:		//Backup hand
    #####:  857:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  858:			temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  859:			state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  860:		}
        -:  861:		//Backup hand
        -:  862:
        -:  863:		//Update Coins for Buy
    #####:  864:		updateCoins(currentPlayer, state, 5);
        -:  865://		x = 1;//Condition to loop on
        -:  866://		while (x == 1) {//Buy one card
    #####:  867:			if (supplyCount(choice1, state) <= 0){
        -:  868:				if (DEBUG)
        -:  869:					printf("None of that card left, sorry!\n");
        -:  870:
        -:  871:				if (DEBUG){
        -:  872:					printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  873:				}
        -:  874:			}
    #####:  875:			else if (state->coins < getCost(choice1)){
    #####:  876:				printf("That card is too expensive!\n");
        -:  877:
        -:  878:				if (DEBUG){
        -:  879:					printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  880:				}
        -:  881:			}
        -:  882:			else{
        -:  883:
        -:  884:				if (DEBUG){
        -:  885:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  886:				}
        -:  887:
    #####:  888:				gainCard(choice1, state, 0, currentPlayer);//Gain the card
        -:  889://				x = 0;//No more buying cards
        -:  890:
        -:  891:				if (DEBUG){
        -:  892:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  893:				}
        -:  894:
        -:  895:			}
        -:  896://		}
        -:  897:
        -:  898:		//Reset Hand
    #####:  899:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  900:			state->hand[currentPlayer][i] = temphand[i];
    #####:  901:			temphand[i] = -1;
        -:  902:		}
        -:  903:		//Reset Hand
        -:  904:
    #####:  905:		return 0;
        -:  906:
        -:  907:	case gardens:
    #####:  908:		return -1;
        -:  909:
        -:  910:	case mine:
        1:  911:		j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  912:
        1:  913:		if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  914:		{
        1:  915:			return -1;
        -:  916:		}
        -:  917:
    #####:  918:		if (choice2 > treasure_map || choice2 < curse)
        -:  919:		{
    #####:  920:			return -1;
        -:  921:		}
        -:  922:
    #####:  923:		if ((getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2))
        -:  924:		{
    #####:  925:			return -1;
        -:  926:		}
        -:  927:
    #####:  928:		gainCard(choice2, state, 2, currentPlayer);
        -:  929:
        -:  930:		//discard card from hand
    #####:  931:		discardCard(handPos, currentPlayer, state, 0);
        -:  932:
        -:  933:		//discard trashed card
    #####:  934:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  935:		{
    #####:  936:			if (state->hand[currentPlayer][i] == j)
        -:  937:			{
    #####:  938:				discardCard(i, currentPlayer, state, 0);
    #####:  939:				break;
        -:  940:			}
        -:  941:		}
        -:  942:
    #####:  943:		return 0;
        -:  944:
        -:  945:	case remodel:
        -:  946:
    #####:  947:		return playRemodel(state, currentPlayer, choice1, choice2, handPos);
        -:  948:
        -:  949:	case smithy:
        -:  950:
        2:  951:		playSmithy(state, currentPlayer, handPos);
        2:  952:		return 0;
        -:  953:
        -:  954:	case village:
        -:  955:		//+1 Card
    #####:  956:		drawCard(currentPlayer, state);
        -:  957:
        -:  958:		//+2 Actions
    #####:  959:		state->numActions = state->numActions + 2;
        -:  960:
        -:  961:		//discard played card from hand
    #####:  962:		discardCard(handPos, currentPlayer, state, 0);
    #####:  963:		return 0;
        -:  964:
        -:  965:	case baron:
        -:  966:
    #####:  967:		playBaron(state, currentPlayer, choice1, handPos);
    #####:  968:		return 0;
        -:  969:
        -:  970:	case great_hall:
        -:  971:		//+1 Card
        4:  972:		drawCard(currentPlayer, state);
        -:  973:
        -:  974:		//+1 Actions
        4:  975:		state->numActions++;
        -:  976:
        -:  977:		//discard card from hand
        4:  978:		discardCard(handPos, currentPlayer, state, 0);
        4:  979:		return 0;
        -:  980:
        -:  981:	case minion:
        -:  982:		//+1 action
    #####:  983:		state->numActions++;
        -:  984:
        -:  985:		//discard card from hand
    #####:  986:		discardCard(handPos, currentPlayer, state, 0);
        -:  987:
    #####:  988:		if (choice1)		//+2 coins
        -:  989:		{
    #####:  990:			state->coins = state->coins + 2;
        -:  991:		}
        -:  992:
    #####:  993:		else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  994:		{
        -:  995:			//discard hand
    #####:  996:			while (numHandCards(state) > 0)
        -:  997:			{
    #####:  998:				discardCard(handPos, currentPlayer, state, 0);
        -:  999:			}
        -: 1000:
        -: 1001:			//draw 4
    #####: 1002:			for (i = 0; i < 4; i++)
        -: 1003:			{
    #####: 1004:				drawCard(currentPlayer, state);
        -: 1005:			}
        -: 1006:
        -: 1007:			//other players discard hand and redraw if hand size > 4
    #####: 1008:			for (i = 0; i < state->numPlayers; i++)
        -: 1009:			{
    #####: 1010:				if (i != currentPlayer)
        -: 1011:				{
    #####: 1012:					if (state->handCount[i] > 4)
        -: 1013:					{
        -: 1014:						//discard hand
    #####: 1015:						while (state->handCount[i] > 0)
        -: 1016:						{
    #####: 1017:							discardCard(handPos, i, state, 0);
        -: 1018:						}
        -: 1019:
        -: 1020:						//draw 4
    #####: 1021:						for (j = 0; j < 4; j++)
        -: 1022:						{
    #####: 1023:							drawCard(i, state);
        -: 1024:						}
        -: 1025:					}
        -: 1026:				}
        -: 1027:			}
        -: 1028:
        -: 1029:		}
    #####: 1030:		return 0;
        -: 1031:
        -: 1032:	case steward:
        3: 1033:		if (choice1 == 1)
        -: 1034:		{
        -: 1035:			//+2 cards
        1: 1036:			drawCard(currentPlayer, state);
        1: 1037:			drawCard(currentPlayer, state);
        -: 1038:		}
        2: 1039:		else if (choice1 == 2)
        -: 1040:		{
        -: 1041:			//+2 coins
    #####: 1042:			state->coins = state->coins + 2;
        -: 1043:		}
        -: 1044:		else
        -: 1045:		{
        -: 1046:			//trash 2 cards in hand
        2: 1047:			discardCard(choice2, currentPlayer, state, 1);
        2: 1048:			discardCard(choice3, currentPlayer, state, 1);
        -: 1049:		}
        -: 1050:
        -: 1051:		//discard card from hand
        3: 1052:		discardCard(handPos, currentPlayer, state, 0);
        3: 1053:		return 0;
        -: 1054:
        -: 1055:	case tribute:
    #####: 1056:		if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####: 1057:			if (state->deckCount[nextPlayer] > 0){
    #####: 1058:				tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1059:				state->deckCount[nextPlayer]--;
        -: 1060:			}
    #####: 1061:			else if (state->discardCount[nextPlayer] > 0){
    #####: 1062:				tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer] - 1];
    #####: 1063:				state->discardCount[nextPlayer]--;
        -: 1064:			}
        -: 1065:			else{
        -: 1066:				//No Card to Reveal
        -: 1067:				if (DEBUG){
        -: 1068:					printf("No cards to reveal\n");
        -: 1069:				}
        -: 1070:			}
        -: 1071:		}
        -: 1072:
        -: 1073:		else{
    #####: 1074:			if (state->deckCount[nextPlayer] == 0){
    #####: 1075:				for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####: 1076:					state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1077:					state->deckCount[nextPlayer]++;
    #####: 1078:					state->discard[nextPlayer][i] = -1;
    #####: 1079:					state->discardCount[nextPlayer]--;
        -: 1080:				}
        -: 1081:
    #####: 1082:				shuffle(nextPlayer, state);//Shuffle the deck
        -: 1083:			}
    #####: 1084:			tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1085:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1086:			state->deckCount[nextPlayer]--;
    #####: 1087:			tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1088:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1089:			state->deckCount[nextPlayer]--;
        -: 1090:		}
        -: 1091:
    #####: 1092:		if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
    #####: 1093:			state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1094:			state->playedCardCount++;
    #####: 1095:			tributeRevealedCards[1] = -1;
        -: 1096:		}
        -: 1097:
    #####: 1098:		for (i = 0; i <= 2; i++){
    #####: 1099:			if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
    #####: 1100:				state->coins += 2;
        -: 1101:			}
        -: 1102:
    #####: 1103:			else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
    #####: 1104:				drawCard(currentPlayer, state);
    #####: 1105:				drawCard(currentPlayer, state);
        -: 1106:			}
        -: 1107:			else{//Action Card
    #####: 1108:				state->numActions = state->numActions + 2;
        -: 1109:			}
        -: 1110:		}
        -: 1111:
    #####: 1112:		return 0;
        -: 1113:
        -: 1114:	case ambassador:
        7: 1115:		j = 0;		//used to check if player has enough cards to discard
        -: 1116:
        7: 1117:		if (choice2 > 2 || choice2 < 0)
        -: 1118:		{
        4: 1119:			return -1;
        -: 1120:		}
        -: 1121:
        3: 1122:		if (choice1 == handPos)
        -: 1123:		{
    #####: 1124:			return -1;
        -: 1125:		}
        -: 1126:
       18: 1127:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1128:		{
       15: 1129:			if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1130:			{
        3: 1131:				j++;
        -: 1132:			}
        -: 1133:		}
        3: 1134:		if (j < choice2)
        -: 1135:		{
        1: 1136:			return -1;
        -: 1137:		}
        -: 1138:
        -: 1139:		if (DEBUG)
        -: 1140:			printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1141:
        -: 1142:		//increase supply count for choosen card by amount being discarded
        2: 1143:		state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1144:
        -: 1145:		//each other player gains a copy of revealed card
        8: 1146:		for (i = 0; i < state->numPlayers; i++)
        -: 1147:		{
        6: 1148:			if (i != currentPlayer)
        -: 1149:			{
        4: 1150:				gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1151:			}
        -: 1152:		}
        -: 1153:
        -: 1154:		//discard played card from hand
        2: 1155:		discardCard(handPos, currentPlayer, state, 0);
        -: 1156:
        -: 1157:		//trash copies of cards returned to supply
        3: 1158:		for (j = 0; j < choice2; j++)
        -: 1159:		{
        1: 1160:			for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1161:			{
        1: 1162:				if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1163:				{
        1: 1164:					discardCard(i, currentPlayer, state, 1);
        1: 1165:					break;
        -: 1166:				}
        -: 1167:			}
        -: 1168:		}
        -: 1169:
        2: 1170:		return 0;
        -: 1171:
        -: 1172:	case cutpurse:
        -: 1173:
    #####: 1174:		updateCoins(currentPlayer, state, 2);
    #####: 1175:		for (i = 0; i < state->numPlayers; i++)
        -: 1176:		{
    #####: 1177:			if (i != currentPlayer)
        -: 1178:			{
    #####: 1179:				for (j = 0; j < state->handCount[i]; j++)
        -: 1180:				{
    #####: 1181:					if (state->hand[i][j] == copper)
        -: 1182:					{
    #####: 1183:						discardCard(j, i, state, 0);
    #####: 1184:						break;
        -: 1185:					}
    #####: 1186:					if (j == state->handCount[i])
        -: 1187:					{
    #####: 1188:						for (k = 0; k < state->handCount[i]; k++)
        -: 1189:						{
        -: 1190:							if (DEBUG)
        -: 1191:								printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1192:						}
    #####: 1193:						break;
        -: 1194:					}
        -: 1195:				}
        -: 1196:
        -: 1197:			}
        -: 1198:
        -: 1199:		}
        -: 1200:
        -: 1201:		//discard played card from hand
    #####: 1202:		discardCard(handPos, currentPlayer, state, 0);
        -: 1203:
    #####: 1204:		return 0;
        -: 1205:
        -: 1206:
        -: 1207:	case embargo:
        -: 1208:		//+2 Coins
        8: 1209:		state->coins = state->coins + 2;
        -: 1210:
        -: 1211:		//see if selected pile is in play
        8: 1212:		if (state->supplyCount[choice1] == -1)
        -: 1213:		{
        3: 1214:			return -1;
        -: 1215:		}
        -: 1216:
        -: 1217:		//add embargo token to selected supply pile
        5: 1218:		state->embargoTokens[choice1]++;
        -: 1219:
        -: 1220:		//trash card
        5: 1221:		discardCard(handPos, currentPlayer, state, 1);
        5: 1222:		return 0;
        -: 1223:
        -: 1224:	case outpost:
        -: 1225:		//set outpost flag
    #####: 1226:		state->outpostPlayed++;
        -: 1227:
        -: 1228:		//discard card
    #####: 1229:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1230:		return 0;
        -: 1231:
        -: 1232:	case salvager:
        -: 1233:		//+1 buy
        1: 1234:		state->numBuys++;
        -: 1235:
        1: 1236:		if (choice1)
        -: 1237:		{
        -: 1238:			//gain coins equal to trashed card
        1: 1239:			state->coins = state->coins + getCost(handCard(choice1, state));
        -: 1240:			//trash card
        1: 1241:			discardCard(choice1, currentPlayer, state, 1);
        -: 1242:		}
        -: 1243:
        -: 1244:		//discard card
        1: 1245:		discardCard(handPos, currentPlayer, state, 0);
        1: 1246:		return 0;
        -: 1247:
        -: 1248:	case sea_hag:
    #####: 1249:		for (i = 0; i < state->numPlayers; i++){
    #####: 1250:			if (i != currentPlayer){
    #####: 1251:				state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1252:				state->discardCount[i]++;
    #####: 1253:				state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1254:			}
        -: 1255:		}
    #####: 1256:		return 0;
        -: 1257:
        -: 1258:	case treasure_map:
        -: 1259:
        1: 1260:		return playTreasureMap(state, currentPlayer, handPos);
        -: 1261:	}
    #####: 1262:	return -1;
        -: 1263:}
        -: 1264:
       25: 1265:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1266:{
        -: 1267:
        -: 1268:	//if card is not trashed, added to Played pile 
       25: 1269:	if (trashFlag < 1)
        -: 1270:	{
        -: 1271:		//add card to played pile
       12: 1272:		state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
       12: 1273:		state->playedCardCount++;
        -: 1274:	}
        -: 1275:
        -: 1276:	//set played card to -1
       25: 1277:	state->hand[currentPlayer][handPos] = -1;
        -: 1278:
        -: 1279:	//remove card from player's hand
       25: 1280:	if (handPos == (state->handCount[currentPlayer] - 1)) 	//last card in hand array is played
        -: 1281:	{
        -: 1282:		//reduce number of cards in hand
        3: 1283:		state->handCount[currentPlayer]--;
        -: 1284:	}
       22: 1285:	else if (state->handCount[currentPlayer] == 1) //only one card in hand
        -: 1286:	{
        -: 1287:		//reduce number of cards in hand
    #####: 1288:		state->handCount[currentPlayer]--;
        -: 1289:	}
        -: 1290:	else
        -: 1291:	{
        -: 1292:		//replace discarded card with last card in hand
       22: 1293:		state->hand[currentPlayer][handPos] = state->hand[currentPlayer][(state->handCount[currentPlayer] - 1)];
        -: 1294:		//set last card to -1
       22: 1295:		state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1296:		//reduce number of cards in hand
       22: 1297:		state->handCount[currentPlayer]--;
        -: 1298:	}
        -: 1299:
       25: 1300:	return 0;
        -: 1301:}
        -: 1302:
       92: 1303:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1304:{
        -: 1305:	//Note: supplyPos is enum of choosen card
        -: 1306:
        -: 1307:	//check if supply pile is empty (0) or card is not used in game (-1)
       92: 1308:	if (supplyCount(supplyPos, state) < 1)
        -: 1309:	{
    #####: 1310:		return -1;
        -: 1311:	}
        -: 1312:
        -: 1313:	//added card for [whoseTurn] current player:
        -: 1314:	// toFlag = 0 : add to discard
        -: 1315:	// toFlag = 1 : add to deck
        -: 1316:	// toFlag = 2 : add to hand
        -: 1317:
       92: 1318:	if (toFlag == 1)
        -: 1319:	{
        4: 1320:		state->deck[player][state->deckCount[player]] = supplyPos;
        4: 1321:		state->deckCount[player]++;
        -: 1322:	}
       88: 1323:	else if (toFlag == 2)
        -: 1324:	{
    #####: 1325:		state->hand[player][state->handCount[player]] = supplyPos;
    #####: 1326:		state->handCount[player]++;
        -: 1327:	}
        -: 1328:	else
        -: 1329:	{
       88: 1330:		state->discard[player][state->discardCount[player]] = supplyPos;
       88: 1331:		state->discardCount[player]++;
        -: 1332:	}
        -: 1333:
        -: 1334:	//decrease number in supply pile
       92: 1335:	state->supplyCount[supplyPos]--;
        -: 1336:
       92: 1337:	return 0;
        -: 1338:}
        -: 1339:
      118: 1340:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1341:{
        -: 1342:	int i;
        -: 1343:
        -: 1344:	//reset coin count
      118: 1345:	state->coins = 0;
        -: 1346:
        -: 1347:	//add coins for each Treasure card in player's hand
      695: 1348:	for (i = 0; i < state->handCount[player]; i++)
        -: 1349:	{
      577: 1350:		if (state->hand[player][i] == copper)
        -: 1351:		{
      253: 1352:			state->coins += 1;
        -: 1353:		}
      324: 1354:		else if (state->hand[player][i] == silver)
        -: 1355:		{
       14: 1356:			state->coins += 2;
        -: 1357:		}
      310: 1358:		else if (state->hand[player][i] == gold)
        -: 1359:		{
       15: 1360:			state->coins += 3;
        -: 1361:		}
        -: 1362:	}
        -: 1363:
        -: 1364:	//add bonus
      118: 1365:	state->coins += bonus;
        -: 1366:
      118: 1367:	return 0;
        -: 1368:}
        -: 1369:
        -: 1370:
        -: 1371://end of dominion.c
File 'dominion.c'
Lines executed:52.06% of 557
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
     1284:    8:int compare(const void* a, const void* b) {
     1284:    9:	if (*(int*)a > *(int*)b)
      447:   10:		return 1;
      837:   11:	if (*(int*)a < *(int*)b)
      394:   12:		return -1;
      443:   13:	return 0;
        -:   14:}
        -:   15:
        2:   16:struct gameState* newGame() {
        2:   17:	struct gameState* g = malloc(sizeof(struct gameState));
        2:   18:	return g;
        -:   19:}
        -:   20:
       17:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:	int k8, int k9, int k10) {
       17:   23:	int* k = malloc(10 * sizeof(int));
       17:   24:	k[0] = k1;
       17:   25:	k[1] = k2;
       17:   26:	k[2] = k3;
       17:   27:	k[3] = k4;
       17:   28:	k[4] = k5;
       17:   29:	k[5] = k6;
       17:   30:	k[6] = k7;
       17:   31:	k[7] = k8;
       17:   32:	k[8] = k9;
       17:   33:	k[9] = k10;
       17:   34:	return k;
        -:   35:}
        -:   36:
       17:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		struct gameState *state) {
        -:   39:
        -:   40:	int i;
        -:   41:	int j;
        -:   42:	int it;
        -:   43:	//set up random number generator
       17:   44:	SelectStream(1);
       17:   45:	PutSeed((long)randomSeed);
        -:   46:
        -:   47:	//check number of players
       17:   48:	if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:	{
    #####:   50:		return -1;
        -:   51:	}
        -:   52:
        -:   53:	//set number of players
       17:   54:	state->numPlayers = numPlayers;
        -:   55:
        -:   56:	//check selected kingdom cards are different
       48:   57:	for (i = 0; i < 10; i++)
        -:   58:	{
      446:   59:		for (j = 0; j < 10; j++)
        -:   60:		{
      415:   61:			if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:			{
       16:   63:				return -1;
        -:   64:			}
        -:   65:		}
        -:   66:	}
        -:   67:
        -:   68:
        -:   69:	//initialize supply
        -:   70:	///////////////////////////////
        -:   71:
        -:   72:	//set number of Curse cards
        1:   73:	if (numPlayers == 2)
        -:   74:	{
    #####:   75:		state->supplyCount[curse] = 10;
        -:   76:	}
        1:   77:	else if (numPlayers == 3)
        -:   78:	{
        1:   79:		state->supplyCount[curse] = 20;
        -:   80:	}
        -:   81:	else
        -:   82:	{
    #####:   83:		state->supplyCount[curse] = 30;
        -:   84:	}
        -:   85:
        -:   86:	//set number of Victory cards
        1:   87:	if (numPlayers == 2)
        -:   88:	{
    #####:   89:		state->supplyCount[estate] = 8;
    #####:   90:		state->supplyCount[duchy] = 8;
    #####:   91:		state->supplyCount[province] = 8;
        -:   92:	}
        -:   93:	else
        -:   94:	{
        1:   95:		state->supplyCount[estate] = 12;
        1:   96:		state->supplyCount[duchy] = 12;
        1:   97:		state->supplyCount[province] = 12;
        -:   98:	}
        -:   99:
        -:  100:	//set number of Treasure cards
        1:  101:	state->supplyCount[copper] = 60 - (7 * numPlayers);
        1:  102:	state->supplyCount[silver] = 40;
        1:  103:	state->supplyCount[gold] = 30;
        -:  104:
        -:  105:	//set number of Kingdom cards
       21:  106:	for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:	{
      165:  108:		for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:		{
      155:  110:			if (kingdomCards[j] == i)
        -:  111:			{
        -:  112:				//check if card is a 'Victory' Kingdom card
       10:  113:				if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:				{
        2:  115:					if (numPlayers == 2){
    #####:  116:						state->supplyCount[i] = 8;
        -:  117:					}
        1:  118:					else{ state->supplyCount[i] = 12; }
        -:  119:				}
        -:  120:				else
        -:  121:				{
        9:  122:					state->supplyCount[i] = 10;
        -:  123:				}
       10:  124:				break;
        -:  125:			}
        -:  126:			else    //card is not in the set choosen for the game
        -:  127:			{
      145:  128:				state->supplyCount[i] = -1;
        -:  129:			}
        -:  130:		}
        -:  131:
        -:  132:	}
        -:  133:
        -:  134:	////////////////////////
        -:  135:	//supply intilization complete
        -:  136:
        -:  137:	//set player decks
        4:  138:	for (i = 0; i < numPlayers; i++)
        -:  139:	{
        3:  140:		state->deckCount[i] = 0;
       12:  141:		for (j = 0; j < 3; j++)
        -:  142:		{
        9:  143:			state->deck[i][j] = estate;
        9:  144:			state->deckCount[i]++;
        -:  145:		}
       24:  146:		for (j = 3; j < 10; j++)
        -:  147:		{
       21:  148:			state->deck[i][j] = copper;
       21:  149:			state->deckCount[i]++;
        -:  150:		}
        -:  151:	}
        -:  152:
        -:  153:	//shuffle player decks
        4:  154:	for (i = 0; i < numPlayers; i++)
        -:  155:	{
        3:  156:		if (shuffle(i, state) < 0)
        -:  157:		{
    #####:  158:			return -1;
        -:  159:		}
        -:  160:	}
        -:  161:
        -:  162:	//draw player hands
        4:  163:	for (i = 0; i < numPlayers; i++)
        -:  164:	{
        -:  165:		//initialize hand size to zero
        3:  166:		state->handCount[i] = 0;
        3:  167:		state->discardCount[i] = 0;
        -:  168:		//draw 5 cards
        -:  169:		// for (j = 0; j < 5; j++)
        -:  170:		//	{
        -:  171:		//	  drawCard(i, state);
        -:  172:		//	}
        -:  173:	}
        -:  174:
        -:  175:	//set embargo tokens to 0 for all supply piles
       28:  176:	for (i = 0; i <= treasure_map; i++)
        -:  177:	{
       27:  178:		state->embargoTokens[i] = 0;
        -:  179:	}
        -:  180:
        -:  181:	//initialize first player's turn
        1:  182:	state->outpostPlayed = 0;
        1:  183:	state->phase = 0;
        1:  184:	state->numActions = 1;
        1:  185:	state->numBuys = 1;
        1:  186:	state->playedCardCount = 0;
        1:  187:	state->whoseTurn = 0;
        1:  188:	state->handCount[state->whoseTurn] = 0;
        -:  189:	//int it; move to top
        -:  190:
        -:  191:	//Moved draw cards to here, only drawing at the start of a turn
        6:  192:	for (it = 0; it < 5; it++){
        5:  193:		drawCard(state->whoseTurn, state);
        -:  194:	}
        -:  195:
        1:  196:	updateCoins(state->whoseTurn, state, 0);
        -:  197:
        1:  198:	return 0;
        -:  199:}
        -:  200:
       37:  201:int shuffle(int player, struct gameState *state) {
        -:  202:
        -:  203:
        -:  204:	int newDeck[MAX_DECK];
       37:  205:	int newDeckPos = 0;
        -:  206:	int card;
        -:  207:	int i;
        -:  208:
       37:  209:	if (state->deckCount[player] < 1)
    #####:  210:		return -1;
       37:  211:	qsort((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
        -:  212:	/* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
      660:  214:	while (state->deckCount[player] > 0) {
      586:  215:		card = floor(Random() * state->deckCount[player]);
      586:  216:		newDeck[newDeckPos] = state->deck[player][card];
      586:  217:		newDeckPos++;
     2922:  218:		for (i = card; i < state->deckCount[player] - 1; i++) {
     2336:  219:			state->deck[player][i] = state->deck[player][i + 1];
        -:  220:		}
      586:  221:		state->deckCount[player]--;
        -:  222:	}
      623:  223:	for (i = 0; i < newDeckPos; i++) {
      586:  224:		state->deck[player][i] = newDeck[i];
      586:  225:		state->deckCount[player]++;
        -:  226:	}
        -:  227:
       37:  228:	return 0;
        -:  229:}
        -:  230:
      661:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state)
        -:  232:{
        -:  233:	int card;
      661:  234:	int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:	//check if it is the right phase
      661:  237:	if (state->phase != 0)
        -:  238:	{
      106:  239:		return -1;
        -:  240:	}
        -:  241:
        -:  242:	//check if player has enough actions
      555:  243:	if (state->numActions < 1)
        -:  244:	{
       10:  245:		return -1;
        -:  246:	}
        -:  247:
        -:  248:	//get card played
      545:  249:	card = handCard(handPos, state);
        -:  250:
        -:  251:	//check if selected card is an action
      545:  252:	if (card < adventurer || card > treasure_map)
        -:  253:	{
      484:  254:		return -1;
        -:  255:	}
        -:  256:
        -:  257:	//play card
       61:  258:	if (cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0)
        -:  259:	{
       45:  260:		return -1;
        -:  261:	}
        -:  262:
        -:  263:	//reduce number of actions
       16:  264:	state->numActions--;
        -:  265:
        -:  266:	//update coins (Treasure cards may be added with card draws)
       16:  267:	updateCoins(state->whoseTurn, state, coin_bonus);
        -:  268:
       16:  269:	return 0;
        -:  270:}
        -:  271:
      673:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:	int who;
        -:  274:	if (DEBUG){
        -:  275:		printf("Entering buyCard...\n");
        -:  276:	}
        -:  277:
        -:  278:	// I don't know what to do about the phase thing.
        -:  279:
      673:  280:	who = state->whoseTurn;
        -:  281:
      673:  282:	if (state->numBuys < 1){
        -:  283:		if (DEBUG)
        -:  284:			printf("You do not have any buys left\n");
       88:  285:		return -1;
        -:  286:	}
      585:  287:	else if (supplyCount(supplyPos, state) < 1){
        -:  288:		if (DEBUG)
        -:  289:			printf("There are not any of that type of card left\n");
      216:  290:		return -1;
        -:  291:	}
      369:  292:	else if (state->coins < getCost(supplyPos)){
        -:  293:		if (DEBUG)
        -:  294:			printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
      277:  295:		return -1;
        -:  296:	}
        -:  297:	else {
       92:  298:		state->phase = 1;
        -:  299:		//state->supplyCount[supplyPos]--;
       92:  300:		gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  301:
       92:  302:		state->coins = (state->coins) - (getCost(supplyPos));
       92:  303:		state->numBuys--;
        -:  304:		if (DEBUG)
        -:  305:			printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  306:	}
        -:  307:
        -:  308:	//state->discard[who][state->discardCount[who]] = supplyPos;
        -:  309:	//state->discardCount[who]++;
        -:  310:
       92:  311:	return 0;
        -:  312:}
        -:  313:
    #####:  314:int numHandCards(struct gameState *state) {
    #####:  315:	return state->handCount[whoseTurn(state)];
        -:  316:}
        -:  317:
      545:  318:int handCard(int handPos, struct gameState *state) {
      545:  319:	int currentPlayer = whoseTurn(state);
      545:  320:	return state->hand[currentPlayer][handPos];
        -:  321:}
        -:  322:
      683:  323:int supplyCount(int card, struct gameState *state) {
      683:  324:	return state->supplyCount[card];
        -:  325:}
        -:  326:
    #####:  327:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  328:	int i;
    #####:  329:	int count = 0;
        -:  330:
    #####:  331:	for (i = 0; i < state->deckCount[player]; i++)
        -:  332:	{
    #####:  333:		if (state->deck[player][i] == card) count++;
        -:  334:	}
        -:  335:
    #####:  336:	for (i = 0; i < state->handCount[player]; i++)
        -:  337:	{
    #####:  338:		if (state->hand[player][i] == card) count++;
        -:  339:	}
        -:  340:
    #####:  341:	for (i = 0; i < state->discardCount[player]; i++)
        -:  342:	{
    #####:  343:		if (state->discard[player][i] == card) count++;
        -:  344:	}
        -:  345:
    #####:  346:	return count;
        -:  347:}
        -:  348:
      711:  349:int whoseTurn(struct gameState *state) {
      711:  350:	return state->whoseTurn;
        -:  351:}
        -:  352:
      105:  353:int endTurn(struct gameState *state) {
        -:  354:	int k;
        -:  355:	int i;
      105:  356:	int currentPlayer = whoseTurn(state);
        -:  357:
        -:  358:	//Discard hand
      600:  359:	for (i = 0; i < state->handCount[currentPlayer]; i++){
      495:  360:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
      495:  361:		state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  362:	}
      105:  363:	state->handCount[currentPlayer] = 0;//Reset hand count
        -:  364:
        -:  365:	//Code for determining the player
      105:  366:	if (currentPlayer < (state->numPlayers - 1)){
       70:  367:		state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  368:	}
        -:  369:	else{
       35:  370:		state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  371:	}
        -:  372:
      105:  373:	state->outpostPlayed = 0;
      105:  374:	state->phase = 0;
      105:  375:	state->numActions = 1;
      105:  376:	state->coins = 0;
      105:  377:	state->numBuys = 1;
      105:  378:	state->playedCardCount = 0;
      105:  379:	state->handCount[state->whoseTurn] = 0;
        -:  380:
        -:  381:	//int k; move to top
        -:  382:	//Next player draws hand
      630:  383:	for (k = 0; k < 5; k++){
      525:  384:		drawCard(state->whoseTurn, state);//Draw a card
        -:  385:	}
        -:  386:
        -:  387:	//Update money
      105:  388:	updateCoins(state->whoseTurn, state, 0);
        -:  389:
      105:  390:	return 0;
        -:  391:}
        -:  392:
     1973:  393:int isGameOver(struct gameState *state) {
        -:  394:	int i;
        -:  395:	int j;
        -:  396:
        -:  397:	//if stack of Province cards is empty, the game ends
     1973:  398:	if (state->supplyCount[province] == 0)
        -:  399:	{
    #####:  400:		return 1;
        -:  401:	}
        -:  402:
        -:  403:	//if three supply pile are at 0, the game ends
     1973:  404:	j = 0;
    51298:  405:	for (i = 0; i < 25; i++)
        -:  406:	{
    49325:  407:		if (state->supplyCount[i] == 0)
        -:  408:		{
      869:  409:			j++;
        -:  410:		}
        -:  411:	}
     1973:  412:	if (j >= 3)
        -:  413:	{
        1:  414:		return 1;
        -:  415:	}
        -:  416:
     1972:  417:	return 0;
        -:  418:}
        -:  419:
    #####:  420:int scoreFor(int player, struct gameState *state) {
        -:  421:
        -:  422:	int i;
    #####:  423:	int score = 0;
        -:  424:	//score from hand
    #####:  425:	for (i = 0; i < state->handCount[player]; i++)
        -:  426:	{
    #####:  427:		if (state->hand[player][i] == curse) { score = score - 1; };
    #####:  428:		if (state->hand[player][i] == estate) { score = score + 1; };
    #####:  429:		if (state->hand[player][i] == duchy) { score = score + 3; };
    #####:  430:		if (state->hand[player][i] == province) { score = score + 6; };
    #####:  431:		if (state->hand[player][i] == great_hall) { score = score + 1; };
    #####:  432:		if (state->hand[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  433:	}
        -:  434:
        -:  435:	//score from discard
    #####:  436:	for (i = 0; i < state->discardCount[player]; i++)
        -:  437:	{
    #####:  438:		if (state->discard[player][i] == curse) { score = score - 1; };
    #####:  439:		if (state->discard[player][i] == estate) { score = score + 1; };
    #####:  440:		if (state->discard[player][i] == duchy) { score = score + 3; };
    #####:  441:		if (state->discard[player][i] == province) { score = score + 6; };
    #####:  442:		if (state->discard[player][i] == great_hall) { score = score + 1; };
    #####:  443:		if (state->discard[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  444:	}
        -:  445:
        -:  446:	//score from deck
    #####:  447:	for (i = 0; i < state->discardCount[player]; i++)
        -:  448:	{
    #####:  449:		if (state->deck[player][i] == curse) { score = score - 1; };
    #####:  450:		if (state->deck[player][i] == estate) { score = score + 1; };
    #####:  451:		if (state->deck[player][i] == duchy) { score = score + 3; };
    #####:  452:		if (state->deck[player][i] == province) { score = score + 6; };
    #####:  453:		if (state->deck[player][i] == great_hall) { score = score + 1; };
    #####:  454:		if (state->deck[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  455:	}
        -:  456:
    #####:  457:	return score;
        -:  458:}
        -:  459:
    #####:  460:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  461:	int i;
        -:  462:	int j;
        -:  463:	int highScore;
        -:  464:	int currentPlayer;
        -:  465:
        -:  466:	//get score for each player
    #####:  467:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  468:	{
        -:  469:		//set unused player scores to -9999
    #####:  470:		if (i >= state->numPlayers)
        -:  471:		{
    #####:  472:			players[i] = -9999;
        -:  473:		}
        -:  474:		else
        -:  475:		{
    #####:  476:			players[i] = scoreFor(i, state);
        -:  477:		}
        -:  478:	}
        -:  479:
        -:  480:	//find highest score
    #####:  481:	j = 0;
    #####:  482:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  483:	{
    #####:  484:		if (players[i] > players[j])
        -:  485:		{
    #####:  486:			j = i;
        -:  487:		}
        -:  488:	}
    #####:  489:	highScore = players[j];
        -:  490:
        -:  491:	//add 1 to players who had less turns
    #####:  492:	currentPlayer = whoseTurn(state);
    #####:  493:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  494:	{
    #####:  495:		if (players[i] == highScore && i > currentPlayer)
        -:  496:		{
    #####:  497:			players[i]++;
        -:  498:		}
        -:  499:	}
        -:  500:
        -:  501:	//find new highest score
    #####:  502:	j = 0;
    #####:  503:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  504:	{
    #####:  505:		if (players[i] > players[j])
        -:  506:		{
    #####:  507:			j = i;
        -:  508:		}
        -:  509:	}
    #####:  510:	highScore = players[j];
        -:  511:
        -:  512:	//set winners in array to 1 and rest to 0
    #####:  513:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  514:	{
    #####:  515:		if (players[i] == highScore)
        -:  516:		{
    #####:  517:			players[i] = 1;
        -:  518:		}
        -:  519:		else
        -:  520:		{
    #####:  521:			players[i] = 0;
        -:  522:		}
        -:  523:	}
        -:  524:
    #####:  525:	return 0;
        -:  526:}
        -:  527:
      539:  528:int drawCard(int player, struct gameState *state)
        -:  529:{
        -:  530:	int count;
        -:  531:	int deckCounter;
      539:  532:	if (state->deckCount[player] <= 0){//Deck is empty
        -:  533:
        -:  534:		//Step 1 Shuffle the discard pile back into a deck
        -:  535:		int i;
        -:  536:		//Move discard to deck
      590:  537:		for (i = 0; i < state->discardCount[player]; i++){
      556:  538:			state->deck[player][i] = state->discard[player][i];
      556:  539:			state->discard[player][i] = -1;
        -:  540:		}
        -:  541:
       34:  542:		state->deckCount[player] = state->discardCount[player];
       34:  543:		state->discardCount[player] = 0;//Reset discard
        -:  544:
        -:  545:		//Shufffle the deck
       34:  546:		shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  547:
        -:  548:		if (DEBUG){//Debug statements
        -:  549:			printf("Deck count now: %d\n", state->deckCount[player]);
        -:  550:		}
        -:  551:
       34:  552:		state->discardCount[player] = 0;
        -:  553:
        -:  554:		//Step 2 Draw Card
       34:  555:		count = state->handCount[player];//Get current player's hand count
        -:  556:
        -:  557:		if (DEBUG){//Debug statements
        -:  558:			printf("Current hand count: %d\n", count);
        -:  559:		}
        -:  560:
       34:  561:		deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  562:
       34:  563:		if (deckCounter == 0)
    #####:  564:			return -1;
        -:  565:
       34:  566:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
       34:  567:		state->deckCount[player]--;
       34:  568:		state->handCount[player]++;//Increment hand count
        -:  569:	}
        -:  570:
        -:  571:	else{
      505:  572:		int count = state->handCount[player];//Get current hand count for player
        -:  573:		int deckCounter;
        -:  574:		if (DEBUG){//Debug statements
        -:  575:			printf("Current hand count: %d\n", count);
        -:  576:		}
        -:  577:
      505:  578:		deckCounter = state->deckCount[player];//Create holder for the deck count
      505:  579:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
      505:  580:		state->deckCount[player]--;
      505:  581:		state->handCount[player]++;//Increment hand count
        -:  582:	}
        -:  583:
      539:  584:	return 0;
        -:  585:}
        -:  586:
      461:  587:int getCost(int cardNumber)
        -:  588:{
      461:  589:	switch (cardNumber)
        -:  590:	{
        -:  591:	case curse:
       30:  592:		return 0;
        -:  593:	case estate:
       26:  594:		return 2;
        -:  595:	case duchy:
       26:  596:		return 5;
        -:  597:	case province:
       21:  598:		return 8;
        -:  599:	case copper:
       42:  600:		return 0;
        -:  601:	case silver:
       35:  602:		return 3;
        -:  603:	case gold:
       35:  604:		return 6;
        -:  605:	case adventurer:
       26:  606:		return 6;
        -:  607:	case council_room:
       25:  608:		return 5;
        -:  609:	case feast:
    #####:  610:		return 4;
        -:  611:	case gardens:
       24:  612:		return 4;
        -:  613:	case mine:
    #####:  614:		return 5;
        -:  615:	case remodel:
       18:  616:		return 4;
        -:  617:	case smithy:
    #####:  618:		return 4;
        -:  619:	case village:
    #####:  620:		return 3;
        -:  621:	case baron:
    #####:  622:		return 4;
        -:  623:	case great_hall:
    #####:  624:		return 3;
        -:  625:	case minion:
       24:  626:		return 5;
        -:  627:	case steward:
       31:  628:		return 3;
        -:  629:	case tribute:
       22:  630:		return 5;
        -:  631:	case ambassador:
       28:  632:		return 3;
        -:  633:	case cutpurse:
    #####:  634:		return 4;
        -:  635:	case embargo:
    #####:  636:		return 2;
        -:  637:	case outpost:
       25:  638:		return 5;
        -:  639:	case salvager:
    #####:  640:		return 4;
        -:  641:	case sea_hag:
       23:  642:		return 4;
        -:  643:	case treasure_map:
    #####:  644:		return 4;
        -:  645:	}
        -:  646:
    #####:  647:	return -1;
        -:  648:}
        -:  649:
        1:  650:void playAdventurer(struct gameState *state, int currentPlayer)
        -:  651:// Reveal cards from deck until 2 Treasure cards are found.  Put those Treasure cards in the hand and discard the rest.
        -:  652:{
        1:  653:	int drawntreasure = 0;
        -:  654:	int temphand[MAX_HAND];
        -:  655:	int cardDrawn;
        1:  656:	int z = 0; // this is the counter for the temp hand
        -:  657:
        5:  658:	while (drawntreasure < 2){
        3:  659:		if (state->deckCount[currentPlayer] < 1){//if the deck is empty we need to shuffle discard and add to deck
    #####:  660:			shuffle(currentPlayer, state);
        -:  661:		}
        3:  662:		drawCard(currentPlayer, state);
        3:  663:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer] - 1];//top card of hand is most recently drawn card.
        3:  664:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
        2:  665:			drawntreasure++;
        -:  666:		else{
        1:  667:			temphand[z] = cardDrawn;
        1:  668:			state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
        1:  669:			z++;
        -:  670:		}
        -:  671:	}
        3:  672:	while (z - 1 >= 0){
        1:  673:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; // discard all cards in play that have been drawn
        1:  674:		z = z - 1;
        -:  675:	}
        1:  676:}
        -:  677:
    #####:  678:int playRemodel(struct gameState *state, int currentPlayer, int choice1, int choice2, int handPos)
        -:  679://Trash a card in the hand, and gain a card costing up to $2 more than the trashed card
        -:  680:{
        -:  681:	int i;
    #####:  682:	int j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  683:
    #####:  684:	if ((getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2))
        -:  685:	{
    #####:  686:		return -1;
        -:  687:	}
        -:  688:
    #####:  689:	gainCard(choice2, state, 0, currentPlayer);
        -:  690:
        -:  691:	//discard card from hand
    #####:  692:	discardCard(handPos, currentPlayer, state, 0);
        -:  693:
        -:  694:	//discard trashed card
    #####:  695:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  696:	{
    #####:  697:		if (state->hand[currentPlayer][i] == j)
        -:  698:		{
    #####:  699:			discardCard(i, currentPlayer, state, 0);
    #####:  700:			break;
        -:  701:		}
        -:  702:	}
        -:  703:
    #####:  704:	return 0;
        -:  705:}
        -:  706:
    #####:  707:void playSmithy(struct gameState *state, int currentPlayer, int handPos)
        -:  708:// Draw 3 cards
        -:  709:{
        -:  710:	int i;
    #####:  711:	for (i = 0; i < 3; i++)
        -:  712:	{
    #####:  713:		drawCard(currentPlayer, state);
        -:  714:	}
        -:  715:
        -:  716:	//discard card from hand
    #####:  717:	discardCard(handPos, currentPlayer, state, 0);
    #####:  718:}
        -:  719:
    #####:  720:void playBaron(struct gameState *state, int currentPlayer, int choice1, int handPos)
        -:  721://Add a buy.  OPTION:  Discard an Estate card and gain $4.  Otherwise, gain an Estate card.
        -:  722:{
    #####:  723:	state->numBuys++;//Increase buys by 1!
    #####:  724:	if (choice1 > 0){//Boolean true or going to discard an estate
    #####:  725:		int p = 0;//Iterator for hand!
    #####:  726:		int card_not_discarded = 1;//Flag for discard set!
    #####:  727:		while (card_not_discarded){
    #####:  728:			if (state->hand[currentPlayer][p] == estate){ //Found an estate card!
    #####:  729:				state->coins += 4;//Add 4 coins to the amount of coins
    #####:  730:				state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  731:				state->discardCount[currentPlayer]++;
    #####:  732:				for (; p < state->handCount[currentPlayer]; p++){
    #####:  733:					state->hand[currentPlayer][p] = state->hand[currentPlayer][p + 1];
        -:  734:				}
    #####:  735:				state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  736:				state->handCount[currentPlayer]--;
    #####:  737:				card_not_discarded = 0;//Exit the loop
        -:  738:			}
    #####:  739:			else if (p > state->handCount[currentPlayer]){
        -:  740:				if (DEBUG) {
        -:  741:					printf("No estate cards in your hand, invalid choice\n");
        -:  742:					printf("Must gain an estate if there are any\n");
        -:  743:				}
    #####:  744:				if (supplyCount(estate, state) > 0){
    #####:  745:					gainCard(estate, state, 1, currentPlayer);
    #####:  746:					state->supplyCount[estate]--;//Decrement estates
    #####:  747:					if (supplyCount(estate, state) == 0){
    #####:  748:						isGameOver(state);
        -:  749:					}
        -:  750:				}
    #####:  751:				card_not_discarded = 0;//Exit the loop
        -:  752:			}
        -:  753:
        -:  754:			else{
    #####:  755:				p++;//Next card
        -:  756:			}
        -:  757:		}
        -:  758:	}
        -:  759:
        -:  760:	else{
    #####:  761:		if (supplyCount(estate, state) > 0){
    #####:  762:			gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  763:			state->supplyCount[estate]--;//Decrement Estates
    #####:  764:			if (supplyCount(estate, state) == 0){
    #####:  765:				isGameOver(state);
        -:  766:			}
        -:  767:		}
        -:  768:	}
    #####:  769:}
        -:  770:
    #####:  771:int playTreasureMap(struct gameState *state, int currentPlayer, int handPos)
        -:  772://Trashing two treasure map cards from the hand = four gold on top of the deck.
        -:  773:{
        -:  774:	int i;
        -:  775:	int index;
        -:  776:
        -:  777:	//search hand for another treasure_map
    #####:  778:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  779:	{
    #####:  780:		if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -:  781:		{
    #####:  782:			index = i;
    #####:  783:			break;
        -:  784:		}
        -:  785:	}
    #####:  786:	if (index > -1)
        -:  787:	{
        -:  788:		//trash both treasure cards
    #####:  789:		discardCard(handPos, currentPlayer, state, 1);
    #####:  790:		discardCard(index, currentPlayer, state, 1);
        -:  791:
        -:  792:		//gain 4 Gold cards
    #####:  793:		for (i = 0; i < 4; i++)
        -:  794:		{
    #####:  795:			gainCard(gold, state, 1, currentPlayer);
        -:  796:		}
        -:  797:
        -:  798:		//return success
    #####:  799:		return 1;
        -:  800:	}
        -:  801:
        -:  802:	//no second treasure_map found in hand
    #####:  803:	return -1;
        -:  804:}
        -:  805:
       61:  806:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  807:{
        -:  808:	int i;
        -:  809:	int j;
        -:  810:	int k;
        -:  811:	//int x;  //Unused after while loop removed from feast.
       61:  812:	int currentPlayer = whoseTurn(state);
       61:  813:	int nextPlayer = currentPlayer + 1;
        -:  814:	int temphand[MAX_HAND];
        -:  815:
       61:  816:	int tributeRevealedCards[2] = { -1, -1 };
        -:  817:
       61:  818:	if (nextPlayer > (state->numPlayers - 1)){
       16:  819:		nextPlayer = 0;
        -:  820:	}
        -:  821:
        -:  822:	//uses switch to select card and perform actions
       61:  823:	switch (card)
        -:  824:	{
        -:  825:	case adventurer:
        -:  826:
        1:  827:		playAdventurer(state, currentPlayer);
        1:  828:		return 0;
        -:  829:
        -:  830:	case council_room:
        -:  831:		//+4 Cards
        5:  832:		for (i = 0; i < 4; i++)
        -:  833:		{
        4:  834:			drawCard(currentPlayer, state);
        -:  835:		}
        -:  836:
        -:  837:		//+1 Buy
        1:  838:		state->numBuys++;
        -:  839:
        -:  840:		//Each other player draws a card
        4:  841:		for (i = 0; i < state->numPlayers; i++)
        -:  842:		{
        3:  843:			if (i != currentPlayer)
        -:  844:			{
        2:  845:				drawCard(i, state);
        -:  846:			}
        -:  847:		}
        -:  848:
        -:  849:		//put played card in played card pile
        1:  850:		discardCard(handPos, currentPlayer, state, 0);
        -:  851:
        1:  852:		return 0;
        -:  853:
        -:  854:	case feast:
        -:  855:		//gain card with cost up to 5
        -:  856:		//Backup hand
    #####:  857:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  858:			temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  859:			state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  860:		}
        -:  861:		//Backup hand
        -:  862:
        -:  863:		//Update Coins for Buy
    #####:  864:		updateCoins(currentPlayer, state, 5);
        -:  865://		x = 1;//Condition to loop on
        -:  866://		while (x == 1) {//Buy one card
    #####:  867:			if (supplyCount(choice1, state) <= 0){
        -:  868:				if (DEBUG)
        -:  869:					printf("None of that card left, sorry!\n");
        -:  870:
        -:  871:				if (DEBUG){
        -:  872:					printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  873:				}
        -:  874:			}
    #####:  875:			else if (state->coins < getCost(choice1)){
    #####:  876:				printf("That card is too expensive!\n");
        -:  877:
        -:  878:				if (DEBUG){
        -:  879:					printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  880:				}
        -:  881:			}
        -:  882:			else{
        -:  883:
        -:  884:				if (DEBUG){
        -:  885:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  886:				}
        -:  887:
    #####:  888:				gainCard(choice1, state, 0, currentPlayer);//Gain the card
        -:  889://				x = 0;//No more buying cards
        -:  890:
        -:  891:				if (DEBUG){
        -:  892:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  893:				}
        -:  894:
        -:  895:			}
        -:  896://		}
        -:  897:
        -:  898:		//Reset Hand
    #####:  899:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  900:			state->hand[currentPlayer][i] = temphand[i];
    #####:  901:			temphand[i] = -1;
        -:  902:		}
        -:  903:		//Reset Hand
        -:  904:
    #####:  905:		return 0;
        -:  906:
        -:  907:	case gardens:
       13:  908:		return -1;
        -:  909:
        -:  910:	case mine:
    #####:  911:		j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  912:
    #####:  913:		if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  914:		{
    #####:  915:			return -1;
        -:  916:		}
        -:  917:
    #####:  918:		if (choice2 > treasure_map || choice2 < curse)
        -:  919:		{
    #####:  920:			return -1;
        -:  921:		}
        -:  922:
    #####:  923:		if ((getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2))
        -:  924:		{
    #####:  925:			return -1;
        -:  926:		}
        -:  927:
    #####:  928:		gainCard(choice2, state, 2, currentPlayer);
        -:  929:
        -:  930:		//discard card from hand
    #####:  931:		discardCard(handPos, currentPlayer, state, 0);
        -:  932:
        -:  933:		//discard trashed card
    #####:  934:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  935:		{
    #####:  936:			if (state->hand[currentPlayer][i] == j)
        -:  937:			{
    #####:  938:				discardCard(i, currentPlayer, state, 0);
    #####:  939:				break;
        -:  940:			}
        -:  941:		}
        -:  942:
    #####:  943:		return 0;
        -:  944:
        -:  945:	case remodel:
        -:  946:
    #####:  947:		return playRemodel(state, currentPlayer, choice1, choice2, handPos);
        -:  948:
        -:  949:	case smithy:
        -:  950:
    #####:  951:		playSmithy(state, currentPlayer, handPos);
    #####:  952:		return 0;
        -:  953:
        -:  954:	case village:
        -:  955:		//+1 Card
    #####:  956:		drawCard(currentPlayer, state);
        -:  957:
        -:  958:		//+2 Actions
    #####:  959:		state->numActions = state->numActions + 2;
        -:  960:
        -:  961:		//discard played card from hand
    #####:  962:		discardCard(handPos, currentPlayer, state, 0);
    #####:  963:		return 0;
        -:  964:
        -:  965:	case baron:
        -:  966:
    #####:  967:		playBaron(state, currentPlayer, choice1, handPos);
    #####:  968:		return 0;
        -:  969:
        -:  970:	case great_hall:
        -:  971:		//+1 Card
    #####:  972:		drawCard(currentPlayer, state);
        -:  973:
        -:  974:		//+1 Actions
    #####:  975:		state->numActions++;
        -:  976:
        -:  977:		//discard card from hand
    #####:  978:		discardCard(handPos, currentPlayer, state, 0);
    #####:  979:		return 0;
        -:  980:
        -:  981:	case minion:
        -:  982:		//+1 action
    #####:  983:		state->numActions++;
        -:  984:
        -:  985:		//discard card from hand
    #####:  986:		discardCard(handPos, currentPlayer, state, 0);
        -:  987:
    #####:  988:		if (choice1)		//+2 coins
        -:  989:		{
    #####:  990:			state->coins = state->coins + 2;
        -:  991:		}
        -:  992:
    #####:  993:		else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  994:		{
        -:  995:			//discard hand
    #####:  996:			while (numHandCards(state) > 0)
        -:  997:			{
    #####:  998:				discardCard(handPos, currentPlayer, state, 0);
        -:  999:			}
        -: 1000:
        -: 1001:			//draw 4
    #####: 1002:			for (i = 0; i < 4; i++)
        -: 1003:			{
    #####: 1004:				drawCard(currentPlayer, state);
        -: 1005:			}
        -: 1006:
        -: 1007:			//other players discard hand and redraw if hand size > 4
    #####: 1008:			for (i = 0; i < state->numPlayers; i++)
        -: 1009:			{
    #####: 1010:				if (i != currentPlayer)
        -: 1011:				{
    #####: 1012:					if (state->handCount[i] > 4)
        -: 1013:					{
        -: 1014:						//discard hand
    #####: 1015:						while (state->handCount[i] > 0)
        -: 1016:						{
    #####: 1017:							discardCard(handPos, i, state, 0);
        -: 1018:						}
        -: 1019:
        -: 1020:						//draw 4
    #####: 1021:						for (j = 0; j < 4; j++)
        -: 1022:						{
    #####: 1023:							drawCard(i, state);
        -: 1024:						}
        -: 1025:					}
        -: 1026:				}
        -: 1027:			}
        -: 1028:
        -: 1029:		}
    #####: 1030:		return 0;
        -: 1031:
        -: 1032:	case steward:
        8: 1033:		if (choice1 == 1)
        -: 1034:		{
        -: 1035:			//+2 cards
    #####: 1036:			drawCard(currentPlayer, state);
    #####: 1037:			drawCard(currentPlayer, state);
        -: 1038:		}
        8: 1039:		else if (choice1 == 2)
        -: 1040:		{
        -: 1041:			//+2 coins
    #####: 1042:			state->coins = state->coins + 2;
        -: 1043:		}
        -: 1044:		else
        -: 1045:		{
        -: 1046:			//trash 2 cards in hand
        8: 1047:			discardCard(choice2, currentPlayer, state, 1);
        8: 1048:			discardCard(choice3, currentPlayer, state, 1);
        -: 1049:		}
        -: 1050:
        -: 1051:		//discard card from hand
        8: 1052:		discardCard(handPos, currentPlayer, state, 0);
        8: 1053:		return 0;
        -: 1054:
        -: 1055:	case tribute:
    #####: 1056:		if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####: 1057:			if (state->deckCount[nextPlayer] > 0){
    #####: 1058:				tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1059:				state->deckCount[nextPlayer]--;
        -: 1060:			}
    #####: 1061:			else if (state->discardCount[nextPlayer] > 0){
    #####: 1062:				tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer] - 1];
    #####: 1063:				state->discardCount[nextPlayer]--;
        -: 1064:			}
        -: 1065:			else{
        -: 1066:				//No Card to Reveal
        -: 1067:				if (DEBUG){
        -: 1068:					printf("No cards to reveal\n");
        -: 1069:				}
        -: 1070:			}
        -: 1071:		}
        -: 1072:
        -: 1073:		else{
    #####: 1074:			if (state->deckCount[nextPlayer] == 0){
    #####: 1075:				for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####: 1076:					state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1077:					state->deckCount[nextPlayer]++;
    #####: 1078:					state->discard[nextPlayer][i] = -1;
    #####: 1079:					state->discardCount[nextPlayer]--;
        -: 1080:				}
        -: 1081:
    #####: 1082:				shuffle(nextPlayer, state);//Shuffle the deck
        -: 1083:			}
    #####: 1084:			tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1085:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1086:			state->deckCount[nextPlayer]--;
    #####: 1087:			tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1088:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1089:			state->deckCount[nextPlayer]--;
        -: 1090:		}
        -: 1091:
    #####: 1092:		if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
    #####: 1093:			state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1094:			state->playedCardCount++;
    #####: 1095:			tributeRevealedCards[1] = -1;
        -: 1096:		}
        -: 1097:
    #####: 1098:		for (i = 0; i <= 2; i++){
    #####: 1099:			if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
    #####: 1100:				state->coins += 2;
        -: 1101:			}
        -: 1102:
    #####: 1103:			else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
    #####: 1104:				drawCard(currentPlayer, state);
    #####: 1105:				drawCard(currentPlayer, state);
        -: 1106:			}
        -: 1107:			else{//Action Card
    #####: 1108:				state->numActions = state->numActions + 2;
        -: 1109:			}
        -: 1110:		}
        -: 1111:
    #####: 1112:		return 0;
        -: 1113:
        -: 1114:	case ambassador:
       35: 1115:		j = 0;		//used to check if player has enough cards to discard
        -: 1116:
       35: 1117:		if (choice2 > 2 || choice2 < 0)
        -: 1118:		{
       30: 1119:			return -1;
        -: 1120:		}
        -: 1121:
        5: 1122:		if (choice1 == handPos)
        -: 1123:		{
    #####: 1124:			return -1;
        -: 1125:		}
        -: 1126:
       30: 1127:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1128:		{
       25: 1129:			if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1130:			{
        3: 1131:				j++;
        -: 1132:			}
        -: 1133:		}
        5: 1134:		if (j < choice2)
        -: 1135:		{
        2: 1136:			return -1;
        -: 1137:		}
        -: 1138:
        -: 1139:		if (DEBUG)
        -: 1140:			printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1141:
        -: 1142:		//increase supply count for choosen card by amount being discarded
        3: 1143:		state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1144:
        -: 1145:		//each other player gains a copy of revealed card
       12: 1146:		for (i = 0; i < state->numPlayers; i++)
        -: 1147:		{
        9: 1148:			if (i != currentPlayer)
        -: 1149:			{
        6: 1150:				gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1151:			}
        -: 1152:		}
        -: 1153:
        -: 1154:		//discard played card from hand
        3: 1155:		discardCard(handPos, currentPlayer, state, 0);
        -: 1156:
        -: 1157:		//trash copies of cards returned to supply
        5: 1158:		for (j = 0; j < choice2; j++)
        -: 1159:		{
        8: 1160:			for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1161:			{
        7: 1162:				if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1163:				{
        1: 1164:					discardCard(i, currentPlayer, state, 1);
        1: 1165:					break;
        -: 1166:				}
        -: 1167:			}
        -: 1168:		}
        -: 1169:
        3: 1170:		return 0;
        -: 1171:
        -: 1172:	case cutpurse:
        -: 1173:
    #####: 1174:		updateCoins(currentPlayer, state, 2);
    #####: 1175:		for (i = 0; i < state->numPlayers; i++)
        -: 1176:		{
    #####: 1177:			if (i != currentPlayer)
        -: 1178:			{
    #####: 1179:				for (j = 0; j < state->handCount[i]; j++)
        -: 1180:				{
    #####: 1181:					if (state->hand[i][j] == copper)
        -: 1182:					{
    #####: 1183:						discardCard(j, i, state, 0);
    #####: 1184:						break;
        -: 1185:					}
    #####: 1186:					if (j == state->handCount[i])
        -: 1187:					{
    #####: 1188:						for (k = 0; k < state->handCount[i]; k++)
        -: 1189:						{
        -: 1190:							if (DEBUG)
        -: 1191:								printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1192:						}
    #####: 1193:						break;
        -: 1194:					}
        -: 1195:				}
        -: 1196:
        -: 1197:			}
        -: 1198:
        -: 1199:		}
        -: 1200:
        -: 1201:		//discard played card from hand
    #####: 1202:		discardCard(handPos, currentPlayer, state, 0);
        -: 1203:
    #####: 1204:		return 0;
        -: 1205:
        -: 1206:
        -: 1207:	case embargo:
        -: 1208:		//+2 Coins
    #####: 1209:		state->coins = state->coins + 2;
        -: 1210:
        -: 1211:		//see if selected pile is in play
    #####: 1212:		if (state->supplyCount[choice1] == -1)
        -: 1213:		{
    #####: 1214:			return -1;
        -: 1215:		}
        -: 1216:
        -: 1217:		//add embargo token to selected supply pile
    #####: 1218:		state->embargoTokens[choice1]++;
        -: 1219:
        -: 1220:		//trash card
    #####: 1221:		discardCard(handPos, currentPlayer, state, 1);
    #####: 1222:		return 0;
        -: 1223:
        -: 1224:	case outpost:
        -: 1225:		//set outpost flag
    #####: 1226:		state->outpostPlayed++;
        -: 1227:
        -: 1228:		//discard card
    #####: 1229:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1230:		return 0;
        -: 1231:
        -: 1232:	case salvager:
        -: 1233:		//+1 buy
    #####: 1234:		state->numBuys++;
        -: 1235:
    #####: 1236:		if (choice1)
        -: 1237:		{
        -: 1238:			//gain coins equal to trashed card
    #####: 1239:			state->coins = state->coins + getCost(handCard(choice1, state));
        -: 1240:			//trash card
    #####: 1241:			discardCard(choice1, currentPlayer, state, 1);
        -: 1242:		}
        -: 1243:
        -: 1244:		//discard card
    #####: 1245:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1246:		return 0;
        -: 1247:
        -: 1248:	case sea_hag:
       12: 1249:		for (i = 0; i < state->numPlayers; i++){
        9: 1250:			if (i != currentPlayer){
        6: 1251:				state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
        6: 1252:				state->discardCount[i]++;
        6: 1253:				state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1254:			}
        -: 1255:		}
        3: 1256:		return 0;
        -: 1257:
        -: 1258:	case treasure_map:
        -: 1259:
    #####: 1260:		return playTreasureMap(state, currentPlayer, handPos);
        -: 1261:	}
    #####: 1262:	return -1;
        -: 1263:}
        -: 1264:
       29: 1265:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1266:{
        -: 1267:
        -: 1268:	//if card is not trashed, added to Played pile 
       29: 1269:	if (trashFlag < 1)
        -: 1270:	{
        -: 1271:		//add card to played pile
       12: 1272:		state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
       12: 1273:		state->playedCardCount++;
        -: 1274:	}
        -: 1275:
        -: 1276:	//set played card to -1
       29: 1277:	state->hand[currentPlayer][handPos] = -1;
        -: 1278:
        -: 1279:	//remove card from player's hand
       29: 1280:	if (handPos == (state->handCount[currentPlayer] - 1)) 	//last card in hand array is played
        -: 1281:	{
        -: 1282:		//reduce number of cards in hand
        5: 1283:		state->handCount[currentPlayer]--;
        -: 1284:	}
       24: 1285:	else if (state->handCount[currentPlayer] == 1) //only one card in hand
        -: 1286:	{
        -: 1287:		//reduce number of cards in hand
    #####: 1288:		state->handCount[currentPlayer]--;
        -: 1289:	}
        -: 1290:	else
        -: 1291:	{
        -: 1292:		//replace discarded card with last card in hand
       24: 1293:		state->hand[currentPlayer][handPos] = state->hand[currentPlayer][(state->handCount[currentPlayer] - 1)];
        -: 1294:		//set last card to -1
       24: 1295:		state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1296:		//reduce number of cards in hand
       24: 1297:		state->handCount[currentPlayer]--;
        -: 1298:	}
        -: 1299:
       29: 1300:	return 0;
        -: 1301:}
        -: 1302:
       98: 1303:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1304:{
        -: 1305:	//Note: supplyPos is enum of choosen card
        -: 1306:
        -: 1307:	//check if supply pile is empty (0) or card is not used in game (-1)
       98: 1308:	if (supplyCount(supplyPos, state) < 1)
        -: 1309:	{
    #####: 1310:		return -1;
        -: 1311:	}
        -: 1312:
        -: 1313:	//added card for [whoseTurn] current player:
        -: 1314:	// toFlag = 0 : add to discard
        -: 1315:	// toFlag = 1 : add to deck
        -: 1316:	// toFlag = 2 : add to hand
        -: 1317:
       98: 1318:	if (toFlag == 1)
        -: 1319:	{
    #####: 1320:		state->deck[player][state->deckCount[player]] = supplyPos;
    #####: 1321:		state->deckCount[player]++;
        -: 1322:	}
       98: 1323:	else if (toFlag == 2)
        -: 1324:	{
    #####: 1325:		state->hand[player][state->handCount[player]] = supplyPos;
    #####: 1326:		state->handCount[player]++;
        -: 1327:	}
        -: 1328:	else
        -: 1329:	{
       98: 1330:		state->discard[player][state->discardCount[player]] = supplyPos;
       98: 1331:		state->discardCount[player]++;
        -: 1332:	}
        -: 1333:
        -: 1334:	//decrease number in supply pile
       98: 1335:	state->supplyCount[supplyPos]--;
        -: 1336:
       98: 1337:	return 0;
        -: 1338:}
        -: 1339:
      122: 1340:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1341:{
        -: 1342:	int i;
        -: 1343:
        -: 1344:	//reset coin count
      122: 1345:	state->coins = 0;
        -: 1346:
        -: 1347:	//add coins for each Treasure card in player's hand
      704: 1348:	for (i = 0; i < state->handCount[player]; i++)
        -: 1349:	{
      582: 1350:		if (state->hand[player][i] == copper)
        -: 1351:		{
      245: 1352:			state->coins += 1;
        -: 1353:		}
      337: 1354:		else if (state->hand[player][i] == silver)
        -: 1355:		{
       53: 1356:			state->coins += 2;
        -: 1357:		}
      284: 1358:		else if (state->hand[player][i] == gold)
        -: 1359:		{
    #####: 1360:			state->coins += 3;
        -: 1361:		}
        -: 1362:	}
        -: 1363:
        -: 1364:	//add bonus
      122: 1365:	state->coins += bonus;
        -: 1366:
      122: 1367:	return 0;
        -: 1368:}
        -: 1369:
        -: 1370:
        -: 1371://end of dominion.c
File 'dominion.c'
Lines executed:64.81% of 557
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
     2712:    8:int compare(const void* a, const void* b) {
     2712:    9:	if (*(int*)a > *(int*)b)
     1132:   10:		return 1;
     1580:   11:	if (*(int*)a < *(int*)b)
      882:   12:		return -1;
      698:   13:	return 0;
        -:   14:}
        -:   15:
        2:   16:struct gameState* newGame() {
        2:   17:	struct gameState* g = malloc(sizeof(struct gameState));
        2:   18:	return g;
        -:   19:}
        -:   20:
       35:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:	int k8, int k9, int k10) {
       35:   23:	int* k = malloc(10 * sizeof(int));
       35:   24:	k[0] = k1;
       35:   25:	k[1] = k2;
       35:   26:	k[2] = k3;
       35:   27:	k[3] = k4;
       35:   28:	k[4] = k5;
       35:   29:	k[5] = k6;
       35:   30:	k[6] = k7;
       35:   31:	k[7] = k8;
       35:   32:	k[8] = k9;
       35:   33:	k[9] = k10;
       35:   34:	return k;
        -:   35:}
        -:   36:
       35:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		struct gameState *state) {
        -:   39:
        -:   40:	int i;
        -:   41:	int j;
        -:   42:	int it;
        -:   43:	//set up random number generator
       35:   44:	SelectStream(1);
       35:   45:	PutSeed((long)randomSeed);
        -:   46:
        -:   47:	//check number of players
       35:   48:	if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:	{
    #####:   50:		return -1;
        -:   51:	}
        -:   52:
        -:   53:	//set number of players
       35:   54:	state->numPlayers = numPlayers;
        -:   55:
        -:   56:	//check selected kingdom cards are different
      114:   57:	for (i = 0; i < 10; i++)
        -:   58:	{
     1101:   59:		for (j = 0; j < 10; j++)
        -:   60:		{
     1022:   61:			if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:			{
       34:   63:				return -1;
        -:   64:			}
        -:   65:		}
        -:   66:	}
        -:   67:
        -:   68:
        -:   69:	//initialize supply
        -:   70:	///////////////////////////////
        -:   71:
        -:   72:	//set number of Curse cards
        1:   73:	if (numPlayers == 2)
        -:   74:	{
    #####:   75:		state->supplyCount[curse] = 10;
        -:   76:	}
        1:   77:	else if (numPlayers == 3)
        -:   78:	{
        1:   79:		state->supplyCount[curse] = 20;
        -:   80:	}
        -:   81:	else
        -:   82:	{
    #####:   83:		state->supplyCount[curse] = 30;
        -:   84:	}
        -:   85:
        -:   86:	//set number of Victory cards
        1:   87:	if (numPlayers == 2)
        -:   88:	{
    #####:   89:		state->supplyCount[estate] = 8;
    #####:   90:		state->supplyCount[duchy] = 8;
    #####:   91:		state->supplyCount[province] = 8;
        -:   92:	}
        -:   93:	else
        -:   94:	{
        1:   95:		state->supplyCount[estate] = 12;
        1:   96:		state->supplyCount[duchy] = 12;
        1:   97:		state->supplyCount[province] = 12;
        -:   98:	}
        -:   99:
        -:  100:	//set number of Treasure cards
        1:  101:	state->supplyCount[copper] = 60 - (7 * numPlayers);
        1:  102:	state->supplyCount[silver] = 40;
        1:  103:	state->supplyCount[gold] = 30;
        -:  104:
        -:  105:	//set number of Kingdom cards
       21:  106:	for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:	{
      165:  108:		for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:		{
      155:  110:			if (kingdomCards[j] == i)
        -:  111:			{
        -:  112:				//check if card is a 'Victory' Kingdom card
       10:  113:				if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:				{
    #####:  115:					if (numPlayers == 2){
    #####:  116:						state->supplyCount[i] = 8;
        -:  117:					}
    #####:  118:					else{ state->supplyCount[i] = 12; }
        -:  119:				}
        -:  120:				else
        -:  121:				{
       10:  122:					state->supplyCount[i] = 10;
        -:  123:				}
       10:  124:				break;
        -:  125:			}
        -:  126:			else    //card is not in the set choosen for the game
        -:  127:			{
      145:  128:				state->supplyCount[i] = -1;
        -:  129:			}
        -:  130:		}
        -:  131:
        -:  132:	}
        -:  133:
        -:  134:	////////////////////////
        -:  135:	//supply intilization complete
        -:  136:
        -:  137:	//set player decks
        4:  138:	for (i = 0; i < numPlayers; i++)
        -:  139:	{
        3:  140:		state->deckCount[i] = 0;
       12:  141:		for (j = 0; j < 3; j++)
        -:  142:		{
        9:  143:			state->deck[i][j] = estate;
        9:  144:			state->deckCount[i]++;
        -:  145:		}
       24:  146:		for (j = 3; j < 10; j++)
        -:  147:		{
       21:  148:			state->deck[i][j] = copper;
       21:  149:			state->deckCount[i]++;
        -:  150:		}
        -:  151:	}
        -:  152:
        -:  153:	//shuffle player decks
        4:  154:	for (i = 0; i < numPlayers; i++)
        -:  155:	{
        3:  156:		if (shuffle(i, state) < 0)
        -:  157:		{
    #####:  158:			return -1;
        -:  159:		}
        -:  160:	}
        -:  161:
        -:  162:	//draw player hands
        4:  163:	for (i = 0; i < numPlayers; i++)
        -:  164:	{
        -:  165:		//initialize hand size to zero
        3:  166:		state->handCount[i] = 0;
        3:  167:		state->discardCount[i] = 0;
        -:  168:		//draw 5 cards
        -:  169:		// for (j = 0; j < 5; j++)
        -:  170:		//	{
        -:  171:		//	  drawCard(i, state);
        -:  172:		//	}
        -:  173:	}
        -:  174:
        -:  175:	//set embargo tokens to 0 for all supply piles
       28:  176:	for (i = 0; i <= treasure_map; i++)
        -:  177:	{
       27:  178:		state->embargoTokens[i] = 0;
        -:  179:	}
        -:  180:
        -:  181:	//initialize first player's turn
        1:  182:	state->outpostPlayed = 0;
        1:  183:	state->phase = 0;
        1:  184:	state->numActions = 1;
        1:  185:	state->numBuys = 1;
        1:  186:	state->playedCardCount = 0;
        1:  187:	state->whoseTurn = 0;
        1:  188:	state->handCount[state->whoseTurn] = 0;
        -:  189:	//int it; move to top
        -:  190:
        -:  191:	//Moved draw cards to here, only drawing at the start of a turn
        6:  192:	for (it = 0; it < 5; it++){
        5:  193:		drawCard(state->whoseTurn, state);
        -:  194:	}
        -:  195:
        1:  196:	updateCoins(state->whoseTurn, state, 0);
        -:  197:
        1:  198:	return 0;
        -:  199:}
        -:  200:
       83:  201:int shuffle(int player, struct gameState *state) {
        -:  202:
        -:  203:
        -:  204:	int newDeck[MAX_DECK];
       83:  205:	int newDeckPos = 0;
        -:  206:	int card;
        -:  207:	int i;
        -:  208:
       83:  209:	if (state->deckCount[player] < 1)
        1:  210:		return -1;
       82:  211:	qsort((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
        -:  212:	/* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
     1307:  214:	while (state->deckCount[player] > 0) {
     1143:  215:		card = floor(Random() * state->deckCount[player]);
     1143:  216:		newDeck[newDeckPos] = state->deck[player][card];
     1143:  217:		newDeckPos++;
     5868:  218:		for (i = card; i < state->deckCount[player] - 1; i++) {
     4725:  219:			state->deck[player][i] = state->deck[player][i + 1];
        -:  220:		}
     1143:  221:		state->deckCount[player]--;
        -:  222:	}
     1225:  223:	for (i = 0; i < newDeckPos; i++) {
     1143:  224:		state->deck[player][i] = newDeck[i];
     1143:  225:		state->deckCount[player]++;
        -:  226:	}
        -:  227:
       82:  228:	return 0;
        -:  229:}
        -:  230:
      690:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state)
        -:  232:{
        -:  233:	int card;
      690:  234:	int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:	//check if it is the right phase
      690:  237:	if (state->phase != 0)
        -:  238:	{
      149:  239:		return -1;
        -:  240:	}
        -:  241:
        -:  242:	//check if player has enough actions
      541:  243:	if (state->numActions < 1)
        -:  244:	{
       58:  245:		return -1;
        -:  246:	}
        -:  247:
        -:  248:	//get card played
      483:  249:	card = handCard(handPos, state);
        -:  250:
        -:  251:	//check if selected card is an action
      483:  252:	if (card < adventurer || card > treasure_map)
        -:  253:	{
      400:  254:		return -1;
        -:  255:	}
        -:  256:
        -:  257:	//play card
       83:  258:	if (cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0)
        -:  259:	{
       13:  260:		return -1;
        -:  261:	}
        -:  262:
        -:  263:	//reduce number of actions
       70:  264:	state->numActions--;
        -:  265:
        -:  266:	//update coins (Treasure cards may be added with card draws)
       70:  267:	updateCoins(state->whoseTurn, state, coin_bonus);
        -:  268:
       70:  269:	return 0;
        -:  270:}
        -:  271:
      697:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:	int who;
        -:  274:	if (DEBUG){
        -:  275:		printf("Entering buyCard...\n");
        -:  276:	}
        -:  277:
        -:  278:	// I don't know what to do about the phase thing.
        -:  279:
      697:  280:	who = state->whoseTurn;
        -:  281:
      697:  282:	if (state->numBuys < 1){
        -:  283:		if (DEBUG)
        -:  284:			printf("You do not have any buys left\n");
      154:  285:		return -1;
        -:  286:	}
      543:  287:	else if (supplyCount(supplyPos, state) < 1){
        -:  288:		if (DEBUG)
        -:  289:			printf("There are not any of that type of card left\n");
      244:  290:		return -1;
        -:  291:	}
      299:  292:	else if (state->coins < getCost(supplyPos)){
        -:  293:		if (DEBUG)
        -:  294:			printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
      159:  295:		return -1;
        -:  296:	}
        -:  297:	else {
      140:  298:		state->phase = 1;
        -:  299:		//state->supplyCount[supplyPos]--;
      140:  300:		gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  301:
      140:  302:		state->coins = (state->coins) - (getCost(supplyPos));
      140:  303:		state->numBuys--;
        -:  304:		if (DEBUG)
        -:  305:			printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  306:	}
        -:  307:
        -:  308:	//state->discard[who][state->discardCount[who]] = supplyPos;
        -:  309:	//state->discardCount[who]++;
        -:  310:
      140:  311:	return 0;
        -:  312:}
        -:  313:
    #####:  314:int numHandCards(struct gameState *state) {
    #####:  315:	return state->handCount[whoseTurn(state)];
        -:  316:}
        -:  317:
      483:  318:int handCard(int handPos, struct gameState *state) {
      483:  319:	int currentPlayer = whoseTurn(state);
      483:  320:	return state->hand[currentPlayer][handPos];
        -:  321:}
        -:  322:
      726:  323:int supplyCount(int card, struct gameState *state) {
      726:  324:	return state->supplyCount[card];
        -:  325:}
        -:  326:
    #####:  327:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  328:	int i;
    #####:  329:	int count = 0;
        -:  330:
    #####:  331:	for (i = 0; i < state->deckCount[player]; i++)
        -:  332:	{
    #####:  333:		if (state->deck[player][i] == card) count++;
        -:  334:	}
        -:  335:
    #####:  336:	for (i = 0; i < state->handCount[player]; i++)
        -:  337:	{
    #####:  338:		if (state->hand[player][i] == card) count++;
        -:  339:	}
        -:  340:
    #####:  341:	for (i = 0; i < state->discardCount[player]; i++)
        -:  342:	{
    #####:  343:		if (state->discard[player][i] == card) count++;
        -:  344:	}
        -:  345:
    #####:  346:	return count;
        -:  347:}
        -:  348:
      762:  349:int whoseTurn(struct gameState *state) {
      762:  350:	return state->whoseTurn;
        -:  351:}
        -:  352:
      196:  353:int endTurn(struct gameState *state) {
        -:  354:	int k;
        -:  355:	int i;
      196:  356:	int currentPlayer = whoseTurn(state);
        -:  357:
        -:  358:	//Discard hand
     1157:  359:	for (i = 0; i < state->handCount[currentPlayer]; i++){
      961:  360:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
      961:  361:		state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  362:	}
      196:  363:	state->handCount[currentPlayer] = 0;//Reset hand count
        -:  364:
        -:  365:	//Code for determining the player
      196:  366:	if (currentPlayer < (state->numPlayers - 1)){
      131:  367:		state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  368:	}
        -:  369:	else{
       65:  370:		state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  371:	}
        -:  372:
      196:  373:	state->outpostPlayed = 0;
      196:  374:	state->phase = 0;
      196:  375:	state->numActions = 1;
      196:  376:	state->coins = 0;
      196:  377:	state->numBuys = 1;
      196:  378:	state->playedCardCount = 0;
      196:  379:	state->handCount[state->whoseTurn] = 0;
        -:  380:
        -:  381:	//int k; move to top
        -:  382:	//Next player draws hand
     1176:  383:	for (k = 0; k < 5; k++){
      980:  384:		drawCard(state->whoseTurn, state);//Draw a card
        -:  385:	}
        -:  386:
        -:  387:	//Update money
      196:  388:	updateCoins(state->whoseTurn, state, 0);
        -:  389:
      196:  390:	return 0;
        -:  391:}
        -:  392:
     2108:  393:int isGameOver(struct gameState *state) {
        -:  394:	int i;
        -:  395:	int j;
        -:  396:
        -:  397:	//if stack of Province cards is empty, the game ends
     2108:  398:	if (state->supplyCount[province] == 0)
        -:  399:	{
    #####:  400:		return 1;
        -:  401:	}
        -:  402:
        -:  403:	//if three supply pile are at 0, the game ends
     2108:  404:	j = 0;
    54808:  405:	for (i = 0; i < 25; i++)
        -:  406:	{
    52700:  407:		if (state->supplyCount[i] == 0)
        -:  408:		{
     2168:  409:			j++;
        -:  410:		}
        -:  411:	}
     2108:  412:	if (j >= 3)
        -:  413:	{
        1:  414:		return 1;
        -:  415:	}
        -:  416:
     2107:  417:	return 0;
        -:  418:}
        -:  419:
    #####:  420:int scoreFor(int player, struct gameState *state) {
        -:  421:
        -:  422:	int i;
    #####:  423:	int score = 0;
        -:  424:	//score from hand
    #####:  425:	for (i = 0; i < state->handCount[player]; i++)
        -:  426:	{
    #####:  427:		if (state->hand[player][i] == curse) { score = score - 1; };
    #####:  428:		if (state->hand[player][i] == estate) { score = score + 1; };
    #####:  429:		if (state->hand[player][i] == duchy) { score = score + 3; };
    #####:  430:		if (state->hand[player][i] == province) { score = score + 6; };
    #####:  431:		if (state->hand[player][i] == great_hall) { score = score + 1; };
    #####:  432:		if (state->hand[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  433:	}
        -:  434:
        -:  435:	//score from discard
    #####:  436:	for (i = 0; i < state->discardCount[player]; i++)
        -:  437:	{
    #####:  438:		if (state->discard[player][i] == curse) { score = score - 1; };
    #####:  439:		if (state->discard[player][i] == estate) { score = score + 1; };
    #####:  440:		if (state->discard[player][i] == duchy) { score = score + 3; };
    #####:  441:		if (state->discard[player][i] == province) { score = score + 6; };
    #####:  442:		if (state->discard[player][i] == great_hall) { score = score + 1; };
    #####:  443:		if (state->discard[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  444:	}
        -:  445:
        -:  446:	//score from deck
    #####:  447:	for (i = 0; i < state->discardCount[player]; i++)
        -:  448:	{
    #####:  449:		if (state->deck[player][i] == curse) { score = score - 1; };
    #####:  450:		if (state->deck[player][i] == estate) { score = score + 1; };
    #####:  451:		if (state->deck[player][i] == duchy) { score = score + 3; };
    #####:  452:		if (state->deck[player][i] == province) { score = score + 6; };
    #####:  453:		if (state->deck[player][i] == great_hall) { score = score + 1; };
    #####:  454:		if (state->deck[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  455:	}
        -:  456:
    #####:  457:	return score;
        -:  458:}
        -:  459:
    #####:  460:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  461:	int i;
        -:  462:	int j;
        -:  463:	int highScore;
        -:  464:	int currentPlayer;
        -:  465:
        -:  466:	//get score for each player
    #####:  467:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  468:	{
        -:  469:		//set unused player scores to -9999
    #####:  470:		if (i >= state->numPlayers)
        -:  471:		{
    #####:  472:			players[i] = -9999;
        -:  473:		}
        -:  474:		else
        -:  475:		{
    #####:  476:			players[i] = scoreFor(i, state);
        -:  477:		}
        -:  478:	}
        -:  479:
        -:  480:	//find highest score
    #####:  481:	j = 0;
    #####:  482:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  483:	{
    #####:  484:		if (players[i] > players[j])
        -:  485:		{
    #####:  486:			j = i;
        -:  487:		}
        -:  488:	}
    #####:  489:	highScore = players[j];
        -:  490:
        -:  491:	//add 1 to players who had less turns
    #####:  492:	currentPlayer = whoseTurn(state);
    #####:  493:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  494:	{
    #####:  495:		if (players[i] == highScore && i > currentPlayer)
        -:  496:		{
    #####:  497:			players[i]++;
        -:  498:		}
        -:  499:	}
        -:  500:
        -:  501:	//find new highest score
    #####:  502:	j = 0;
    #####:  503:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  504:	{
    #####:  505:		if (players[i] > players[j])
        -:  506:		{
    #####:  507:			j = i;
        -:  508:		}
        -:  509:	}
    #####:  510:	highScore = players[j];
        -:  511:
        -:  512:	//set winners in array to 1 and rest to 0
    #####:  513:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  514:	{
    #####:  515:		if (players[i] == highScore)
        -:  516:		{
    #####:  517:			players[i] = 1;
        -:  518:		}
        -:  519:		else
        -:  520:		{
    #####:  521:			players[i] = 0;
        -:  522:		}
        -:  523:	}
        -:  524:
    #####:  525:	return 0;
        -:  526:}
        -:  527:
     1016:  528:int drawCard(int player, struct gameState *state)
        -:  529:{
        -:  530:	int count;
        -:  531:	int deckCounter;
     1016:  532:	if (state->deckCount[player] <= 0){//Deck is empty
        -:  533:
        -:  534:		//Step 1 Shuffle the discard pile back into a deck
        -:  535:		int i;
        -:  536:		//Move discard to deck
     1192:  537:		for (i = 0; i < state->discardCount[player]; i++){
     1113:  538:			state->deck[player][i] = state->discard[player][i];
     1113:  539:			state->discard[player][i] = -1;
        -:  540:		}
        -:  541:
       79:  542:		state->deckCount[player] = state->discardCount[player];
       79:  543:		state->discardCount[player] = 0;//Reset discard
        -:  544:
        -:  545:		//Shufffle the deck
       79:  546:		shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  547:
        -:  548:		if (DEBUG){//Debug statements
        -:  549:			printf("Deck count now: %d\n", state->deckCount[player]);
        -:  550:		}
        -:  551:
       79:  552:		state->discardCount[player] = 0;
        -:  553:
        -:  554:		//Step 2 Draw Card
       79:  555:		count = state->handCount[player];//Get current player's hand count
        -:  556:
        -:  557:		if (DEBUG){//Debug statements
        -:  558:			printf("Current hand count: %d\n", count);
        -:  559:		}
        -:  560:
       79:  561:		deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  562:
       79:  563:		if (deckCounter == 0)
    #####:  564:			return -1;
        -:  565:
       79:  566:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
       79:  567:		state->deckCount[player]--;
       79:  568:		state->handCount[player]++;//Increment hand count
        -:  569:	}
        -:  570:
        -:  571:	else{
      937:  572:		int count = state->handCount[player];//Get current hand count for player
        -:  573:		int deckCounter;
        -:  574:		if (DEBUG){//Debug statements
        -:  575:			printf("Current hand count: %d\n", count);
        -:  576:		}
        -:  577:
      937:  578:		deckCounter = state->deckCount[player];//Create holder for the deck count
      937:  579:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
      937:  580:		state->deckCount[player]--;
      937:  581:		state->handCount[player]++;//Increment hand count
        -:  582:	}
        -:  583:
     1016:  584:	return 0;
        -:  585:}
        -:  586:
      447:  587:int getCost(int cardNumber)
        -:  588:{
      447:  589:	switch (cardNumber)
        -:  590:	{
        -:  591:	case curse:
       40:  592:		return 0;
        -:  593:	case estate:
       19:  594:		return 2;
        -:  595:	case duchy:
       30:  596:		return 5;
        -:  597:	case province:
       23:  598:		return 8;
        -:  599:	case copper:
       38:  600:		return 0;
        -:  601:	case silver:
       26:  602:		return 3;
        -:  603:	case gold:
       16:  604:		return 6;
        -:  605:	case adventurer:
       22:  606:		return 6;
        -:  607:	case council_room:
       24:  608:		return 5;
        -:  609:	case feast:
    #####:  610:		return 4;
        -:  611:	case gardens:
    #####:  612:		return 4;
        -:  613:	case mine:
        1:  614:		return 5;
        -:  615:	case remodel:
       18:  616:		return 4;
        -:  617:	case smithy:
        1:  618:		return 4;
        -:  619:	case village:
    #####:  620:		return 3;
        -:  621:	case baron:
       28:  622:		return 4;
        -:  623:	case great_hall:
    #####:  624:		return 3;
        -:  625:	case minion:
    #####:  626:		return 5;
        -:  627:	case steward:
    #####:  628:		return 3;
        -:  629:	case tribute:
       22:  630:		return 5;
        -:  631:	case ambassador:
       22:  632:		return 3;
        -:  633:	case cutpurse:
       35:  634:		return 4;
        -:  635:	case embargo:
       22:  636:		return 2;
        -:  637:	case outpost:
    #####:  638:		return 5;
        -:  639:	case salvager:
    #####:  640:		return 4;
        -:  641:	case sea_hag:
       33:  642:		return 4;
        -:  643:	case treasure_map:
       27:  644:		return 4;
        -:  645:	}
        -:  646:
    #####:  647:	return -1;
        -:  648:}
        -:  649:
        4:  650:void playAdventurer(struct gameState *state, int currentPlayer)
        -:  651:// Reveal cards from deck until 2 Treasure cards are found.  Put those Treasure cards in the hand and discard the rest.
        -:  652:{
        4:  653:	int drawntreasure = 0;
        -:  654:	int temphand[MAX_HAND];
        -:  655:	int cardDrawn;
        4:  656:	int z = 0; // this is the counter for the temp hand
        -:  657:
       19:  658:	while (drawntreasure < 2){
       11:  659:		if (state->deckCount[currentPlayer] < 1){//if the deck is empty we need to shuffle discard and add to deck
        1:  660:			shuffle(currentPlayer, state);
        -:  661:		}
       11:  662:		drawCard(currentPlayer, state);
       11:  663:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer] - 1];//top card of hand is most recently drawn card.
       11:  664:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
        8:  665:			drawntreasure++;
        -:  666:		else{
        3:  667:			temphand[z] = cardDrawn;
        3:  668:			state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
        3:  669:			z++;
        -:  670:		}
        -:  671:	}
       11:  672:	while (z - 1 >= 0){
        3:  673:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; // discard all cards in play that have been drawn
        3:  674:		z = z - 1;
        -:  675:	}
        4:  676:}
        -:  677:
        4:  678:int playRemodel(struct gameState *state, int currentPlayer, int choice1, int choice2, int handPos)
        -:  679://Trash a card in the hand, and gain a card costing up to $2 more than the trashed card
        -:  680:{
        -:  681:	int i;
        4:  682:	int j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  683:
        4:  684:	if ((getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2))
        -:  685:	{
    #####:  686:		return -1;
        -:  687:	}
        -:  688:
        4:  689:	gainCard(choice2, state, 0, currentPlayer);
        -:  690:
        -:  691:	//discard card from hand
        4:  692:	discardCard(handPos, currentPlayer, state, 0);
        -:  693:
        -:  694:	//discard trashed card
       14:  695:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  696:	{
       12:  697:		if (state->hand[currentPlayer][i] == j)
        -:  698:		{
        2:  699:			discardCard(i, currentPlayer, state, 0);
        2:  700:			break;
        -:  701:		}
        -:  702:	}
        -:  703:
        4:  704:	return 0;
        -:  705:}
        -:  706:
    #####:  707:void playSmithy(struct gameState *state, int currentPlayer, int handPos)
        -:  708:// Draw 3 cards
        -:  709:{
        -:  710:	int i;
    #####:  711:	for (i = 0; i < 3; i++)
        -:  712:	{
    #####:  713:		drawCard(currentPlayer, state);
        -:  714:	}
        -:  715:
        -:  716:	//discard card from hand
    #####:  717:	discardCard(handPos, currentPlayer, state, 0);
    #####:  718:}
        -:  719:
        8:  720:void playBaron(struct gameState *state, int currentPlayer, int choice1, int handPos)
        -:  721://Add a buy.  OPTION:  Discard an Estate card and gain $4.  Otherwise, gain an Estate card.
        -:  722:{
        8:  723:	state->numBuys++;//Increase buys by 1!
        8:  724:	if (choice1 > 0){//Boolean true or going to discard an estate
        8:  725:		int p = 0;//Iterator for hand!
        8:  726:		int card_not_discarded = 1;//Flag for discard set!
       55:  727:		while (card_not_discarded){
       39:  728:			if (state->hand[currentPlayer][p] == estate){ //Found an estate card!
        3:  729:				state->coins += 4;//Add 4 coins to the amount of coins
        3:  730:				state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
        3:  731:				state->discardCount[currentPlayer]++;
       17:  732:				for (; p < state->handCount[currentPlayer]; p++){
       14:  733:					state->hand[currentPlayer][p] = state->hand[currentPlayer][p + 1];
        -:  734:				}
        3:  735:				state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
        3:  736:				state->handCount[currentPlayer]--;
        3:  737:				card_not_discarded = 0;//Exit the loop
        -:  738:			}
       36:  739:			else if (p > state->handCount[currentPlayer]){
        -:  740:				if (DEBUG) {
        -:  741:					printf("No estate cards in your hand, invalid choice\n");
        -:  742:					printf("Must gain an estate if there are any\n");
        -:  743:				}
        5:  744:				if (supplyCount(estate, state) > 0){
        2:  745:					gainCard(estate, state, 1, currentPlayer);
        2:  746:					state->supplyCount[estate]--;//Decrement estates
        2:  747:					if (supplyCount(estate, state) == 0){
    #####:  748:						isGameOver(state);
        -:  749:					}
        -:  750:				}
        5:  751:				card_not_discarded = 0;//Exit the loop
        -:  752:			}
        -:  753:
        -:  754:			else{
       31:  755:				p++;//Next card
        -:  756:			}
        -:  757:		}
        -:  758:	}
        -:  759:
        -:  760:	else{
    #####:  761:		if (supplyCount(estate, state) > 0){
    #####:  762:			gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  763:			state->supplyCount[estate]--;//Decrement Estates
    #####:  764:			if (supplyCount(estate, state) == 0){
    #####:  765:				isGameOver(state);
        -:  766:			}
        -:  767:		}
        -:  768:	}
        8:  769:}
        -:  770:
        7:  771:int playTreasureMap(struct gameState *state, int currentPlayer, int handPos)
        -:  772://Trashing two treasure map cards from the hand = four gold on top of the deck.
        -:  773:{
        -:  774:	int i;
        -:  775:	int index;
        -:  776:
        -:  777:	//search hand for another treasure_map
       42:  778:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  779:	{
       35:  780:		if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -:  781:		{
    #####:  782:			index = i;
    #####:  783:			break;
        -:  784:		}
        -:  785:	}
        7:  786:	if (index > -1)
        -:  787:	{
        -:  788:		//trash both treasure cards
        7:  789:		discardCard(handPos, currentPlayer, state, 1);
        7:  790:		discardCard(index, currentPlayer, state, 1);
        -:  791:
        -:  792:		//gain 4 Gold cards
       35:  793:		for (i = 0; i < 4; i++)
        -:  794:		{
       28:  795:			gainCard(gold, state, 1, currentPlayer);
        -:  796:		}
        -:  797:
        -:  798:		//return success
        7:  799:		return 1;
        -:  800:	}
        -:  801:
        -:  802:	//no second treasure_map found in hand
    #####:  803:	return -1;
        -:  804:}
        -:  805:
       83:  806:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  807:{
        -:  808:	int i;
        -:  809:	int j;
        -:  810:	int k;
        -:  811:	//int x;  //Unused after while loop removed from feast.
       83:  812:	int currentPlayer = whoseTurn(state);
       83:  813:	int nextPlayer = currentPlayer + 1;
        -:  814:	int temphand[MAX_HAND];
        -:  815:
       83:  816:	int tributeRevealedCards[2] = { -1, -1 };
        -:  817:
       83:  818:	if (nextPlayer > (state->numPlayers - 1)){
       23:  819:		nextPlayer = 0;
        -:  820:	}
        -:  821:
        -:  822:	//uses switch to select card and perform actions
       83:  823:	switch (card)
        -:  824:	{
        -:  825:	case adventurer:
        -:  826:
        4:  827:		playAdventurer(state, currentPlayer);
        4:  828:		return 0;
        -:  829:
        -:  830:	case council_room:
        -:  831:		//+4 Cards
       15:  832:		for (i = 0; i < 4; i++)
        -:  833:		{
       12:  834:			drawCard(currentPlayer, state);
        -:  835:		}
        -:  836:
        -:  837:		//+1 Buy
        3:  838:		state->numBuys++;
        -:  839:
        -:  840:		//Each other player draws a card
       12:  841:		for (i = 0; i < state->numPlayers; i++)
        -:  842:		{
        9:  843:			if (i != currentPlayer)
        -:  844:			{
        6:  845:				drawCard(i, state);
        -:  846:			}
        -:  847:		}
        -:  848:
        -:  849:		//put played card in played card pile
        3:  850:		discardCard(handPos, currentPlayer, state, 0);
        -:  851:
        3:  852:		return 0;
        -:  853:
        -:  854:	case feast:
        -:  855:		//gain card with cost up to 5
        -:  856:		//Backup hand
    #####:  857:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  858:			temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  859:			state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  860:		}
        -:  861:		//Backup hand
        -:  862:
        -:  863:		//Update Coins for Buy
    #####:  864:		updateCoins(currentPlayer, state, 5);
        -:  865://		x = 1;//Condition to loop on
        -:  866://		while (x == 1) {//Buy one card
    #####:  867:			if (supplyCount(choice1, state) <= 0){
        -:  868:				if (DEBUG)
        -:  869:					printf("None of that card left, sorry!\n");
        -:  870:
        -:  871:				if (DEBUG){
        -:  872:					printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  873:				}
        -:  874:			}
    #####:  875:			else if (state->coins < getCost(choice1)){
    #####:  876:				printf("That card is too expensive!\n");
        -:  877:
        -:  878:				if (DEBUG){
        -:  879:					printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  880:				}
        -:  881:			}
        -:  882:			else{
        -:  883:
        -:  884:				if (DEBUG){
        -:  885:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  886:				}
        -:  887:
    #####:  888:				gainCard(choice1, state, 0, currentPlayer);//Gain the card
        -:  889://				x = 0;//No more buying cards
        -:  890:
        -:  891:				if (DEBUG){
        -:  892:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  893:				}
        -:  894:
        -:  895:			}
        -:  896://		}
        -:  897:
        -:  898:		//Reset Hand
    #####:  899:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  900:			state->hand[currentPlayer][i] = temphand[i];
    #####:  901:			temphand[i] = -1;
        -:  902:		}
        -:  903:		//Reset Hand
        -:  904:
    #####:  905:		return 0;
        -:  906:
        -:  907:	case gardens:
    #####:  908:		return -1;
        -:  909:
        -:  910:	case mine:
    #####:  911:		j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  912:
    #####:  913:		if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  914:		{
    #####:  915:			return -1;
        -:  916:		}
        -:  917:
    #####:  918:		if (choice2 > treasure_map || choice2 < curse)
        -:  919:		{
    #####:  920:			return -1;
        -:  921:		}
        -:  922:
    #####:  923:		if ((getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2))
        -:  924:		{
    #####:  925:			return -1;
        -:  926:		}
        -:  927:
    #####:  928:		gainCard(choice2, state, 2, currentPlayer);
        -:  929:
        -:  930:		//discard card from hand
    #####:  931:		discardCard(handPos, currentPlayer, state, 0);
        -:  932:
        -:  933:		//discard trashed card
    #####:  934:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  935:		{
    #####:  936:			if (state->hand[currentPlayer][i] == j)
        -:  937:			{
    #####:  938:				discardCard(i, currentPlayer, state, 0);
    #####:  939:				break;
        -:  940:			}
        -:  941:		}
        -:  942:
    #####:  943:		return 0;
        -:  944:
        -:  945:	case remodel:
        -:  946:
        4:  947:		return playRemodel(state, currentPlayer, choice1, choice2, handPos);
        -:  948:
        -:  949:	case smithy:
        -:  950:
    #####:  951:		playSmithy(state, currentPlayer, handPos);
    #####:  952:		return 0;
        -:  953:
        -:  954:	case village:
        -:  955:		//+1 Card
    #####:  956:		drawCard(currentPlayer, state);
        -:  957:
        -:  958:		//+2 Actions
    #####:  959:		state->numActions = state->numActions + 2;
        -:  960:
        -:  961:		//discard played card from hand
    #####:  962:		discardCard(handPos, currentPlayer, state, 0);
    #####:  963:		return 0;
        -:  964:
        -:  965:	case baron:
        -:  966:
        8:  967:		playBaron(state, currentPlayer, choice1, handPos);
        8:  968:		return 0;
        -:  969:
        -:  970:	case great_hall:
        -:  971:		//+1 Card
    #####:  972:		drawCard(currentPlayer, state);
        -:  973:
        -:  974:		//+1 Actions
    #####:  975:		state->numActions++;
        -:  976:
        -:  977:		//discard card from hand
    #####:  978:		discardCard(handPos, currentPlayer, state, 0);
    #####:  979:		return 0;
        -:  980:
        -:  981:	case minion:
        -:  982:		//+1 action
    #####:  983:		state->numActions++;
        -:  984:
        -:  985:		//discard card from hand
    #####:  986:		discardCard(handPos, currentPlayer, state, 0);
        -:  987:
    #####:  988:		if (choice1)		//+2 coins
        -:  989:		{
    #####:  990:			state->coins = state->coins + 2;
        -:  991:		}
        -:  992:
    #####:  993:		else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  994:		{
        -:  995:			//discard hand
    #####:  996:			while (numHandCards(state) > 0)
        -:  997:			{
    #####:  998:				discardCard(handPos, currentPlayer, state, 0);
        -:  999:			}
        -: 1000:
        -: 1001:			//draw 4
    #####: 1002:			for (i = 0; i < 4; i++)
        -: 1003:			{
    #####: 1004:				drawCard(currentPlayer, state);
        -: 1005:			}
        -: 1006:
        -: 1007:			//other players discard hand and redraw if hand size > 4
    #####: 1008:			for (i = 0; i < state->numPlayers; i++)
        -: 1009:			{
    #####: 1010:				if (i != currentPlayer)
        -: 1011:				{
    #####: 1012:					if (state->handCount[i] > 4)
        -: 1013:					{
        -: 1014:						//discard hand
    #####: 1015:						while (state->handCount[i] > 0)
        -: 1016:						{
    #####: 1017:							discardCard(handPos, i, state, 0);
        -: 1018:						}
        -: 1019:
        -: 1020:						//draw 4
    #####: 1021:						for (j = 0; j < 4; j++)
        -: 1022:						{
    #####: 1023:							drawCard(i, state);
        -: 1024:						}
        -: 1025:					}
        -: 1026:				}
        -: 1027:			}
        -: 1028:
        -: 1029:		}
    #####: 1030:		return 0;
        -: 1031:
        -: 1032:	case steward:
    #####: 1033:		if (choice1 == 1)
        -: 1034:		{
        -: 1035:			//+2 cards
    #####: 1036:			drawCard(currentPlayer, state);
    #####: 1037:			drawCard(currentPlayer, state);
        -: 1038:		}
    #####: 1039:		else if (choice1 == 2)
        -: 1040:		{
        -: 1041:			//+2 coins
    #####: 1042:			state->coins = state->coins + 2;
        -: 1043:		}
        -: 1044:		else
        -: 1045:		{
        -: 1046:			//trash 2 cards in hand
    #####: 1047:			discardCard(choice2, currentPlayer, state, 1);
    #####: 1048:			discardCard(choice3, currentPlayer, state, 1);
        -: 1049:		}
        -: 1050:
        -: 1051:		//discard card from hand
    #####: 1052:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1053:		return 0;
        -: 1054:
        -: 1055:	case tribute:
        6: 1056:		if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####: 1057:			if (state->deckCount[nextPlayer] > 0){
    #####: 1058:				tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1059:				state->deckCount[nextPlayer]--;
        -: 1060:			}
    #####: 1061:			else if (state->discardCount[nextPlayer] > 0){
    #####: 1062:				tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer] - 1];
    #####: 1063:				state->discardCount[nextPlayer]--;
        -: 1064:			}
        -: 1065:			else{
        -: 1066:				//No Card to Reveal
        -: 1067:				if (DEBUG){
        -: 1068:					printf("No cards to reveal\n");
        -: 1069:				}
        -: 1070:			}
        -: 1071:		}
        -: 1072:
        -: 1073:		else{
        6: 1074:			if (state->deckCount[nextPlayer] == 0){
    #####: 1075:				for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####: 1076:					state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1077:					state->deckCount[nextPlayer]++;
    #####: 1078:					state->discard[nextPlayer][i] = -1;
    #####: 1079:					state->discardCount[nextPlayer]--;
        -: 1080:				}
        -: 1081:
    #####: 1082:				shuffle(nextPlayer, state);//Shuffle the deck
        -: 1083:			}
        6: 1084:			tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
        6: 1085:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
        6: 1086:			state->deckCount[nextPlayer]--;
        6: 1087:			tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
        6: 1088:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
        6: 1089:			state->deckCount[nextPlayer]--;
        -: 1090:		}
        -: 1091:
        6: 1092:		if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
    #####: 1093:			state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1094:			state->playedCardCount++;
    #####: 1095:			tributeRevealedCards[1] = -1;
        -: 1096:		}
        -: 1097:
       24: 1098:		for (i = 0; i <= 2; i++){
       18: 1099:			if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
        9: 1100:				state->coins += 2;
        -: 1101:			}
        -: 1102:
        9: 1103:			else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
        1: 1104:				drawCard(currentPlayer, state);
        1: 1105:				drawCard(currentPlayer, state);
        -: 1106:			}
        -: 1107:			else{//Action Card
        8: 1108:				state->numActions = state->numActions + 2;
        -: 1109:			}
        -: 1110:		}
        -: 1111:
        6: 1112:		return 0;
        -: 1113:
        -: 1114:	case ambassador:
        9: 1115:		j = 0;		//used to check if player has enough cards to discard
        -: 1116:
        9: 1117:		if (choice2 > 2 || choice2 < 0)
        -: 1118:		{
        8: 1119:			return -1;
        -: 1120:		}
        -: 1121:
        1: 1122:		if (choice1 == handPos)
        -: 1123:		{
    #####: 1124:			return -1;
        -: 1125:		}
        -: 1126:
        6: 1127:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1128:		{
        5: 1129:			if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1130:			{
        1: 1131:				j++;
        -: 1132:			}
        -: 1133:		}
        1: 1134:		if (j < choice2)
        -: 1135:		{
    #####: 1136:			return -1;
        -: 1137:		}
        -: 1138:
        -: 1139:		if (DEBUG)
        -: 1140:			printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1141:
        -: 1142:		//increase supply count for choosen card by amount being discarded
        1: 1143:		state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1144:
        -: 1145:		//each other player gains a copy of revealed card
        4: 1146:		for (i = 0; i < state->numPlayers; i++)
        -: 1147:		{
        3: 1148:			if (i != currentPlayer)
        -: 1149:			{
        2: 1150:				gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1151:			}
        -: 1152:		}
        -: 1153:
        -: 1154:		//discard played card from hand
        1: 1155:		discardCard(handPos, currentPlayer, state, 0);
        -: 1156:
        -: 1157:		//trash copies of cards returned to supply
        2: 1158:		for (j = 0; j < choice2; j++)
        -: 1159:		{
        5: 1160:			for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1161:			{
        4: 1162:				if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1163:				{
    #####: 1164:					discardCard(i, currentPlayer, state, 1);
    #####: 1165:					break;
        -: 1166:				}
        -: 1167:			}
        -: 1168:		}
        -: 1169:
        1: 1170:		return 0;
        -: 1171:
        -: 1172:	case cutpurse:
        -: 1173:
        4: 1174:		updateCoins(currentPlayer, state, 2);
       16: 1175:		for (i = 0; i < state->numPlayers; i++)
        -: 1176:		{
       12: 1177:			if (i != currentPlayer)
        -: 1178:			{
        8: 1179:				for (j = 0; j < state->handCount[i]; j++)
        -: 1180:				{
    #####: 1181:					if (state->hand[i][j] == copper)
        -: 1182:					{
    #####: 1183:						discardCard(j, i, state, 0);
    #####: 1184:						break;
        -: 1185:					}
    #####: 1186:					if (j == state->handCount[i])
        -: 1187:					{
    #####: 1188:						for (k = 0; k < state->handCount[i]; k++)
        -: 1189:						{
        -: 1190:							if (DEBUG)
        -: 1191:								printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1192:						}
    #####: 1193:						break;
        -: 1194:					}
        -: 1195:				}
        -: 1196:
        -: 1197:			}
        -: 1198:
        -: 1199:		}
        -: 1200:
        -: 1201:		//discard played card from hand
        4: 1202:		discardCard(handPos, currentPlayer, state, 0);
        -: 1203:
        4: 1204:		return 0;
        -: 1205:
        -: 1206:
        -: 1207:	case embargo:
        -: 1208:		//+2 Coins
       15: 1209:		state->coins = state->coins + 2;
        -: 1210:
        -: 1211:		//see if selected pile is in play
       15: 1212:		if (state->supplyCount[choice1] == -1)
        -: 1213:		{
        5: 1214:			return -1;
        -: 1215:		}
        -: 1216:
        -: 1217:		//add embargo token to selected supply pile
       10: 1218:		state->embargoTokens[choice1]++;
        -: 1219:
        -: 1220:		//trash card
       10: 1221:		discardCard(handPos, currentPlayer, state, 1);
       10: 1222:		return 0;
        -: 1223:
        -: 1224:	case outpost:
        -: 1225:		//set outpost flag
    #####: 1226:		state->outpostPlayed++;
        -: 1227:
        -: 1228:		//discard card
    #####: 1229:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1230:		return 0;
        -: 1231:
        -: 1232:	case salvager:
        -: 1233:		//+1 buy
    #####: 1234:		state->numBuys++;
        -: 1235:
    #####: 1236:		if (choice1)
        -: 1237:		{
        -: 1238:			//gain coins equal to trashed card
    #####: 1239:			state->coins = state->coins + getCost(handCard(choice1, state));
        -: 1240:			//trash card
    #####: 1241:			discardCard(choice1, currentPlayer, state, 1);
        -: 1242:		}
        -: 1243:
        -: 1244:		//discard card
    #####: 1245:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1246:		return 0;
        -: 1247:
        -: 1248:	case sea_hag:
       92: 1249:		for (i = 0; i < state->numPlayers; i++){
       69: 1250:			if (i != currentPlayer){
       46: 1251:				state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
       46: 1252:				state->discardCount[i]++;
       46: 1253:				state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1254:			}
        -: 1255:		}
       23: 1256:		return 0;
        -: 1257:
        -: 1258:	case treasure_map:
        -: 1259:
        7: 1260:		return playTreasureMap(state, currentPlayer, handPos);
        -: 1261:	}
    #####: 1262:	return -1;
        -: 1263:}
        -: 1264:
       38: 1265:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1266:{
        -: 1267:
        -: 1268:	//if card is not trashed, added to Played pile 
       38: 1269:	if (trashFlag < 1)
        -: 1270:	{
        -: 1271:		//add card to played pile
       14: 1272:		state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
       14: 1273:		state->playedCardCount++;
        -: 1274:	}
        -: 1275:
        -: 1276:	//set played card to -1
       38: 1277:	state->hand[currentPlayer][handPos] = -1;
        -: 1278:
        -: 1279:	//remove card from player's hand
       38: 1280:	if (handPos == (state->handCount[currentPlayer] - 1)) 	//last card in hand array is played
        -: 1281:	{
        -: 1282:		//reduce number of cards in hand
       11: 1283:		state->handCount[currentPlayer]--;
        -: 1284:	}
       27: 1285:	else if (state->handCount[currentPlayer] == 1) //only one card in hand
        -: 1286:	{
        -: 1287:		//reduce number of cards in hand
    #####: 1288:		state->handCount[currentPlayer]--;
        -: 1289:	}
        -: 1290:	else
        -: 1291:	{
        -: 1292:		//replace discarded card with last card in hand
       27: 1293:		state->hand[currentPlayer][handPos] = state->hand[currentPlayer][(state->handCount[currentPlayer] - 1)];
        -: 1294:		//set last card to -1
       27: 1295:		state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1296:		//reduce number of cards in hand
       27: 1297:		state->handCount[currentPlayer]--;
        -: 1298:	}
        -: 1299:
       38: 1300:	return 0;
        -: 1301:}
        -: 1302:
      176: 1303:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1304:{
        -: 1305:	//Note: supplyPos is enum of choosen card
        -: 1306:
        -: 1307:	//check if supply pile is empty (0) or card is not used in game (-1)
      176: 1308:	if (supplyCount(supplyPos, state) < 1)
        -: 1309:	{
        3: 1310:		return -1;
        -: 1311:	}
        -: 1312:
        -: 1313:	//added card for [whoseTurn] current player:
        -: 1314:	// toFlag = 0 : add to discard
        -: 1315:	// toFlag = 1 : add to deck
        -: 1316:	// toFlag = 2 : add to hand
        -: 1317:
      173: 1318:	if (toFlag == 1)
        -: 1319:	{
       30: 1320:		state->deck[player][state->deckCount[player]] = supplyPos;
       30: 1321:		state->deckCount[player]++;
        -: 1322:	}
      143: 1323:	else if (toFlag == 2)
        -: 1324:	{
    #####: 1325:		state->hand[player][state->handCount[player]] = supplyPos;
    #####: 1326:		state->handCount[player]++;
        -: 1327:	}
        -: 1328:	else
        -: 1329:	{
      143: 1330:		state->discard[player][state->discardCount[player]] = supplyPos;
      143: 1331:		state->discardCount[player]++;
        -: 1332:	}
        -: 1333:
        -: 1334:	//decrease number in supply pile
      173: 1335:	state->supplyCount[supplyPos]--;
        -: 1336:
      173: 1337:	return 0;
        -: 1338:}
        -: 1339:
      271: 1340:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1341:{
        -: 1342:	int i;
        -: 1343:
        -: 1344:	//reset coin count
      271: 1345:	state->coins = 0;
        -: 1346:
        -: 1347:	//add coins for each Treasure card in player's hand
     1607: 1348:	for (i = 0; i < state->handCount[player]; i++)
        -: 1349:	{
     1336: 1350:		if (state->hand[player][i] == copper)
        -: 1351:		{
      448: 1352:			state->coins += 1;
        -: 1353:		}
      888: 1354:		else if (state->hand[player][i] == silver)
        -: 1355:		{
       93: 1356:			state->coins += 2;
        -: 1357:		}
      795: 1358:		else if (state->hand[player][i] == gold)
        -: 1359:		{
      140: 1360:			state->coins += 3;
        -: 1361:		}
        -: 1362:	}
        -: 1363:
        -: 1364:	//add bonus
      271: 1365:	state->coins += bonus;
        -: 1366:
      271: 1367:	return 0;
        -: 1368:}
        -: 1369:
        -: 1370:
        -: 1371://end of dominion.c
File 'dominion.c'
Lines executed:52.96% of 557
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
     1289:    8:int compare(const void* a, const void* b) {
     1289:    9:	if (*(int*)a > *(int*)b)
      437:   10:		return 1;
      852:   11:	if (*(int*)a < *(int*)b)
      348:   12:		return -1;
      504:   13:	return 0;
        -:   14:}
        -:   15:
        2:   16:struct gameState* newGame() {
        2:   17:	struct gameState* g = malloc(sizeof(struct gameState));
        2:   18:	return g;
        -:   19:}
        -:   20:
        6:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:	int k8, int k9, int k10) {
        6:   23:	int* k = malloc(10 * sizeof(int));
        6:   24:	k[0] = k1;
        6:   25:	k[1] = k2;
        6:   26:	k[2] = k3;
        6:   27:	k[3] = k4;
        6:   28:	k[4] = k5;
        6:   29:	k[5] = k6;
        6:   30:	k[6] = k7;
        6:   31:	k[7] = k8;
        6:   32:	k[8] = k9;
        6:   33:	k[9] = k10;
        6:   34:	return k;
        -:   35:}
        -:   36:
        6:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		struct gameState *state) {
        -:   39:
        -:   40:	int i;
        -:   41:	int j;
        -:   42:	int it;
        -:   43:	//set up random number generator
        6:   44:	SelectStream(1);
        6:   45:	PutSeed((long)randomSeed);
        -:   46:
        -:   47:	//check number of players
        6:   48:	if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:	{
    #####:   50:		return -1;
        -:   51:	}
        -:   52:
        -:   53:	//set number of players
        6:   54:	state->numPlayers = numPlayers;
        -:   55:
        -:   56:	//check selected kingdom cards are different
       27:   57:	for (i = 0; i < 10; i++)
        -:   58:	{
      262:   59:		for (j = 0; j < 10; j++)
        -:   60:		{
      241:   61:			if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:			{
        5:   63:				return -1;
        -:   64:			}
        -:   65:		}
        -:   66:	}
        -:   67:
        -:   68:
        -:   69:	//initialize supply
        -:   70:	///////////////////////////////
        -:   71:
        -:   72:	//set number of Curse cards
        1:   73:	if (numPlayers == 2)
        -:   74:	{
    #####:   75:		state->supplyCount[curse] = 10;
        -:   76:	}
        1:   77:	else if (numPlayers == 3)
        -:   78:	{
        1:   79:		state->supplyCount[curse] = 20;
        -:   80:	}
        -:   81:	else
        -:   82:	{
    #####:   83:		state->supplyCount[curse] = 30;
        -:   84:	}
        -:   85:
        -:   86:	//set number of Victory cards
        1:   87:	if (numPlayers == 2)
        -:   88:	{
    #####:   89:		state->supplyCount[estate] = 8;
    #####:   90:		state->supplyCount[duchy] = 8;
    #####:   91:		state->supplyCount[province] = 8;
        -:   92:	}
        -:   93:	else
        -:   94:	{
        1:   95:		state->supplyCount[estate] = 12;
        1:   96:		state->supplyCount[duchy] = 12;
        1:   97:		state->supplyCount[province] = 12;
        -:   98:	}
        -:   99:
        -:  100:	//set number of Treasure cards
        1:  101:	state->supplyCount[copper] = 60 - (7 * numPlayers);
        1:  102:	state->supplyCount[silver] = 40;
        1:  103:	state->supplyCount[gold] = 30;
        -:  104:
        -:  105:	//set number of Kingdom cards
       21:  106:	for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:	{
      165:  108:		for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:		{
      155:  110:			if (kingdomCards[j] == i)
        -:  111:			{
        -:  112:				//check if card is a 'Victory' Kingdom card
       10:  113:				if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:				{
        4:  115:					if (numPlayers == 2){
    #####:  116:						state->supplyCount[i] = 8;
        -:  117:					}
        2:  118:					else{ state->supplyCount[i] = 12; }
        -:  119:				}
        -:  120:				else
        -:  121:				{
        8:  122:					state->supplyCount[i] = 10;
        -:  123:				}
       10:  124:				break;
        -:  125:			}
        -:  126:			else    //card is not in the set choosen for the game
        -:  127:			{
      145:  128:				state->supplyCount[i] = -1;
        -:  129:			}
        -:  130:		}
        -:  131:
        -:  132:	}
        -:  133:
        -:  134:	////////////////////////
        -:  135:	//supply intilization complete
        -:  136:
        -:  137:	//set player decks
        4:  138:	for (i = 0; i < numPlayers; i++)
        -:  139:	{
        3:  140:		state->deckCount[i] = 0;
       12:  141:		for (j = 0; j < 3; j++)
        -:  142:		{
        9:  143:			state->deck[i][j] = estate;
        9:  144:			state->deckCount[i]++;
        -:  145:		}
       24:  146:		for (j = 3; j < 10; j++)
        -:  147:		{
       21:  148:			state->deck[i][j] = copper;
       21:  149:			state->deckCount[i]++;
        -:  150:		}
        -:  151:	}
        -:  152:
        -:  153:	//shuffle player decks
        4:  154:	for (i = 0; i < numPlayers; i++)
        -:  155:	{
        3:  156:		if (shuffle(i, state) < 0)
        -:  157:		{
    #####:  158:			return -1;
        -:  159:		}
        -:  160:	}
        -:  161:
        -:  162:	//draw player hands
        4:  163:	for (i = 0; i < numPlayers; i++)
        -:  164:	{
        -:  165:		//initialize hand size to zero
        3:  166:		state->handCount[i] = 0;
        3:  167:		state->discardCount[i] = 0;
        -:  168:		//draw 5 cards
        -:  169:		// for (j = 0; j < 5; j++)
        -:  170:		//	{
        -:  171:		//	  drawCard(i, state);
        -:  172:		//	}
        -:  173:	}
        -:  174:
        -:  175:	//set embargo tokens to 0 for all supply piles
       28:  176:	for (i = 0; i <= treasure_map; i++)
        -:  177:	{
       27:  178:		state->embargoTokens[i] = 0;
        -:  179:	}
        -:  180:
        -:  181:	//initialize first player's turn
        1:  182:	state->outpostPlayed = 0;
        1:  183:	state->phase = 0;
        1:  184:	state->numActions = 1;
        1:  185:	state->numBuys = 1;
        1:  186:	state->playedCardCount = 0;
        1:  187:	state->whoseTurn = 0;
        1:  188:	state->handCount[state->whoseTurn] = 0;
        -:  189:	//int it; move to top
        -:  190:
        -:  191:	//Moved draw cards to here, only drawing at the start of a turn
        6:  192:	for (it = 0; it < 5; it++){
        5:  193:		drawCard(state->whoseTurn, state);
        -:  194:	}
        -:  195:
        1:  196:	updateCoins(state->whoseTurn, state, 0);
        -:  197:
        1:  198:	return 0;
        -:  199:}
        -:  200:
       61:  201:int shuffle(int player, struct gameState *state) {
        -:  202:
        -:  203:
        -:  204:	int newDeck[MAX_DECK];
       61:  205:	int newDeckPos = 0;
        -:  206:	int card;
        -:  207:	int i;
        -:  208:
       61:  209:	if (state->deckCount[player] < 1)
    #####:  210:		return -1;
       61:  211:	qsort((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
        -:  212:	/* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
      813:  214:	while (state->deckCount[player] > 0) {
      691:  215:		card = floor(Random() * state->deckCount[player]);
      691:  216:		newDeck[newDeckPos] = state->deck[player][card];
      691:  217:		newDeckPos++;
     2573:  218:		for (i = card; i < state->deckCount[player] - 1; i++) {
     1882:  219:			state->deck[player][i] = state->deck[player][i + 1];
        -:  220:		}
      691:  221:		state->deckCount[player]--;
        -:  222:	}
      752:  223:	for (i = 0; i < newDeckPos; i++) {
      691:  224:		state->deck[player][i] = newDeck[i];
      691:  225:		state->deckCount[player]++;
        -:  226:	}
        -:  227:
       61:  228:	return 0;
        -:  229:}
        -:  230:
      927:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state)
        -:  232:{
        -:  233:	int card;
      927:  234:	int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:	//check if it is the right phase
      927:  237:	if (state->phase != 0)
        -:  238:	{
       83:  239:		return -1;
        -:  240:	}
        -:  241:
        -:  242:	//check if player has enough actions
      844:  243:	if (state->numActions < 1)
        -:  244:	{
        9:  245:		return -1;
        -:  246:	}
        -:  247:
        -:  248:	//get card played
      835:  249:	card = handCard(handPos, state);
        -:  250:
        -:  251:	//check if selected card is an action
      835:  252:	if (card < adventurer || card > treasure_map)
        -:  253:	{
      759:  254:		return -1;
        -:  255:	}
        -:  256:
        -:  257:	//play card
       76:  258:	if (cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0)
        -:  259:	{
       47:  260:		return -1;
        -:  261:	}
        -:  262:
        -:  263:	//reduce number of actions
       29:  264:	state->numActions--;
        -:  265:
        -:  266:	//update coins (Treasure cards may be added with card draws)
       29:  267:	updateCoins(state->whoseTurn, state, coin_bonus);
        -:  268:
       29:  269:	return 0;
        -:  270:}
        -:  271:
      951:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:	int who;
        -:  274:	if (DEBUG){
        -:  275:		printf("Entering buyCard...\n");
        -:  276:	}
        -:  277:
        -:  278:	// I don't know what to do about the phase thing.
        -:  279:
      951:  280:	who = state->whoseTurn;
        -:  281:
      951:  282:	if (state->numBuys < 1){
        -:  283:		if (DEBUG)
        -:  284:			printf("You do not have any buys left\n");
      100:  285:		return -1;
        -:  286:	}
      851:  287:	else if (supplyCount(supplyPos, state) < 1){
        -:  288:		if (DEBUG)
        -:  289:			printf("There are not any of that type of card left\n");
      336:  290:		return -1;
        -:  291:	}
      515:  292:	else if (state->coins < getCost(supplyPos)){
        -:  293:		if (DEBUG)
        -:  294:			printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
      425:  295:		return -1;
        -:  296:	}
        -:  297:	else {
       90:  298:		state->phase = 1;
        -:  299:		//state->supplyCount[supplyPos]--;
       90:  300:		gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  301:
       90:  302:		state->coins = (state->coins) - (getCost(supplyPos));
       90:  303:		state->numBuys--;
        -:  304:		if (DEBUG)
        -:  305:			printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  306:	}
        -:  307:
        -:  308:	//state->discard[who][state->discardCount[who]] = supplyPos;
        -:  309:	//state->discardCount[who]++;
        -:  310:
       90:  311:	return 0;
        -:  312:}
        -:  313:
        5:  314:int numHandCards(struct gameState *state) {
        5:  315:	return state->handCount[whoseTurn(state)];
        -:  316:}
        -:  317:
      835:  318:int handCard(int handPos, struct gameState *state) {
      835:  319:	int currentPlayer = whoseTurn(state);
      835:  320:	return state->hand[currentPlayer][handPos];
        -:  321:}
        -:  322:
      941:  323:int supplyCount(int card, struct gameState *state) {
      941:  324:	return state->supplyCount[card];
        -:  325:}
        -:  326:
        1:  327:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  328:	int i;
        1:  329:	int count = 0;
        -:  330:
       14:  331:	for (i = 0; i < state->deckCount[player]; i++)
        -:  332:	{
       13:  333:		if (state->deck[player][i] == card) count++;
        -:  334:	}
        -:  335:
        6:  336:	for (i = 0; i < state->handCount[player]; i++)
        -:  337:	{
        5:  338:		if (state->hand[player][i] == card) count++;
        -:  339:	}
        -:  340:
        2:  341:	for (i = 0; i < state->discardCount[player]; i++)
        -:  342:	{
        1:  343:		if (state->discard[player][i] == card) count++;
        -:  344:	}
        -:  345:
        1:  346:	return count;
        -:  347:}
        -:  348:
     1029:  349:int whoseTurn(struct gameState *state) {
     1029:  350:	return state->whoseTurn;
        -:  351:}
        -:  352:
      113:  353:int endTurn(struct gameState *state) {
        -:  354:	int k;
        -:  355:	int i;
      113:  356:	int currentPlayer = whoseTurn(state);
        -:  357:
        -:  358:	//Discard hand
      676:  359:	for (i = 0; i < state->handCount[currentPlayer]; i++){
      563:  360:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
      563:  361:		state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  362:	}
      113:  363:	state->handCount[currentPlayer] = 0;//Reset hand count
        -:  364:
        -:  365:	//Code for determining the player
      113:  366:	if (currentPlayer < (state->numPlayers - 1)){
       76:  367:		state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  368:	}
        -:  369:	else{
       37:  370:		state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  371:	}
        -:  372:
      113:  373:	state->outpostPlayed = 0;
      113:  374:	state->phase = 0;
      113:  375:	state->numActions = 1;
      113:  376:	state->coins = 0;
      113:  377:	state->numBuys = 1;
      113:  378:	state->playedCardCount = 0;
      113:  379:	state->handCount[state->whoseTurn] = 0;
        -:  380:
        -:  381:	//int k; move to top
        -:  382:	//Next player draws hand
      678:  383:	for (k = 0; k < 5; k++){
      565:  384:		drawCard(state->whoseTurn, state);//Draw a card
        -:  385:	}
        -:  386:
        -:  387:	//Update money
      113:  388:	updateCoins(state->whoseTurn, state, 0);
        -:  389:
      113:  390:	return 0;
        -:  391:}
        -:  392:
     2820:  393:int isGameOver(struct gameState *state) {
        -:  394:	int i;
        -:  395:	int j;
        -:  396:
        -:  397:	//if stack of Province cards is empty, the game ends
     2820:  398:	if (state->supplyCount[province] == 0)
        -:  399:	{
    #####:  400:		return 1;
        -:  401:	}
        -:  402:
        -:  403:	//if three supply pile are at 0, the game ends
     2820:  404:	j = 0;
    73320:  405:	for (i = 0; i < 25; i++)
        -:  406:	{
    70500:  407:		if (state->supplyCount[i] == 0)
        -:  408:		{
     1584:  409:			j++;
        -:  410:		}
        -:  411:	}
     2820:  412:	if (j >= 3)
        -:  413:	{
        1:  414:		return 1;
        -:  415:	}
        -:  416:
     2819:  417:	return 0;
        -:  418:}
        -:  419:
        3:  420:int scoreFor(int player, struct gameState *state) {
        -:  421:
        -:  422:	int i;
        3:  423:	int score = 0;
        -:  424:	//score from hand
        8:  425:	for (i = 0; i < state->handCount[player]; i++)
        -:  426:	{
        5:  427:		if (state->hand[player][i] == curse) { score = score - 1; };
        5:  428:		if (state->hand[player][i] == estate) { score = score + 1; };
        5:  429:		if (state->hand[player][i] == duchy) { score = score + 3; };
        5:  430:		if (state->hand[player][i] == province) { score = score + 6; };
        5:  431:		if (state->hand[player][i] == great_hall) { score = score + 1; };
        5:  432:		if (state->hand[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  433:	}
        -:  434:
        -:  435:	//score from discard
       27:  436:	for (i = 0; i < state->discardCount[player]; i++)
        -:  437:	{
       24:  438:		if (state->discard[player][i] == curse) { score = score - 1; };
       24:  439:		if (state->discard[player][i] == estate) { score = score + 1; };
       24:  440:		if (state->discard[player][i] == duchy) { score = score + 3; };
       24:  441:		if (state->discard[player][i] == province) { score = score + 6; };
       24:  442:		if (state->discard[player][i] == great_hall) { score = score + 1; };
       24:  443:		if (state->discard[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  444:	}
        -:  445:
        -:  446:	//score from deck
       27:  447:	for (i = 0; i < state->discardCount[player]; i++)
        -:  448:	{
       24:  449:		if (state->deck[player][i] == curse) { score = score - 1; };
       24:  450:		if (state->deck[player][i] == estate) { score = score + 1; };
       24:  451:		if (state->deck[player][i] == duchy) { score = score + 3; };
       24:  452:		if (state->deck[player][i] == province) { score = score + 6; };
       24:  453:		if (state->deck[player][i] == great_hall) { score = score + 1; };
       24:  454:		if (state->deck[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  455:	}
        -:  456:
        3:  457:	return score;
        -:  458:}
        -:  459:
    #####:  460:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  461:	int i;
        -:  462:	int j;
        -:  463:	int highScore;
        -:  464:	int currentPlayer;
        -:  465:
        -:  466:	//get score for each player
    #####:  467:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  468:	{
        -:  469:		//set unused player scores to -9999
    #####:  470:		if (i >= state->numPlayers)
        -:  471:		{
    #####:  472:			players[i] = -9999;
        -:  473:		}
        -:  474:		else
        -:  475:		{
    #####:  476:			players[i] = scoreFor(i, state);
        -:  477:		}
        -:  478:	}
        -:  479:
        -:  480:	//find highest score
    #####:  481:	j = 0;
    #####:  482:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  483:	{
    #####:  484:		if (players[i] > players[j])
        -:  485:		{
    #####:  486:			j = i;
        -:  487:		}
        -:  488:	}
    #####:  489:	highScore = players[j];
        -:  490:
        -:  491:	//add 1 to players who had less turns
    #####:  492:	currentPlayer = whoseTurn(state);
    #####:  493:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  494:	{
    #####:  495:		if (players[i] == highScore && i > currentPlayer)
        -:  496:		{
    #####:  497:			players[i]++;
        -:  498:		}
        -:  499:	}
        -:  500:
        -:  501:	//find new highest score
    #####:  502:	j = 0;
    #####:  503:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  504:	{
    #####:  505:		if (players[i] > players[j])
        -:  506:		{
    #####:  507:			j = i;
        -:  508:		}
        -:  509:	}
    #####:  510:	highScore = players[j];
        -:  511:
        -:  512:	//set winners in array to 1 and rest to 0
    #####:  513:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  514:	{
    #####:  515:		if (players[i] == highScore)
        -:  516:		{
    #####:  517:			players[i] = 1;
        -:  518:		}
        -:  519:		else
        -:  520:		{
    #####:  521:			players[i] = 0;
        -:  522:		}
        -:  523:	}
        -:  524:
    #####:  525:	return 0;
        -:  526:}
        -:  527:
      585:  528:int drawCard(int player, struct gameState *state)
        -:  529:{
        -:  530:	int count;
        -:  531:	int deckCounter;
      585:  532:	if (state->deckCount[player] <= 0){//Deck is empty
        -:  533:
        -:  534:		//Step 1 Shuffle the discard pile back into a deck
        -:  535:		int i;
        -:  536:		//Move discard to deck
      719:  537:		for (i = 0; i < state->discardCount[player]; i++){
      661:  538:			state->deck[player][i] = state->discard[player][i];
      661:  539:			state->discard[player][i] = -1;
        -:  540:		}
        -:  541:
       58:  542:		state->deckCount[player] = state->discardCount[player];
       58:  543:		state->discardCount[player] = 0;//Reset discard
        -:  544:
        -:  545:		//Shufffle the deck
       58:  546:		shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  547:
        -:  548:		if (DEBUG){//Debug statements
        -:  549:			printf("Deck count now: %d\n", state->deckCount[player]);
        -:  550:		}
        -:  551:
       58:  552:		state->discardCount[player] = 0;
        -:  553:
        -:  554:		//Step 2 Draw Card
       58:  555:		count = state->handCount[player];//Get current player's hand count
        -:  556:
        -:  557:		if (DEBUG){//Debug statements
        -:  558:			printf("Current hand count: %d\n", count);
        -:  559:		}
        -:  560:
       58:  561:		deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  562:
       58:  563:		if (deckCounter == 0)
    #####:  564:			return -1;
        -:  565:
       58:  566:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
       58:  567:		state->deckCount[player]--;
       58:  568:		state->handCount[player]++;//Increment hand count
        -:  569:	}
        -:  570:
        -:  571:	else{
      527:  572:		int count = state->handCount[player];//Get current hand count for player
        -:  573:		int deckCounter;
        -:  574:		if (DEBUG){//Debug statements
        -:  575:			printf("Current hand count: %d\n", count);
        -:  576:		}
        -:  577:
      527:  578:		deckCounter = state->deckCount[player];//Create holder for the deck count
      527:  579:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
      527:  580:		state->deckCount[player]--;
      527:  581:		state->handCount[player]++;//Increment hand count
        -:  582:	}
        -:  583:
      585:  584:	return 0;
        -:  585:}
        -:  586:
      605:  587:int getCost(int cardNumber)
        -:  588:{
      605:  589:	switch (cardNumber)
        -:  590:	{
        -:  591:	case curse:
       40:  592:		return 0;
        -:  593:	case estate:
       33:  594:		return 2;
        -:  595:	case duchy:
       32:  596:		return 5;
        -:  597:	case province:
       37:  598:		return 8;
        -:  599:	case copper:
       48:  600:		return 0;
        -:  601:	case silver:
       39:  602:		return 3;
        -:  603:	case gold:
       38:  604:		return 6;
        -:  605:	case adventurer:
    #####:  606:		return 6;
        -:  607:	case council_room:
    #####:  608:		return 5;
        -:  609:	case feast:
       25:  610:		return 4;
        -:  611:	case gardens:
       35:  612:		return 4;
        -:  613:	case mine:
       33:  614:		return 5;
        -:  615:	case remodel:
    #####:  616:		return 4;
        -:  617:	case smithy:
       35:  618:		return 4;
        -:  619:	case village:
       36:  620:		return 3;
        -:  621:	case baron:
    #####:  622:		return 4;
        -:  623:	case great_hall:
       41:  624:		return 3;
        -:  625:	case minion:
       34:  626:		return 5;
        -:  627:	case steward:
    #####:  628:		return 3;
        -:  629:	case tribute:
       31:  630:		return 5;
        -:  631:	case ambassador:
    #####:  632:		return 3;
        -:  633:	case cutpurse:
    #####:  634:		return 4;
        -:  635:	case embargo:
    #####:  636:		return 2;
        -:  637:	case outpost:
       23:  638:		return 5;
        -:  639:	case salvager:
    #####:  640:		return 4;
        -:  641:	case sea_hag:
       45:  642:		return 4;
        -:  643:	case treasure_map:
    #####:  644:		return 4;
        -:  645:	}
        -:  646:
    #####:  647:	return -1;
        -:  648:}
        -:  649:
    #####:  650:void playAdventurer(struct gameState *state, int currentPlayer)
        -:  651:// Reveal cards from deck until 2 Treasure cards are found.  Put those Treasure cards in the hand and discard the rest.
        -:  652:{
    #####:  653:	int drawntreasure = 0;
        -:  654:	int temphand[MAX_HAND];
        -:  655:	int cardDrawn;
    #####:  656:	int z = 0; // this is the counter for the temp hand
        -:  657:
    #####:  658:	while (drawntreasure < 2){
    #####:  659:		if (state->deckCount[currentPlayer] < 1){//if the deck is empty we need to shuffle discard and add to deck
    #####:  660:			shuffle(currentPlayer, state);
        -:  661:		}
    #####:  662:		drawCard(currentPlayer, state);
    #####:  663:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer] - 1];//top card of hand is most recently drawn card.
    #####:  664:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
    #####:  665:			drawntreasure++;
        -:  666:		else{
    #####:  667:			temphand[z] = cardDrawn;
    #####:  668:			state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####:  669:			z++;
        -:  670:		}
        -:  671:	}
    #####:  672:	while (z - 1 >= 0){
    #####:  673:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; // discard all cards in play that have been drawn
    #####:  674:		z = z - 1;
        -:  675:	}
    #####:  676:}
        -:  677:
    #####:  678:int playRemodel(struct gameState *state, int currentPlayer, int choice1, int choice2, int handPos)
        -:  679://Trash a card in the hand, and gain a card costing up to $2 more than the trashed card
        -:  680:{
        -:  681:	int i;
    #####:  682:	int j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  683:
    #####:  684:	if ((getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2))
        -:  685:	{
    #####:  686:		return -1;
        -:  687:	}
        -:  688:
    #####:  689:	gainCard(choice2, state, 0, currentPlayer);
        -:  690:
        -:  691:	//discard card from hand
    #####:  692:	discardCard(handPos, currentPlayer, state, 0);
        -:  693:
        -:  694:	//discard trashed card
    #####:  695:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  696:	{
    #####:  697:		if (state->hand[currentPlayer][i] == j)
        -:  698:		{
    #####:  699:			discardCard(i, currentPlayer, state, 0);
    #####:  700:			break;
        -:  701:		}
        -:  702:	}
        -:  703:
    #####:  704:	return 0;
        -:  705:}
        -:  706:
    #####:  707:void playSmithy(struct gameState *state, int currentPlayer, int handPos)
        -:  708:// Draw 3 cards
        -:  709:{
        -:  710:	int i;
    #####:  711:	for (i = 0; i < 3; i++)
        -:  712:	{
    #####:  713:		drawCard(currentPlayer, state);
        -:  714:	}
        -:  715:
        -:  716:	//discard card from hand
    #####:  717:	discardCard(handPos, currentPlayer, state, 0);
    #####:  718:}
        -:  719:
    #####:  720:void playBaron(struct gameState *state, int currentPlayer, int choice1, int handPos)
        -:  721://Add a buy.  OPTION:  Discard an Estate card and gain $4.  Otherwise, gain an Estate card.
        -:  722:{
    #####:  723:	state->numBuys++;//Increase buys by 1!
    #####:  724:	if (choice1 > 0){//Boolean true or going to discard an estate
    #####:  725:		int p = 0;//Iterator for hand!
    #####:  726:		int card_not_discarded = 1;//Flag for discard set!
    #####:  727:		while (card_not_discarded){
    #####:  728:			if (state->hand[currentPlayer][p] == estate){ //Found an estate card!
    #####:  729:				state->coins += 4;//Add 4 coins to the amount of coins
    #####:  730:				state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  731:				state->discardCount[currentPlayer]++;
    #####:  732:				for (; p < state->handCount[currentPlayer]; p++){
    #####:  733:					state->hand[currentPlayer][p] = state->hand[currentPlayer][p + 1];
        -:  734:				}
    #####:  735:				state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  736:				state->handCount[currentPlayer]--;
    #####:  737:				card_not_discarded = 0;//Exit the loop
        -:  738:			}
    #####:  739:			else if (p > state->handCount[currentPlayer]){
        -:  740:				if (DEBUG) {
        -:  741:					printf("No estate cards in your hand, invalid choice\n");
        -:  742:					printf("Must gain an estate if there are any\n");
        -:  743:				}
    #####:  744:				if (supplyCount(estate, state) > 0){
    #####:  745:					gainCard(estate, state, 1, currentPlayer);
    #####:  746:					state->supplyCount[estate]--;//Decrement estates
    #####:  747:					if (supplyCount(estate, state) == 0){
    #####:  748:						isGameOver(state);
        -:  749:					}
        -:  750:				}
    #####:  751:				card_not_discarded = 0;//Exit the loop
        -:  752:			}
        -:  753:
        -:  754:			else{
    #####:  755:				p++;//Next card
        -:  756:			}
        -:  757:		}
        -:  758:	}
        -:  759:
        -:  760:	else{
    #####:  761:		if (supplyCount(estate, state) > 0){
    #####:  762:			gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  763:			state->supplyCount[estate]--;//Decrement Estates
    #####:  764:			if (supplyCount(estate, state) == 0){
    #####:  765:				isGameOver(state);
        -:  766:			}
        -:  767:		}
        -:  768:	}
    #####:  769:}
        -:  770:
    #####:  771:int playTreasureMap(struct gameState *state, int currentPlayer, int handPos)
        -:  772://Trashing two treasure map cards from the hand = four gold on top of the deck.
        -:  773:{
        -:  774:	int i;
        -:  775:	int index;
        -:  776:
        -:  777:	//search hand for another treasure_map
    #####:  778:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  779:	{
    #####:  780:		if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -:  781:		{
    #####:  782:			index = i;
    #####:  783:			break;
        -:  784:		}
        -:  785:	}
    #####:  786:	if (index > -1)
        -:  787:	{
        -:  788:		//trash both treasure cards
    #####:  789:		discardCard(handPos, currentPlayer, state, 1);
    #####:  790:		discardCard(index, currentPlayer, state, 1);
        -:  791:
        -:  792:		//gain 4 Gold cards
    #####:  793:		for (i = 0; i < 4; i++)
        -:  794:		{
    #####:  795:			gainCard(gold, state, 1, currentPlayer);
        -:  796:		}
        -:  797:
        -:  798:		//return success
    #####:  799:		return 1;
        -:  800:	}
        -:  801:
        -:  802:	//no second treasure_map found in hand
    #####:  803:	return -1;
        -:  804:}
        -:  805:
       76:  806:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  807:{
        -:  808:	int i;
        -:  809:	int j;
        -:  810:	int k;
        -:  811:	//int x;  //Unused after while loop removed from feast.
       76:  812:	int currentPlayer = whoseTurn(state);
       76:  813:	int nextPlayer = currentPlayer + 1;
        -:  814:	int temphand[MAX_HAND];
        -:  815:
       76:  816:	int tributeRevealedCards[2] = { -1, -1 };
        -:  817:
       76:  818:	if (nextPlayer > (state->numPlayers - 1)){
       22:  819:		nextPlayer = 0;
        -:  820:	}
        -:  821:
        -:  822:	//uses switch to select card and perform actions
       76:  823:	switch (card)
        -:  824:	{
        -:  825:	case adventurer:
        -:  826:
    #####:  827:		playAdventurer(state, currentPlayer);
    #####:  828:		return 0;
        -:  829:
        -:  830:	case council_room:
        -:  831:		//+4 Cards
    #####:  832:		for (i = 0; i < 4; i++)
        -:  833:		{
    #####:  834:			drawCard(currentPlayer, state);
        -:  835:		}
        -:  836:
        -:  837:		//+1 Buy
    #####:  838:		state->numBuys++;
        -:  839:
        -:  840:		//Each other player draws a card
    #####:  841:		for (i = 0; i < state->numPlayers; i++)
        -:  842:		{
    #####:  843:			if (i != currentPlayer)
        -:  844:			{
    #####:  845:				drawCard(i, state);
        -:  846:			}
        -:  847:		}
        -:  848:
        -:  849:		//put played card in played card pile
    #####:  850:		discardCard(handPos, currentPlayer, state, 0);
        -:  851:
    #####:  852:		return 0;
        -:  853:
        -:  854:	case feast:
        -:  855:		//gain card with cost up to 5
        -:  856:		//Backup hand
    #####:  857:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  858:			temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  859:			state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  860:		}
        -:  861:		//Backup hand
        -:  862:
        -:  863:		//Update Coins for Buy
    #####:  864:		updateCoins(currentPlayer, state, 5);
        -:  865://		x = 1;//Condition to loop on
        -:  866://		while (x == 1) {//Buy one card
    #####:  867:			if (supplyCount(choice1, state) <= 0){
        -:  868:				if (DEBUG)
        -:  869:					printf("None of that card left, sorry!\n");
        -:  870:
        -:  871:				if (DEBUG){
        -:  872:					printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  873:				}
        -:  874:			}
    #####:  875:			else if (state->coins < getCost(choice1)){
    #####:  876:				printf("That card is too expensive!\n");
        -:  877:
        -:  878:				if (DEBUG){
        -:  879:					printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  880:				}
        -:  881:			}
        -:  882:			else{
        -:  883:
        -:  884:				if (DEBUG){
        -:  885:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  886:				}
        -:  887:
    #####:  888:				gainCard(choice1, state, 0, currentPlayer);//Gain the card
        -:  889://				x = 0;//No more buying cards
        -:  890:
        -:  891:				if (DEBUG){
        -:  892:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  893:				}
        -:  894:
        -:  895:			}
        -:  896://		}
        -:  897:
        -:  898:		//Reset Hand
    #####:  899:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  900:			state->hand[currentPlayer][i] = temphand[i];
    #####:  901:			temphand[i] = -1;
        -:  902:		}
        -:  903:		//Reset Hand
        -:  904:
    #####:  905:		return 0;
        -:  906:
        -:  907:	case gardens:
       47:  908:		return -1;
        -:  909:
        -:  910:	case mine:
    #####:  911:		j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  912:
    #####:  913:		if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  914:		{
    #####:  915:			return -1;
        -:  916:		}
        -:  917:
    #####:  918:		if (choice2 > treasure_map || choice2 < curse)
        -:  919:		{
    #####:  920:			return -1;
        -:  921:		}
        -:  922:
    #####:  923:		if ((getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2))
        -:  924:		{
    #####:  925:			return -1;
        -:  926:		}
        -:  927:
    #####:  928:		gainCard(choice2, state, 2, currentPlayer);
        -:  929:
        -:  930:		//discard card from hand
    #####:  931:		discardCard(handPos, currentPlayer, state, 0);
        -:  932:
        -:  933:		//discard trashed card
    #####:  934:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  935:		{
    #####:  936:			if (state->hand[currentPlayer][i] == j)
        -:  937:			{
    #####:  938:				discardCard(i, currentPlayer, state, 0);
    #####:  939:				break;
        -:  940:			}
        -:  941:		}
        -:  942:
    #####:  943:		return 0;
        -:  944:
        -:  945:	case remodel:
        -:  946:
    #####:  947:		return playRemodel(state, currentPlayer, choice1, choice2, handPos);
        -:  948:
        -:  949:	case smithy:
        -:  950:
    #####:  951:		playSmithy(state, currentPlayer, handPos);
    #####:  952:		return 0;
        -:  953:
        -:  954:	case village:
        -:  955:		//+1 Card
        7:  956:		drawCard(currentPlayer, state);
        -:  957:
        -:  958:		//+2 Actions
        7:  959:		state->numActions = state->numActions + 2;
        -:  960:
        -:  961:		//discard played card from hand
        7:  962:		discardCard(handPos, currentPlayer, state, 0);
        7:  963:		return 0;
        -:  964:
        -:  965:	case baron:
        -:  966:
    #####:  967:		playBaron(state, currentPlayer, choice1, handPos);
    #####:  968:		return 0;
        -:  969:
        -:  970:	case great_hall:
        -:  971:		//+1 Card
        4:  972:		drawCard(currentPlayer, state);
        -:  973:
        -:  974:		//+1 Actions
        4:  975:		state->numActions++;
        -:  976:
        -:  977:		//discard card from hand
        4:  978:		discardCard(handPos, currentPlayer, state, 0);
        4:  979:		return 0;
        -:  980:
        -:  981:	case minion:
        -:  982:		//+1 action
        2:  983:		state->numActions++;
        -:  984:
        -:  985:		//discard card from hand
        2:  986:		discardCard(handPos, currentPlayer, state, 0);
        -:  987:
        2:  988:		if (choice1)		//+2 coins
        -:  989:		{
        1:  990:			state->coins = state->coins + 2;
        -:  991:		}
        -:  992:
        1:  993:		else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  994:		{
        -:  995:			//discard hand
        6:  996:			while (numHandCards(state) > 0)
        -:  997:			{
        4:  998:				discardCard(handPos, currentPlayer, state, 0);
        -:  999:			}
        -: 1000:
        -: 1001:			//draw 4
        5: 1002:			for (i = 0; i < 4; i++)
        -: 1003:			{
        4: 1004:				drawCard(currentPlayer, state);
        -: 1005:			}
        -: 1006:
        -: 1007:			//other players discard hand and redraw if hand size > 4
        4: 1008:			for (i = 0; i < state->numPlayers; i++)
        -: 1009:			{
        3: 1010:				if (i != currentPlayer)
        -: 1011:				{
        2: 1012:					if (state->handCount[i] > 4)
        -: 1013:					{
        -: 1014:						//discard hand
    #####: 1015:						while (state->handCount[i] > 0)
        -: 1016:						{
    #####: 1017:							discardCard(handPos, i, state, 0);
        -: 1018:						}
        -: 1019:
        -: 1020:						//draw 4
    #####: 1021:						for (j = 0; j < 4; j++)
        -: 1022:						{
    #####: 1023:							drawCard(i, state);
        -: 1024:						}
        -: 1025:					}
        -: 1026:				}
        -: 1027:			}
        -: 1028:
        -: 1029:		}
        2: 1030:		return 0;
        -: 1031:
        -: 1032:	case steward:
    #####: 1033:		if (choice1 == 1)
        -: 1034:		{
        -: 1035:			//+2 cards
    #####: 1036:			drawCard(currentPlayer, state);
    #####: 1037:			drawCard(currentPlayer, state);
        -: 1038:		}
    #####: 1039:		else if (choice1 == 2)
        -: 1040:		{
        -: 1041:			//+2 coins
    #####: 1042:			state->coins = state->coins + 2;
        -: 1043:		}
        -: 1044:		else
        -: 1045:		{
        -: 1046:			//trash 2 cards in hand
    #####: 1047:			discardCard(choice2, currentPlayer, state, 1);
    #####: 1048:			discardCard(choice3, currentPlayer, state, 1);
        -: 1049:		}
        -: 1050:
        -: 1051:		//discard card from hand
    #####: 1052:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1053:		return 0;
        -: 1054:
        -: 1055:	case tribute:
    #####: 1056:		if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####: 1057:			if (state->deckCount[nextPlayer] > 0){
    #####: 1058:				tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1059:				state->deckCount[nextPlayer]--;
        -: 1060:			}
    #####: 1061:			else if (state->discardCount[nextPlayer] > 0){
    #####: 1062:				tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer] - 1];
    #####: 1063:				state->discardCount[nextPlayer]--;
        -: 1064:			}
        -: 1065:			else{
        -: 1066:				//No Card to Reveal
        -: 1067:				if (DEBUG){
        -: 1068:					printf("No cards to reveal\n");
        -: 1069:				}
        -: 1070:			}
        -: 1071:		}
        -: 1072:
        -: 1073:		else{
    #####: 1074:			if (state->deckCount[nextPlayer] == 0){
    #####: 1075:				for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####: 1076:					state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1077:					state->deckCount[nextPlayer]++;
    #####: 1078:					state->discard[nextPlayer][i] = -1;
    #####: 1079:					state->discardCount[nextPlayer]--;
        -: 1080:				}
        -: 1081:
    #####: 1082:				shuffle(nextPlayer, state);//Shuffle the deck
        -: 1083:			}
    #####: 1084:			tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1085:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1086:			state->deckCount[nextPlayer]--;
    #####: 1087:			tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1088:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1089:			state->deckCount[nextPlayer]--;
        -: 1090:		}
        -: 1091:
    #####: 1092:		if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
    #####: 1093:			state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1094:			state->playedCardCount++;
    #####: 1095:			tributeRevealedCards[1] = -1;
        -: 1096:		}
        -: 1097:
    #####: 1098:		for (i = 0; i <= 2; i++){
    #####: 1099:			if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
    #####: 1100:				state->coins += 2;
        -: 1101:			}
        -: 1102:
    #####: 1103:			else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
    #####: 1104:				drawCard(currentPlayer, state);
    #####: 1105:				drawCard(currentPlayer, state);
        -: 1106:			}
        -: 1107:			else{//Action Card
    #####: 1108:				state->numActions = state->numActions + 2;
        -: 1109:			}
        -: 1110:		}
        -: 1111:
    #####: 1112:		return 0;
        -: 1113:
        -: 1114:	case ambassador:
    #####: 1115:		j = 0;		//used to check if player has enough cards to discard
        -: 1116:
    #####: 1117:		if (choice2 > 2 || choice2 < 0)
        -: 1118:		{
    #####: 1119:			return -1;
        -: 1120:		}
        -: 1121:
    #####: 1122:		if (choice1 == handPos)
        -: 1123:		{
    #####: 1124:			return -1;
        -: 1125:		}
        -: 1126:
    #####: 1127:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1128:		{
    #####: 1129:			if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1130:			{
    #####: 1131:				j++;
        -: 1132:			}
        -: 1133:		}
    #####: 1134:		if (j < choice2)
        -: 1135:		{
    #####: 1136:			return -1;
        -: 1137:		}
        -: 1138:
        -: 1139:		if (DEBUG)
        -: 1140:			printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1141:
        -: 1142:		//increase supply count for choosen card by amount being discarded
    #####: 1143:		state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1144:
        -: 1145:		//each other player gains a copy of revealed card
    #####: 1146:		for (i = 0; i < state->numPlayers; i++)
        -: 1147:		{
    #####: 1148:			if (i != currentPlayer)
        -: 1149:			{
    #####: 1150:				gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1151:			}
        -: 1152:		}
        -: 1153:
        -: 1154:		//discard played card from hand
    #####: 1155:		discardCard(handPos, currentPlayer, state, 0);
        -: 1156:
        -: 1157:		//trash copies of cards returned to supply
    #####: 1158:		for (j = 0; j < choice2; j++)
        -: 1159:		{
    #####: 1160:			for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1161:			{
    #####: 1162:				if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1163:				{
    #####: 1164:					discardCard(i, currentPlayer, state, 1);
    #####: 1165:					break;
        -: 1166:				}
        -: 1167:			}
        -: 1168:		}
        -: 1169:
    #####: 1170:		return 0;
        -: 1171:
        -: 1172:	case cutpurse:
        -: 1173:
    #####: 1174:		updateCoins(currentPlayer, state, 2);
    #####: 1175:		for (i = 0; i < state->numPlayers; i++)
        -: 1176:		{
    #####: 1177:			if (i != currentPlayer)
        -: 1178:			{
    #####: 1179:				for (j = 0; j < state->handCount[i]; j++)
        -: 1180:				{
    #####: 1181:					if (state->hand[i][j] == copper)
        -: 1182:					{
    #####: 1183:						discardCard(j, i, state, 0);
    #####: 1184:						break;
        -: 1185:					}
    #####: 1186:					if (j == state->handCount[i])
        -: 1187:					{
    #####: 1188:						for (k = 0; k < state->handCount[i]; k++)
        -: 1189:						{
        -: 1190:							if (DEBUG)
        -: 1191:								printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1192:						}
    #####: 1193:						break;
        -: 1194:					}
        -: 1195:				}
        -: 1196:
        -: 1197:			}
        -: 1198:
        -: 1199:		}
        -: 1200:
        -: 1201:		//discard played card from hand
    #####: 1202:		discardCard(handPos, currentPlayer, state, 0);
        -: 1203:
    #####: 1204:		return 0;
        -: 1205:
        -: 1206:
        -: 1207:	case embargo:
        -: 1208:		//+2 Coins
    #####: 1209:		state->coins = state->coins + 2;
        -: 1210:
        -: 1211:		//see if selected pile is in play
    #####: 1212:		if (state->supplyCount[choice1] == -1)
        -: 1213:		{
    #####: 1214:			return -1;
        -: 1215:		}
        -: 1216:
        -: 1217:		//add embargo token to selected supply pile
    #####: 1218:		state->embargoTokens[choice1]++;
        -: 1219:
        -: 1220:		//trash card
    #####: 1221:		discardCard(handPos, currentPlayer, state, 1);
    #####: 1222:		return 0;
        -: 1223:
        -: 1224:	case outpost:
        -: 1225:		//set outpost flag
    #####: 1226:		state->outpostPlayed++;
        -: 1227:
        -: 1228:		//discard card
    #####: 1229:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1230:		return 0;
        -: 1231:
        -: 1232:	case salvager:
        -: 1233:		//+1 buy
    #####: 1234:		state->numBuys++;
        -: 1235:
    #####: 1236:		if (choice1)
        -: 1237:		{
        -: 1238:			//gain coins equal to trashed card
    #####: 1239:			state->coins = state->coins + getCost(handCard(choice1, state));
        -: 1240:			//trash card
    #####: 1241:			discardCard(choice1, currentPlayer, state, 1);
        -: 1242:		}
        -: 1243:
        -: 1244:		//discard card
    #####: 1245:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1246:		return 0;
        -: 1247:
        -: 1248:	case sea_hag:
       64: 1249:		for (i = 0; i < state->numPlayers; i++){
       48: 1250:			if (i != currentPlayer){
       32: 1251:				state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
       32: 1252:				state->discardCount[i]++;
       32: 1253:				state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1254:			}
        -: 1255:		}
       16: 1256:		return 0;
        -: 1257:
        -: 1258:	case treasure_map:
        -: 1259:
    #####: 1260:		return playTreasureMap(state, currentPlayer, handPos);
        -: 1261:	}
    #####: 1262:	return -1;
        -: 1263:}
        -: 1264:
       17: 1265:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1266:{
        -: 1267:
        -: 1268:	//if card is not trashed, added to Played pile 
       17: 1269:	if (trashFlag < 1)
        -: 1270:	{
        -: 1271:		//add card to played pile
       17: 1272:		state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
       17: 1273:		state->playedCardCount++;
        -: 1274:	}
        -: 1275:
        -: 1276:	//set played card to -1
       17: 1277:	state->hand[currentPlayer][handPos] = -1;
        -: 1278:
        -: 1279:	//remove card from player's hand
       17: 1280:	if (handPos == (state->handCount[currentPlayer] - 1)) 	//last card in hand array is played
        -: 1281:	{
        -: 1282:		//reduce number of cards in hand
        2: 1283:		state->handCount[currentPlayer]--;
        -: 1284:	}
       15: 1285:	else if (state->handCount[currentPlayer] == 1) //only one card in hand
        -: 1286:	{
        -: 1287:		//reduce number of cards in hand
        1: 1288:		state->handCount[currentPlayer]--;
        -: 1289:	}
        -: 1290:	else
        -: 1291:	{
        -: 1292:		//replace discarded card with last card in hand
       14: 1293:		state->hand[currentPlayer][handPos] = state->hand[currentPlayer][(state->handCount[currentPlayer] - 1)];
        -: 1294:		//set last card to -1
       14: 1295:		state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1296:		//reduce number of cards in hand
       14: 1297:		state->handCount[currentPlayer]--;
        -: 1298:	}
        -: 1299:
       17: 1300:	return 0;
        -: 1301:}
        -: 1302:
       90: 1303:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1304:{
        -: 1305:	//Note: supplyPos is enum of choosen card
        -: 1306:
        -: 1307:	//check if supply pile is empty (0) or card is not used in game (-1)
       90: 1308:	if (supplyCount(supplyPos, state) < 1)
        -: 1309:	{
    #####: 1310:		return -1;
        -: 1311:	}
        -: 1312:
        -: 1313:	//added card for [whoseTurn] current player:
        -: 1314:	// toFlag = 0 : add to discard
        -: 1315:	// toFlag = 1 : add to deck
        -: 1316:	// toFlag = 2 : add to hand
        -: 1317:
       90: 1318:	if (toFlag == 1)
        -: 1319:	{
    #####: 1320:		state->deck[player][state->deckCount[player]] = supplyPos;
    #####: 1321:		state->deckCount[player]++;
        -: 1322:	}
       90: 1323:	else if (toFlag == 2)
        -: 1324:	{
    #####: 1325:		state->hand[player][state->handCount[player]] = supplyPos;
    #####: 1326:		state->handCount[player]++;
        -: 1327:	}
        -: 1328:	else
        -: 1329:	{
       90: 1330:		state->discard[player][state->discardCount[player]] = supplyPos;
       90: 1331:		state->discardCount[player]++;
        -: 1332:	}
        -: 1333:
        -: 1334:	//decrease number in supply pile
       90: 1335:	state->supplyCount[supplyPos]--;
        -: 1336:
       90: 1337:	return 0;
        -: 1338:}
        -: 1339:
      143: 1340:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1341:{
        -: 1342:	int i;
        -: 1343:
        -: 1344:	//reset coin count
      143: 1345:	state->coins = 0;
        -: 1346:
        -: 1347:	//add coins for each Treasure card in player's hand
      856: 1348:	for (i = 0; i < state->handCount[player]; i++)
        -: 1349:	{
      713: 1350:		if (state->hand[player][i] == copper)
        -: 1351:		{
      303: 1352:			state->coins += 1;
        -: 1353:		}
      410: 1354:		else if (state->hand[player][i] == silver)
        -: 1355:		{
       25: 1356:			state->coins += 2;
        -: 1357:		}
      385: 1358:		else if (state->hand[player][i] == gold)
        -: 1359:		{
    #####: 1360:			state->coins += 3;
        -: 1361:		}
        -: 1362:	}
        -: 1363:
        -: 1364:	//add bonus
      143: 1365:	state->coins += bonus;
        -: 1366:
      143: 1367:	return 0;
        -: 1368:}
        -: 1369:
        -: 1370:
        -: 1371://end of dominion.c
File 'dominion.c'
Lines executed:62.12% of 557
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
     1172:    8:int compare(const void* a, const void* b) {
     1172:    9:	if (*(int*)a > *(int*)b)
      452:   10:		return 1;
      720:   11:	if (*(int*)a < *(int*)b)
      363:   12:		return -1;
      357:   13:	return 0;
        -:   14:}
        -:   15:
        2:   16:struct gameState* newGame() {
        2:   17:	struct gameState* g = malloc(sizeof(struct gameState));
        2:   18:	return g;
        -:   19:}
        -:   20:
       44:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:	int k8, int k9, int k10) {
       44:   23:	int* k = malloc(10 * sizeof(int));
       44:   24:	k[0] = k1;
       44:   25:	k[1] = k2;
       44:   26:	k[2] = k3;
       44:   27:	k[3] = k4;
       44:   28:	k[4] = k5;
       44:   29:	k[5] = k6;
       44:   30:	k[6] = k7;
       44:   31:	k[7] = k8;
       44:   32:	k[8] = k9;
       44:   33:	k[9] = k10;
       44:   34:	return k;
        -:   35:}
        -:   36:
       44:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		struct gameState *state) {
        -:   39:
        -:   40:	int i;
        -:   41:	int j;
        -:   42:	int it;
        -:   43:	//set up random number generator
       44:   44:	SelectStream(1);
       44:   45:	PutSeed((long)randomSeed);
        -:   46:
        -:   47:	//check number of players
       44:   48:	if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:	{
    #####:   50:		return -1;
        -:   51:	}
        -:   52:
        -:   53:	//set number of players
       44:   54:	state->numPlayers = numPlayers;
        -:   55:
        -:   56:	//check selected kingdom cards are different
      122:   57:	for (i = 0; i < 10; i++)
        -:   58:	{
     1135:   59:		for (j = 0; j < 10; j++)
        -:   60:		{
     1057:   61:			if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:			{
       43:   63:				return -1;
        -:   64:			}
        -:   65:		}
        -:   66:	}
        -:   67:
        -:   68:
        -:   69:	//initialize supply
        -:   70:	///////////////////////////////
        -:   71:
        -:   72:	//set number of Curse cards
        1:   73:	if (numPlayers == 2)
        -:   74:	{
        1:   75:		state->supplyCount[curse] = 10;
        -:   76:	}
    #####:   77:	else if (numPlayers == 3)
        -:   78:	{
    #####:   79:		state->supplyCount[curse] = 20;
        -:   80:	}
        -:   81:	else
        -:   82:	{
    #####:   83:		state->supplyCount[curse] = 30;
        -:   84:	}
        -:   85:
        -:   86:	//set number of Victory cards
        1:   87:	if (numPlayers == 2)
        -:   88:	{
        1:   89:		state->supplyCount[estate] = 8;
        1:   90:		state->supplyCount[duchy] = 8;
        1:   91:		state->supplyCount[province] = 8;
        -:   92:	}
        -:   93:	else
        -:   94:	{
    #####:   95:		state->supplyCount[estate] = 12;
    #####:   96:		state->supplyCount[duchy] = 12;
    #####:   97:		state->supplyCount[province] = 12;
        -:   98:	}
        -:   99:
        -:  100:	//set number of Treasure cards
        1:  101:	state->supplyCount[copper] = 60 - (7 * numPlayers);
        1:  102:	state->supplyCount[silver] = 40;
        1:  103:	state->supplyCount[gold] = 30;
        -:  104:
        -:  105:	//set number of Kingdom cards
       21:  106:	for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:	{
      165:  108:		for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:		{
      155:  110:			if (kingdomCards[j] == i)
        -:  111:			{
        -:  112:				//check if card is a 'Victory' Kingdom card
       10:  113:				if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:				{
    #####:  115:					if (numPlayers == 2){
    #####:  116:						state->supplyCount[i] = 8;
        -:  117:					}
    #####:  118:					else{ state->supplyCount[i] = 12; }
        -:  119:				}
        -:  120:				else
        -:  121:				{
       10:  122:					state->supplyCount[i] = 10;
        -:  123:				}
       10:  124:				break;
        -:  125:			}
        -:  126:			else    //card is not in the set choosen for the game
        -:  127:			{
      145:  128:				state->supplyCount[i] = -1;
        -:  129:			}
        -:  130:		}
        -:  131:
        -:  132:	}
        -:  133:
        -:  134:	////////////////////////
        -:  135:	//supply intilization complete
        -:  136:
        -:  137:	//set player decks
        3:  138:	for (i = 0; i < numPlayers; i++)
        -:  139:	{
        2:  140:		state->deckCount[i] = 0;
        8:  141:		for (j = 0; j < 3; j++)
        -:  142:		{
        6:  143:			state->deck[i][j] = estate;
        6:  144:			state->deckCount[i]++;
        -:  145:		}
       16:  146:		for (j = 3; j < 10; j++)
        -:  147:		{
       14:  148:			state->deck[i][j] = copper;
       14:  149:			state->deckCount[i]++;
        -:  150:		}
        -:  151:	}
        -:  152:
        -:  153:	//shuffle player decks
        3:  154:	for (i = 0; i < numPlayers; i++)
        -:  155:	{
        2:  156:		if (shuffle(i, state) < 0)
        -:  157:		{
    #####:  158:			return -1;
        -:  159:		}
        -:  160:	}
        -:  161:
        -:  162:	//draw player hands
        3:  163:	for (i = 0; i < numPlayers; i++)
        -:  164:	{
        -:  165:		//initialize hand size to zero
        2:  166:		state->handCount[i] = 0;
        2:  167:		state->discardCount[i] = 0;
        -:  168:		//draw 5 cards
        -:  169:		// for (j = 0; j < 5; j++)
        -:  170:		//	{
        -:  171:		//	  drawCard(i, state);
        -:  172:		//	}
        -:  173:	}
        -:  174:
        -:  175:	//set embargo tokens to 0 for all supply piles
       28:  176:	for (i = 0; i <= treasure_map; i++)
        -:  177:	{
       27:  178:		state->embargoTokens[i] = 0;
        -:  179:	}
        -:  180:
        -:  181:	//initialize first player's turn
        1:  182:	state->outpostPlayed = 0;
        1:  183:	state->phase = 0;
        1:  184:	state->numActions = 1;
        1:  185:	state->numBuys = 1;
        1:  186:	state->playedCardCount = 0;
        1:  187:	state->whoseTurn = 0;
        1:  188:	state->handCount[state->whoseTurn] = 0;
        -:  189:	//int it; move to top
        -:  190:
        -:  191:	//Moved draw cards to here, only drawing at the start of a turn
        6:  192:	for (it = 0; it < 5; it++){
        5:  193:		drawCard(state->whoseTurn, state);
        -:  194:	}
        -:  195:
        1:  196:	updateCoins(state->whoseTurn, state, 0);
        -:  197:
        1:  198:	return 0;
        -:  199:}
        -:  200:
       50:  201:int shuffle(int player, struct gameState *state) {
        -:  202:
        -:  203:
        -:  204:	int newDeck[MAX_DECK];
       50:  205:	int newDeckPos = 0;
        -:  206:	int card;
        -:  207:	int i;
        -:  208:
       50:  209:	if (state->deckCount[player] < 1)
    #####:  210:		return -1;
       50:  211:	qsort((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
        -:  212:	/* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
      677:  214:	while (state->deckCount[player] > 0) {
      577:  215:		card = floor(Random() * state->deckCount[player]);
      577:  216:		newDeck[newDeckPos] = state->deck[player][card];
      577:  217:		newDeckPos++;
     2458:  218:		for (i = card; i < state->deckCount[player] - 1; i++) {
     1881:  219:			state->deck[player][i] = state->deck[player][i + 1];
        -:  220:		}
      577:  221:		state->deckCount[player]--;
        -:  222:	}
      627:  223:	for (i = 0; i < newDeckPos; i++) {
      577:  224:		state->deck[player][i] = newDeck[i];
      577:  225:		state->deckCount[player]++;
        -:  226:	}
        -:  227:
       50:  228:	return 0;
        -:  229:}
        -:  230:
      471:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state)
        -:  232:{
        -:  233:	int card;
      471:  234:	int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:	//check if it is the right phase
      471:  237:	if (state->phase != 0)
        -:  238:	{
       86:  239:		return -1;
        -:  240:	}
        -:  241:
        -:  242:	//check if player has enough actions
      385:  243:	if (state->numActions < 1)
        -:  244:	{
       18:  245:		return -1;
        -:  246:	}
        -:  247:
        -:  248:	//get card played
      367:  249:	card = handCard(handPos, state);
        -:  250:
        -:  251:	//check if selected card is an action
      367:  252:	if (card < adventurer || card > treasure_map)
        -:  253:	{
      309:  254:		return -1;
        -:  255:	}
        -:  256:
        -:  257:	//play card
       58:  258:	if (cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0)
        -:  259:	{
       26:  260:		return -1;
        -:  261:	}
        -:  262:
        -:  263:	//reduce number of actions
       32:  264:	state->numActions--;
        -:  265:
        -:  266:	//update coins (Treasure cards may be added with card draws)
       32:  267:	updateCoins(state->whoseTurn, state, coin_bonus);
        -:  268:
       32:  269:	return 0;
        -:  270:}
        -:  271:
      468:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:	int who;
        -:  274:	if (DEBUG){
        -:  275:		printf("Entering buyCard...\n");
        -:  276:	}
        -:  277:
        -:  278:	// I don't know what to do about the phase thing.
        -:  279:
      468:  280:	who = state->whoseTurn;
        -:  281:
      468:  282:	if (state->numBuys < 1){
        -:  283:		if (DEBUG)
        -:  284:			printf("You do not have any buys left\n");
       79:  285:		return -1;
        -:  286:	}
      389:  287:	else if (supplyCount(supplyPos, state) < 1){
        -:  288:		if (DEBUG)
        -:  289:			printf("There are not any of that type of card left\n");
      161:  290:		return -1;
        -:  291:	}
      228:  292:	else if (state->coins < getCost(supplyPos)){
        -:  293:		if (DEBUG)
        -:  294:			printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
      155:  295:		return -1;
        -:  296:	}
        -:  297:	else {
       73:  298:		state->phase = 1;
        -:  299:		//state->supplyCount[supplyPos]--;
       73:  300:		gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  301:
       73:  302:		state->coins = (state->coins) - (getCost(supplyPos));
       73:  303:		state->numBuys--;
        -:  304:		if (DEBUG)
        -:  305:			printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  306:	}
        -:  307:
        -:  308:	//state->discard[who][state->discardCount[who]] = supplyPos;
        -:  309:	//state->discardCount[who]++;
        -:  310:
       73:  311:	return 0;
        -:  312:}
        -:  313:
    #####:  314:int numHandCards(struct gameState *state) {
    #####:  315:	return state->handCount[whoseTurn(state)];
        -:  316:}
        -:  317:
      367:  318:int handCard(int handPos, struct gameState *state) {
      367:  319:	int currentPlayer = whoseTurn(state);
      367:  320:	return state->hand[currentPlayer][handPos];
        -:  321:}
        -:  322:
      471:  323:int supplyCount(int card, struct gameState *state) {
      471:  324:	return state->supplyCount[card];
        -:  325:}
        -:  326:
    #####:  327:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  328:	int i;
    #####:  329:	int count = 0;
        -:  330:
    #####:  331:	for (i = 0; i < state->deckCount[player]; i++)
        -:  332:	{
    #####:  333:		if (state->deck[player][i] == card) count++;
        -:  334:	}
        -:  335:
    #####:  336:	for (i = 0; i < state->handCount[player]; i++)
        -:  337:	{
    #####:  338:		if (state->hand[player][i] == card) count++;
        -:  339:	}
        -:  340:
    #####:  341:	for (i = 0; i < state->discardCount[player]; i++)
        -:  342:	{
    #####:  343:		if (state->discard[player][i] == card) count++;
        -:  344:	}
        -:  345:
    #####:  346:	return count;
        -:  347:}
        -:  348:
      524:  349:int whoseTurn(struct gameState *state) {
      524:  350:	return state->whoseTurn;
        -:  351:}
        -:  352:
       99:  353:int endTurn(struct gameState *state) {
        -:  354:	int k;
        -:  355:	int i;
       99:  356:	int currentPlayer = whoseTurn(state);
        -:  357:
        -:  358:	//Discard hand
      596:  359:	for (i = 0; i < state->handCount[currentPlayer]; i++){
      497:  360:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
      497:  361:		state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  362:	}
       99:  363:	state->handCount[currentPlayer] = 0;//Reset hand count
        -:  364:
        -:  365:	//Code for determining the player
       99:  366:	if (currentPlayer < (state->numPlayers - 1)){
       50:  367:		state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  368:	}
        -:  369:	else{
       49:  370:		state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  371:	}
        -:  372:
       99:  373:	state->outpostPlayed = 0;
       99:  374:	state->phase = 0;
       99:  375:	state->numActions = 1;
       99:  376:	state->coins = 0;
       99:  377:	state->numBuys = 1;
       99:  378:	state->playedCardCount = 0;
       99:  379:	state->handCount[state->whoseTurn] = 0;
        -:  380:
        -:  381:	//int k; move to top
        -:  382:	//Next player draws hand
      594:  383:	for (k = 0; k < 5; k++){
      495:  384:		drawCard(state->whoseTurn, state);//Draw a card
        -:  385:	}
        -:  386:
        -:  387:	//Update money
       99:  388:	updateCoins(state->whoseTurn, state, 0);
        -:  389:
       99:  390:	return 0;
        -:  391:}
        -:  392:
     1415:  393:int isGameOver(struct gameState *state) {
        -:  394:	int i;
        -:  395:	int j;
        -:  396:
        -:  397:	//if stack of Province cards is empty, the game ends
     1415:  398:	if (state->supplyCount[province] == 0)
        -:  399:	{
    #####:  400:		return 1;
        -:  401:	}
        -:  402:
        -:  403:	//if three supply pile are at 0, the game ends
     1415:  404:	j = 0;
    36790:  405:	for (i = 0; i < 25; i++)
        -:  406:	{
    35375:  407:		if (state->supplyCount[i] == 0)
        -:  408:		{
      939:  409:			j++;
        -:  410:		}
        -:  411:	}
     1415:  412:	if (j >= 3)
        -:  413:	{
        1:  414:		return 1;
        -:  415:	}
        -:  416:
     1414:  417:	return 0;
        -:  418:}
        -:  419:
        2:  420:int scoreFor(int player, struct gameState *state) {
        -:  421:
        -:  422:	int i;
        2:  423:	int score = 0;
        -:  424:	//score from hand
        7:  425:	for (i = 0; i < state->handCount[player]; i++)
        -:  426:	{
        5:  427:		if (state->hand[player][i] == curse) { score = score - 1; };
        5:  428:		if (state->hand[player][i] == estate) { score = score + 1; };
        5:  429:		if (state->hand[player][i] == duchy) { score = score + 3; };
        5:  430:		if (state->hand[player][i] == province) { score = score + 6; };
        5:  431:		if (state->hand[player][i] == great_hall) { score = score + 1; };
        5:  432:		if (state->hand[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  433:	}
        -:  434:
        -:  435:	//score from discard
       34:  436:	for (i = 0; i < state->discardCount[player]; i++)
        -:  437:	{
       32:  438:		if (state->discard[player][i] == curse) { score = score - 1; };
       32:  439:		if (state->discard[player][i] == estate) { score = score + 1; };
       32:  440:		if (state->discard[player][i] == duchy) { score = score + 3; };
       32:  441:		if (state->discard[player][i] == province) { score = score + 6; };
       32:  442:		if (state->discard[player][i] == great_hall) { score = score + 1; };
       32:  443:		if (state->discard[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  444:	}
        -:  445:
        -:  446:	//score from deck
       34:  447:	for (i = 0; i < state->discardCount[player]; i++)
        -:  448:	{
       32:  449:		if (state->deck[player][i] == curse) { score = score - 1; };
       32:  450:		if (state->deck[player][i] == estate) { score = score + 1; };
       32:  451:		if (state->deck[player][i] == duchy) { score = score + 3; };
       32:  452:		if (state->deck[player][i] == province) { score = score + 6; };
       32:  453:		if (state->deck[player][i] == great_hall) { score = score + 1; };
       32:  454:		if (state->deck[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  455:	}
        -:  456:
        2:  457:	return score;
        -:  458:}
        -:  459:
    #####:  460:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  461:	int i;
        -:  462:	int j;
        -:  463:	int highScore;
        -:  464:	int currentPlayer;
        -:  465:
        -:  466:	//get score for each player
    #####:  467:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  468:	{
        -:  469:		//set unused player scores to -9999
    #####:  470:		if (i >= state->numPlayers)
        -:  471:		{
    #####:  472:			players[i] = -9999;
        -:  473:		}
        -:  474:		else
        -:  475:		{
    #####:  476:			players[i] = scoreFor(i, state);
        -:  477:		}
        -:  478:	}
        -:  479:
        -:  480:	//find highest score
    #####:  481:	j = 0;
    #####:  482:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  483:	{
    #####:  484:		if (players[i] > players[j])
        -:  485:		{
    #####:  486:			j = i;
        -:  487:		}
        -:  488:	}
    #####:  489:	highScore = players[j];
        -:  490:
        -:  491:	//add 1 to players who had less turns
    #####:  492:	currentPlayer = whoseTurn(state);
    #####:  493:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  494:	{
    #####:  495:		if (players[i] == highScore && i > currentPlayer)
        -:  496:		{
    #####:  497:			players[i]++;
        -:  498:		}
        -:  499:	}
        -:  500:
        -:  501:	//find new highest score
    #####:  502:	j = 0;
    #####:  503:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  504:	{
    #####:  505:		if (players[i] > players[j])
        -:  506:		{
    #####:  507:			j = i;
        -:  508:		}
        -:  509:	}
    #####:  510:	highScore = players[j];
        -:  511:
        -:  512:	//set winners in array to 1 and rest to 0
    #####:  513:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  514:	{
    #####:  515:		if (players[i] == highScore)
        -:  516:		{
    #####:  517:			players[i] = 1;
        -:  518:		}
        -:  519:		else
        -:  520:		{
    #####:  521:			players[i] = 0;
        -:  522:		}
        -:  523:	}
        -:  524:
    #####:  525:	return 0;
        -:  526:}
        -:  527:
      516:  528:int drawCard(int player, struct gameState *state)
        -:  529:{
        -:  530:	int count;
        -:  531:	int deckCounter;
      516:  532:	if (state->deckCount[player] <= 0){//Deck is empty
        -:  533:
        -:  534:		//Step 1 Shuffle the discard pile back into a deck
        -:  535:		int i;
        -:  536:		//Move discard to deck
      605:  537:		for (i = 0; i < state->discardCount[player]; i++){
      557:  538:			state->deck[player][i] = state->discard[player][i];
      557:  539:			state->discard[player][i] = -1;
        -:  540:		}
        -:  541:
       48:  542:		state->deckCount[player] = state->discardCount[player];
       48:  543:		state->discardCount[player] = 0;//Reset discard
        -:  544:
        -:  545:		//Shufffle the deck
       48:  546:		shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  547:
        -:  548:		if (DEBUG){//Debug statements
        -:  549:			printf("Deck count now: %d\n", state->deckCount[player]);
        -:  550:		}
        -:  551:
       48:  552:		state->discardCount[player] = 0;
        -:  553:
        -:  554:		//Step 2 Draw Card
       48:  555:		count = state->handCount[player];//Get current player's hand count
        -:  556:
        -:  557:		if (DEBUG){//Debug statements
        -:  558:			printf("Current hand count: %d\n", count);
        -:  559:		}
        -:  560:
       48:  561:		deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  562:
       48:  563:		if (deckCounter == 0)
    #####:  564:			return -1;
        -:  565:
       48:  566:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
       48:  567:		state->deckCount[player]--;
       48:  568:		state->handCount[player]++;//Increment hand count
        -:  569:	}
        -:  570:
        -:  571:	else{
      468:  572:		int count = state->handCount[player];//Get current hand count for player
        -:  573:		int deckCounter;
        -:  574:		if (DEBUG){//Debug statements
        -:  575:			printf("Current hand count: %d\n", count);
        -:  576:		}
        -:  577:
      468:  578:		deckCounter = state->deckCount[player];//Create holder for the deck count
      468:  579:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
      468:  580:		state->deckCount[player]--;
      468:  581:		state->handCount[player]++;//Increment hand count
        -:  582:	}
        -:  583:
      516:  584:	return 0;
        -:  585:}
        -:  586:
      307:  587:int getCost(int cardNumber)
        -:  588:{
      307:  589:	switch (cardNumber)
        -:  590:	{
        -:  591:	case curse:
       21:  592:		return 0;
        -:  593:	case estate:
       13:  594:		return 2;
        -:  595:	case duchy:
        8:  596:		return 5;
        -:  597:	case province:
       14:  598:		return 8;
        -:  599:	case copper:
       34:  600:		return 0;
        -:  601:	case silver:
       16:  602:		return 3;
        -:  603:	case gold:
       16:  604:		return 6;
        -:  605:	case adventurer:
       16:  606:		return 6;
        -:  607:	case council_room:
       17:  608:		return 5;
        -:  609:	case feast:
    #####:  610:		return 4;
        -:  611:	case gardens:
    #####:  612:		return 4;
        -:  613:	case mine:
    #####:  614:		return 5;
        -:  615:	case remodel:
       19:  616:		return 4;
        -:  617:	case smithy:
       10:  618:		return 4;
        -:  619:	case village:
    #####:  620:		return 3;
        -:  621:	case baron:
       16:  622:		return 4;
        -:  623:	case great_hall:
    #####:  624:		return 3;
        -:  625:	case minion:
       14:  626:		return 5;
        -:  627:	case steward:
    #####:  628:		return 3;
        -:  629:	case tribute:
       21:  630:		return 5;
        -:  631:	case ambassador:
       28:  632:		return 3;
        -:  633:	case cutpurse:
       22:  634:		return 4;
        -:  635:	case embargo:
        1:  636:		return 2;
        -:  637:	case outpost:
    #####:  638:		return 5;
        -:  639:	case salvager:
    #####:  640:		return 4;
        -:  641:	case sea_hag:
       20:  642:		return 4;
        -:  643:	case treasure_map:
        1:  644:		return 4;
        -:  645:	}
        -:  646:
    #####:  647:	return -1;
        -:  648:}
        -:  649:
    #####:  650:void playAdventurer(struct gameState *state, int currentPlayer)
        -:  651:// Reveal cards from deck until 2 Treasure cards are found.  Put those Treasure cards in the hand and discard the rest.
        -:  652:{
    #####:  653:	int drawntreasure = 0;
        -:  654:	int temphand[MAX_HAND];
        -:  655:	int cardDrawn;
    #####:  656:	int z = 0; // this is the counter for the temp hand
        -:  657:
    #####:  658:	while (drawntreasure < 2){
    #####:  659:		if (state->deckCount[currentPlayer] < 1){//if the deck is empty we need to shuffle discard and add to deck
    #####:  660:			shuffle(currentPlayer, state);
        -:  661:		}
    #####:  662:		drawCard(currentPlayer, state);
    #####:  663:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer] - 1];//top card of hand is most recently drawn card.
    #####:  664:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
    #####:  665:			drawntreasure++;
        -:  666:		else{
    #####:  667:			temphand[z] = cardDrawn;
    #####:  668:			state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####:  669:			z++;
        -:  670:		}
        -:  671:	}
    #####:  672:	while (z - 1 >= 0){
    #####:  673:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; // discard all cards in play that have been drawn
    #####:  674:		z = z - 1;
        -:  675:	}
    #####:  676:}
        -:  677:
        3:  678:int playRemodel(struct gameState *state, int currentPlayer, int choice1, int choice2, int handPos)
        -:  679://Trash a card in the hand, and gain a card costing up to $2 more than the trashed card
        -:  680:{
        -:  681:	int i;
        3:  682:	int j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  683:
        3:  684:	if ((getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2))
        -:  685:	{
    #####:  686:		return -1;
        -:  687:	}
        -:  688:
        3:  689:	gainCard(choice2, state, 0, currentPlayer);
        -:  690:
        -:  691:	//discard card from hand
        3:  692:	discardCard(handPos, currentPlayer, state, 0);
        -:  693:
        -:  694:	//discard trashed card
        6:  695:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  696:	{
        6:  697:		if (state->hand[currentPlayer][i] == j)
        -:  698:		{
        3:  699:			discardCard(i, currentPlayer, state, 0);
        3:  700:			break;
        -:  701:		}
        -:  702:	}
        -:  703:
        3:  704:	return 0;
        -:  705:}
        -:  706:
    #####:  707:void playSmithy(struct gameState *state, int currentPlayer, int handPos)
        -:  708:// Draw 3 cards
        -:  709:{
        -:  710:	int i;
    #####:  711:	for (i = 0; i < 3; i++)
        -:  712:	{
    #####:  713:		drawCard(currentPlayer, state);
        -:  714:	}
        -:  715:
        -:  716:	//discard card from hand
    #####:  717:	discardCard(handPos, currentPlayer, state, 0);
    #####:  718:}
        -:  719:
        4:  720:void playBaron(struct gameState *state, int currentPlayer, int choice1, int handPos)
        -:  721://Add a buy.  OPTION:  Discard an Estate card and gain $4.  Otherwise, gain an Estate card.
        -:  722:{
        4:  723:	state->numBuys++;//Increase buys by 1!
        4:  724:	if (choice1 > 0){//Boolean true or going to discard an estate
        4:  725:		int p = 0;//Iterator for hand!
        4:  726:		int card_not_discarded = 1;//Flag for discard set!
       34:  727:		while (card_not_discarded){
       26:  728:			if (state->hand[currentPlayer][p] == estate){ //Found an estate card!
        1:  729:				state->coins += 4;//Add 4 coins to the amount of coins
        1:  730:				state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
        1:  731:				state->discardCount[currentPlayer]++;
        2:  732:				for (; p < state->handCount[currentPlayer]; p++){
        1:  733:					state->hand[currentPlayer][p] = state->hand[currentPlayer][p + 1];
        -:  734:				}
        1:  735:				state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
        1:  736:				state->handCount[currentPlayer]--;
        1:  737:				card_not_discarded = 0;//Exit the loop
        -:  738:			}
       25:  739:			else if (p > state->handCount[currentPlayer]){
        -:  740:				if (DEBUG) {
        -:  741:					printf("No estate cards in your hand, invalid choice\n");
        -:  742:					printf("Must gain an estate if there are any\n");
        -:  743:				}
        3:  744:				if (supplyCount(estate, state) > 0){
        1:  745:					gainCard(estate, state, 1, currentPlayer);
        1:  746:					state->supplyCount[estate]--;//Decrement estates
        1:  747:					if (supplyCount(estate, state) == 0){
    #####:  748:						isGameOver(state);
        -:  749:					}
        -:  750:				}
        3:  751:				card_not_discarded = 0;//Exit the loop
        -:  752:			}
        -:  753:
        -:  754:			else{
       22:  755:				p++;//Next card
        -:  756:			}
        -:  757:		}
        -:  758:	}
        -:  759:
        -:  760:	else{
    #####:  761:		if (supplyCount(estate, state) > 0){
    #####:  762:			gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  763:			state->supplyCount[estate]--;//Decrement Estates
    #####:  764:			if (supplyCount(estate, state) == 0){
    #####:  765:				isGameOver(state);
        -:  766:			}
        -:  767:		}
        -:  768:	}
        4:  769:}
        -:  770:
    #####:  771:int playTreasureMap(struct gameState *state, int currentPlayer, int handPos)
        -:  772://Trashing two treasure map cards from the hand = four gold on top of the deck.
        -:  773:{
        -:  774:	int i;
        -:  775:	int index;
        -:  776:
        -:  777:	//search hand for another treasure_map
    #####:  778:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  779:	{
    #####:  780:		if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -:  781:		{
    #####:  782:			index = i;
    #####:  783:			break;
        -:  784:		}
        -:  785:	}
    #####:  786:	if (index > -1)
        -:  787:	{
        -:  788:		//trash both treasure cards
    #####:  789:		discardCard(handPos, currentPlayer, state, 1);
    #####:  790:		discardCard(index, currentPlayer, state, 1);
        -:  791:
        -:  792:		//gain 4 Gold cards
    #####:  793:		for (i = 0; i < 4; i++)
        -:  794:		{
    #####:  795:			gainCard(gold, state, 1, currentPlayer);
        -:  796:		}
        -:  797:
        -:  798:		//return success
    #####:  799:		return 1;
        -:  800:	}
        -:  801:
        -:  802:	//no second treasure_map found in hand
    #####:  803:	return -1;
        -:  804:}
        -:  805:
       58:  806:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  807:{
        -:  808:	int i;
        -:  809:	int j;
        -:  810:	int k;
        -:  811:	//int x;  //Unused after while loop removed from feast.
       58:  812:	int currentPlayer = whoseTurn(state);
       58:  813:	int nextPlayer = currentPlayer + 1;
        -:  814:	int temphand[MAX_HAND];
        -:  815:
       58:  816:	int tributeRevealedCards[2] = { -1, -1 };
        -:  817:
       58:  818:	if (nextPlayer > (state->numPlayers - 1)){
       41:  819:		nextPlayer = 0;
        -:  820:	}
        -:  821:
        -:  822:	//uses switch to select card and perform actions
       58:  823:	switch (card)
        -:  824:	{
        -:  825:	case adventurer:
        -:  826:
    #####:  827:		playAdventurer(state, currentPlayer);
    #####:  828:		return 0;
        -:  829:
        -:  830:	case council_room:
        -:  831:		//+4 Cards
       10:  832:		for (i = 0; i < 4; i++)
        -:  833:		{
        8:  834:			drawCard(currentPlayer, state);
        -:  835:		}
        -:  836:
        -:  837:		//+1 Buy
        2:  838:		state->numBuys++;
        -:  839:
        -:  840:		//Each other player draws a card
        6:  841:		for (i = 0; i < state->numPlayers; i++)
        -:  842:		{
        4:  843:			if (i != currentPlayer)
        -:  844:			{
        2:  845:				drawCard(i, state);
        -:  846:			}
        -:  847:		}
        -:  848:
        -:  849:		//put played card in played card pile
        2:  850:		discardCard(handPos, currentPlayer, state, 0);
        -:  851:
        2:  852:		return 0;
        -:  853:
        -:  854:	case feast:
        -:  855:		//gain card with cost up to 5
        -:  856:		//Backup hand
    #####:  857:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  858:			temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  859:			state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  860:		}
        -:  861:		//Backup hand
        -:  862:
        -:  863:		//Update Coins for Buy
    #####:  864:		updateCoins(currentPlayer, state, 5);
        -:  865://		x = 1;//Condition to loop on
        -:  866://		while (x == 1) {//Buy one card
    #####:  867:			if (supplyCount(choice1, state) <= 0){
        -:  868:				if (DEBUG)
        -:  869:					printf("None of that card left, sorry!\n");
        -:  870:
        -:  871:				if (DEBUG){
        -:  872:					printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  873:				}
        -:  874:			}
    #####:  875:			else if (state->coins < getCost(choice1)){
    #####:  876:				printf("That card is too expensive!\n");
        -:  877:
        -:  878:				if (DEBUG){
        -:  879:					printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  880:				}
        -:  881:			}
        -:  882:			else{
        -:  883:
        -:  884:				if (DEBUG){
        -:  885:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  886:				}
        -:  887:
    #####:  888:				gainCard(choice1, state, 0, currentPlayer);//Gain the card
        -:  889://				x = 0;//No more buying cards
        -:  890:
        -:  891:				if (DEBUG){
        -:  892:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  893:				}
        -:  894:
        -:  895:			}
        -:  896://		}
        -:  897:
        -:  898:		//Reset Hand
    #####:  899:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  900:			state->hand[currentPlayer][i] = temphand[i];
    #####:  901:			temphand[i] = -1;
        -:  902:		}
        -:  903:		//Reset Hand
        -:  904:
    #####:  905:		return 0;
        -:  906:
        -:  907:	case gardens:
    #####:  908:		return -1;
        -:  909:
        -:  910:	case mine:
    #####:  911:		j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  912:
    #####:  913:		if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  914:		{
    #####:  915:			return -1;
        -:  916:		}
        -:  917:
    #####:  918:		if (choice2 > treasure_map || choice2 < curse)
        -:  919:		{
    #####:  920:			return -1;
        -:  921:		}
        -:  922:
    #####:  923:		if ((getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2))
        -:  924:		{
    #####:  925:			return -1;
        -:  926:		}
        -:  927:
    #####:  928:		gainCard(choice2, state, 2, currentPlayer);
        -:  929:
        -:  930:		//discard card from hand
    #####:  931:		discardCard(handPos, currentPlayer, state, 0);
        -:  932:
        -:  933:		//discard trashed card
    #####:  934:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  935:		{
    #####:  936:			if (state->hand[currentPlayer][i] == j)
        -:  937:			{
    #####:  938:				discardCard(i, currentPlayer, state, 0);
    #####:  939:				break;
        -:  940:			}
        -:  941:		}
        -:  942:
    #####:  943:		return 0;
        -:  944:
        -:  945:	case remodel:
        -:  946:
        3:  947:		return playRemodel(state, currentPlayer, choice1, choice2, handPos);
        -:  948:
        -:  949:	case smithy:
        -:  950:
    #####:  951:		playSmithy(state, currentPlayer, handPos);
    #####:  952:		return 0;
        -:  953:
        -:  954:	case village:
        -:  955:		//+1 Card
    #####:  956:		drawCard(currentPlayer, state);
        -:  957:
        -:  958:		//+2 Actions
    #####:  959:		state->numActions = state->numActions + 2;
        -:  960:
        -:  961:		//discard played card from hand
    #####:  962:		discardCard(handPos, currentPlayer, state, 0);
    #####:  963:		return 0;
        -:  964:
        -:  965:	case baron:
        -:  966:
        4:  967:		playBaron(state, currentPlayer, choice1, handPos);
        4:  968:		return 0;
        -:  969:
        -:  970:	case great_hall:
        -:  971:		//+1 Card
    #####:  972:		drawCard(currentPlayer, state);
        -:  973:
        -:  974:		//+1 Actions
    #####:  975:		state->numActions++;
        -:  976:
        -:  977:		//discard card from hand
    #####:  978:		discardCard(handPos, currentPlayer, state, 0);
    #####:  979:		return 0;
        -:  980:
        -:  981:	case minion:
        -:  982:		//+1 action
    #####:  983:		state->numActions++;
        -:  984:
        -:  985:		//discard card from hand
    #####:  986:		discardCard(handPos, currentPlayer, state, 0);
        -:  987:
    #####:  988:		if (choice1)		//+2 coins
        -:  989:		{
    #####:  990:			state->coins = state->coins + 2;
        -:  991:		}
        -:  992:
    #####:  993:		else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  994:		{
        -:  995:			//discard hand
    #####:  996:			while (numHandCards(state) > 0)
        -:  997:			{
    #####:  998:				discardCard(handPos, currentPlayer, state, 0);
        -:  999:			}
        -: 1000:
        -: 1001:			//draw 4
    #####: 1002:			for (i = 0; i < 4; i++)
        -: 1003:			{
    #####: 1004:				drawCard(currentPlayer, state);
        -: 1005:			}
        -: 1006:
        -: 1007:			//other players discard hand and redraw if hand size > 4
    #####: 1008:			for (i = 0; i < state->numPlayers; i++)
        -: 1009:			{
    #####: 1010:				if (i != currentPlayer)
        -: 1011:				{
    #####: 1012:					if (state->handCount[i] > 4)
        -: 1013:					{
        -: 1014:						//discard hand
    #####: 1015:						while (state->handCount[i] > 0)
        -: 1016:						{
    #####: 1017:							discardCard(handPos, i, state, 0);
        -: 1018:						}
        -: 1019:
        -: 1020:						//draw 4
    #####: 1021:						for (j = 0; j < 4; j++)
        -: 1022:						{
    #####: 1023:							drawCard(i, state);
        -: 1024:						}
        -: 1025:					}
        -: 1026:				}
        -: 1027:			}
        -: 1028:
        -: 1029:		}
    #####: 1030:		return 0;
        -: 1031:
        -: 1032:	case steward:
    #####: 1033:		if (choice1 == 1)
        -: 1034:		{
        -: 1035:			//+2 cards
    #####: 1036:			drawCard(currentPlayer, state);
    #####: 1037:			drawCard(currentPlayer, state);
        -: 1038:		}
    #####: 1039:		else if (choice1 == 2)
        -: 1040:		{
        -: 1041:			//+2 coins
    #####: 1042:			state->coins = state->coins + 2;
        -: 1043:		}
        -: 1044:		else
        -: 1045:		{
        -: 1046:			//trash 2 cards in hand
    #####: 1047:			discardCard(choice2, currentPlayer, state, 1);
    #####: 1048:			discardCard(choice3, currentPlayer, state, 1);
        -: 1049:		}
        -: 1050:
        -: 1051:		//discard card from hand
    #####: 1052:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1053:		return 0;
        -: 1054:
        -: 1055:	case tribute:
        4: 1056:		if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####: 1057:			if (state->deckCount[nextPlayer] > 0){
    #####: 1058:				tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1059:				state->deckCount[nextPlayer]--;
        -: 1060:			}
    #####: 1061:			else if (state->discardCount[nextPlayer] > 0){
    #####: 1062:				tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer] - 1];
    #####: 1063:				state->discardCount[nextPlayer]--;
        -: 1064:			}
        -: 1065:			else{
        -: 1066:				//No Card to Reveal
        -: 1067:				if (DEBUG){
        -: 1068:					printf("No cards to reveal\n");
        -: 1069:				}
        -: 1070:			}
        -: 1071:		}
        -: 1072:
        -: 1073:		else{
        4: 1074:			if (state->deckCount[nextPlayer] == 0){
    #####: 1075:				for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####: 1076:					state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1077:					state->deckCount[nextPlayer]++;
    #####: 1078:					state->discard[nextPlayer][i] = -1;
    #####: 1079:					state->discardCount[nextPlayer]--;
        -: 1080:				}
        -: 1081:
    #####: 1082:				shuffle(nextPlayer, state);//Shuffle the deck
        -: 1083:			}
        4: 1084:			tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
        4: 1085:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
        4: 1086:			state->deckCount[nextPlayer]--;
        4: 1087:			tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
        4: 1088:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
        4: 1089:			state->deckCount[nextPlayer]--;
        -: 1090:		}
        -: 1091:
        4: 1092:		if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
    #####: 1093:			state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1094:			state->playedCardCount++;
    #####: 1095:			tributeRevealedCards[1] = -1;
        -: 1096:		}
        -: 1097:
       16: 1098:		for (i = 0; i <= 2; i++){
       12: 1099:			if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
        6: 1100:				state->coins += 2;
        -: 1101:			}
        -: 1102:
        6: 1103:			else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
        3: 1104:				drawCard(currentPlayer, state);
        3: 1105:				drawCard(currentPlayer, state);
        -: 1106:			}
        -: 1107:			else{//Action Card
        3: 1108:				state->numActions = state->numActions + 2;
        -: 1109:			}
        -: 1110:		}
        -: 1111:
        4: 1112:		return 0;
        -: 1113:
        -: 1114:	case ambassador:
       27: 1115:		j = 0;		//used to check if player has enough cards to discard
        -: 1116:
       27: 1117:		if (choice2 > 2 || choice2 < 0)
        -: 1118:		{
       24: 1119:			return -1;
        -: 1120:		}
        -: 1121:
        3: 1122:		if (choice1 == handPos)
        -: 1123:		{
    #####: 1124:			return -1;
        -: 1125:		}
        -: 1126:
       18: 1127:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1128:		{
       15: 1129:			if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1130:			{
    #####: 1131:				j++;
        -: 1132:			}
        -: 1133:		}
        3: 1134:		if (j < choice2)
        -: 1135:		{
        2: 1136:			return -1;
        -: 1137:		}
        -: 1138:
        -: 1139:		if (DEBUG)
        -: 1140:			printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1141:
        -: 1142:		//increase supply count for choosen card by amount being discarded
        1: 1143:		state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1144:
        -: 1145:		//each other player gains a copy of revealed card
        3: 1146:		for (i = 0; i < state->numPlayers; i++)
        -: 1147:		{
        2: 1148:			if (i != currentPlayer)
        -: 1149:			{
        1: 1150:				gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1151:			}
        -: 1152:		}
        -: 1153:
        -: 1154:		//discard played card from hand
        1: 1155:		discardCard(handPos, currentPlayer, state, 0);
        -: 1156:
        -: 1157:		//trash copies of cards returned to supply
        1: 1158:		for (j = 0; j < choice2; j++)
        -: 1159:		{
    #####: 1160:			for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1161:			{
    #####: 1162:				if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1163:				{
    #####: 1164:					discardCard(i, currentPlayer, state, 1);
    #####: 1165:					break;
        -: 1166:				}
        -: 1167:			}
        -: 1168:		}
        -: 1169:
        1: 1170:		return 0;
        -: 1171:
        -: 1172:	case cutpurse:
        -: 1173:
        2: 1174:		updateCoins(currentPlayer, state, 2);
        6: 1175:		for (i = 0; i < state->numPlayers; i++)
        -: 1176:		{
        4: 1177:			if (i != currentPlayer)
        -: 1178:			{
        2: 1179:				for (j = 0; j < state->handCount[i]; j++)
        -: 1180:				{
    #####: 1181:					if (state->hand[i][j] == copper)
        -: 1182:					{
    #####: 1183:						discardCard(j, i, state, 0);
    #####: 1184:						break;
        -: 1185:					}
    #####: 1186:					if (j == state->handCount[i])
        -: 1187:					{
    #####: 1188:						for (k = 0; k < state->handCount[i]; k++)
        -: 1189:						{
        -: 1190:							if (DEBUG)
        -: 1191:								printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1192:						}
    #####: 1193:						break;
        -: 1194:					}
        -: 1195:				}
        -: 1196:
        -: 1197:			}
        -: 1198:
        -: 1199:		}
        -: 1200:
        -: 1201:		//discard played card from hand
        2: 1202:		discardCard(handPos, currentPlayer, state, 0);
        -: 1203:
        2: 1204:		return 0;
        -: 1205:
        -: 1206:
        -: 1207:	case embargo:
        -: 1208:		//+2 Coins
    #####: 1209:		state->coins = state->coins + 2;
        -: 1210:
        -: 1211:		//see if selected pile is in play
    #####: 1212:		if (state->supplyCount[choice1] == -1)
        -: 1213:		{
    #####: 1214:			return -1;
        -: 1215:		}
        -: 1216:
        -: 1217:		//add embargo token to selected supply pile
    #####: 1218:		state->embargoTokens[choice1]++;
        -: 1219:
        -: 1220:		//trash card
    #####: 1221:		discardCard(handPos, currentPlayer, state, 1);
    #####: 1222:		return 0;
        -: 1223:
        -: 1224:	case outpost:
        -: 1225:		//set outpost flag
    #####: 1226:		state->outpostPlayed++;
        -: 1227:
        -: 1228:		//discard card
    #####: 1229:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1230:		return 0;
        -: 1231:
        -: 1232:	case salvager:
        -: 1233:		//+1 buy
    #####: 1234:		state->numBuys++;
        -: 1235:
    #####: 1236:		if (choice1)
        -: 1237:		{
        -: 1238:			//gain coins equal to trashed card
    #####: 1239:			state->coins = state->coins + getCost(handCard(choice1, state));
        -: 1240:			//trash card
    #####: 1241:			discardCard(choice1, currentPlayer, state, 1);
        -: 1242:		}
        -: 1243:
        -: 1244:		//discard card
    #####: 1245:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1246:		return 0;
        -: 1247:
        -: 1248:	case sea_hag:
       48: 1249:		for (i = 0; i < state->numPlayers; i++){
       32: 1250:			if (i != currentPlayer){
       16: 1251:				state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
       16: 1252:				state->discardCount[i]++;
       16: 1253:				state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1254:			}
        -: 1255:		}
       16: 1256:		return 0;
        -: 1257:
        -: 1258:	case treasure_map:
        -: 1259:
    #####: 1260:		return playTreasureMap(state, currentPlayer, handPos);
        -: 1261:	}
    #####: 1262:	return -1;
        -: 1263:}
        -: 1264:
       11: 1265:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1266:{
        -: 1267:
        -: 1268:	//if card is not trashed, added to Played pile 
       11: 1269:	if (trashFlag < 1)
        -: 1270:	{
        -: 1271:		//add card to played pile
       11: 1272:		state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
       11: 1273:		state->playedCardCount++;
        -: 1274:	}
        -: 1275:
        -: 1276:	//set played card to -1
       11: 1277:	state->hand[currentPlayer][handPos] = -1;
        -: 1278:
        -: 1279:	//remove card from player's hand
       11: 1280:	if (handPos == (state->handCount[currentPlayer] - 1)) 	//last card in hand array is played
        -: 1281:	{
        -: 1282:		//reduce number of cards in hand
        4: 1283:		state->handCount[currentPlayer]--;
        -: 1284:	}
        7: 1285:	else if (state->handCount[currentPlayer] == 1) //only one card in hand
        -: 1286:	{
        -: 1287:		//reduce number of cards in hand
    #####: 1288:		state->handCount[currentPlayer]--;
        -: 1289:	}
        -: 1290:	else
        -: 1291:	{
        -: 1292:		//replace discarded card with last card in hand
        7: 1293:		state->hand[currentPlayer][handPos] = state->hand[currentPlayer][(state->handCount[currentPlayer] - 1)];
        -: 1294:		//set last card to -1
        7: 1295:		state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1296:		//reduce number of cards in hand
        7: 1297:		state->handCount[currentPlayer]--;
        -: 1298:	}
        -: 1299:
       11: 1300:	return 0;
        -: 1301:}
        -: 1302:
       78: 1303:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1304:{
        -: 1305:	//Note: supplyPos is enum of choosen card
        -: 1306:
        -: 1307:	//check if supply pile is empty (0) or card is not used in game (-1)
       78: 1308:	if (supplyCount(supplyPos, state) < 1)
        -: 1309:	{
        2: 1310:		return -1;
        -: 1311:	}
        -: 1312:
        -: 1313:	//added card for [whoseTurn] current player:
        -: 1314:	// toFlag = 0 : add to discard
        -: 1315:	// toFlag = 1 : add to deck
        -: 1316:	// toFlag = 2 : add to hand
        -: 1317:
       76: 1318:	if (toFlag == 1)
        -: 1319:	{
        1: 1320:		state->deck[player][state->deckCount[player]] = supplyPos;
        1: 1321:		state->deckCount[player]++;
        -: 1322:	}
       75: 1323:	else if (toFlag == 2)
        -: 1324:	{
    #####: 1325:		state->hand[player][state->handCount[player]] = supplyPos;
    #####: 1326:		state->handCount[player]++;
        -: 1327:	}
        -: 1328:	else
        -: 1329:	{
       75: 1330:		state->discard[player][state->discardCount[player]] = supplyPos;
       75: 1331:		state->discardCount[player]++;
        -: 1332:	}
        -: 1333:
        -: 1334:	//decrease number in supply pile
       76: 1335:	state->supplyCount[supplyPos]--;
        -: 1336:
       76: 1337:	return 0;
        -: 1338:}
        -: 1339:
      134: 1340:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1341:{
        -: 1342:	int i;
        -: 1343:
        -: 1344:	//reset coin count
      134: 1345:	state->coins = 0;
        -: 1346:
        -: 1347:	//add coins for each Treasure card in player's hand
      806: 1348:	for (i = 0; i < state->handCount[player]; i++)
        -: 1349:	{
      672: 1350:		if (state->hand[player][i] == copper)
        -: 1351:		{
      245: 1352:			state->coins += 1;
        -: 1353:		}
      427: 1354:		else if (state->hand[player][i] == silver)
        -: 1355:		{
       63: 1356:			state->coins += 2;
        -: 1357:		}
      364: 1358:		else if (state->hand[player][i] == gold)
        -: 1359:		{
       31: 1360:			state->coins += 3;
        -: 1361:		}
        -: 1362:	}
        -: 1363:
        -: 1364:	//add bonus
      134: 1365:	state->coins += bonus;
        -: 1366:
      134: 1367:	return 0;
        -: 1368:}
        -: 1369:
        -: 1370:
        -: 1371://end of dominion.c
File 'dominion.c'
Lines executed:55.66% of 557
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
      982:    8:int compare(const void* a, const void* b) {
      982:    9:	if (*(int*)a > *(int*)b)
      262:   10:		return 1;
      720:   11:	if (*(int*)a < *(int*)b)
      329:   12:		return -1;
      391:   13:	return 0;
        -:   14:}
        -:   15:
        2:   16:struct gameState* newGame() {
        2:   17:	struct gameState* g = malloc(sizeof(struct gameState));
        2:   18:	return g;
        -:   19:}
        -:   20:
       42:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:	int k8, int k9, int k10) {
       42:   23:	int* k = malloc(10 * sizeof(int));
       42:   24:	k[0] = k1;
       42:   25:	k[1] = k2;
       42:   26:	k[2] = k3;
       42:   27:	k[3] = k4;
       42:   28:	k[4] = k5;
       42:   29:	k[5] = k6;
       42:   30:	k[6] = k7;
       42:   31:	k[7] = k8;
       42:   32:	k[8] = k9;
       42:   33:	k[9] = k10;
       42:   34:	return k;
        -:   35:}
        -:   36:
       42:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		struct gameState *state) {
        -:   39:
        -:   40:	int i;
        -:   41:	int j;
        -:   42:	int it;
        -:   43:	//set up random number generator
       42:   44:	SelectStream(1);
       42:   45:	PutSeed((long)randomSeed);
        -:   46:
        -:   47:	//check number of players
       42:   48:	if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:	{
    #####:   50:		return -1;
        -:   51:	}
        -:   52:
        -:   53:	//set number of players
       42:   54:	state->numPlayers = numPlayers;
        -:   55:
        -:   56:	//check selected kingdom cards are different
      104:   57:	for (i = 0; i < 10; i++)
        -:   58:	{
      950:   59:		for (j = 0; j < 10; j++)
        -:   60:		{
      888:   61:			if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:			{
       41:   63:				return -1;
        -:   64:			}
        -:   65:		}
        -:   66:	}
        -:   67:
        -:   68:
        -:   69:	//initialize supply
        -:   70:	///////////////////////////////
        -:   71:
        -:   72:	//set number of Curse cards
        1:   73:	if (numPlayers == 2)
        -:   74:	{
        1:   75:		state->supplyCount[curse] = 10;
        -:   76:	}
    #####:   77:	else if (numPlayers == 3)
        -:   78:	{
    #####:   79:		state->supplyCount[curse] = 20;
        -:   80:	}
        -:   81:	else
        -:   82:	{
    #####:   83:		state->supplyCount[curse] = 30;
        -:   84:	}
        -:   85:
        -:   86:	//set number of Victory cards
        1:   87:	if (numPlayers == 2)
        -:   88:	{
        1:   89:		state->supplyCount[estate] = 8;
        1:   90:		state->supplyCount[duchy] = 8;
        1:   91:		state->supplyCount[province] = 8;
        -:   92:	}
        -:   93:	else
        -:   94:	{
    #####:   95:		state->supplyCount[estate] = 12;
    #####:   96:		state->supplyCount[duchy] = 12;
    #####:   97:		state->supplyCount[province] = 12;
        -:   98:	}
        -:   99:
        -:  100:	//set number of Treasure cards
        1:  101:	state->supplyCount[copper] = 60 - (7 * numPlayers);
        1:  102:	state->supplyCount[silver] = 40;
        1:  103:	state->supplyCount[gold] = 30;
        -:  104:
        -:  105:	//set number of Kingdom cards
       21:  106:	for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:	{
      165:  108:		for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:		{
      155:  110:			if (kingdomCards[j] == i)
        -:  111:			{
        -:  112:				//check if card is a 'Victory' Kingdom card
       10:  113:				if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:				{
        4:  115:					if (numPlayers == 2){
        2:  116:						state->supplyCount[i] = 8;
        -:  117:					}
    #####:  118:					else{ state->supplyCount[i] = 12; }
        -:  119:				}
        -:  120:				else
        -:  121:				{
        8:  122:					state->supplyCount[i] = 10;
        -:  123:				}
       10:  124:				break;
        -:  125:			}
        -:  126:			else    //card is not in the set choosen for the game
        -:  127:			{
      145:  128:				state->supplyCount[i] = -1;
        -:  129:			}
        -:  130:		}
        -:  131:
        -:  132:	}
        -:  133:
        -:  134:	////////////////////////
        -:  135:	//supply intilization complete
        -:  136:
        -:  137:	//set player decks
        3:  138:	for (i = 0; i < numPlayers; i++)
        -:  139:	{
        2:  140:		state->deckCount[i] = 0;
        8:  141:		for (j = 0; j < 3; j++)
        -:  142:		{
        6:  143:			state->deck[i][j] = estate;
        6:  144:			state->deckCount[i]++;
        -:  145:		}
       16:  146:		for (j = 3; j < 10; j++)
        -:  147:		{
       14:  148:			state->deck[i][j] = copper;
       14:  149:			state->deckCount[i]++;
        -:  150:		}
        -:  151:	}
        -:  152:
        -:  153:	//shuffle player decks
        3:  154:	for (i = 0; i < numPlayers; i++)
        -:  155:	{
        2:  156:		if (shuffle(i, state) < 0)
        -:  157:		{
    #####:  158:			return -1;
        -:  159:		}
        -:  160:	}
        -:  161:
        -:  162:	//draw player hands
        3:  163:	for (i = 0; i < numPlayers; i++)
        -:  164:	{
        -:  165:		//initialize hand size to zero
        2:  166:		state->handCount[i] = 0;
        2:  167:		state->discardCount[i] = 0;
        -:  168:		//draw 5 cards
        -:  169:		// for (j = 0; j < 5; j++)
        -:  170:		//	{
        -:  171:		//	  drawCard(i, state);
        -:  172:		//	}
        -:  173:	}
        -:  174:
        -:  175:	//set embargo tokens to 0 for all supply piles
       28:  176:	for (i = 0; i <= treasure_map; i++)
        -:  177:	{
       27:  178:		state->embargoTokens[i] = 0;
        -:  179:	}
        -:  180:
        -:  181:	//initialize first player's turn
        1:  182:	state->outpostPlayed = 0;
        1:  183:	state->phase = 0;
        1:  184:	state->numActions = 1;
        1:  185:	state->numBuys = 1;
        1:  186:	state->playedCardCount = 0;
        1:  187:	state->whoseTurn = 0;
        1:  188:	state->handCount[state->whoseTurn] = 0;
        -:  189:	//int it; move to top
        -:  190:
        -:  191:	//Moved draw cards to here, only drawing at the start of a turn
        6:  192:	for (it = 0; it < 5; it++){
        5:  193:		drawCard(state->whoseTurn, state);
        -:  194:	}
        -:  195:
        1:  196:	updateCoins(state->whoseTurn, state, 0);
        -:  197:
        1:  198:	return 0;
        -:  199:}
        -:  200:
       25:  201:int shuffle(int player, struct gameState *state) {
        -:  202:
        -:  203:
        -:  204:	int newDeck[MAX_DECK];
       25:  205:	int newDeckPos = 0;
        -:  206:	int card;
        -:  207:	int i;
        -:  208:
       25:  209:	if (state->deckCount[player] < 1)
    #####:  210:		return -1;
       25:  211:	qsort((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
        -:  212:	/* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
      524:  214:	while (state->deckCount[player] > 0) {
      474:  215:		card = floor(Random() * state->deckCount[player]);
      474:  216:		newDeck[newDeckPos] = state->deck[player][card];
      474:  217:		newDeckPos++;
     3036:  218:		for (i = card; i < state->deckCount[player] - 1; i++) {
     2562:  219:			state->deck[player][i] = state->deck[player][i + 1];
        -:  220:		}
      474:  221:		state->deckCount[player]--;
        -:  222:	}
      499:  223:	for (i = 0; i < newDeckPos; i++) {
      474:  224:		state->deck[player][i] = newDeck[i];
      474:  225:		state->deckCount[player]++;
        -:  226:	}
        -:  227:
       25:  228:	return 0;
        -:  229:}
        -:  230:
      682:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state)
        -:  232:{
        -:  233:	int card;
      682:  234:	int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:	//check if it is the right phase
      682:  237:	if (state->phase != 0)
        -:  238:	{
       93:  239:		return -1;
        -:  240:	}
        -:  241:
        -:  242:	//check if player has enough actions
      589:  243:	if (state->numActions < 1)
        -:  244:	{
        9:  245:		return -1;
        -:  246:	}
        -:  247:
        -:  248:	//get card played
      580:  249:	card = handCard(handPos, state);
        -:  250:
        -:  251:	//check if selected card is an action
      580:  252:	if (card < adventurer || card > treasure_map)
        -:  253:	{
      538:  254:		return -1;
        -:  255:	}
        -:  256:
        -:  257:	//play card
       42:  258:	if (cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0)
        -:  259:	{
       27:  260:		return -1;
        -:  261:	}
        -:  262:
        -:  263:	//reduce number of actions
       15:  264:	state->numActions--;
        -:  265:
        -:  266:	//update coins (Treasure cards may be added with card draws)
       15:  267:	updateCoins(state->whoseTurn, state, coin_bonus);
        -:  268:
       15:  269:	return 0;
        -:  270:}
        -:  271:
      722:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:	int who;
        -:  274:	if (DEBUG){
        -:  275:		printf("Entering buyCard...\n");
        -:  276:	}
        -:  277:
        -:  278:	// I don't know what to do about the phase thing.
        -:  279:
      722:  280:	who = state->whoseTurn;
        -:  281:
      722:  282:	if (state->numBuys < 1){
        -:  283:		if (DEBUG)
        -:  284:			printf("You do not have any buys left\n");
       78:  285:		return -1;
        -:  286:	}
      644:  287:	else if (supplyCount(supplyPos, state) < 1){
        -:  288:		if (DEBUG)
        -:  289:			printf("There are not any of that type of card left\n");
      272:  290:		return -1;
        -:  291:	}
      372:  292:	else if (state->coins < getCost(supplyPos)){
        -:  293:		if (DEBUG)
        -:  294:			printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
      298:  295:		return -1;
        -:  296:	}
        -:  297:	else {
       74:  298:		state->phase = 1;
        -:  299:		//state->supplyCount[supplyPos]--;
       74:  300:		gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  301:
       74:  302:		state->coins = (state->coins) - (getCost(supplyPos));
       74:  303:		state->numBuys--;
        -:  304:		if (DEBUG)
        -:  305:			printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  306:	}
        -:  307:
        -:  308:	//state->discard[who][state->discardCount[who]] = supplyPos;
        -:  309:	//state->discardCount[who]++;
        -:  310:
       74:  311:	return 0;
        -:  312:}
        -:  313:
    #####:  314:int numHandCards(struct gameState *state) {
    #####:  315:	return state->handCount[whoseTurn(state)];
        -:  316:}
        -:  317:
      580:  318:int handCard(int handPos, struct gameState *state) {
      580:  319:	int currentPlayer = whoseTurn(state);
      580:  320:	return state->hand[currentPlayer][handPos];
        -:  321:}
        -:  322:
      720:  323:int supplyCount(int card, struct gameState *state) {
      720:  324:	return state->supplyCount[card];
        -:  325:}
        -:  326:
        2:  327:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  328:	int i;
        2:  329:	int count = 0;
        -:  330:
       28:  331:	for (i = 0; i < state->deckCount[player]; i++)
        -:  332:	{
       26:  333:		if (state->deck[player][i] == card) count++;
        -:  334:	}
        -:  335:
        7:  336:	for (i = 0; i < state->handCount[player]; i++)
        -:  337:	{
        5:  338:		if (state->hand[player][i] == card) count++;
        -:  339:	}
        -:  340:
       44:  341:	for (i = 0; i < state->discardCount[player]; i++)
        -:  342:	{
       42:  343:		if (state->discard[player][i] == card) count++;
        -:  344:	}
        -:  345:
        2:  346:	return count;
        -:  347:}
        -:  348:
      708:  349:int whoseTurn(struct gameState *state) {
      708:  350:	return state->whoseTurn;
        -:  351:}
        -:  352:
       86:  353:int endTurn(struct gameState *state) {
        -:  354:	int k;
        -:  355:	int i;
       86:  356:	int currentPlayer = whoseTurn(state);
        -:  357:
        -:  358:	//Discard hand
      508:  359:	for (i = 0; i < state->handCount[currentPlayer]; i++){
      422:  360:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
      422:  361:		state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  362:	}
       86:  363:	state->handCount[currentPlayer] = 0;//Reset hand count
        -:  364:
        -:  365:	//Code for determining the player
       86:  366:	if (currentPlayer < (state->numPlayers - 1)){
       43:  367:		state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  368:	}
        -:  369:	else{
       43:  370:		state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  371:	}
        -:  372:
       86:  373:	state->outpostPlayed = 0;
       86:  374:	state->phase = 0;
       86:  375:	state->numActions = 1;
       86:  376:	state->coins = 0;
       86:  377:	state->numBuys = 1;
       86:  378:	state->playedCardCount = 0;
       86:  379:	state->handCount[state->whoseTurn] = 0;
        -:  380:
        -:  381:	//int k; move to top
        -:  382:	//Next player draws hand
      516:  383:	for (k = 0; k < 5; k++){
      430:  384:		drawCard(state->whoseTurn, state);//Draw a card
        -:  385:	}
        -:  386:
        -:  387:	//Update money
       86:  388:	updateCoins(state->whoseTurn, state, 0);
        -:  389:
       86:  390:	return 0;
        -:  391:}
        -:  392:
     2103:  393:int isGameOver(struct gameState *state) {
        -:  394:	int i;
        -:  395:	int j;
        -:  396:
        -:  397:	//if stack of Province cards is empty, the game ends
     2103:  398:	if (state->supplyCount[province] == 0)
        -:  399:	{
    #####:  400:		return 1;
        -:  401:	}
        -:  402:
        -:  403:	//if three supply pile are at 0, the game ends
     2103:  404:	j = 0;
    54678:  405:	for (i = 0; i < 25; i++)
        -:  406:	{
    52575:  407:		if (state->supplyCount[i] == 0)
        -:  408:		{
     2706:  409:			j++;
        -:  410:		}
        -:  411:	}
     2103:  412:	if (j >= 3)
        -:  413:	{
        1:  414:		return 1;
        -:  415:	}
        -:  416:
     2102:  417:	return 0;
        -:  418:}
        -:  419:
        2:  420:int scoreFor(int player, struct gameState *state) {
        -:  421:
        -:  422:	int i;
        2:  423:	int score = 0;
        -:  424:	//score from hand
        7:  425:	for (i = 0; i < state->handCount[player]; i++)
        -:  426:	{
        5:  427:		if (state->hand[player][i] == curse) { score = score - 1; };
        5:  428:		if (state->hand[player][i] == estate) { score = score + 1; };
        5:  429:		if (state->hand[player][i] == duchy) { score = score + 3; };
        5:  430:		if (state->hand[player][i] == province) { score = score + 6; };
        5:  431:		if (state->hand[player][i] == great_hall) { score = score + 1; };
        5:  432:		if (state->hand[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  433:	}
        -:  434:
        -:  435:	//score from discard
       44:  436:	for (i = 0; i < state->discardCount[player]; i++)
        -:  437:	{
       42:  438:		if (state->discard[player][i] == curse) { score = score - 1; };
       42:  439:		if (state->discard[player][i] == estate) { score = score + 1; };
       42:  440:		if (state->discard[player][i] == duchy) { score = score + 3; };
       42:  441:		if (state->discard[player][i] == province) { score = score + 6; };
       42:  442:		if (state->discard[player][i] == great_hall) { score = score + 1; };
       42:  443:		if (state->discard[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  444:	}
        -:  445:
        -:  446:	//score from deck
       44:  447:	for (i = 0; i < state->discardCount[player]; i++)
        -:  448:	{
       42:  449:		if (state->deck[player][i] == curse) { score = score - 1; };
       42:  450:		if (state->deck[player][i] == estate) { score = score + 1; };
       42:  451:		if (state->deck[player][i] == duchy) { score = score + 3; };
       42:  452:		if (state->deck[player][i] == province) { score = score + 6; };
       42:  453:		if (state->deck[player][i] == great_hall) { score = score + 1; };
       42:  454:		if (state->deck[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  455:	}
        -:  456:
        2:  457:	return score;
        -:  458:}
        -:  459:
    #####:  460:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  461:	int i;
        -:  462:	int j;
        -:  463:	int highScore;
        -:  464:	int currentPlayer;
        -:  465:
        -:  466:	//get score for each player
    #####:  467:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  468:	{
        -:  469:		//set unused player scores to -9999
    #####:  470:		if (i >= state->numPlayers)
        -:  471:		{
    #####:  472:			players[i] = -9999;
        -:  473:		}
        -:  474:		else
        -:  475:		{
    #####:  476:			players[i] = scoreFor(i, state);
        -:  477:		}
        -:  478:	}
        -:  479:
        -:  480:	//find highest score
    #####:  481:	j = 0;
    #####:  482:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  483:	{
    #####:  484:		if (players[i] > players[j])
        -:  485:		{
    #####:  486:			j = i;
        -:  487:		}
        -:  488:	}
    #####:  489:	highScore = players[j];
        -:  490:
        -:  491:	//add 1 to players who had less turns
    #####:  492:	currentPlayer = whoseTurn(state);
    #####:  493:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  494:	{
    #####:  495:		if (players[i] == highScore && i > currentPlayer)
        -:  496:		{
    #####:  497:			players[i]++;
        -:  498:		}
        -:  499:	}
        -:  500:
        -:  501:	//find new highest score
    #####:  502:	j = 0;
    #####:  503:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  504:	{
    #####:  505:		if (players[i] > players[j])
        -:  506:		{
    #####:  507:			j = i;
        -:  508:		}
        -:  509:	}
    #####:  510:	highScore = players[j];
        -:  511:
        -:  512:	//set winners in array to 1 and rest to 0
    #####:  513:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  514:	{
    #####:  515:		if (players[i] == highScore)
        -:  516:		{
    #####:  517:			players[i] = 1;
        -:  518:		}
        -:  519:		else
        -:  520:		{
    #####:  521:			players[i] = 0;
        -:  522:		}
        -:  523:	}
        -:  524:
    #####:  525:	return 0;
        -:  526:}
        -:  527:
      448:  528:int drawCard(int player, struct gameState *state)
        -:  529:{
        -:  530:	int count;
        -:  531:	int deckCounter;
      448:  532:	if (state->deckCount[player] <= 0){//Deck is empty
        -:  533:
        -:  534:		//Step 1 Shuffle the discard pile back into a deck
        -:  535:		int i;
        -:  536:		//Move discard to deck
      477:  537:		for (i = 0; i < state->discardCount[player]; i++){
      454:  538:			state->deck[player][i] = state->discard[player][i];
      454:  539:			state->discard[player][i] = -1;
        -:  540:		}
        -:  541:
       23:  542:		state->deckCount[player] = state->discardCount[player];
       23:  543:		state->discardCount[player] = 0;//Reset discard
        -:  544:
        -:  545:		//Shufffle the deck
       23:  546:		shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  547:
        -:  548:		if (DEBUG){//Debug statements
        -:  549:			printf("Deck count now: %d\n", state->deckCount[player]);
        -:  550:		}
        -:  551:
       23:  552:		state->discardCount[player] = 0;
        -:  553:
        -:  554:		//Step 2 Draw Card
       23:  555:		count = state->handCount[player];//Get current player's hand count
        -:  556:
        -:  557:		if (DEBUG){//Debug statements
        -:  558:			printf("Current hand count: %d\n", count);
        -:  559:		}
        -:  560:
       23:  561:		deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  562:
       23:  563:		if (deckCounter == 0)
    #####:  564:			return -1;
        -:  565:
       23:  566:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
       23:  567:		state->deckCount[player]--;
       23:  568:		state->handCount[player]++;//Increment hand count
        -:  569:	}
        -:  570:
        -:  571:	else{
      425:  572:		int count = state->handCount[player];//Get current hand count for player
        -:  573:		int deckCounter;
        -:  574:		if (DEBUG){//Debug statements
        -:  575:			printf("Current hand count: %d\n", count);
        -:  576:		}
        -:  577:
      425:  578:		deckCounter = state->deckCount[player];//Create holder for the deck count
      425:  579:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
      425:  580:		state->deckCount[player]--;
      425:  581:		state->handCount[player]++;//Increment hand count
        -:  582:	}
        -:  583:
      448:  584:	return 0;
        -:  585:}
        -:  586:
      450:  587:int getCost(int cardNumber)
        -:  588:{
      450:  589:	switch (cardNumber)
        -:  590:	{
        -:  591:	case curse:
       22:  592:		return 0;
        -:  593:	case estate:
       18:  594:		return 2;
        -:  595:	case duchy:
       24:  596:		return 5;
        -:  597:	case province:
       22:  598:		return 8;
        -:  599:	case copper:
       48:  600:		return 0;
        -:  601:	case silver:
       21:  602:		return 3;
        -:  603:	case gold:
       30:  604:		return 6;
        -:  605:	case adventurer:
       20:  606:		return 6;
        -:  607:	case council_room:
       30:  608:		return 5;
        -:  609:	case feast:
    #####:  610:		return 4;
        -:  611:	case gardens:
       28:  612:		return 4;
        -:  613:	case mine:
    #####:  614:		return 5;
        -:  615:	case remodel:
       19:  616:		return 4;
        -:  617:	case smithy:
       25:  618:		return 4;
        -:  619:	case village:
        1:  620:		return 3;
        -:  621:	case baron:
    #####:  622:		return 4;
        -:  623:	case great_hall:
       36:  624:		return 3;
        -:  625:	case minion:
    #####:  626:		return 5;
        -:  627:	case steward:
       23:  628:		return 3;
        -:  629:	case tribute:
    #####:  630:		return 5;
        -:  631:	case ambassador:
    #####:  632:		return 3;
        -:  633:	case cutpurse:
       38:  634:		return 4;
        -:  635:	case embargo:
    #####:  636:		return 2;
        -:  637:	case outpost:
       21:  638:		return 5;
        -:  639:	case salvager:
    #####:  640:		return 4;
        -:  641:	case sea_hag:
        1:  642:		return 4;
        -:  643:	case treasure_map:
       23:  644:		return 4;
        -:  645:	}
        -:  646:
    #####:  647:	return -1;
        -:  648:}
        -:  649:
    #####:  650:void playAdventurer(struct gameState *state, int currentPlayer)
        -:  651:// Reveal cards from deck until 2 Treasure cards are found.  Put those Treasure cards in the hand and discard the rest.
        -:  652:{
    #####:  653:	int drawntreasure = 0;
        -:  654:	int temphand[MAX_HAND];
        -:  655:	int cardDrawn;
    #####:  656:	int z = 0; // this is the counter for the temp hand
        -:  657:
    #####:  658:	while (drawntreasure < 2){
    #####:  659:		if (state->deckCount[currentPlayer] < 1){//if the deck is empty we need to shuffle discard and add to deck
    #####:  660:			shuffle(currentPlayer, state);
        -:  661:		}
    #####:  662:		drawCard(currentPlayer, state);
    #####:  663:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer] - 1];//top card of hand is most recently drawn card.
    #####:  664:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
    #####:  665:			drawntreasure++;
        -:  666:		else{
    #####:  667:			temphand[z] = cardDrawn;
    #####:  668:			state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####:  669:			z++;
        -:  670:		}
        -:  671:	}
    #####:  672:	while (z - 1 >= 0){
    #####:  673:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; // discard all cards in play that have been drawn
    #####:  674:		z = z - 1;
        -:  675:	}
    #####:  676:}
        -:  677:
        2:  678:int playRemodel(struct gameState *state, int currentPlayer, int choice1, int choice2, int handPos)
        -:  679://Trash a card in the hand, and gain a card costing up to $2 more than the trashed card
        -:  680:{
        -:  681:	int i;
        2:  682:	int j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  683:
        2:  684:	if ((getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2))
        -:  685:	{
    #####:  686:		return -1;
        -:  687:	}
        -:  688:
        2:  689:	gainCard(choice2, state, 0, currentPlayer);
        -:  690:
        -:  691:	//discard card from hand
        2:  692:	discardCard(handPos, currentPlayer, state, 0);
        -:  693:
        -:  694:	//discard trashed card
        6:  695:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  696:	{
        5:  697:		if (state->hand[currentPlayer][i] == j)
        -:  698:		{
        1:  699:			discardCard(i, currentPlayer, state, 0);
        1:  700:			break;
        -:  701:		}
        -:  702:	}
        -:  703:
        2:  704:	return 0;
        -:  705:}
        -:  706:
        1:  707:void playSmithy(struct gameState *state, int currentPlayer, int handPos)
        -:  708:// Draw 3 cards
        -:  709:{
        -:  710:	int i;
        4:  711:	for (i = 0; i < 3; i++)
        -:  712:	{
        3:  713:		drawCard(currentPlayer, state);
        -:  714:	}
        -:  715:
        -:  716:	//discard card from hand
        1:  717:	discardCard(handPos, currentPlayer, state, 0);
        1:  718:}
        -:  719:
    #####:  720:void playBaron(struct gameState *state, int currentPlayer, int choice1, int handPos)
        -:  721://Add a buy.  OPTION:  Discard an Estate card and gain $4.  Otherwise, gain an Estate card.
        -:  722:{
    #####:  723:	state->numBuys++;//Increase buys by 1!
    #####:  724:	if (choice1 > 0){//Boolean true or going to discard an estate
    #####:  725:		int p = 0;//Iterator for hand!
    #####:  726:		int card_not_discarded = 1;//Flag for discard set!
    #####:  727:		while (card_not_discarded){
    #####:  728:			if (state->hand[currentPlayer][p] == estate){ //Found an estate card!
    #####:  729:				state->coins += 4;//Add 4 coins to the amount of coins
    #####:  730:				state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  731:				state->discardCount[currentPlayer]++;
    #####:  732:				for (; p < state->handCount[currentPlayer]; p++){
    #####:  733:					state->hand[currentPlayer][p] = state->hand[currentPlayer][p + 1];
        -:  734:				}
    #####:  735:				state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  736:				state->handCount[currentPlayer]--;
    #####:  737:				card_not_discarded = 0;//Exit the loop
        -:  738:			}
    #####:  739:			else if (p > state->handCount[currentPlayer]){
        -:  740:				if (DEBUG) {
        -:  741:					printf("No estate cards in your hand, invalid choice\n");
        -:  742:					printf("Must gain an estate if there are any\n");
        -:  743:				}
    #####:  744:				if (supplyCount(estate, state) > 0){
    #####:  745:					gainCard(estate, state, 1, currentPlayer);
    #####:  746:					state->supplyCount[estate]--;//Decrement estates
    #####:  747:					if (supplyCount(estate, state) == 0){
    #####:  748:						isGameOver(state);
        -:  749:					}
        -:  750:				}
    #####:  751:				card_not_discarded = 0;//Exit the loop
        -:  752:			}
        -:  753:
        -:  754:			else{
    #####:  755:				p++;//Next card
        -:  756:			}
        -:  757:		}
        -:  758:	}
        -:  759:
        -:  760:	else{
    #####:  761:		if (supplyCount(estate, state) > 0){
    #####:  762:			gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  763:			state->supplyCount[estate]--;//Decrement Estates
    #####:  764:			if (supplyCount(estate, state) == 0){
    #####:  765:				isGameOver(state);
        -:  766:			}
        -:  767:		}
        -:  768:	}
    #####:  769:}
        -:  770:
    #####:  771:int playTreasureMap(struct gameState *state, int currentPlayer, int handPos)
        -:  772://Trashing two treasure map cards from the hand = four gold on top of the deck.
        -:  773:{
        -:  774:	int i;
        -:  775:	int index;
        -:  776:
        -:  777:	//search hand for another treasure_map
    #####:  778:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  779:	{
    #####:  780:		if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -:  781:		{
    #####:  782:			index = i;
    #####:  783:			break;
        -:  784:		}
        -:  785:	}
    #####:  786:	if (index > -1)
        -:  787:	{
        -:  788:		//trash both treasure cards
    #####:  789:		discardCard(handPos, currentPlayer, state, 1);
    #####:  790:		discardCard(index, currentPlayer, state, 1);
        -:  791:
        -:  792:		//gain 4 Gold cards
    #####:  793:		for (i = 0; i < 4; i++)
        -:  794:		{
    #####:  795:			gainCard(gold, state, 1, currentPlayer);
        -:  796:		}
        -:  797:
        -:  798:		//return success
    #####:  799:		return 1;
        -:  800:	}
        -:  801:
        -:  802:	//no second treasure_map found in hand
    #####:  803:	return -1;
        -:  804:}
        -:  805:
       42:  806:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  807:{
        -:  808:	int i;
        -:  809:	int j;
        -:  810:	int k;
        -:  811:	//int x;  //Unused after while loop removed from feast.
       42:  812:	int currentPlayer = whoseTurn(state);
       42:  813:	int nextPlayer = currentPlayer + 1;
        -:  814:	int temphand[MAX_HAND];
        -:  815:
       42:  816:	int tributeRevealedCards[2] = { -1, -1 };
        -:  817:
       42:  818:	if (nextPlayer > (state->numPlayers - 1)){
       27:  819:		nextPlayer = 0;
        -:  820:	}
        -:  821:
        -:  822:	//uses switch to select card and perform actions
       42:  823:	switch (card)
        -:  824:	{
        -:  825:	case adventurer:
        -:  826:
    #####:  827:		playAdventurer(state, currentPlayer);
    #####:  828:		return 0;
        -:  829:
        -:  830:	case council_room:
        -:  831:		//+4 Cards
        5:  832:		for (i = 0; i < 4; i++)
        -:  833:		{
        4:  834:			drawCard(currentPlayer, state);
        -:  835:		}
        -:  836:
        -:  837:		//+1 Buy
        1:  838:		state->numBuys++;
        -:  839:
        -:  840:		//Each other player draws a card
        3:  841:		for (i = 0; i < state->numPlayers; i++)
        -:  842:		{
        2:  843:			if (i != currentPlayer)
        -:  844:			{
        1:  845:				drawCard(i, state);
        -:  846:			}
        -:  847:		}
        -:  848:
        -:  849:		//put played card in played card pile
        1:  850:		discardCard(handPos, currentPlayer, state, 0);
        -:  851:
        1:  852:		return 0;
        -:  853:
        -:  854:	case feast:
        -:  855:		//gain card with cost up to 5
        -:  856:		//Backup hand
    #####:  857:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  858:			temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  859:			state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  860:		}
        -:  861:		//Backup hand
        -:  862:
        -:  863:		//Update Coins for Buy
    #####:  864:		updateCoins(currentPlayer, state, 5);
        -:  865://		x = 1;//Condition to loop on
        -:  866://		while (x == 1) {//Buy one card
    #####:  867:			if (supplyCount(choice1, state) <= 0){
        -:  868:				if (DEBUG)
        -:  869:					printf("None of that card left, sorry!\n");
        -:  870:
        -:  871:				if (DEBUG){
        -:  872:					printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  873:				}
        -:  874:			}
    #####:  875:			else if (state->coins < getCost(choice1)){
    #####:  876:				printf("That card is too expensive!\n");
        -:  877:
        -:  878:				if (DEBUG){
        -:  879:					printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  880:				}
        -:  881:			}
        -:  882:			else{
        -:  883:
        -:  884:				if (DEBUG){
        -:  885:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  886:				}
        -:  887:
    #####:  888:				gainCard(choice1, state, 0, currentPlayer);//Gain the card
        -:  889://				x = 0;//No more buying cards
        -:  890:
        -:  891:				if (DEBUG){
        -:  892:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  893:				}
        -:  894:
        -:  895:			}
        -:  896://		}
        -:  897:
        -:  898:		//Reset Hand
    #####:  899:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  900:			state->hand[currentPlayer][i] = temphand[i];
    #####:  901:			temphand[i] = -1;
        -:  902:		}
        -:  903:		//Reset Hand
        -:  904:
    #####:  905:		return 0;
        -:  906:
        -:  907:	case gardens:
       27:  908:		return -1;
        -:  909:
        -:  910:	case mine:
    #####:  911:		j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  912:
    #####:  913:		if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  914:		{
    #####:  915:			return -1;
        -:  916:		}
        -:  917:
    #####:  918:		if (choice2 > treasure_map || choice2 < curse)
        -:  919:		{
    #####:  920:			return -1;
        -:  921:		}
        -:  922:
    #####:  923:		if ((getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2))
        -:  924:		{
    #####:  925:			return -1;
        -:  926:		}
        -:  927:
    #####:  928:		gainCard(choice2, state, 2, currentPlayer);
        -:  929:
        -:  930:		//discard card from hand
    #####:  931:		discardCard(handPos, currentPlayer, state, 0);
        -:  932:
        -:  933:		//discard trashed card
    #####:  934:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  935:		{
    #####:  936:			if (state->hand[currentPlayer][i] == j)
        -:  937:			{
    #####:  938:				discardCard(i, currentPlayer, state, 0);
    #####:  939:				break;
        -:  940:			}
        -:  941:		}
        -:  942:
    #####:  943:		return 0;
        -:  944:
        -:  945:	case remodel:
        -:  946:
        2:  947:		return playRemodel(state, currentPlayer, choice1, choice2, handPos);
        -:  948:
        -:  949:	case smithy:
        -:  950:
        1:  951:		playSmithy(state, currentPlayer, handPos);
        1:  952:		return 0;
        -:  953:
        -:  954:	case village:
        -:  955:		//+1 Card
    #####:  956:		drawCard(currentPlayer, state);
        -:  957:
        -:  958:		//+2 Actions
    #####:  959:		state->numActions = state->numActions + 2;
        -:  960:
        -:  961:		//discard played card from hand
    #####:  962:		discardCard(handPos, currentPlayer, state, 0);
    #####:  963:		return 0;
        -:  964:
        -:  965:	case baron:
        -:  966:
    #####:  967:		playBaron(state, currentPlayer, choice1, handPos);
    #####:  968:		return 0;
        -:  969:
        -:  970:	case great_hall:
        -:  971:		//+1 Card
        5:  972:		drawCard(currentPlayer, state);
        -:  973:
        -:  974:		//+1 Actions
        5:  975:		state->numActions++;
        -:  976:
        -:  977:		//discard card from hand
        5:  978:		discardCard(handPos, currentPlayer, state, 0);
        5:  979:		return 0;
        -:  980:
        -:  981:	case minion:
        -:  982:		//+1 action
    #####:  983:		state->numActions++;
        -:  984:
        -:  985:		//discard card from hand
    #####:  986:		discardCard(handPos, currentPlayer, state, 0);
        -:  987:
    #####:  988:		if (choice1)		//+2 coins
        -:  989:		{
    #####:  990:			state->coins = state->coins + 2;
        -:  991:		}
        -:  992:
    #####:  993:		else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  994:		{
        -:  995:			//discard hand
    #####:  996:			while (numHandCards(state) > 0)
        -:  997:			{
    #####:  998:				discardCard(handPos, currentPlayer, state, 0);
        -:  999:			}
        -: 1000:
        -: 1001:			//draw 4
    #####: 1002:			for (i = 0; i < 4; i++)
        -: 1003:			{
    #####: 1004:				drawCard(currentPlayer, state);
        -: 1005:			}
        -: 1006:
        -: 1007:			//other players discard hand and redraw if hand size > 4
    #####: 1008:			for (i = 0; i < state->numPlayers; i++)
        -: 1009:			{
    #####: 1010:				if (i != currentPlayer)
        -: 1011:				{
    #####: 1012:					if (state->handCount[i] > 4)
        -: 1013:					{
        -: 1014:						//discard hand
    #####: 1015:						while (state->handCount[i] > 0)
        -: 1016:						{
    #####: 1017:							discardCard(handPos, i, state, 0);
        -: 1018:						}
        -: 1019:
        -: 1020:						//draw 4
    #####: 1021:						for (j = 0; j < 4; j++)
        -: 1022:						{
    #####: 1023:							drawCard(i, state);
        -: 1024:						}
        -: 1025:					}
        -: 1026:				}
        -: 1027:			}
        -: 1028:
        -: 1029:		}
    #####: 1030:		return 0;
        -: 1031:
        -: 1032:	case steward:
        3: 1033:		if (choice1 == 1)
        -: 1034:		{
        -: 1035:			//+2 cards
    #####: 1036:			drawCard(currentPlayer, state);
    #####: 1037:			drawCard(currentPlayer, state);
        -: 1038:		}
        3: 1039:		else if (choice1 == 2)
        -: 1040:		{
        -: 1041:			//+2 coins
        1: 1042:			state->coins = state->coins + 2;
        -: 1043:		}
        -: 1044:		else
        -: 1045:		{
        -: 1046:			//trash 2 cards in hand
        2: 1047:			discardCard(choice2, currentPlayer, state, 1);
        2: 1048:			discardCard(choice3, currentPlayer, state, 1);
        -: 1049:		}
        -: 1050:
        -: 1051:		//discard card from hand
        3: 1052:		discardCard(handPos, currentPlayer, state, 0);
        3: 1053:		return 0;
        -: 1054:
        -: 1055:	case tribute:
    #####: 1056:		if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####: 1057:			if (state->deckCount[nextPlayer] > 0){
    #####: 1058:				tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1059:				state->deckCount[nextPlayer]--;
        -: 1060:			}
    #####: 1061:			else if (state->discardCount[nextPlayer] > 0){
    #####: 1062:				tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer] - 1];
    #####: 1063:				state->discardCount[nextPlayer]--;
        -: 1064:			}
        -: 1065:			else{
        -: 1066:				//No Card to Reveal
        -: 1067:				if (DEBUG){
        -: 1068:					printf("No cards to reveal\n");
        -: 1069:				}
        -: 1070:			}
        -: 1071:		}
        -: 1072:
        -: 1073:		else{
    #####: 1074:			if (state->deckCount[nextPlayer] == 0){
    #####: 1075:				for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####: 1076:					state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1077:					state->deckCount[nextPlayer]++;
    #####: 1078:					state->discard[nextPlayer][i] = -1;
    #####: 1079:					state->discardCount[nextPlayer]--;
        -: 1080:				}
        -: 1081:
    #####: 1082:				shuffle(nextPlayer, state);//Shuffle the deck
        -: 1083:			}
    #####: 1084:			tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1085:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1086:			state->deckCount[nextPlayer]--;
    #####: 1087:			tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1088:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1089:			state->deckCount[nextPlayer]--;
        -: 1090:		}
        -: 1091:
    #####: 1092:		if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
    #####: 1093:			state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1094:			state->playedCardCount++;
    #####: 1095:			tributeRevealedCards[1] = -1;
        -: 1096:		}
        -: 1097:
    #####: 1098:		for (i = 0; i <= 2; i++){
    #####: 1099:			if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
    #####: 1100:				state->coins += 2;
        -: 1101:			}
        -: 1102:
    #####: 1103:			else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
    #####: 1104:				drawCard(currentPlayer, state);
    #####: 1105:				drawCard(currentPlayer, state);
        -: 1106:			}
        -: 1107:			else{//Action Card
    #####: 1108:				state->numActions = state->numActions + 2;
        -: 1109:			}
        -: 1110:		}
        -: 1111:
    #####: 1112:		return 0;
        -: 1113:
        -: 1114:	case ambassador:
    #####: 1115:		j = 0;		//used to check if player has enough cards to discard
        -: 1116:
    #####: 1117:		if (choice2 > 2 || choice2 < 0)
        -: 1118:		{
    #####: 1119:			return -1;
        -: 1120:		}
        -: 1121:
    #####: 1122:		if (choice1 == handPos)
        -: 1123:		{
    #####: 1124:			return -1;
        -: 1125:		}
        -: 1126:
    #####: 1127:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1128:		{
    #####: 1129:			if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1130:			{
    #####: 1131:				j++;
        -: 1132:			}
        -: 1133:		}
    #####: 1134:		if (j < choice2)
        -: 1135:		{
    #####: 1136:			return -1;
        -: 1137:		}
        -: 1138:
        -: 1139:		if (DEBUG)
        -: 1140:			printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1141:
        -: 1142:		//increase supply count for choosen card by amount being discarded
    #####: 1143:		state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1144:
        -: 1145:		//each other player gains a copy of revealed card
    #####: 1146:		for (i = 0; i < state->numPlayers; i++)
        -: 1147:		{
    #####: 1148:			if (i != currentPlayer)
        -: 1149:			{
    #####: 1150:				gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1151:			}
        -: 1152:		}
        -: 1153:
        -: 1154:		//discard played card from hand
    #####: 1155:		discardCard(handPos, currentPlayer, state, 0);
        -: 1156:
        -: 1157:		//trash copies of cards returned to supply
    #####: 1158:		for (j = 0; j < choice2; j++)
        -: 1159:		{
    #####: 1160:			for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1161:			{
    #####: 1162:				if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1163:				{
    #####: 1164:					discardCard(i, currentPlayer, state, 1);
    #####: 1165:					break;
        -: 1166:				}
        -: 1167:			}
        -: 1168:		}
        -: 1169:
    #####: 1170:		return 0;
        -: 1171:
        -: 1172:	case cutpurse:
        -: 1173:
        3: 1174:		updateCoins(currentPlayer, state, 2);
        9: 1175:		for (i = 0; i < state->numPlayers; i++)
        -: 1176:		{
        6: 1177:			if (i != currentPlayer)
        -: 1178:			{
        3: 1179:				for (j = 0; j < state->handCount[i]; j++)
        -: 1180:				{
    #####: 1181:					if (state->hand[i][j] == copper)
        -: 1182:					{
    #####: 1183:						discardCard(j, i, state, 0);
    #####: 1184:						break;
        -: 1185:					}
    #####: 1186:					if (j == state->handCount[i])
        -: 1187:					{
    #####: 1188:						for (k = 0; k < state->handCount[i]; k++)
        -: 1189:						{
        -: 1190:							if (DEBUG)
        -: 1191:								printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1192:						}
    #####: 1193:						break;
        -: 1194:					}
        -: 1195:				}
        -: 1196:
        -: 1197:			}
        -: 1198:
        -: 1199:		}
        -: 1200:
        -: 1201:		//discard played card from hand
        3: 1202:		discardCard(handPos, currentPlayer, state, 0);
        -: 1203:
        3: 1204:		return 0;
        -: 1205:
        -: 1206:
        -: 1207:	case embargo:
        -: 1208:		//+2 Coins
    #####: 1209:		state->coins = state->coins + 2;
        -: 1210:
        -: 1211:		//see if selected pile is in play
    #####: 1212:		if (state->supplyCount[choice1] == -1)
        -: 1213:		{
    #####: 1214:			return -1;
        -: 1215:		}
        -: 1216:
        -: 1217:		//add embargo token to selected supply pile
    #####: 1218:		state->embargoTokens[choice1]++;
        -: 1219:
        -: 1220:		//trash card
    #####: 1221:		discardCard(handPos, currentPlayer, state, 1);
    #####: 1222:		return 0;
        -: 1223:
        -: 1224:	case outpost:
        -: 1225:		//set outpost flag
    #####: 1226:		state->outpostPlayed++;
        -: 1227:
        -: 1228:		//discard card
    #####: 1229:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1230:		return 0;
        -: 1231:
        -: 1232:	case salvager:
        -: 1233:		//+1 buy
    #####: 1234:		state->numBuys++;
        -: 1235:
    #####: 1236:		if (choice1)
        -: 1237:		{
        -: 1238:			//gain coins equal to trashed card
    #####: 1239:			state->coins = state->coins + getCost(handCard(choice1, state));
        -: 1240:			//trash card
    #####: 1241:			discardCard(choice1, currentPlayer, state, 1);
        -: 1242:		}
        -: 1243:
        -: 1244:		//discard card
    #####: 1245:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1246:		return 0;
        -: 1247:
        -: 1248:	case sea_hag:
    #####: 1249:		for (i = 0; i < state->numPlayers; i++){
    #####: 1250:			if (i != currentPlayer){
    #####: 1251:				state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1252:				state->discardCount[i]++;
    #####: 1253:				state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1254:			}
        -: 1255:		}
    #####: 1256:		return 0;
        -: 1257:
        -: 1258:	case treasure_map:
        -: 1259:
    #####: 1260:		return playTreasureMap(state, currentPlayer, handPos);
        -: 1261:	}
    #####: 1262:	return -1;
        -: 1263:}
        -: 1264:
       20: 1265:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1266:{
        -: 1267:
        -: 1268:	//if card is not trashed, added to Played pile 
       20: 1269:	if (trashFlag < 1)
        -: 1270:	{
        -: 1271:		//add card to played pile
       16: 1272:		state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
       16: 1273:		state->playedCardCount++;
        -: 1274:	}
        -: 1275:
        -: 1276:	//set played card to -1
       20: 1277:	state->hand[currentPlayer][handPos] = -1;
        -: 1278:
        -: 1279:	//remove card from player's hand
       20: 1280:	if (handPos == (state->handCount[currentPlayer] - 1)) 	//last card in hand array is played
        -: 1281:	{
        -: 1282:		//reduce number of cards in hand
        1: 1283:		state->handCount[currentPlayer]--;
        -: 1284:	}
       19: 1285:	else if (state->handCount[currentPlayer] == 1) //only one card in hand
        -: 1286:	{
        -: 1287:		//reduce number of cards in hand
    #####: 1288:		state->handCount[currentPlayer]--;
        -: 1289:	}
        -: 1290:	else
        -: 1291:	{
        -: 1292:		//replace discarded card with last card in hand
       19: 1293:		state->hand[currentPlayer][handPos] = state->hand[currentPlayer][(state->handCount[currentPlayer] - 1)];
        -: 1294:		//set last card to -1
       19: 1295:		state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1296:		//reduce number of cards in hand
       19: 1297:		state->handCount[currentPlayer]--;
        -: 1298:	}
        -: 1299:
       20: 1300:	return 0;
        -: 1301:}
        -: 1302:
       76: 1303:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1304:{
        -: 1305:	//Note: supplyPos is enum of choosen card
        -: 1306:
        -: 1307:	//check if supply pile is empty (0) or card is not used in game (-1)
       76: 1308:	if (supplyCount(supplyPos, state) < 1)
        -: 1309:	{
        2: 1310:		return -1;
        -: 1311:	}
        -: 1312:
        -: 1313:	//added card for [whoseTurn] current player:
        -: 1314:	// toFlag = 0 : add to discard
        -: 1315:	// toFlag = 1 : add to deck
        -: 1316:	// toFlag = 2 : add to hand
        -: 1317:
       74: 1318:	if (toFlag == 1)
        -: 1319:	{
    #####: 1320:		state->deck[player][state->deckCount[player]] = supplyPos;
    #####: 1321:		state->deckCount[player]++;
        -: 1322:	}
       74: 1323:	else if (toFlag == 2)
        -: 1324:	{
    #####: 1325:		state->hand[player][state->handCount[player]] = supplyPos;
    #####: 1326:		state->handCount[player]++;
        -: 1327:	}
        -: 1328:	else
        -: 1329:	{
       74: 1330:		state->discard[player][state->discardCount[player]] = supplyPos;
       74: 1331:		state->discardCount[player]++;
        -: 1332:	}
        -: 1333:
        -: 1334:	//decrease number in supply pile
       74: 1335:	state->supplyCount[supplyPos]--;
        -: 1336:
       74: 1337:	return 0;
        -: 1338:}
        -: 1339:
      105: 1340:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1341:{
        -: 1342:	int i;
        -: 1343:
        -: 1344:	//reset coin count
      105: 1345:	state->coins = 0;
        -: 1346:
        -: 1347:	//add coins for each Treasure card in player's hand
      622: 1348:	for (i = 0; i < state->handCount[player]; i++)
        -: 1349:	{
      517: 1350:		if (state->hand[player][i] == copper)
        -: 1351:		{
      248: 1352:			state->coins += 1;
        -: 1353:		}
      269: 1354:		else if (state->hand[player][i] == silver)
        -: 1355:		{
       21: 1356:			state->coins += 2;
        -: 1357:		}
      248: 1358:		else if (state->hand[player][i] == gold)
        -: 1359:		{
    #####: 1360:			state->coins += 3;
        -: 1361:		}
        -: 1362:	}
        -: 1363:
        -: 1364:	//add bonus
      105: 1365:	state->coins += bonus;
        -: 1366:
      105: 1367:	return 0;
        -: 1368:}
        -: 1369:
        -: 1370:
        -: 1371://end of dominion.c
File 'dominion.c'
Lines executed:59.78% of 557
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
     1554:    8:int compare(const void* a, const void* b) {
     1554:    9:	if (*(int*)a > *(int*)b)
      482:   10:		return 1;
     1072:   11:	if (*(int*)a < *(int*)b)
      436:   12:		return -1;
      636:   13:	return 0;
        -:   14:}
        -:   15:
        2:   16:struct gameState* newGame() {
        2:   17:	struct gameState* g = malloc(sizeof(struct gameState));
        2:   18:	return g;
        -:   19:}
        -:   20:
       21:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:	int k8, int k9, int k10) {
       21:   23:	int* k = malloc(10 * sizeof(int));
       21:   24:	k[0] = k1;
       21:   25:	k[1] = k2;
       21:   26:	k[2] = k3;
       21:   27:	k[3] = k4;
       21:   28:	k[4] = k5;
       21:   29:	k[5] = k6;
       21:   30:	k[6] = k7;
       21:   31:	k[7] = k8;
       21:   32:	k[8] = k9;
       21:   33:	k[9] = k10;
       21:   34:	return k;
        -:   35:}
        -:   36:
       21:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		struct gameState *state) {
        -:   39:
        -:   40:	int i;
        -:   41:	int j;
        -:   42:	int it;
        -:   43:	//set up random number generator
       21:   44:	SelectStream(1);
       21:   45:	PutSeed((long)randomSeed);
        -:   46:
        -:   47:	//check number of players
       21:   48:	if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:	{
    #####:   50:		return -1;
        -:   51:	}
        -:   52:
        -:   53:	//set number of players
       21:   54:	state->numPlayers = numPlayers;
        -:   55:
        -:   56:	//check selected kingdom cards are different
       56:   57:	for (i = 0; i < 10; i++)
        -:   58:	{
      522:   59:		for (j = 0; j < 10; j++)
        -:   60:		{
      487:   61:			if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:			{
       20:   63:				return -1;
        -:   64:			}
        -:   65:		}
        -:   66:	}
        -:   67:
        -:   68:
        -:   69:	//initialize supply
        -:   70:	///////////////////////////////
        -:   71:
        -:   72:	//set number of Curse cards
        1:   73:	if (numPlayers == 2)
        -:   74:	{
    #####:   75:		state->supplyCount[curse] = 10;
        -:   76:	}
        1:   77:	else if (numPlayers == 3)
        -:   78:	{
        1:   79:		state->supplyCount[curse] = 20;
        -:   80:	}
        -:   81:	else
        -:   82:	{
    #####:   83:		state->supplyCount[curse] = 30;
        -:   84:	}
        -:   85:
        -:   86:	//set number of Victory cards
        1:   87:	if (numPlayers == 2)
        -:   88:	{
    #####:   89:		state->supplyCount[estate] = 8;
    #####:   90:		state->supplyCount[duchy] = 8;
    #####:   91:		state->supplyCount[province] = 8;
        -:   92:	}
        -:   93:	else
        -:   94:	{
        1:   95:		state->supplyCount[estate] = 12;
        1:   96:		state->supplyCount[duchy] = 12;
        1:   97:		state->supplyCount[province] = 12;
        -:   98:	}
        -:   99:
        -:  100:	//set number of Treasure cards
        1:  101:	state->supplyCount[copper] = 60 - (7 * numPlayers);
        1:  102:	state->supplyCount[silver] = 40;
        1:  103:	state->supplyCount[gold] = 30;
        -:  104:
        -:  105:	//set number of Kingdom cards
       21:  106:	for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:	{
      165:  108:		for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:		{
      155:  110:			if (kingdomCards[j] == i)
        -:  111:			{
        -:  112:				//check if card is a 'Victory' Kingdom card
       10:  113:				if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:				{
    #####:  115:					if (numPlayers == 2){
    #####:  116:						state->supplyCount[i] = 8;
        -:  117:					}
    #####:  118:					else{ state->supplyCount[i] = 12; }
        -:  119:				}
        -:  120:				else
        -:  121:				{
       10:  122:					state->supplyCount[i] = 10;
        -:  123:				}
       10:  124:				break;
        -:  125:			}
        -:  126:			else    //card is not in the set choosen for the game
        -:  127:			{
      145:  128:				state->supplyCount[i] = -1;
        -:  129:			}
        -:  130:		}
        -:  131:
        -:  132:	}
        -:  133:
        -:  134:	////////////////////////
        -:  135:	//supply intilization complete
        -:  136:
        -:  137:	//set player decks
        4:  138:	for (i = 0; i < numPlayers; i++)
        -:  139:	{
        3:  140:		state->deckCount[i] = 0;
       12:  141:		for (j = 0; j < 3; j++)
        -:  142:		{
        9:  143:			state->deck[i][j] = estate;
        9:  144:			state->deckCount[i]++;
        -:  145:		}
       24:  146:		for (j = 3; j < 10; j++)
        -:  147:		{
       21:  148:			state->deck[i][j] = copper;
       21:  149:			state->deckCount[i]++;
        -:  150:		}
        -:  151:	}
        -:  152:
        -:  153:	//shuffle player decks
        4:  154:	for (i = 0; i < numPlayers; i++)
        -:  155:	{
        3:  156:		if (shuffle(i, state) < 0)
        -:  157:		{
    #####:  158:			return -1;
        -:  159:		}
        -:  160:	}
        -:  161:
        -:  162:	//draw player hands
        4:  163:	for (i = 0; i < numPlayers; i++)
        -:  164:	{
        -:  165:		//initialize hand size to zero
        3:  166:		state->handCount[i] = 0;
        3:  167:		state->discardCount[i] = 0;
        -:  168:		//draw 5 cards
        -:  169:		// for (j = 0; j < 5; j++)
        -:  170:		//	{
        -:  171:		//	  drawCard(i, state);
        -:  172:		//	}
        -:  173:	}
        -:  174:
        -:  175:	//set embargo tokens to 0 for all supply piles
       28:  176:	for (i = 0; i <= treasure_map; i++)
        -:  177:	{
       27:  178:		state->embargoTokens[i] = 0;
        -:  179:	}
        -:  180:
        -:  181:	//initialize first player's turn
        1:  182:	state->outpostPlayed = 0;
        1:  183:	state->phase = 0;
        1:  184:	state->numActions = 1;
        1:  185:	state->numBuys = 1;
        1:  186:	state->playedCardCount = 0;
        1:  187:	state->whoseTurn = 0;
        1:  188:	state->handCount[state->whoseTurn] = 0;
        -:  189:	//int it; move to top
        -:  190:
        -:  191:	//Moved draw cards to here, only drawing at the start of a turn
        6:  192:	for (it = 0; it < 5; it++){
        5:  193:		drawCard(state->whoseTurn, state);
        -:  194:	}
        -:  195:
        1:  196:	updateCoins(state->whoseTurn, state, 0);
        -:  197:
        1:  198:	return 0;
        -:  199:}
        -:  200:
       45:  201:int shuffle(int player, struct gameState *state) {
        -:  202:
        -:  203:
        -:  204:	int newDeck[MAX_DECK];
       45:  205:	int newDeckPos = 0;
        -:  206:	int card;
        -:  207:	int i;
        -:  208:
       45:  209:	if (state->deckCount[player] < 1)
    #####:  210:		return -1;
       45:  211:	qsort((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
        -:  212:	/* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
      876:  214:	while (state->deckCount[player] > 0) {
      786:  215:		card = floor(Random() * state->deckCount[player]);
      786:  216:		newDeck[newDeckPos] = state->deck[player][card];
      786:  217:		newDeckPos++;
     4514:  218:		for (i = card; i < state->deckCount[player] - 1; i++) {
     3728:  219:			state->deck[player][i] = state->deck[player][i + 1];
        -:  220:		}
      786:  221:		state->deckCount[player]--;
        -:  222:	}
      831:  223:	for (i = 0; i < newDeckPos; i++) {
      786:  224:		state->deck[player][i] = newDeck[i];
      786:  225:		state->deckCount[player]++;
        -:  226:	}
        -:  227:
       45:  228:	return 0;
        -:  229:}
        -:  230:
      771:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state)
        -:  232:{
        -:  233:	int card;
      771:  234:	int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:	//check if it is the right phase
      771:  237:	if (state->phase != 0)
        -:  238:	{
       89:  239:		return -1;
        -:  240:	}
        -:  241:
        -:  242:	//check if player has enough actions
      682:  243:	if (state->numActions < 1)
        -:  244:	{
       20:  245:		return -1;
        -:  246:	}
        -:  247:
        -:  248:	//get card played
      662:  249:	card = handCard(handPos, state);
        -:  250:
        -:  251:	//check if selected card is an action
      662:  252:	if (card < adventurer || card > treasure_map)
        -:  253:	{
      621:  254:		return -1;
        -:  255:	}
        -:  256:
        -:  257:	//play card
       41:  258:	if (cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0)
        -:  259:	{
    #####:  260:		return -1;
        -:  261:	}
        -:  262:
        -:  263:	//reduce number of actions
       41:  264:	state->numActions--;
        -:  265:
        -:  266:	//update coins (Treasure cards may be added with card draws)
       41:  267:	updateCoins(state->whoseTurn, state, coin_bonus);
        -:  268:
       41:  269:	return 0;
        -:  270:}
        -:  271:
      849:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:	int who;
        -:  274:	if (DEBUG){
        -:  275:		printf("Entering buyCard...\n");
        -:  276:	}
        -:  277:
        -:  278:	// I don't know what to do about the phase thing.
        -:  279:
      849:  280:	who = state->whoseTurn;
        -:  281:
      849:  282:	if (state->numBuys < 1){
        -:  283:		if (DEBUG)
        -:  284:			printf("You do not have any buys left\n");
      106:  285:		return -1;
        -:  286:	}
      743:  287:	else if (supplyCount(supplyPos, state) < 1){
        -:  288:		if (DEBUG)
        -:  289:			printf("There are not any of that type of card left\n");
      273:  290:		return -1;
        -:  291:	}
      470:  292:	else if (state->coins < getCost(supplyPos)){
        -:  293:		if (DEBUG)
        -:  294:			printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
      366:  295:		return -1;
        -:  296:	}
        -:  297:	else {
      104:  298:		state->phase = 1;
        -:  299:		//state->supplyCount[supplyPos]--;
      104:  300:		gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  301:
      104:  302:		state->coins = (state->coins) - (getCost(supplyPos));
      104:  303:		state->numBuys--;
        -:  304:		if (DEBUG)
        -:  305:			printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  306:	}
        -:  307:
        -:  308:	//state->discard[who][state->discardCount[who]] = supplyPos;
        -:  309:	//state->discardCount[who]++;
        -:  310:
      104:  311:	return 0;
        -:  312:}
        -:  313:
    #####:  314:int numHandCards(struct gameState *state) {
    #####:  315:	return state->handCount[whoseTurn(state)];
        -:  316:}
        -:  317:
      663:  318:int handCard(int handPos, struct gameState *state) {
      663:  319:	int currentPlayer = whoseTurn(state);
      663:  320:	return state->hand[currentPlayer][handPos];
        -:  321:}
        -:  322:
      864:  323:int supplyCount(int card, struct gameState *state) {
      864:  324:	return state->supplyCount[card];
        -:  325:}
        -:  326:
    #####:  327:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  328:	int i;
    #####:  329:	int count = 0;
        -:  330:
    #####:  331:	for (i = 0; i < state->deckCount[player]; i++)
        -:  332:	{
    #####:  333:		if (state->deck[player][i] == card) count++;
        -:  334:	}
        -:  335:
    #####:  336:	for (i = 0; i < state->handCount[player]; i++)
        -:  337:	{
    #####:  338:		if (state->hand[player][i] == card) count++;
        -:  339:	}
        -:  340:
    #####:  341:	for (i = 0; i < state->discardCount[player]; i++)
        -:  342:	{
    #####:  343:		if (state->discard[player][i] == card) count++;
        -:  344:	}
        -:  345:
    #####:  346:	return count;
        -:  347:}
        -:  348:
      843:  349:int whoseTurn(struct gameState *state) {
      843:  350:	return state->whoseTurn;
        -:  351:}
        -:  352:
      139:  353:int endTurn(struct gameState *state) {
        -:  354:	int k;
        -:  355:	int i;
      139:  356:	int currentPlayer = whoseTurn(state);
        -:  357:
        -:  358:	//Discard hand
      800:  359:	for (i = 0; i < state->handCount[currentPlayer]; i++){
      661:  360:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
      661:  361:		state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  362:	}
      139:  363:	state->handCount[currentPlayer] = 0;//Reset hand count
        -:  364:
        -:  365:	//Code for determining the player
      139:  366:	if (currentPlayer < (state->numPlayers - 1)){
       93:  367:		state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  368:	}
        -:  369:	else{
       46:  370:		state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  371:	}
        -:  372:
      139:  373:	state->outpostPlayed = 0;
      139:  374:	state->phase = 0;
      139:  375:	state->numActions = 1;
      139:  376:	state->coins = 0;
      139:  377:	state->numBuys = 1;
      139:  378:	state->playedCardCount = 0;
      139:  379:	state->handCount[state->whoseTurn] = 0;
        -:  380:
        -:  381:	//int k; move to top
        -:  382:	//Next player draws hand
      834:  383:	for (k = 0; k < 5; k++){
      695:  384:		drawCard(state->whoseTurn, state);//Draw a card
        -:  385:	}
        -:  386:
        -:  387:	//Update money
      139:  388:	updateCoins(state->whoseTurn, state, 0);
        -:  389:
      139:  390:	return 0;
        -:  391:}
        -:  392:
     2428:  393:int isGameOver(struct gameState *state) {
        -:  394:	int i;
        -:  395:	int j;
        -:  396:
        -:  397:	//if stack of Province cards is empty, the game ends
     2428:  398:	if (state->supplyCount[province] == 0)
        -:  399:	{
    #####:  400:		return 1;
        -:  401:	}
        -:  402:
        -:  403:	//if three supply pile are at 0, the game ends
     2428:  404:	j = 0;
    63128:  405:	for (i = 0; i < 25; i++)
        -:  406:	{
    60700:  407:		if (state->supplyCount[i] == 0)
        -:  408:		{
     1676:  409:			j++;
        -:  410:		}
        -:  411:	}
     2428:  412:	if (j >= 3)
        -:  413:	{
        1:  414:		return 1;
        -:  415:	}
        -:  416:
     2427:  417:	return 0;
        -:  418:}
        -:  419:
        3:  420:int scoreFor(int player, struct gameState *state) {
        -:  421:
        -:  422:	int i;
        3:  423:	int score = 0;
        -:  424:	//score from hand
        8:  425:	for (i = 0; i < state->handCount[player]; i++)
        -:  426:	{
        5:  427:		if (state->hand[player][i] == curse) { score = score - 1; };
        5:  428:		if (state->hand[player][i] == estate) { score = score + 1; };
        5:  429:		if (state->hand[player][i] == duchy) { score = score + 3; };
        5:  430:		if (state->hand[player][i] == province) { score = score + 6; };
        5:  431:		if (state->hand[player][i] == great_hall) { score = score + 1; };
        5:  432:		if (state->hand[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  433:	}
        -:  434:
        -:  435:	//score from discard
       33:  436:	for (i = 0; i < state->discardCount[player]; i++)
        -:  437:	{
       30:  438:		if (state->discard[player][i] == curse) { score = score - 1; };
       30:  439:		if (state->discard[player][i] == estate) { score = score + 1; };
       30:  440:		if (state->discard[player][i] == duchy) { score = score + 3; };
       30:  441:		if (state->discard[player][i] == province) { score = score + 6; };
       30:  442:		if (state->discard[player][i] == great_hall) { score = score + 1; };
       30:  443:		if (state->discard[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  444:	}
        -:  445:
        -:  446:	//score from deck
       33:  447:	for (i = 0; i < state->discardCount[player]; i++)
        -:  448:	{
       30:  449:		if (state->deck[player][i] == curse) { score = score - 1; };
       30:  450:		if (state->deck[player][i] == estate) { score = score + 1; };
       30:  451:		if (state->deck[player][i] == duchy) { score = score + 3; };
       30:  452:		if (state->deck[player][i] == province) { score = score + 6; };
       30:  453:		if (state->deck[player][i] == great_hall) { score = score + 1; };
       30:  454:		if (state->deck[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  455:	}
        -:  456:
        3:  457:	return score;
        -:  458:}
        -:  459:
    #####:  460:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  461:	int i;
        -:  462:	int j;
        -:  463:	int highScore;
        -:  464:	int currentPlayer;
        -:  465:
        -:  466:	//get score for each player
    #####:  467:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  468:	{
        -:  469:		//set unused player scores to -9999
    #####:  470:		if (i >= state->numPlayers)
        -:  471:		{
    #####:  472:			players[i] = -9999;
        -:  473:		}
        -:  474:		else
        -:  475:		{
    #####:  476:			players[i] = scoreFor(i, state);
        -:  477:		}
        -:  478:	}
        -:  479:
        -:  480:	//find highest score
    #####:  481:	j = 0;
    #####:  482:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  483:	{
    #####:  484:		if (players[i] > players[j])
        -:  485:		{
    #####:  486:			j = i;
        -:  487:		}
        -:  488:	}
    #####:  489:	highScore = players[j];
        -:  490:
        -:  491:	//add 1 to players who had less turns
    #####:  492:	currentPlayer = whoseTurn(state);
    #####:  493:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  494:	{
    #####:  495:		if (players[i] == highScore && i > currentPlayer)
        -:  496:		{
    #####:  497:			players[i]++;
        -:  498:		}
        -:  499:	}
        -:  500:
        -:  501:	//find new highest score
    #####:  502:	j = 0;
    #####:  503:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  504:	{
    #####:  505:		if (players[i] > players[j])
        -:  506:		{
    #####:  507:			j = i;
        -:  508:		}
        -:  509:	}
    #####:  510:	highScore = players[j];
        -:  511:
        -:  512:	//set winners in array to 1 and rest to 0
    #####:  513:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  514:	{
    #####:  515:		if (players[i] == highScore)
        -:  516:		{
    #####:  517:			players[i] = 1;
        -:  518:		}
        -:  519:		else
        -:  520:		{
    #####:  521:			players[i] = 0;
        -:  522:		}
        -:  523:	}
        -:  524:
    #####:  525:	return 0;
        -:  526:}
        -:  527:
      709:  528:int drawCard(int player, struct gameState *state)
        -:  529:{
        -:  530:	int count;
        -:  531:	int deckCounter;
      709:  532:	if (state->deckCount[player] <= 0){//Deck is empty
        -:  533:
        -:  534:		//Step 1 Shuffle the discard pile back into a deck
        -:  535:		int i;
        -:  536:		//Move discard to deck
      798:  537:		for (i = 0; i < state->discardCount[player]; i++){
      756:  538:			state->deck[player][i] = state->discard[player][i];
      756:  539:			state->discard[player][i] = -1;
        -:  540:		}
        -:  541:
       42:  542:		state->deckCount[player] = state->discardCount[player];
       42:  543:		state->discardCount[player] = 0;//Reset discard
        -:  544:
        -:  545:		//Shufffle the deck
       42:  546:		shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  547:
        -:  548:		if (DEBUG){//Debug statements
        -:  549:			printf("Deck count now: %d\n", state->deckCount[player]);
        -:  550:		}
        -:  551:
       42:  552:		state->discardCount[player] = 0;
        -:  553:
        -:  554:		//Step 2 Draw Card
       42:  555:		count = state->handCount[player];//Get current player's hand count
        -:  556:
        -:  557:		if (DEBUG){//Debug statements
        -:  558:			printf("Current hand count: %d\n", count);
        -:  559:		}
        -:  560:
       42:  561:		deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  562:
       42:  563:		if (deckCounter == 0)
    #####:  564:			return -1;
        -:  565:
       42:  566:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
       42:  567:		state->deckCount[player]--;
       42:  568:		state->handCount[player]++;//Increment hand count
        -:  569:	}
        -:  570:
        -:  571:	else{
      667:  572:		int count = state->handCount[player];//Get current hand count for player
        -:  573:		int deckCounter;
        -:  574:		if (DEBUG){//Debug statements
        -:  575:			printf("Current hand count: %d\n", count);
        -:  576:		}
        -:  577:
      667:  578:		deckCounter = state->deckCount[player];//Create holder for the deck count
      667:  579:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
      667:  580:		state->deckCount[player]--;
      667:  581:		state->handCount[player]++;//Increment hand count
        -:  582:	}
        -:  583:
      709:  584:	return 0;
        -:  585:}
        -:  586:
      578:  587:int getCost(int cardNumber)
        -:  588:{
      578:  589:	switch (cardNumber)
        -:  590:	{
        -:  591:	case curse:
       41:  592:		return 0;
        -:  593:	case estate:
       23:  594:		return 2;
        -:  595:	case duchy:
       26:  596:		return 5;
        -:  597:	case province:
       17:  598:		return 8;
        -:  599:	case copper:
       68:  600:		return 0;
        -:  601:	case silver:
       34:  602:		return 3;
        -:  603:	case gold:
       27:  604:		return 6;
        -:  605:	case adventurer:
    #####:  606:		return 6;
        -:  607:	case council_room:
    #####:  608:		return 5;
        -:  609:	case feast:
       32:  610:		return 4;
        -:  611:	case gardens:
    #####:  612:		return 4;
        -:  613:	case mine:
    #####:  614:		return 5;
        -:  615:	case remodel:
    #####:  616:		return 4;
        -:  617:	case smithy:
       44:  618:		return 4;
        -:  619:	case village:
    #####:  620:		return 3;
        -:  621:	case baron:
       37:  622:		return 4;
        -:  623:	case great_hall:
    #####:  624:		return 3;
        -:  625:	case minion:
    #####:  626:		return 5;
        -:  627:	case steward:
       44:  628:		return 3;
        -:  629:	case tribute:
       22:  630:		return 5;
        -:  631:	case ambassador:
    #####:  632:		return 3;
        -:  633:	case cutpurse:
       44:  634:		return 4;
        -:  635:	case embargo:
    #####:  636:		return 2;
        -:  637:	case outpost:
       33:  638:		return 5;
        -:  639:	case salvager:
       29:  640:		return 4;
        -:  641:	case sea_hag:
       32:  642:		return 4;
        -:  643:	case treasure_map:
       25:  644:		return 4;
        -:  645:	}
        -:  646:
    #####:  647:	return -1;
        -:  648:}
        -:  649:
    #####:  650:void playAdventurer(struct gameState *state, int currentPlayer)
        -:  651:// Reveal cards from deck until 2 Treasure cards are found.  Put those Treasure cards in the hand and discard the rest.
        -:  652:{
    #####:  653:	int drawntreasure = 0;
        -:  654:	int temphand[MAX_HAND];
        -:  655:	int cardDrawn;
    #####:  656:	int z = 0; // this is the counter for the temp hand
        -:  657:
    #####:  658:	while (drawntreasure < 2){
    #####:  659:		if (state->deckCount[currentPlayer] < 1){//if the deck is empty we need to shuffle discard and add to deck
    #####:  660:			shuffle(currentPlayer, state);
        -:  661:		}
    #####:  662:		drawCard(currentPlayer, state);
    #####:  663:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer] - 1];//top card of hand is most recently drawn card.
    #####:  664:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
    #####:  665:			drawntreasure++;
        -:  666:		else{
    #####:  667:			temphand[z] = cardDrawn;
    #####:  668:			state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####:  669:			z++;
        -:  670:		}
        -:  671:	}
    #####:  672:	while (z - 1 >= 0){
    #####:  673:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; // discard all cards in play that have been drawn
    #####:  674:		z = z - 1;
        -:  675:	}
    #####:  676:}
        -:  677:
    #####:  678:int playRemodel(struct gameState *state, int currentPlayer, int choice1, int choice2, int handPos)
        -:  679://Trash a card in the hand, and gain a card costing up to $2 more than the trashed card
        -:  680:{
        -:  681:	int i;
    #####:  682:	int j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  683:
    #####:  684:	if ((getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2))
        -:  685:	{
    #####:  686:		return -1;
        -:  687:	}
        -:  688:
    #####:  689:	gainCard(choice2, state, 0, currentPlayer);
        -:  690:
        -:  691:	//discard card from hand
    #####:  692:	discardCard(handPos, currentPlayer, state, 0);
        -:  693:
        -:  694:	//discard trashed card
    #####:  695:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  696:	{
    #####:  697:		if (state->hand[currentPlayer][i] == j)
        -:  698:		{
    #####:  699:			discardCard(i, currentPlayer, state, 0);
    #####:  700:			break;
        -:  701:		}
        -:  702:	}
        -:  703:
    #####:  704:	return 0;
        -:  705:}
        -:  706:
        3:  707:void playSmithy(struct gameState *state, int currentPlayer, int handPos)
        -:  708:// Draw 3 cards
        -:  709:{
        -:  710:	int i;
       12:  711:	for (i = 0; i < 3; i++)
        -:  712:	{
        9:  713:		drawCard(currentPlayer, state);
        -:  714:	}
        -:  715:
        -:  716:	//discard card from hand
        3:  717:	discardCard(handPos, currentPlayer, state, 0);
        3:  718:}
        -:  719:
       12:  720:void playBaron(struct gameState *state, int currentPlayer, int choice1, int handPos)
        -:  721://Add a buy.  OPTION:  Discard an Estate card and gain $4.  Otherwise, gain an Estate card.
        -:  722:{
       12:  723:	state->numBuys++;//Increase buys by 1!
       12:  724:	if (choice1 > 0){//Boolean true or going to discard an estate
       12:  725:		int p = 0;//Iterator for hand!
       12:  726:		int card_not_discarded = 1;//Flag for discard set!
       63:  727:		while (card_not_discarded){
       39:  728:			if (state->hand[currentPlayer][p] == estate){ //Found an estate card!
       10:  729:				state->coins += 4;//Add 4 coins to the amount of coins
       10:  730:				state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
       10:  731:				state->discardCount[currentPlayer]++;
       45:  732:				for (; p < state->handCount[currentPlayer]; p++){
       35:  733:					state->hand[currentPlayer][p] = state->hand[currentPlayer][p + 1];
        -:  734:				}
       10:  735:				state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
       10:  736:				state->handCount[currentPlayer]--;
       10:  737:				card_not_discarded = 0;//Exit the loop
        -:  738:			}
       29:  739:			else if (p > state->handCount[currentPlayer]){
        -:  740:				if (DEBUG) {
        -:  741:					printf("No estate cards in your hand, invalid choice\n");
        -:  742:					printf("Must gain an estate if there are any\n");
        -:  743:				}
        2:  744:				if (supplyCount(estate, state) > 0){
        1:  745:					gainCard(estate, state, 1, currentPlayer);
        1:  746:					state->supplyCount[estate]--;//Decrement estates
        1:  747:					if (supplyCount(estate, state) == 0){
    #####:  748:						isGameOver(state);
        -:  749:					}
        -:  750:				}
        2:  751:				card_not_discarded = 0;//Exit the loop
        -:  752:			}
        -:  753:
        -:  754:			else{
       27:  755:				p++;//Next card
        -:  756:			}
        -:  757:		}
        -:  758:	}
        -:  759:
        -:  760:	else{
    #####:  761:		if (supplyCount(estate, state) > 0){
    #####:  762:			gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  763:			state->supplyCount[estate]--;//Decrement Estates
    #####:  764:			if (supplyCount(estate, state) == 0){
    #####:  765:				isGameOver(state);
        -:  766:			}
        -:  767:		}
        -:  768:	}
       12:  769:}
        -:  770:
        1:  771:int playTreasureMap(struct gameState *state, int currentPlayer, int handPos)
        -:  772://Trashing two treasure map cards from the hand = four gold on top of the deck.
        -:  773:{
        -:  774:	int i;
        -:  775:	int index;
        -:  776:
        -:  777:	//search hand for another treasure_map
        6:  778:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  779:	{
        5:  780:		if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -:  781:		{
    #####:  782:			index = i;
    #####:  783:			break;
        -:  784:		}
        -:  785:	}
        1:  786:	if (index > -1)
        -:  787:	{
        -:  788:		//trash both treasure cards
        1:  789:		discardCard(handPos, currentPlayer, state, 1);
        1:  790:		discardCard(index, currentPlayer, state, 1);
        -:  791:
        -:  792:		//gain 4 Gold cards
        5:  793:		for (i = 0; i < 4; i++)
        -:  794:		{
        4:  795:			gainCard(gold, state, 1, currentPlayer);
        -:  796:		}
        -:  797:
        -:  798:		//return success
        1:  799:		return 1;
        -:  800:	}
        -:  801:
        -:  802:	//no second treasure_map found in hand
    #####:  803:	return -1;
        -:  804:}
        -:  805:
       41:  806:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  807:{
        -:  808:	int i;
        -:  809:	int j;
        -:  810:	int k;
        -:  811:	//int x;  //Unused after while loop removed from feast.
       41:  812:	int currentPlayer = whoseTurn(state);
       41:  813:	int nextPlayer = currentPlayer + 1;
        -:  814:	int temphand[MAX_HAND];
        -:  815:
       41:  816:	int tributeRevealedCards[2] = { -1, -1 };
        -:  817:
       41:  818:	if (nextPlayer > (state->numPlayers - 1)){
       10:  819:		nextPlayer = 0;
        -:  820:	}
        -:  821:
        -:  822:	//uses switch to select card and perform actions
       41:  823:	switch (card)
        -:  824:	{
        -:  825:	case adventurer:
        -:  826:
    #####:  827:		playAdventurer(state, currentPlayer);
    #####:  828:		return 0;
        -:  829:
        -:  830:	case council_room:
        -:  831:		//+4 Cards
    #####:  832:		for (i = 0; i < 4; i++)
        -:  833:		{
    #####:  834:			drawCard(currentPlayer, state);
        -:  835:		}
        -:  836:
        -:  837:		//+1 Buy
    #####:  838:		state->numBuys++;
        -:  839:
        -:  840:		//Each other player draws a card
    #####:  841:		for (i = 0; i < state->numPlayers; i++)
        -:  842:		{
    #####:  843:			if (i != currentPlayer)
        -:  844:			{
    #####:  845:				drawCard(i, state);
        -:  846:			}
        -:  847:		}
        -:  848:
        -:  849:		//put played card in played card pile
    #####:  850:		discardCard(handPos, currentPlayer, state, 0);
        -:  851:
    #####:  852:		return 0;
        -:  853:
        -:  854:	case feast:
        -:  855:		//gain card with cost up to 5
        -:  856:		//Backup hand
       42:  857:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
       36:  858:			temphand[i] = state->hand[currentPlayer][i];//Backup card
       36:  859:			state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  860:		}
        -:  861:		//Backup hand
        -:  862:
        -:  863:		//Update Coins for Buy
        6:  864:		updateCoins(currentPlayer, state, 5);
        -:  865://		x = 1;//Condition to loop on
        -:  866://		while (x == 1) {//Buy one card
        6:  867:			if (supplyCount(choice1, state) <= 0){
        -:  868:				if (DEBUG)
        -:  869:					printf("None of that card left, sorry!\n");
        -:  870:
        -:  871:				if (DEBUG){
        -:  872:					printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  873:				}
        -:  874:			}
        3:  875:			else if (state->coins < getCost(choice1)){
    #####:  876:				printf("That card is too expensive!\n");
        -:  877:
        -:  878:				if (DEBUG){
        -:  879:					printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  880:				}
        -:  881:			}
        -:  882:			else{
        -:  883:
        -:  884:				if (DEBUG){
        -:  885:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  886:				}
        -:  887:
        3:  888:				gainCard(choice1, state, 0, currentPlayer);//Gain the card
        -:  889://				x = 0;//No more buying cards
        -:  890:
        -:  891:				if (DEBUG){
        -:  892:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  893:				}
        -:  894:
        -:  895:			}
        -:  896://		}
        -:  897:
        -:  898:		//Reset Hand
       42:  899:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
       36:  900:			state->hand[currentPlayer][i] = temphand[i];
       36:  901:			temphand[i] = -1;
        -:  902:		}
        -:  903:		//Reset Hand
        -:  904:
        6:  905:		return 0;
        -:  906:
        -:  907:	case gardens:
    #####:  908:		return -1;
        -:  909:
        -:  910:	case mine:
    #####:  911:		j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  912:
    #####:  913:		if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  914:		{
    #####:  915:			return -1;
        -:  916:		}
        -:  917:
    #####:  918:		if (choice2 > treasure_map || choice2 < curse)
        -:  919:		{
    #####:  920:			return -1;
        -:  921:		}
        -:  922:
    #####:  923:		if ((getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2))
        -:  924:		{
    #####:  925:			return -1;
        -:  926:		}
        -:  927:
    #####:  928:		gainCard(choice2, state, 2, currentPlayer);
        -:  929:
        -:  930:		//discard card from hand
    #####:  931:		discardCard(handPos, currentPlayer, state, 0);
        -:  932:
        -:  933:		//discard trashed card
    #####:  934:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  935:		{
    #####:  936:			if (state->hand[currentPlayer][i] == j)
        -:  937:			{
    #####:  938:				discardCard(i, currentPlayer, state, 0);
    #####:  939:				break;
        -:  940:			}
        -:  941:		}
        -:  942:
    #####:  943:		return 0;
        -:  944:
        -:  945:	case remodel:
        -:  946:
    #####:  947:		return playRemodel(state, currentPlayer, choice1, choice2, handPos);
        -:  948:
        -:  949:	case smithy:
        -:  950:
        3:  951:		playSmithy(state, currentPlayer, handPos);
        3:  952:		return 0;
        -:  953:
        -:  954:	case village:
        -:  955:		//+1 Card
    #####:  956:		drawCard(currentPlayer, state);
        -:  957:
        -:  958:		//+2 Actions
    #####:  959:		state->numActions = state->numActions + 2;
        -:  960:
        -:  961:		//discard played card from hand
    #####:  962:		discardCard(handPos, currentPlayer, state, 0);
    #####:  963:		return 0;
        -:  964:
        -:  965:	case baron:
        -:  966:
       12:  967:		playBaron(state, currentPlayer, choice1, handPos);
       12:  968:		return 0;
        -:  969:
        -:  970:	case great_hall:
        -:  971:		//+1 Card
    #####:  972:		drawCard(currentPlayer, state);
        -:  973:
        -:  974:		//+1 Actions
    #####:  975:		state->numActions++;
        -:  976:
        -:  977:		//discard card from hand
    #####:  978:		discardCard(handPos, currentPlayer, state, 0);
    #####:  979:		return 0;
        -:  980:
        -:  981:	case minion:
        -:  982:		//+1 action
    #####:  983:		state->numActions++;
        -:  984:
        -:  985:		//discard card from hand
    #####:  986:		discardCard(handPos, currentPlayer, state, 0);
        -:  987:
    #####:  988:		if (choice1)		//+2 coins
        -:  989:		{
    #####:  990:			state->coins = state->coins + 2;
        -:  991:		}
        -:  992:
    #####:  993:		else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  994:		{
        -:  995:			//discard hand
    #####:  996:			while (numHandCards(state) > 0)
        -:  997:			{
    #####:  998:				discardCard(handPos, currentPlayer, state, 0);
        -:  999:			}
        -: 1000:
        -: 1001:			//draw 4
    #####: 1002:			for (i = 0; i < 4; i++)
        -: 1003:			{
    #####: 1004:				drawCard(currentPlayer, state);
        -: 1005:			}
        -: 1006:
        -: 1007:			//other players discard hand and redraw if hand size > 4
    #####: 1008:			for (i = 0; i < state->numPlayers; i++)
        -: 1009:			{
    #####: 1010:				if (i != currentPlayer)
        -: 1011:				{
    #####: 1012:					if (state->handCount[i] > 4)
        -: 1013:					{
        -: 1014:						//discard hand
    #####: 1015:						while (state->handCount[i] > 0)
        -: 1016:						{
    #####: 1017:							discardCard(handPos, i, state, 0);
        -: 1018:						}
        -: 1019:
        -: 1020:						//draw 4
    #####: 1021:						for (j = 0; j < 4; j++)
        -: 1022:						{
    #####: 1023:							drawCard(i, state);
        -: 1024:						}
        -: 1025:					}
        -: 1026:				}
        -: 1027:			}
        -: 1028:
        -: 1029:		}
    #####: 1030:		return 0;
        -: 1031:
        -: 1032:	case steward:
        7: 1033:		if (choice1 == 1)
        -: 1034:		{
        -: 1035:			//+2 cards
    #####: 1036:			drawCard(currentPlayer, state);
    #####: 1037:			drawCard(currentPlayer, state);
        -: 1038:		}
        7: 1039:		else if (choice1 == 2)
        -: 1040:		{
        -: 1041:			//+2 coins
        1: 1042:			state->coins = state->coins + 2;
        -: 1043:		}
        -: 1044:		else
        -: 1045:		{
        -: 1046:			//trash 2 cards in hand
        6: 1047:			discardCard(choice2, currentPlayer, state, 1);
        6: 1048:			discardCard(choice3, currentPlayer, state, 1);
        -: 1049:		}
        -: 1050:
        -: 1051:		//discard card from hand
        7: 1052:		discardCard(handPos, currentPlayer, state, 0);
        7: 1053:		return 0;
        -: 1054:
        -: 1055:	case tribute:
    #####: 1056:		if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####: 1057:			if (state->deckCount[nextPlayer] > 0){
    #####: 1058:				tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1059:				state->deckCount[nextPlayer]--;
        -: 1060:			}
    #####: 1061:			else if (state->discardCount[nextPlayer] > 0){
    #####: 1062:				tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer] - 1];
    #####: 1063:				state->discardCount[nextPlayer]--;
        -: 1064:			}
        -: 1065:			else{
        -: 1066:				//No Card to Reveal
        -: 1067:				if (DEBUG){
        -: 1068:					printf("No cards to reveal\n");
        -: 1069:				}
        -: 1070:			}
        -: 1071:		}
        -: 1072:
        -: 1073:		else{
    #####: 1074:			if (state->deckCount[nextPlayer] == 0){
    #####: 1075:				for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####: 1076:					state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1077:					state->deckCount[nextPlayer]++;
    #####: 1078:					state->discard[nextPlayer][i] = -1;
    #####: 1079:					state->discardCount[nextPlayer]--;
        -: 1080:				}
        -: 1081:
    #####: 1082:				shuffle(nextPlayer, state);//Shuffle the deck
        -: 1083:			}
    #####: 1084:			tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1085:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1086:			state->deckCount[nextPlayer]--;
    #####: 1087:			tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1088:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1089:			state->deckCount[nextPlayer]--;
        -: 1090:		}
        -: 1091:
    #####: 1092:		if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
    #####: 1093:			state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1094:			state->playedCardCount++;
    #####: 1095:			tributeRevealedCards[1] = -1;
        -: 1096:		}
        -: 1097:
    #####: 1098:		for (i = 0; i <= 2; i++){
    #####: 1099:			if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
    #####: 1100:				state->coins += 2;
        -: 1101:			}
        -: 1102:
    #####: 1103:			else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
    #####: 1104:				drawCard(currentPlayer, state);
    #####: 1105:				drawCard(currentPlayer, state);
        -: 1106:			}
        -: 1107:			else{//Action Card
    #####: 1108:				state->numActions = state->numActions + 2;
        -: 1109:			}
        -: 1110:		}
        -: 1111:
    #####: 1112:		return 0;
        -: 1113:
        -: 1114:	case ambassador:
    #####: 1115:		j = 0;		//used to check if player has enough cards to discard
        -: 1116:
    #####: 1117:		if (choice2 > 2 || choice2 < 0)
        -: 1118:		{
    #####: 1119:			return -1;
        -: 1120:		}
        -: 1121:
    #####: 1122:		if (choice1 == handPos)
        -: 1123:		{
    #####: 1124:			return -1;
        -: 1125:		}
        -: 1126:
    #####: 1127:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1128:		{
    #####: 1129:			if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1130:			{
    #####: 1131:				j++;
        -: 1132:			}
        -: 1133:		}
    #####: 1134:		if (j < choice2)
        -: 1135:		{
    #####: 1136:			return -1;
        -: 1137:		}
        -: 1138:
        -: 1139:		if (DEBUG)
        -: 1140:			printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1141:
        -: 1142:		//increase supply count for choosen card by amount being discarded
    #####: 1143:		state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1144:
        -: 1145:		//each other player gains a copy of revealed card
    #####: 1146:		for (i = 0; i < state->numPlayers; i++)
        -: 1147:		{
    #####: 1148:			if (i != currentPlayer)
        -: 1149:			{
    #####: 1150:				gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1151:			}
        -: 1152:		}
        -: 1153:
        -: 1154:		//discard played card from hand
    #####: 1155:		discardCard(handPos, currentPlayer, state, 0);
        -: 1156:
        -: 1157:		//trash copies of cards returned to supply
    #####: 1158:		for (j = 0; j < choice2; j++)
        -: 1159:		{
    #####: 1160:			for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1161:			{
    #####: 1162:				if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1163:				{
    #####: 1164:					discardCard(i, currentPlayer, state, 1);
    #####: 1165:					break;
        -: 1166:				}
        -: 1167:			}
        -: 1168:		}
        -: 1169:
    #####: 1170:		return 0;
        -: 1171:
        -: 1172:	case cutpurse:
        -: 1173:
        7: 1174:		updateCoins(currentPlayer, state, 2);
       28: 1175:		for (i = 0; i < state->numPlayers; i++)
        -: 1176:		{
       21: 1177:			if (i != currentPlayer)
        -: 1178:			{
       14: 1179:				for (j = 0; j < state->handCount[i]; j++)
        -: 1180:				{
    #####: 1181:					if (state->hand[i][j] == copper)
        -: 1182:					{
    #####: 1183:						discardCard(j, i, state, 0);
    #####: 1184:						break;
        -: 1185:					}
    #####: 1186:					if (j == state->handCount[i])
        -: 1187:					{
    #####: 1188:						for (k = 0; k < state->handCount[i]; k++)
        -: 1189:						{
        -: 1190:							if (DEBUG)
        -: 1191:								printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1192:						}
    #####: 1193:						break;
        -: 1194:					}
        -: 1195:				}
        -: 1196:
        -: 1197:			}
        -: 1198:
        -: 1199:		}
        -: 1200:
        -: 1201:		//discard played card from hand
        7: 1202:		discardCard(handPos, currentPlayer, state, 0);
        -: 1203:
        7: 1204:		return 0;
        -: 1205:
        -: 1206:
        -: 1207:	case embargo:
        -: 1208:		//+2 Coins
    #####: 1209:		state->coins = state->coins + 2;
        -: 1210:
        -: 1211:		//see if selected pile is in play
    #####: 1212:		if (state->supplyCount[choice1] == -1)
        -: 1213:		{
    #####: 1214:			return -1;
        -: 1215:		}
        -: 1216:
        -: 1217:		//add embargo token to selected supply pile
    #####: 1218:		state->embargoTokens[choice1]++;
        -: 1219:
        -: 1220:		//trash card
    #####: 1221:		discardCard(handPos, currentPlayer, state, 1);
    #####: 1222:		return 0;
        -: 1223:
        -: 1224:	case outpost:
        -: 1225:		//set outpost flag
    #####: 1226:		state->outpostPlayed++;
        -: 1227:
        -: 1228:		//discard card
    #####: 1229:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1230:		return 0;
        -: 1231:
        -: 1232:	case salvager:
        -: 1233:		//+1 buy
        1: 1234:		state->numBuys++;
        -: 1235:
        1: 1236:		if (choice1)
        -: 1237:		{
        -: 1238:			//gain coins equal to trashed card
        1: 1239:			state->coins = state->coins + getCost(handCard(choice1, state));
        -: 1240:			//trash card
        1: 1241:			discardCard(choice1, currentPlayer, state, 1);
        -: 1242:		}
        -: 1243:
        -: 1244:		//discard card
        1: 1245:		discardCard(handPos, currentPlayer, state, 0);
        1: 1246:		return 0;
        -: 1247:
        -: 1248:	case sea_hag:
       16: 1249:		for (i = 0; i < state->numPlayers; i++){
       12: 1250:			if (i != currentPlayer){
        8: 1251:				state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
        8: 1252:				state->discardCount[i]++;
        8: 1253:				state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1254:			}
        -: 1255:		}
        4: 1256:		return 0;
        -: 1257:
        -: 1258:	case treasure_map:
        -: 1259:
        1: 1260:		return playTreasureMap(state, currentPlayer, handPos);
        -: 1261:	}
    #####: 1262:	return -1;
        -: 1263:}
        -: 1264:
       33: 1265:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1266:{
        -: 1267:
        -: 1268:	//if card is not trashed, added to Played pile 
       33: 1269:	if (trashFlag < 1)
        -: 1270:	{
        -: 1271:		//add card to played pile
       18: 1272:		state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
       18: 1273:		state->playedCardCount++;
        -: 1274:	}
        -: 1275:
        -: 1276:	//set played card to -1
       33: 1277:	state->hand[currentPlayer][handPos] = -1;
        -: 1278:
        -: 1279:	//remove card from player's hand
       33: 1280:	if (handPos == (state->handCount[currentPlayer] - 1)) 	//last card in hand array is played
        -: 1281:	{
        -: 1282:		//reduce number of cards in hand
        2: 1283:		state->handCount[currentPlayer]--;
        -: 1284:	}
       31: 1285:	else if (state->handCount[currentPlayer] == 1) //only one card in hand
        -: 1286:	{
        -: 1287:		//reduce number of cards in hand
    #####: 1288:		state->handCount[currentPlayer]--;
        -: 1289:	}
        -: 1290:	else
        -: 1291:	{
        -: 1292:		//replace discarded card with last card in hand
       31: 1293:		state->hand[currentPlayer][handPos] = state->hand[currentPlayer][(state->handCount[currentPlayer] - 1)];
        -: 1294:		//set last card to -1
       31: 1295:		state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1296:		//reduce number of cards in hand
       31: 1297:		state->handCount[currentPlayer]--;
        -: 1298:	}
        -: 1299:
       33: 1300:	return 0;
        -: 1301:}
        -: 1302:
      112: 1303:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1304:{
        -: 1305:	//Note: supplyPos is enum of choosen card
        -: 1306:
        -: 1307:	//check if supply pile is empty (0) or card is not used in game (-1)
      112: 1308:	if (supplyCount(supplyPos, state) < 1)
        -: 1309:	{
    #####: 1310:		return -1;
        -: 1311:	}
        -: 1312:
        -: 1313:	//added card for [whoseTurn] current player:
        -: 1314:	// toFlag = 0 : add to discard
        -: 1315:	// toFlag = 1 : add to deck
        -: 1316:	// toFlag = 2 : add to hand
        -: 1317:
      112: 1318:	if (toFlag == 1)
        -: 1319:	{
        5: 1320:		state->deck[player][state->deckCount[player]] = supplyPos;
        5: 1321:		state->deckCount[player]++;
        -: 1322:	}
      107: 1323:	else if (toFlag == 2)
        -: 1324:	{
    #####: 1325:		state->hand[player][state->handCount[player]] = supplyPos;
    #####: 1326:		state->handCount[player]++;
        -: 1327:	}
        -: 1328:	else
        -: 1329:	{
      107: 1330:		state->discard[player][state->discardCount[player]] = supplyPos;
      107: 1331:		state->discardCount[player]++;
        -: 1332:	}
        -: 1333:
        -: 1334:	//decrease number in supply pile
      112: 1335:	state->supplyCount[supplyPos]--;
        -: 1336:
      112: 1337:	return 0;
        -: 1338:}
        -: 1339:
      194: 1340:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1341:{
        -: 1342:	int i;
        -: 1343:
        -: 1344:	//reset coin count
      194: 1345:	state->coins = 0;
        -: 1346:
        -: 1347:	//add coins for each Treasure card in player's hand
     1130: 1348:	for (i = 0; i < state->handCount[player]; i++)
        -: 1349:	{
      936: 1350:		if (state->hand[player][i] == copper)
        -: 1351:		{
      419: 1352:			state->coins += 1;
        -: 1353:		}
      517: 1354:		else if (state->hand[player][i] == silver)
        -: 1355:		{
       20: 1356:			state->coins += 2;
        -: 1357:		}
      497: 1358:		else if (state->hand[player][i] == gold)
        -: 1359:		{
        4: 1360:			state->coins += 3;
        -: 1361:		}
        -: 1362:	}
        -: 1363:
        -: 1364:	//add bonus
      194: 1365:	state->coins += bonus;
        -: 1366:
      194: 1367:	return 0;
        -: 1368:}
        -: 1369:
        -: 1370:
        -: 1371://end of dominion.c
File 'dominion.c'
Lines executed:58.35% of 557
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
     1646:    8:int compare(const void* a, const void* b) {
     1646:    9:	if (*(int*)a > *(int*)b)
      541:   10:		return 1;
     1105:   11:	if (*(int*)a < *(int*)b)
      478:   12:		return -1;
      627:   13:	return 0;
        -:   14:}
        -:   15:
        2:   16:struct gameState* newGame() {
        2:   17:	struct gameState* g = malloc(sizeof(struct gameState));
        2:   18:	return g;
        -:   19:}
        -:   20:
        7:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:	int k8, int k9, int k10) {
        7:   23:	int* k = malloc(10 * sizeof(int));
        7:   24:	k[0] = k1;
        7:   25:	k[1] = k2;
        7:   26:	k[2] = k3;
        7:   27:	k[3] = k4;
        7:   28:	k[4] = k5;
        7:   29:	k[5] = k6;
        7:   30:	k[6] = k7;
        7:   31:	k[7] = k8;
        7:   32:	k[8] = k9;
        7:   33:	k[9] = k10;
        7:   34:	return k;
        -:   35:}
        -:   36:
        7:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		struct gameState *state) {
        -:   39:
        -:   40:	int i;
        -:   41:	int j;
        -:   42:	int it;
        -:   43:	//set up random number generator
        7:   44:	SelectStream(1);
        7:   45:	PutSeed((long)randomSeed);
        -:   46:
        -:   47:	//check number of players
        7:   48:	if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:	{
    #####:   50:		return -1;
        -:   51:	}
        -:   52:
        -:   53:	//set number of players
        7:   54:	state->numPlayers = numPlayers;
        -:   55:
        -:   56:	//check selected kingdom cards are different
       20:   57:	for (i = 0; i < 10; i++)
        -:   58:	{
      177:   59:		for (j = 0; j < 10; j++)
        -:   60:		{
      164:   61:			if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:			{
        6:   63:				return -1;
        -:   64:			}
        -:   65:		}
        -:   66:	}
        -:   67:
        -:   68:
        -:   69:	//initialize supply
        -:   70:	///////////////////////////////
        -:   71:
        -:   72:	//set number of Curse cards
        1:   73:	if (numPlayers == 2)
        -:   74:	{
    #####:   75:		state->supplyCount[curse] = 10;
        -:   76:	}
        1:   77:	else if (numPlayers == 3)
        -:   78:	{
    #####:   79:		state->supplyCount[curse] = 20;
        -:   80:	}
        -:   81:	else
        -:   82:	{
        1:   83:		state->supplyCount[curse] = 30;
        -:   84:	}
        -:   85:
        -:   86:	//set number of Victory cards
        1:   87:	if (numPlayers == 2)
        -:   88:	{
    #####:   89:		state->supplyCount[estate] = 8;
    #####:   90:		state->supplyCount[duchy] = 8;
    #####:   91:		state->supplyCount[province] = 8;
        -:   92:	}
        -:   93:	else
        -:   94:	{
        1:   95:		state->supplyCount[estate] = 12;
        1:   96:		state->supplyCount[duchy] = 12;
        1:   97:		state->supplyCount[province] = 12;
        -:   98:	}
        -:   99:
        -:  100:	//set number of Treasure cards
        1:  101:	state->supplyCount[copper] = 60 - (7 * numPlayers);
        1:  102:	state->supplyCount[silver] = 40;
        1:  103:	state->supplyCount[gold] = 30;
        -:  104:
        -:  105:	//set number of Kingdom cards
       21:  106:	for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:	{
      165:  108:		for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:		{
      155:  110:			if (kingdomCards[j] == i)
        -:  111:			{
        -:  112:				//check if card is a 'Victory' Kingdom card
       10:  113:				if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:				{
        2:  115:					if (numPlayers == 2){
    #####:  116:						state->supplyCount[i] = 8;
        -:  117:					}
        1:  118:					else{ state->supplyCount[i] = 12; }
        -:  119:				}
        -:  120:				else
        -:  121:				{
        9:  122:					state->supplyCount[i] = 10;
        -:  123:				}
       10:  124:				break;
        -:  125:			}
        -:  126:			else    //card is not in the set choosen for the game
        -:  127:			{
      145:  128:				state->supplyCount[i] = -1;
        -:  129:			}
        -:  130:		}
        -:  131:
        -:  132:	}
        -:  133:
        -:  134:	////////////////////////
        -:  135:	//supply intilization complete
        -:  136:
        -:  137:	//set player decks
        5:  138:	for (i = 0; i < numPlayers; i++)
        -:  139:	{
        4:  140:		state->deckCount[i] = 0;
       16:  141:		for (j = 0; j < 3; j++)
        -:  142:		{
       12:  143:			state->deck[i][j] = estate;
       12:  144:			state->deckCount[i]++;
        -:  145:		}
       32:  146:		for (j = 3; j < 10; j++)
        -:  147:		{
       28:  148:			state->deck[i][j] = copper;
       28:  149:			state->deckCount[i]++;
        -:  150:		}
        -:  151:	}
        -:  152:
        -:  153:	//shuffle player decks
        5:  154:	for (i = 0; i < numPlayers; i++)
        -:  155:	{
        4:  156:		if (shuffle(i, state) < 0)
        -:  157:		{
    #####:  158:			return -1;
        -:  159:		}
        -:  160:	}
        -:  161:
        -:  162:	//draw player hands
        5:  163:	for (i = 0; i < numPlayers; i++)
        -:  164:	{
        -:  165:		//initialize hand size to zero
        4:  166:		state->handCount[i] = 0;
        4:  167:		state->discardCount[i] = 0;
        -:  168:		//draw 5 cards
        -:  169:		// for (j = 0; j < 5; j++)
        -:  170:		//	{
        -:  171:		//	  drawCard(i, state);
        -:  172:		//	}
        -:  173:	}
        -:  174:
        -:  175:	//set embargo tokens to 0 for all supply piles
       28:  176:	for (i = 0; i <= treasure_map; i++)
        -:  177:	{
       27:  178:		state->embargoTokens[i] = 0;
        -:  179:	}
        -:  180:
        -:  181:	//initialize first player's turn
        1:  182:	state->outpostPlayed = 0;
        1:  183:	state->phase = 0;
        1:  184:	state->numActions = 1;
        1:  185:	state->numBuys = 1;
        1:  186:	state->playedCardCount = 0;
        1:  187:	state->whoseTurn = 0;
        1:  188:	state->handCount[state->whoseTurn] = 0;
        -:  189:	//int it; move to top
        -:  190:
        -:  191:	//Moved draw cards to here, only drawing at the start of a turn
        6:  192:	for (it = 0; it < 5; it++){
        5:  193:		drawCard(state->whoseTurn, state);
        -:  194:	}
        -:  195:
        1:  196:	updateCoins(state->whoseTurn, state, 0);
        -:  197:
        1:  198:	return 0;
        -:  199:}
        -:  200:
       48:  201:int shuffle(int player, struct gameState *state) {
        -:  202:
        -:  203:
        -:  204:	int newDeck[MAX_DECK];
       48:  205:	int newDeckPos = 0;
        -:  206:	int card;
        -:  207:	int i;
        -:  208:
       48:  209:	if (state->deckCount[player] < 1)
    #####:  210:		return -1;
       48:  211:	qsort((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
        -:  212:	/* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
      892:  214:	while (state->deckCount[player] > 0) {
      796:  215:		card = floor(Random() * state->deckCount[player]);
      796:  216:		newDeck[newDeckPos] = state->deck[player][card];
      796:  217:		newDeckPos++;
     4346:  218:		for (i = card; i < state->deckCount[player] - 1; i++) {
     3550:  219:			state->deck[player][i] = state->deck[player][i + 1];
        -:  220:		}
      796:  221:		state->deckCount[player]--;
        -:  222:	}
      844:  223:	for (i = 0; i < newDeckPos; i++) {
      796:  224:		state->deck[player][i] = newDeck[i];
      796:  225:		state->deckCount[player]++;
        -:  226:	}
        -:  227:
       48:  228:	return 0;
        -:  229:}
        -:  230:
      729:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state)
        -:  232:{
        -:  233:	int card;
      729:  234:	int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:	//check if it is the right phase
      729:  237:	if (state->phase != 0)
        -:  238:	{
      109:  239:		return -1;
        -:  240:	}
        -:  241:
        -:  242:	//check if player has enough actions
      620:  243:	if (state->numActions < 1)
        -:  244:	{
       19:  245:		return -1;
        -:  246:	}
        -:  247:
        -:  248:	//get card played
      601:  249:	card = handCard(handPos, state);
        -:  250:
        -:  251:	//check if selected card is an action
      601:  252:	if (card < adventurer || card > treasure_map)
        -:  253:	{
      552:  254:		return -1;
        -:  255:	}
        -:  256:
        -:  257:	//play card
       49:  258:	if (cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0)
        -:  259:	{
        9:  260:		return -1;
        -:  261:	}
        -:  262:
        -:  263:	//reduce number of actions
       40:  264:	state->numActions--;
        -:  265:
        -:  266:	//update coins (Treasure cards may be added with card draws)
       40:  267:	updateCoins(state->whoseTurn, state, coin_bonus);
        -:  268:
       40:  269:	return 0;
        -:  270:}
        -:  271:
      713:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:	int who;
        -:  274:	if (DEBUG){
        -:  275:		printf("Entering buyCard...\n");
        -:  276:	}
        -:  277:
        -:  278:	// I don't know what to do about the phase thing.
        -:  279:
      713:  280:	who = state->whoseTurn;
        -:  281:
      713:  282:	if (state->numBuys < 1){
        -:  283:		if (DEBUG)
        -:  284:			printf("You do not have any buys left\n");
      123:  285:		return -1;
        -:  286:	}
      590:  287:	else if (supplyCount(supplyPos, state) < 1){
        -:  288:		if (DEBUG)
        -:  289:			printf("There are not any of that type of card left\n");
      261:  290:		return -1;
        -:  291:	}
      329:  292:	else if (state->coins < getCost(supplyPos)){
        -:  293:		if (DEBUG)
        -:  294:			printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
      212:  295:		return -1;
        -:  296:	}
        -:  297:	else {
      117:  298:		state->phase = 1;
        -:  299:		//state->supplyCount[supplyPos]--;
      117:  300:		gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  301:
      117:  302:		state->coins = (state->coins) - (getCost(supplyPos));
      117:  303:		state->numBuys--;
        -:  304:		if (DEBUG)
        -:  305:			printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  306:	}
        -:  307:
        -:  308:	//state->discard[who][state->discardCount[who]] = supplyPos;
        -:  309:	//state->discardCount[who]++;
        -:  310:
      117:  311:	return 0;
        -:  312:}
        -:  313:
    #####:  314:int numHandCards(struct gameState *state) {
    #####:  315:	return state->handCount[whoseTurn(state)];
        -:  316:}
        -:  317:
      605:  318:int handCard(int handPos, struct gameState *state) {
      605:  319:	int currentPlayer = whoseTurn(state);
      605:  320:	return state->hand[currentPlayer][handPos];
        -:  321:}
        -:  322:
      722:  323:int supplyCount(int card, struct gameState *state) {
      722:  324:	return state->supplyCount[card];
        -:  325:}
        -:  326:
    #####:  327:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  328:	int i;
    #####:  329:	int count = 0;
        -:  330:
    #####:  331:	for (i = 0; i < state->deckCount[player]; i++)
        -:  332:	{
    #####:  333:		if (state->deck[player][i] == card) count++;
        -:  334:	}
        -:  335:
    #####:  336:	for (i = 0; i < state->handCount[player]; i++)
        -:  337:	{
    #####:  338:		if (state->hand[player][i] == card) count++;
        -:  339:	}
        -:  340:
    #####:  341:	for (i = 0; i < state->discardCount[player]; i++)
        -:  342:	{
    #####:  343:		if (state->discard[player][i] == card) count++;
        -:  344:	}
        -:  345:
    #####:  346:	return count;
        -:  347:}
        -:  348:
      803:  349:int whoseTurn(struct gameState *state) {
      803:  350:	return state->whoseTurn;
        -:  351:}
        -:  352:
      149:  353:int endTurn(struct gameState *state) {
        -:  354:	int k;
        -:  355:	int i;
      149:  356:	int currentPlayer = whoseTurn(state);
        -:  357:
        -:  358:	//Discard hand
      870:  359:	for (i = 0; i < state->handCount[currentPlayer]; i++){
      721:  360:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
      721:  361:		state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  362:	}
      149:  363:	state->handCount[currentPlayer] = 0;//Reset hand count
        -:  364:
        -:  365:	//Code for determining the player
      149:  366:	if (currentPlayer < (state->numPlayers - 1)){
      112:  367:		state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  368:	}
        -:  369:	else{
       37:  370:		state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  371:	}
        -:  372:
      149:  373:	state->outpostPlayed = 0;
      149:  374:	state->phase = 0;
      149:  375:	state->numActions = 1;
      149:  376:	state->coins = 0;
      149:  377:	state->numBuys = 1;
      149:  378:	state->playedCardCount = 0;
      149:  379:	state->handCount[state->whoseTurn] = 0;
        -:  380:
        -:  381:	//int k; move to top
        -:  382:	//Next player draws hand
      894:  383:	for (k = 0; k < 5; k++){
      745:  384:		drawCard(state->whoseTurn, state);//Draw a card
        -:  385:	}
        -:  386:
        -:  387:	//Update money
      149:  388:	updateCoins(state->whoseTurn, state, 0);
        -:  389:
      149:  390:	return 0;
        -:  391:}
        -:  392:
     2176:  393:int isGameOver(struct gameState *state) {
        -:  394:	int i;
        -:  395:	int j;
        -:  396:
        -:  397:	//if stack of Province cards is empty, the game ends
     2176:  398:	if (state->supplyCount[province] == 0)
        -:  399:	{
    #####:  400:		return 1;
        -:  401:	}
        -:  402:
        -:  403:	//if three supply pile are at 0, the game ends
     2176:  404:	j = 0;
    56576:  405:	for (i = 0; i < 25; i++)
        -:  406:	{
    54400:  407:		if (state->supplyCount[i] == 0)
        -:  408:		{
     2647:  409:			j++;
        -:  410:		}
        -:  411:	}
     2176:  412:	if (j >= 3)
        -:  413:	{
        1:  414:		return 1;
        -:  415:	}
        -:  416:
     2175:  417:	return 0;
        -:  418:}
        -:  419:
        4:  420:int scoreFor(int player, struct gameState *state) {
        -:  421:
        -:  422:	int i;
        4:  423:	int score = 0;
        -:  424:	//score from hand
        9:  425:	for (i = 0; i < state->handCount[player]; i++)
        -:  426:	{
        5:  427:		if (state->hand[player][i] == curse) { score = score - 1; };
        5:  428:		if (state->hand[player][i] == estate) { score = score + 1; };
        5:  429:		if (state->hand[player][i] == duchy) { score = score + 3; };
        5:  430:		if (state->hand[player][i] == province) { score = score + 6; };
        5:  431:		if (state->hand[player][i] == great_hall) { score = score + 1; };
        5:  432:		if (state->hand[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  433:	}
        -:  434:
        -:  435:	//score from discard
       92:  436:	for (i = 0; i < state->discardCount[player]; i++)
        -:  437:	{
       88:  438:		if (state->discard[player][i] == curse) { score = score - 1; };
       88:  439:		if (state->discard[player][i] == estate) { score = score + 1; };
       88:  440:		if (state->discard[player][i] == duchy) { score = score + 3; };
       88:  441:		if (state->discard[player][i] == province) { score = score + 6; };
       88:  442:		if (state->discard[player][i] == great_hall) { score = score + 1; };
       88:  443:		if (state->discard[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  444:	}
        -:  445:
        -:  446:	//score from deck
       92:  447:	for (i = 0; i < state->discardCount[player]; i++)
        -:  448:	{
       88:  449:		if (state->deck[player][i] == curse) { score = score - 1; };
       88:  450:		if (state->deck[player][i] == estate) { score = score + 1; };
       88:  451:		if (state->deck[player][i] == duchy) { score = score + 3; };
       88:  452:		if (state->deck[player][i] == province) { score = score + 6; };
       88:  453:		if (state->deck[player][i] == great_hall) { score = score + 1; };
       88:  454:		if (state->deck[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  455:	}
        -:  456:
        4:  457:	return score;
        -:  458:}
        -:  459:
    #####:  460:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  461:	int i;
        -:  462:	int j;
        -:  463:	int highScore;
        -:  464:	int currentPlayer;
        -:  465:
        -:  466:	//get score for each player
    #####:  467:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  468:	{
        -:  469:		//set unused player scores to -9999
    #####:  470:		if (i >= state->numPlayers)
        -:  471:		{
    #####:  472:			players[i] = -9999;
        -:  473:		}
        -:  474:		else
        -:  475:		{
    #####:  476:			players[i] = scoreFor(i, state);
        -:  477:		}
        -:  478:	}
        -:  479:
        -:  480:	//find highest score
    #####:  481:	j = 0;
    #####:  482:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  483:	{
    #####:  484:		if (players[i] > players[j])
        -:  485:		{
    #####:  486:			j = i;
        -:  487:		}
        -:  488:	}
    #####:  489:	highScore = players[j];
        -:  490:
        -:  491:	//add 1 to players who had less turns
    #####:  492:	currentPlayer = whoseTurn(state);
    #####:  493:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  494:	{
    #####:  495:		if (players[i] == highScore && i > currentPlayer)
        -:  496:		{
    #####:  497:			players[i]++;
        -:  498:		}
        -:  499:	}
        -:  500:
        -:  501:	//find new highest score
    #####:  502:	j = 0;
    #####:  503:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  504:	{
    #####:  505:		if (players[i] > players[j])
        -:  506:		{
    #####:  507:			j = i;
        -:  508:		}
        -:  509:	}
    #####:  510:	highScore = players[j];
        -:  511:
        -:  512:	//set winners in array to 1 and rest to 0
    #####:  513:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  514:	{
    #####:  515:		if (players[i] == highScore)
        -:  516:		{
    #####:  517:			players[i] = 1;
        -:  518:		}
        -:  519:		else
        -:  520:		{
    #####:  521:			players[i] = 0;
        -:  522:		}
        -:  523:	}
        -:  524:
    #####:  525:	return 0;
        -:  526:}
        -:  527:
      762:  528:int drawCard(int player, struct gameState *state)
        -:  529:{
        -:  530:	int count;
        -:  531:	int deckCounter;
      762:  532:	if (state->deckCount[player] <= 0){//Deck is empty
        -:  533:
        -:  534:		//Step 1 Shuffle the discard pile back into a deck
        -:  535:		int i;
        -:  536:		//Move discard to deck
      800:  537:		for (i = 0; i < state->discardCount[player]; i++){
      756:  538:			state->deck[player][i] = state->discard[player][i];
      756:  539:			state->discard[player][i] = -1;
        -:  540:		}
        -:  541:
       44:  542:		state->deckCount[player] = state->discardCount[player];
       44:  543:		state->discardCount[player] = 0;//Reset discard
        -:  544:
        -:  545:		//Shufffle the deck
       44:  546:		shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  547:
        -:  548:		if (DEBUG){//Debug statements
        -:  549:			printf("Deck count now: %d\n", state->deckCount[player]);
        -:  550:		}
        -:  551:
       44:  552:		state->discardCount[player] = 0;
        -:  553:
        -:  554:		//Step 2 Draw Card
       44:  555:		count = state->handCount[player];//Get current player's hand count
        -:  556:
        -:  557:		if (DEBUG){//Debug statements
        -:  558:			printf("Current hand count: %d\n", count);
        -:  559:		}
        -:  560:
       44:  561:		deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  562:
       44:  563:		if (deckCounter == 0)
    #####:  564:			return -1;
        -:  565:
       44:  566:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
       44:  567:		state->deckCount[player]--;
       44:  568:		state->handCount[player]++;//Increment hand count
        -:  569:	}
        -:  570:
        -:  571:	else{
      718:  572:		int count = state->handCount[player];//Get current hand count for player
        -:  573:		int deckCounter;
        -:  574:		if (DEBUG){//Debug statements
        -:  575:			printf("Current hand count: %d\n", count);
        -:  576:		}
        -:  577:
      718:  578:		deckCounter = state->deckCount[player];//Create holder for the deck count
      718:  579:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
      718:  580:		state->deckCount[player]--;
      718:  581:		state->handCount[player]++;//Increment hand count
        -:  582:	}
        -:  583:
      762:  584:	return 0;
        -:  585:}
        -:  586:
      461:  587:int getCost(int cardNumber)
        -:  588:{
      461:  589:	switch (cardNumber)
        -:  590:	{
        -:  591:	case curse:
       42:  592:		return 0;
        -:  593:	case estate:
       25:  594:		return 2;
        -:  595:	case duchy:
       18:  596:		return 5;
        -:  597:	case province:
       16:  598:		return 8;
        -:  599:	case copper:
       56:  600:		return 0;
        -:  601:	case silver:
       37:  602:		return 3;
        -:  603:	case gold:
       17:  604:		return 6;
        -:  605:	case adventurer:
    #####:  606:		return 6;
        -:  607:	case council_room:
       11:  608:		return 5;
        -:  609:	case feast:
       32:  610:		return 4;
        -:  611:	case gardens:
    #####:  612:		return 4;
        -:  613:	case mine:
    #####:  614:		return 5;
        -:  615:	case remodel:
       32:  616:		return 4;
        -:  617:	case smithy:
    #####:  618:		return 4;
        -:  619:	case village:
    #####:  620:		return 3;
        -:  621:	case baron:
    #####:  622:		return 4;
        -:  623:	case great_hall:
       35:  624:		return 3;
        -:  625:	case minion:
       27:  626:		return 5;
        -:  627:	case steward:
       16:  628:		return 3;
        -:  629:	case tribute:
       23:  630:		return 5;
        -:  631:	case ambassador:
    #####:  632:		return 3;
        -:  633:	case cutpurse:
    #####:  634:		return 4;
        -:  635:	case embargo:
       22:  636:		return 2;
        -:  637:	case outpost:
       22:  638:		return 5;
        -:  639:	case salvager:
       29:  640:		return 4;
        -:  641:	case sea_hag:
    #####:  642:		return 4;
        -:  643:	case treasure_map:
    #####:  644:		return 4;
        -:  645:	}
        -:  646:
        1:  647:	return -1;
        -:  648:}
        -:  649:
    #####:  650:void playAdventurer(struct gameState *state, int currentPlayer)
        -:  651:// Reveal cards from deck until 2 Treasure cards are found.  Put those Treasure cards in the hand and discard the rest.
        -:  652:{
    #####:  653:	int drawntreasure = 0;
        -:  654:	int temphand[MAX_HAND];
        -:  655:	int cardDrawn;
    #####:  656:	int z = 0; // this is the counter for the temp hand
        -:  657:
    #####:  658:	while (drawntreasure < 2){
    #####:  659:		if (state->deckCount[currentPlayer] < 1){//if the deck is empty we need to shuffle discard and add to deck
    #####:  660:			shuffle(currentPlayer, state);
        -:  661:		}
    #####:  662:		drawCard(currentPlayer, state);
    #####:  663:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer] - 1];//top card of hand is most recently drawn card.
    #####:  664:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
    #####:  665:			drawntreasure++;
        -:  666:		else{
    #####:  667:			temphand[z] = cardDrawn;
    #####:  668:			state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####:  669:			z++;
        -:  670:		}
        -:  671:	}
    #####:  672:	while (z - 1 >= 0){
    #####:  673:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; // discard all cards in play that have been drawn
    #####:  674:		z = z - 1;
        -:  675:	}
    #####:  676:}
        -:  677:
        3:  678:int playRemodel(struct gameState *state, int currentPlayer, int choice1, int choice2, int handPos)
        -:  679://Trash a card in the hand, and gain a card costing up to $2 more than the trashed card
        -:  680:{
        -:  681:	int i;
        3:  682:	int j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  683:
        3:  684:	if ((getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2))
        -:  685:	{
        1:  686:		return -1;
        -:  687:	}
        -:  688:
        2:  689:	gainCard(choice2, state, 0, currentPlayer);
        -:  690:
        -:  691:	//discard card from hand
        2:  692:	discardCard(handPos, currentPlayer, state, 0);
        -:  693:
        -:  694:	//discard trashed card
        7:  695:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  696:	{
        6:  697:		if (state->hand[currentPlayer][i] == j)
        -:  698:		{
        1:  699:			discardCard(i, currentPlayer, state, 0);
        1:  700:			break;
        -:  701:		}
        -:  702:	}
        -:  703:
        2:  704:	return 0;
        -:  705:}
        -:  706:
    #####:  707:void playSmithy(struct gameState *state, int currentPlayer, int handPos)
        -:  708:// Draw 3 cards
        -:  709:{
        -:  710:	int i;
    #####:  711:	for (i = 0; i < 3; i++)
        -:  712:	{
    #####:  713:		drawCard(currentPlayer, state);
        -:  714:	}
        -:  715:
        -:  716:	//discard card from hand
    #####:  717:	discardCard(handPos, currentPlayer, state, 0);
    #####:  718:}
        -:  719:
    #####:  720:void playBaron(struct gameState *state, int currentPlayer, int choice1, int handPos)
        -:  721://Add a buy.  OPTION:  Discard an Estate card and gain $4.  Otherwise, gain an Estate card.
        -:  722:{
    #####:  723:	state->numBuys++;//Increase buys by 1!
    #####:  724:	if (choice1 > 0){//Boolean true or going to discard an estate
    #####:  725:		int p = 0;//Iterator for hand!
    #####:  726:		int card_not_discarded = 1;//Flag for discard set!
    #####:  727:		while (card_not_discarded){
    #####:  728:			if (state->hand[currentPlayer][p] == estate){ //Found an estate card!
    #####:  729:				state->coins += 4;//Add 4 coins to the amount of coins
    #####:  730:				state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  731:				state->discardCount[currentPlayer]++;
    #####:  732:				for (; p < state->handCount[currentPlayer]; p++){
    #####:  733:					state->hand[currentPlayer][p] = state->hand[currentPlayer][p + 1];
        -:  734:				}
    #####:  735:				state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  736:				state->handCount[currentPlayer]--;
    #####:  737:				card_not_discarded = 0;//Exit the loop
        -:  738:			}
    #####:  739:			else if (p > state->handCount[currentPlayer]){
        -:  740:				if (DEBUG) {
        -:  741:					printf("No estate cards in your hand, invalid choice\n");
        -:  742:					printf("Must gain an estate if there are any\n");
        -:  743:				}
    #####:  744:				if (supplyCount(estate, state) > 0){
    #####:  745:					gainCard(estate, state, 1, currentPlayer);
    #####:  746:					state->supplyCount[estate]--;//Decrement estates
    #####:  747:					if (supplyCount(estate, state) == 0){
    #####:  748:						isGameOver(state);
        -:  749:					}
        -:  750:				}
    #####:  751:				card_not_discarded = 0;//Exit the loop
        -:  752:			}
        -:  753:
        -:  754:			else{
    #####:  755:				p++;//Next card
        -:  756:			}
        -:  757:		}
        -:  758:	}
        -:  759:
        -:  760:	else{
    #####:  761:		if (supplyCount(estate, state) > 0){
    #####:  762:			gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  763:			state->supplyCount[estate]--;//Decrement Estates
    #####:  764:			if (supplyCount(estate, state) == 0){
    #####:  765:				isGameOver(state);
        -:  766:			}
        -:  767:		}
        -:  768:	}
    #####:  769:}
        -:  770:
    #####:  771:int playTreasureMap(struct gameState *state, int currentPlayer, int handPos)
        -:  772://Trashing two treasure map cards from the hand = four gold on top of the deck.
        -:  773:{
        -:  774:	int i;
        -:  775:	int index;
        -:  776:
        -:  777:	//search hand for another treasure_map
    #####:  778:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  779:	{
    #####:  780:		if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -:  781:		{
    #####:  782:			index = i;
    #####:  783:			break;
        -:  784:		}
        -:  785:	}
    #####:  786:	if (index > -1)
        -:  787:	{
        -:  788:		//trash both treasure cards
    #####:  789:		discardCard(handPos, currentPlayer, state, 1);
    #####:  790:		discardCard(index, currentPlayer, state, 1);
        -:  791:
        -:  792:		//gain 4 Gold cards
    #####:  793:		for (i = 0; i < 4; i++)
        -:  794:		{
    #####:  795:			gainCard(gold, state, 1, currentPlayer);
        -:  796:		}
        -:  797:
        -:  798:		//return success
    #####:  799:		return 1;
        -:  800:	}
        -:  801:
        -:  802:	//no second treasure_map found in hand
    #####:  803:	return -1;
        -:  804:}
        -:  805:
       49:  806:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  807:{
        -:  808:	int i;
        -:  809:	int j;
        -:  810:	int k;
        -:  811:	//int x;  //Unused after while loop removed from feast.
       49:  812:	int currentPlayer = whoseTurn(state);
       49:  813:	int nextPlayer = currentPlayer + 1;
        -:  814:	int temphand[MAX_HAND];
        -:  815:
       49:  816:	int tributeRevealedCards[2] = { -1, -1 };
        -:  817:
       49:  818:	if (nextPlayer > (state->numPlayers - 1)){
        9:  819:		nextPlayer = 0;
        -:  820:	}
        -:  821:
        -:  822:	//uses switch to select card and perform actions
       49:  823:	switch (card)
        -:  824:	{
        -:  825:	case adventurer:
        -:  826:
    #####:  827:		playAdventurer(state, currentPlayer);
    #####:  828:		return 0;
        -:  829:
        -:  830:	case council_room:
        -:  831:		//+4 Cards
    #####:  832:		for (i = 0; i < 4; i++)
        -:  833:		{
    #####:  834:			drawCard(currentPlayer, state);
        -:  835:		}
        -:  836:
        -:  837:		//+1 Buy
    #####:  838:		state->numBuys++;
        -:  839:
        -:  840:		//Each other player draws a card
    #####:  841:		for (i = 0; i < state->numPlayers; i++)
        -:  842:		{
    #####:  843:			if (i != currentPlayer)
        -:  844:			{
    #####:  845:				drawCard(i, state);
        -:  846:			}
        -:  847:		}
        -:  848:
        -:  849:		//put played card in played card pile
    #####:  850:		discardCard(handPos, currentPlayer, state, 0);
        -:  851:
    #####:  852:		return 0;
        -:  853:
        -:  854:	case feast:
        -:  855:		//gain card with cost up to 5
        -:  856:		//Backup hand
       63:  857:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
       54:  858:			temphand[i] = state->hand[currentPlayer][i];//Backup card
       54:  859:			state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  860:		}
        -:  861:		//Backup hand
        -:  862:
        -:  863:		//Update Coins for Buy
        9:  864:		updateCoins(currentPlayer, state, 5);
        -:  865://		x = 1;//Condition to loop on
        -:  866://		while (x == 1) {//Buy one card
        9:  867:			if (supplyCount(choice1, state) <= 0){
        -:  868:				if (DEBUG)
        -:  869:					printf("None of that card left, sorry!\n");
        -:  870:
        -:  871:				if (DEBUG){
        -:  872:					printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  873:				}
        -:  874:			}
        5:  875:			else if (state->coins < getCost(choice1)){
        1:  876:				printf("That card is too expensive!\n");
        -:  877:
        -:  878:				if (DEBUG){
        -:  879:					printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  880:				}
        -:  881:			}
        -:  882:			else{
        -:  883:
        -:  884:				if (DEBUG){
        -:  885:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  886:				}
        -:  887:
        4:  888:				gainCard(choice1, state, 0, currentPlayer);//Gain the card
        -:  889://				x = 0;//No more buying cards
        -:  890:
        -:  891:				if (DEBUG){
        -:  892:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  893:				}
        -:  894:
        -:  895:			}
        -:  896://		}
        -:  897:
        -:  898:		//Reset Hand
       63:  899:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
       54:  900:			state->hand[currentPlayer][i] = temphand[i];
       54:  901:			temphand[i] = -1;
        -:  902:		}
        -:  903:		//Reset Hand
        -:  904:
        9:  905:		return 0;
        -:  906:
        -:  907:	case gardens:
    #####:  908:		return -1;
        -:  909:
        -:  910:	case mine:
    #####:  911:		j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  912:
    #####:  913:		if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  914:		{
    #####:  915:			return -1;
        -:  916:		}
        -:  917:
    #####:  918:		if (choice2 > treasure_map || choice2 < curse)
        -:  919:		{
    #####:  920:			return -1;
        -:  921:		}
        -:  922:
    #####:  923:		if ((getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2))
        -:  924:		{
    #####:  925:			return -1;
        -:  926:		}
        -:  927:
    #####:  928:		gainCard(choice2, state, 2, currentPlayer);
        -:  929:
        -:  930:		//discard card from hand
    #####:  931:		discardCard(handPos, currentPlayer, state, 0);
        -:  932:
        -:  933:		//discard trashed card
    #####:  934:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  935:		{
    #####:  936:			if (state->hand[currentPlayer][i] == j)
        -:  937:			{
    #####:  938:				discardCard(i, currentPlayer, state, 0);
    #####:  939:				break;
        -:  940:			}
        -:  941:		}
        -:  942:
    #####:  943:		return 0;
        -:  944:
        -:  945:	case remodel:
        -:  946:
        3:  947:		return playRemodel(state, currentPlayer, choice1, choice2, handPos);
        -:  948:
        -:  949:	case smithy:
        -:  950:
    #####:  951:		playSmithy(state, currentPlayer, handPos);
    #####:  952:		return 0;
        -:  953:
        -:  954:	case village:
        -:  955:		//+1 Card
    #####:  956:		drawCard(currentPlayer, state);
        -:  957:
        -:  958:		//+2 Actions
    #####:  959:		state->numActions = state->numActions + 2;
        -:  960:
        -:  961:		//discard played card from hand
    #####:  962:		discardCard(handPos, currentPlayer, state, 0);
    #####:  963:		return 0;
        -:  964:
        -:  965:	case baron:
        -:  966:
    #####:  967:		playBaron(state, currentPlayer, choice1, handPos);
    #####:  968:		return 0;
        -:  969:
        -:  970:	case great_hall:
        -:  971:		//+1 Card
       10:  972:		drawCard(currentPlayer, state);
        -:  973:
        -:  974:		//+1 Actions
       10:  975:		state->numActions++;
        -:  976:
        -:  977:		//discard card from hand
       10:  978:		discardCard(handPos, currentPlayer, state, 0);
       10:  979:		return 0;
        -:  980:
        -:  981:	case minion:
        -:  982:		//+1 action
    #####:  983:		state->numActions++;
        -:  984:
        -:  985:		//discard card from hand
    #####:  986:		discardCard(handPos, currentPlayer, state, 0);
        -:  987:
    #####:  988:		if (choice1)		//+2 coins
        -:  989:		{
    #####:  990:			state->coins = state->coins + 2;
        -:  991:		}
        -:  992:
    #####:  993:		else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  994:		{
        -:  995:			//discard hand
    #####:  996:			while (numHandCards(state) > 0)
        -:  997:			{
    #####:  998:				discardCard(handPos, currentPlayer, state, 0);
        -:  999:			}
        -: 1000:
        -: 1001:			//draw 4
    #####: 1002:			for (i = 0; i < 4; i++)
        -: 1003:			{
    #####: 1004:				drawCard(currentPlayer, state);
        -: 1005:			}
        -: 1006:
        -: 1007:			//other players discard hand and redraw if hand size > 4
    #####: 1008:			for (i = 0; i < state->numPlayers; i++)
        -: 1009:			{
    #####: 1010:				if (i != currentPlayer)
        -: 1011:				{
    #####: 1012:					if (state->handCount[i] > 4)
        -: 1013:					{
        -: 1014:						//discard hand
    #####: 1015:						while (state->handCount[i] > 0)
        -: 1016:						{
    #####: 1017:							discardCard(handPos, i, state, 0);
        -: 1018:						}
        -: 1019:
        -: 1020:						//draw 4
    #####: 1021:						for (j = 0; j < 4; j++)
        -: 1022:						{
    #####: 1023:							drawCard(i, state);
        -: 1024:						}
        -: 1025:					}
        -: 1026:				}
        -: 1027:			}
        -: 1028:
        -: 1029:		}
    #####: 1030:		return 0;
        -: 1031:
        -: 1032:	case steward:
        1: 1033:		if (choice1 == 1)
        -: 1034:		{
        -: 1035:			//+2 cards
    #####: 1036:			drawCard(currentPlayer, state);
    #####: 1037:			drawCard(currentPlayer, state);
        -: 1038:		}
        1: 1039:		else if (choice1 == 2)
        -: 1040:		{
        -: 1041:			//+2 coins
    #####: 1042:			state->coins = state->coins + 2;
        -: 1043:		}
        -: 1044:		else
        -: 1045:		{
        -: 1046:			//trash 2 cards in hand
        1: 1047:			discardCard(choice2, currentPlayer, state, 1);
        1: 1048:			discardCard(choice3, currentPlayer, state, 1);
        -: 1049:		}
        -: 1050:
        -: 1051:		//discard card from hand
        1: 1052:		discardCard(handPos, currentPlayer, state, 0);
        1: 1053:		return 0;
        -: 1054:
        -: 1055:	case tribute:
        2: 1056:		if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####: 1057:			if (state->deckCount[nextPlayer] > 0){
    #####: 1058:				tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1059:				state->deckCount[nextPlayer]--;
        -: 1060:			}
    #####: 1061:			else if (state->discardCount[nextPlayer] > 0){
    #####: 1062:				tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer] - 1];
    #####: 1063:				state->discardCount[nextPlayer]--;
        -: 1064:			}
        -: 1065:			else{
        -: 1066:				//No Card to Reveal
        -: 1067:				if (DEBUG){
        -: 1068:					printf("No cards to reveal\n");
        -: 1069:				}
        -: 1070:			}
        -: 1071:		}
        -: 1072:
        -: 1073:		else{
        2: 1074:			if (state->deckCount[nextPlayer] == 0){
    #####: 1075:				for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####: 1076:					state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1077:					state->deckCount[nextPlayer]++;
    #####: 1078:					state->discard[nextPlayer][i] = -1;
    #####: 1079:					state->discardCount[nextPlayer]--;
        -: 1080:				}
        -: 1081:
    #####: 1082:				shuffle(nextPlayer, state);//Shuffle the deck
        -: 1083:			}
        2: 1084:			tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
        2: 1085:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
        2: 1086:			state->deckCount[nextPlayer]--;
        2: 1087:			tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
        2: 1088:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
        2: 1089:			state->deckCount[nextPlayer]--;
        -: 1090:		}
        -: 1091:
        2: 1092:		if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
        1: 1093:			state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
        1: 1094:			state->playedCardCount++;
        1: 1095:			tributeRevealedCards[1] = -1;
        -: 1096:		}
        -: 1097:
        8: 1098:		for (i = 0; i <= 2; i++){
        6: 1099:			if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
        3: 1100:				state->coins += 2;
        -: 1101:			}
        -: 1102:
        3: 1103:			else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
        1: 1104:				drawCard(currentPlayer, state);
        1: 1105:				drawCard(currentPlayer, state);
        -: 1106:			}
        -: 1107:			else{//Action Card
        2: 1108:				state->numActions = state->numActions + 2;
        -: 1109:			}
        -: 1110:		}
        -: 1111:
        2: 1112:		return 0;
        -: 1113:
        -: 1114:	case ambassador:
    #####: 1115:		j = 0;		//used to check if player has enough cards to discard
        -: 1116:
    #####: 1117:		if (choice2 > 2 || choice2 < 0)
        -: 1118:		{
    #####: 1119:			return -1;
        -: 1120:		}
        -: 1121:
    #####: 1122:		if (choice1 == handPos)
        -: 1123:		{
    #####: 1124:			return -1;
        -: 1125:		}
        -: 1126:
    #####: 1127:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1128:		{
    #####: 1129:			if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1130:			{
    #####: 1131:				j++;
        -: 1132:			}
        -: 1133:		}
    #####: 1134:		if (j < choice2)
        -: 1135:		{
    #####: 1136:			return -1;
        -: 1137:		}
        -: 1138:
        -: 1139:		if (DEBUG)
        -: 1140:			printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1141:
        -: 1142:		//increase supply count for choosen card by amount being discarded
    #####: 1143:		state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1144:
        -: 1145:		//each other player gains a copy of revealed card
    #####: 1146:		for (i = 0; i < state->numPlayers; i++)
        -: 1147:		{
    #####: 1148:			if (i != currentPlayer)
        -: 1149:			{
    #####: 1150:				gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1151:			}
        -: 1152:		}
        -: 1153:
        -: 1154:		//discard played card from hand
    #####: 1155:		discardCard(handPos, currentPlayer, state, 0);
        -: 1156:
        -: 1157:		//trash copies of cards returned to supply
    #####: 1158:		for (j = 0; j < choice2; j++)
        -: 1159:		{
    #####: 1160:			for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1161:			{
    #####: 1162:				if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1163:				{
    #####: 1164:					discardCard(i, currentPlayer, state, 1);
    #####: 1165:					break;
        -: 1166:				}
        -: 1167:			}
        -: 1168:		}
        -: 1169:
    #####: 1170:		return 0;
        -: 1171:
        -: 1172:	case cutpurse:
        -: 1173:
    #####: 1174:		updateCoins(currentPlayer, state, 2);
    #####: 1175:		for (i = 0; i < state->numPlayers; i++)
        -: 1176:		{
    #####: 1177:			if (i != currentPlayer)
        -: 1178:			{
    #####: 1179:				for (j = 0; j < state->handCount[i]; j++)
        -: 1180:				{
    #####: 1181:					if (state->hand[i][j] == copper)
        -: 1182:					{
    #####: 1183:						discardCard(j, i, state, 0);
    #####: 1184:						break;
        -: 1185:					}
    #####: 1186:					if (j == state->handCount[i])
        -: 1187:					{
    #####: 1188:						for (k = 0; k < state->handCount[i]; k++)
        -: 1189:						{
        -: 1190:							if (DEBUG)
        -: 1191:								printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1192:						}
    #####: 1193:						break;
        -: 1194:					}
        -: 1195:				}
        -: 1196:
        -: 1197:			}
        -: 1198:
        -: 1199:		}
        -: 1200:
        -: 1201:		//discard played card from hand
    #####: 1202:		discardCard(handPos, currentPlayer, state, 0);
        -: 1203:
    #####: 1204:		return 0;
        -: 1205:
        -: 1206:
        -: 1207:	case embargo:
        -: 1208:		//+2 Coins
       16: 1209:		state->coins = state->coins + 2;
        -: 1210:
        -: 1211:		//see if selected pile is in play
       16: 1212:		if (state->supplyCount[choice1] == -1)
        -: 1213:		{
        8: 1214:			return -1;
        -: 1215:		}
        -: 1216:
        -: 1217:		//add embargo token to selected supply pile
        8: 1218:		state->embargoTokens[choice1]++;
        -: 1219:
        -: 1220:		//trash card
        8: 1221:		discardCard(handPos, currentPlayer, state, 1);
        8: 1222:		return 0;
        -: 1223:
        -: 1224:	case outpost:
        -: 1225:		//set outpost flag
        3: 1226:		state->outpostPlayed++;
        -: 1227:
        -: 1228:		//discard card
        3: 1229:		discardCard(handPos, currentPlayer, state, 0);
        3: 1230:		return 0;
        -: 1231:
        -: 1232:	case salvager:
        -: 1233:		//+1 buy
        5: 1234:		state->numBuys++;
        -: 1235:
        5: 1236:		if (choice1)
        -: 1237:		{
        -: 1238:			//gain coins equal to trashed card
        4: 1239:			state->coins = state->coins + getCost(handCard(choice1, state));
        -: 1240:			//trash card
        4: 1241:			discardCard(choice1, currentPlayer, state, 1);
        -: 1242:		}
        -: 1243:
        -: 1244:		//discard card
        5: 1245:		discardCard(handPos, currentPlayer, state, 0);
        5: 1246:		return 0;
        -: 1247:
        -: 1248:	case sea_hag:
    #####: 1249:		for (i = 0; i < state->numPlayers; i++){
    #####: 1250:			if (i != currentPlayer){
    #####: 1251:				state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1252:				state->discardCount[i]++;
    #####: 1253:				state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1254:			}
        -: 1255:		}
    #####: 1256:		return 0;
        -: 1257:
        -: 1258:	case treasure_map:
        -: 1259:
    #####: 1260:		return playTreasureMap(state, currentPlayer, handPos);
        -: 1261:	}
    #####: 1262:	return -1;
        -: 1263:}
        -: 1264:
       36: 1265:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1266:{
        -: 1267:
        -: 1268:	//if card is not trashed, added to Played pile 
       36: 1269:	if (trashFlag < 1)
        -: 1270:	{
        -: 1271:		//add card to played pile
       22: 1272:		state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
       22: 1273:		state->playedCardCount++;
        -: 1274:	}
        -: 1275:
        -: 1276:	//set played card to -1
       36: 1277:	state->hand[currentPlayer][handPos] = -1;
        -: 1278:
        -: 1279:	//remove card from player's hand
       36: 1280:	if (handPos == (state->handCount[currentPlayer] - 1)) 	//last card in hand array is played
        -: 1281:	{
        -: 1282:		//reduce number of cards in hand
        3: 1283:		state->handCount[currentPlayer]--;
        -: 1284:	}
       33: 1285:	else if (state->handCount[currentPlayer] == 1) //only one card in hand
        -: 1286:	{
        -: 1287:		//reduce number of cards in hand
    #####: 1288:		state->handCount[currentPlayer]--;
        -: 1289:	}
        -: 1290:	else
        -: 1291:	{
        -: 1292:		//replace discarded card with last card in hand
       33: 1293:		state->hand[currentPlayer][handPos] = state->hand[currentPlayer][(state->handCount[currentPlayer] - 1)];
        -: 1294:		//set last card to -1
       33: 1295:		state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1296:		//reduce number of cards in hand
       33: 1297:		state->handCount[currentPlayer]--;
        -: 1298:	}
        -: 1299:
       36: 1300:	return 0;
        -: 1301:}
        -: 1302:
      123: 1303:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1304:{
        -: 1305:	//Note: supplyPos is enum of choosen card
        -: 1306:
        -: 1307:	//check if supply pile is empty (0) or card is not used in game (-1)
      123: 1308:	if (supplyCount(supplyPos, state) < 1)
        -: 1309:	{
    #####: 1310:		return -1;
        -: 1311:	}
        -: 1312:
        -: 1313:	//added card for [whoseTurn] current player:
        -: 1314:	// toFlag = 0 : add to discard
        -: 1315:	// toFlag = 1 : add to deck
        -: 1316:	// toFlag = 2 : add to hand
        -: 1317:
      123: 1318:	if (toFlag == 1)
        -: 1319:	{
    #####: 1320:		state->deck[player][state->deckCount[player]] = supplyPos;
    #####: 1321:		state->deckCount[player]++;
        -: 1322:	}
      123: 1323:	else if (toFlag == 2)
        -: 1324:	{
    #####: 1325:		state->hand[player][state->handCount[player]] = supplyPos;
    #####: 1326:		state->handCount[player]++;
        -: 1327:	}
        -: 1328:	else
        -: 1329:	{
      123: 1330:		state->discard[player][state->discardCount[player]] = supplyPos;
      123: 1331:		state->discardCount[player]++;
        -: 1332:	}
        -: 1333:
        -: 1334:	//decrease number in supply pile
      123: 1335:	state->supplyCount[supplyPos]--;
        -: 1336:
      123: 1337:	return 0;
        -: 1338:}
        -: 1339:
      199: 1340:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1341:{
        -: 1342:	int i;
        -: 1343:
        -: 1344:	//reset coin count
      199: 1345:	state->coins = 0;
        -: 1346:
        -: 1347:	//add coins for each Treasure card in player's hand
     1170: 1348:	for (i = 0; i < state->handCount[player]; i++)
        -: 1349:	{
      971: 1350:		if (state->hand[player][i] == copper)
        -: 1351:		{
      394: 1352:			state->coins += 1;
        -: 1353:		}
      577: 1354:		else if (state->hand[player][i] == silver)
        -: 1355:		{
       68: 1356:			state->coins += 2;
        -: 1357:		}
      509: 1358:		else if (state->hand[player][i] == gold)
        -: 1359:		{
    #####: 1360:			state->coins += 3;
        -: 1361:		}
        -: 1362:	}
        -: 1363:
        -: 1364:	//add bonus
      199: 1365:	state->coins += bonus;
        -: 1366:
      199: 1367:	return 0;
        -: 1368:}
        -: 1369:
        -: 1370:
        -: 1371://end of dominion.c
File 'dominion.c'
Lines executed:59.43% of 557
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
     1479:    8:int compare(const void* a, const void* b) {
     1479:    9:	if (*(int*)a > *(int*)b)
      600:   10:		return 1;
      879:   11:	if (*(int*)a < *(int*)b)
      459:   12:		return -1;
      420:   13:	return 0;
        -:   14:}
        -:   15:
        2:   16:struct gameState* newGame() {
        2:   17:	struct gameState* g = malloc(sizeof(struct gameState));
        2:   18:	return g;
        -:   19:}
        -:   20:
       18:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:	int k8, int k9, int k10) {
       18:   23:	int* k = malloc(10 * sizeof(int));
       18:   24:	k[0] = k1;
       18:   25:	k[1] = k2;
       18:   26:	k[2] = k3;
       18:   27:	k[3] = k4;
       18:   28:	k[4] = k5;
       18:   29:	k[5] = k6;
       18:   30:	k[6] = k7;
       18:   31:	k[7] = k8;
       18:   32:	k[8] = k9;
       18:   33:	k[9] = k10;
       18:   34:	return k;
        -:   35:}
        -:   36:
       18:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		struct gameState *state) {
        -:   39:
        -:   40:	int i;
        -:   41:	int j;
        -:   42:	int it;
        -:   43:	//set up random number generator
       18:   44:	SelectStream(1);
       18:   45:	PutSeed((long)randomSeed);
        -:   46:
        -:   47:	//check number of players
       18:   48:	if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:	{
    #####:   50:		return -1;
        -:   51:	}
        -:   52:
        -:   53:	//set number of players
       18:   54:	state->numPlayers = numPlayers;
        -:   55:
        -:   56:	//check selected kingdom cards are different
       66:   57:	for (i = 0; i < 10; i++)
        -:   58:	{
      640:   59:		for (j = 0; j < 10; j++)
        -:   60:		{
      592:   61:			if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:			{
       17:   63:				return -1;
        -:   64:			}
        -:   65:		}
        -:   66:	}
        -:   67:
        -:   68:
        -:   69:	//initialize supply
        -:   70:	///////////////////////////////
        -:   71:
        -:   72:	//set number of Curse cards
        1:   73:	if (numPlayers == 2)
        -:   74:	{
        1:   75:		state->supplyCount[curse] = 10;
        -:   76:	}
    #####:   77:	else if (numPlayers == 3)
        -:   78:	{
    #####:   79:		state->supplyCount[curse] = 20;
        -:   80:	}
        -:   81:	else
        -:   82:	{
    #####:   83:		state->supplyCount[curse] = 30;
        -:   84:	}
        -:   85:
        -:   86:	//set number of Victory cards
        1:   87:	if (numPlayers == 2)
        -:   88:	{
        1:   89:		state->supplyCount[estate] = 8;
        1:   90:		state->supplyCount[duchy] = 8;
        1:   91:		state->supplyCount[province] = 8;
        -:   92:	}
        -:   93:	else
        -:   94:	{
    #####:   95:		state->supplyCount[estate] = 12;
    #####:   96:		state->supplyCount[duchy] = 12;
    #####:   97:		state->supplyCount[province] = 12;
        -:   98:	}
        -:   99:
        -:  100:	//set number of Treasure cards
        1:  101:	state->supplyCount[copper] = 60 - (7 * numPlayers);
        1:  102:	state->supplyCount[silver] = 40;
        1:  103:	state->supplyCount[gold] = 30;
        -:  104:
        -:  105:	//set number of Kingdom cards
       21:  106:	for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:	{
      165:  108:		for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:		{
      155:  110:			if (kingdomCards[j] == i)
        -:  111:			{
        -:  112:				//check if card is a 'Victory' Kingdom card
       10:  113:				if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:				{
        2:  115:					if (numPlayers == 2){
        1:  116:						state->supplyCount[i] = 8;
        -:  117:					}
    #####:  118:					else{ state->supplyCount[i] = 12; }
        -:  119:				}
        -:  120:				else
        -:  121:				{
        9:  122:					state->supplyCount[i] = 10;
        -:  123:				}
       10:  124:				break;
        -:  125:			}
        -:  126:			else    //card is not in the set choosen for the game
        -:  127:			{
      145:  128:				state->supplyCount[i] = -1;
        -:  129:			}
        -:  130:		}
        -:  131:
        -:  132:	}
        -:  133:
        -:  134:	////////////////////////
        -:  135:	//supply intilization complete
        -:  136:
        -:  137:	//set player decks
        3:  138:	for (i = 0; i < numPlayers; i++)
        -:  139:	{
        2:  140:		state->deckCount[i] = 0;
        8:  141:		for (j = 0; j < 3; j++)
        -:  142:		{
        6:  143:			state->deck[i][j] = estate;
        6:  144:			state->deckCount[i]++;
        -:  145:		}
       16:  146:		for (j = 3; j < 10; j++)
        -:  147:		{
       14:  148:			state->deck[i][j] = copper;
       14:  149:			state->deckCount[i]++;
        -:  150:		}
        -:  151:	}
        -:  152:
        -:  153:	//shuffle player decks
        3:  154:	for (i = 0; i < numPlayers; i++)
        -:  155:	{
        2:  156:		if (shuffle(i, state) < 0)
        -:  157:		{
    #####:  158:			return -1;
        -:  159:		}
        -:  160:	}
        -:  161:
        -:  162:	//draw player hands
        3:  163:	for (i = 0; i < numPlayers; i++)
        -:  164:	{
        -:  165:		//initialize hand size to zero
        2:  166:		state->handCount[i] = 0;
        2:  167:		state->discardCount[i] = 0;
        -:  168:		//draw 5 cards
        -:  169:		// for (j = 0; j < 5; j++)
        -:  170:		//	{
        -:  171:		//	  drawCard(i, state);
        -:  172:		//	}
        -:  173:	}
        -:  174:
        -:  175:	//set embargo tokens to 0 for all supply piles
       28:  176:	for (i = 0; i <= treasure_map; i++)
        -:  177:	{
       27:  178:		state->embargoTokens[i] = 0;
        -:  179:	}
        -:  180:
        -:  181:	//initialize first player's turn
        1:  182:	state->outpostPlayed = 0;
        1:  183:	state->phase = 0;
        1:  184:	state->numActions = 1;
        1:  185:	state->numBuys = 1;
        1:  186:	state->playedCardCount = 0;
        1:  187:	state->whoseTurn = 0;
        1:  188:	state->handCount[state->whoseTurn] = 0;
        -:  189:	//int it; move to top
        -:  190:
        -:  191:	//Moved draw cards to here, only drawing at the start of a turn
        6:  192:	for (it = 0; it < 5; it++){
        5:  193:		drawCard(state->whoseTurn, state);
        -:  194:	}
        -:  195:
        1:  196:	updateCoins(state->whoseTurn, state, 0);
        -:  197:
        1:  198:	return 0;
        -:  199:}
        -:  200:
       25:  201:int shuffle(int player, struct gameState *state) {
        -:  202:
        -:  203:
        -:  204:	int newDeck[MAX_DECK];
       25:  205:	int newDeckPos = 0;
        -:  206:	int card;
        -:  207:	int i;
        -:  208:
       25:  209:	if (state->deckCount[player] < 1)
    #####:  210:		return -1;
       25:  211:	qsort((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
        -:  212:	/* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
      606:  214:	while (state->deckCount[player] > 0) {
      556:  215:		card = floor(Random() * state->deckCount[player]);
      556:  216:		newDeck[newDeckPos] = state->deck[player][card];
      556:  217:		newDeckPos++;
     4172:  218:		for (i = card; i < state->deckCount[player] - 1; i++) {
     3616:  219:			state->deck[player][i] = state->deck[player][i + 1];
        -:  220:		}
      556:  221:		state->deckCount[player]--;
        -:  222:	}
      581:  223:	for (i = 0; i < newDeckPos; i++) {
      556:  224:		state->deck[player][i] = newDeck[i];
      556:  225:		state->deckCount[player]++;
        -:  226:	}
        -:  227:
       25:  228:	return 0;
        -:  229:}
        -:  230:
      260:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state)
        -:  232:{
        -:  233:	int card;
      260:  234:	int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:	//check if it is the right phase
      260:  237:	if (state->phase != 0)
        -:  238:	{
       65:  239:		return -1;
        -:  240:	}
        -:  241:
        -:  242:	//check if player has enough actions
      195:  243:	if (state->numActions < 1)
        -:  244:	{
       10:  245:		return -1;
        -:  246:	}
        -:  247:
        -:  248:	//get card played
      185:  249:	card = handCard(handPos, state);
        -:  250:
        -:  251:	//check if selected card is an action
      185:  252:	if (card < adventurer || card > treasure_map)
        -:  253:	{
      156:  254:		return -1;
        -:  255:	}
        -:  256:
        -:  257:	//play card
       29:  258:	if (cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0)
        -:  259:	{
        4:  260:		return -1;
        -:  261:	}
        -:  262:
        -:  263:	//reduce number of actions
       25:  264:	state->numActions--;
        -:  265:
        -:  266:	//update coins (Treasure cards may be added with card draws)
       25:  267:	updateCoins(state->whoseTurn, state, coin_bonus);
        -:  268:
       25:  269:	return 0;
        -:  270:}
        -:  271:
      271:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:	int who;
        -:  274:	if (DEBUG){
        -:  275:		printf("Entering buyCard...\n");
        -:  276:	}
        -:  277:
        -:  278:	// I don't know what to do about the phase thing.
        -:  279:
      271:  280:	who = state->whoseTurn;
        -:  281:
      271:  282:	if (state->numBuys < 1){
        -:  283:		if (DEBUG)
        -:  284:			printf("You do not have any buys left\n");
       71:  285:		return -1;
        -:  286:	}
      200:  287:	else if (supplyCount(supplyPos, state) < 1){
        -:  288:		if (DEBUG)
        -:  289:			printf("There are not any of that type of card left\n");
       62:  290:		return -1;
        -:  291:	}
      138:  292:	else if (state->coins < getCost(supplyPos)){
        -:  293:		if (DEBUG)
        -:  294:			printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
       58:  295:		return -1;
        -:  296:	}
        -:  297:	else {
       80:  298:		state->phase = 1;
        -:  299:		//state->supplyCount[supplyPos]--;
       80:  300:		gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  301:
       80:  302:		state->coins = (state->coins) - (getCost(supplyPos));
       80:  303:		state->numBuys--;
        -:  304:		if (DEBUG)
        -:  305:			printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  306:	}
        -:  307:
        -:  308:	//state->discard[who][state->discardCount[who]] = supplyPos;
        -:  309:	//state->discardCount[who]++;
        -:  310:
       80:  311:	return 0;
        -:  312:}
        -:  313:
    #####:  314:int numHandCards(struct gameState *state) {
    #####:  315:	return state->handCount[whoseTurn(state)];
        -:  316:}
        -:  317:
      185:  318:int handCard(int handPos, struct gameState *state) {
      185:  319:	int currentPlayer = whoseTurn(state);
      185:  320:	return state->hand[currentPlayer][handPos];
        -:  321:}
        -:  322:
      298:  323:int supplyCount(int card, struct gameState *state) {
      298:  324:	return state->supplyCount[card];
        -:  325:}
        -:  326:
    #####:  327:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  328:	int i;
    #####:  329:	int count = 0;
        -:  330:
    #####:  331:	for (i = 0; i < state->deckCount[player]; i++)
        -:  332:	{
    #####:  333:		if (state->deck[player][i] == card) count++;
        -:  334:	}
        -:  335:
    #####:  336:	for (i = 0; i < state->handCount[player]; i++)
        -:  337:	{
    #####:  338:		if (state->hand[player][i] == card) count++;
        -:  339:	}
        -:  340:
    #####:  341:	for (i = 0; i < state->discardCount[player]; i++)
        -:  342:	{
    #####:  343:		if (state->discard[player][i] == card) count++;
        -:  344:	}
        -:  345:
    #####:  346:	return count;
        -:  347:}
        -:  348:
      312:  349:int whoseTurn(struct gameState *state) {
      312:  350:	return state->whoseTurn;
        -:  351:}
        -:  352:
       98:  353:int endTurn(struct gameState *state) {
        -:  354:	int k;
        -:  355:	int i;
       98:  356:	int currentPlayer = whoseTurn(state);
        -:  357:
        -:  358:	//Discard hand
      572:  359:	for (i = 0; i < state->handCount[currentPlayer]; i++){
      474:  360:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
      474:  361:		state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  362:	}
       98:  363:	state->handCount[currentPlayer] = 0;//Reset hand count
        -:  364:
        -:  365:	//Code for determining the player
       98:  366:	if (currentPlayer < (state->numPlayers - 1)){
       49:  367:		state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  368:	}
        -:  369:	else{
       49:  370:		state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  371:	}
        -:  372:
       98:  373:	state->outpostPlayed = 0;
       98:  374:	state->phase = 0;
       98:  375:	state->numActions = 1;
       98:  376:	state->coins = 0;
       98:  377:	state->numBuys = 1;
       98:  378:	state->playedCardCount = 0;
       98:  379:	state->handCount[state->whoseTurn] = 0;
        -:  380:
        -:  381:	//int k; move to top
        -:  382:	//Next player draws hand
      588:  383:	for (k = 0; k < 5; k++){
      490:  384:		drawCard(state->whoseTurn, state);//Draw a card
        -:  385:	}
        -:  386:
        -:  387:	//Update money
       98:  388:	updateCoins(state->whoseTurn, state, 0);
        -:  389:
       98:  390:	return 0;
        -:  391:}
        -:  392:
      803:  393:int isGameOver(struct gameState *state) {
        -:  394:	int i;
        -:  395:	int j;
        -:  396:
        -:  397:	//if stack of Province cards is empty, the game ends
      803:  398:	if (state->supplyCount[province] == 0)
        -:  399:	{
    #####:  400:		return 1;
        -:  401:	}
        -:  402:
        -:  403:	//if three supply pile are at 0, the game ends
      803:  404:	j = 0;
    20878:  405:	for (i = 0; i < 25; i++)
        -:  406:	{
    20075:  407:		if (state->supplyCount[i] == 0)
        -:  408:		{
      238:  409:			j++;
        -:  410:		}
        -:  411:	}
      803:  412:	if (j >= 3)
        -:  413:	{
        1:  414:		return 1;
        -:  415:	}
        -:  416:
      802:  417:	return 0;
        -:  418:}
        -:  419:
        2:  420:int scoreFor(int player, struct gameState *state) {
        -:  421:
        -:  422:	int i;
        2:  423:	int score = 0;
        -:  424:	//score from hand
        7:  425:	for (i = 0; i < state->handCount[player]; i++)
        -:  426:	{
        5:  427:		if (state->hand[player][i] == curse) { score = score - 1; };
        5:  428:		if (state->hand[player][i] == estate) { score = score + 1; };
        5:  429:		if (state->hand[player][i] == duchy) { score = score + 3; };
        5:  430:		if (state->hand[player][i] == province) { score = score + 6; };
        5:  431:		if (state->hand[player][i] == great_hall) { score = score + 1; };
        5:  432:		if (state->hand[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  433:	}
        -:  434:
        -:  435:	//score from discard
       26:  436:	for (i = 0; i < state->discardCount[player]; i++)
        -:  437:	{
       24:  438:		if (state->discard[player][i] == curse) { score = score - 1; };
       24:  439:		if (state->discard[player][i] == estate) { score = score + 1; };
       24:  440:		if (state->discard[player][i] == duchy) { score = score + 3; };
       24:  441:		if (state->discard[player][i] == province) { score = score + 6; };
       24:  442:		if (state->discard[player][i] == great_hall) { score = score + 1; };
       24:  443:		if (state->discard[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  444:	}
        -:  445:
        -:  446:	//score from deck
       26:  447:	for (i = 0; i < state->discardCount[player]; i++)
        -:  448:	{
       24:  449:		if (state->deck[player][i] == curse) { score = score - 1; };
       24:  450:		if (state->deck[player][i] == estate) { score = score + 1; };
       24:  451:		if (state->deck[player][i] == duchy) { score = score + 3; };
       24:  452:		if (state->deck[player][i] == province) { score = score + 6; };
       24:  453:		if (state->deck[player][i] == great_hall) { score = score + 1; };
       24:  454:		if (state->deck[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  455:	}
        -:  456:
        2:  457:	return score;
        -:  458:}
        -:  459:
    #####:  460:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  461:	int i;
        -:  462:	int j;
        -:  463:	int highScore;
        -:  464:	int currentPlayer;
        -:  465:
        -:  466:	//get score for each player
    #####:  467:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  468:	{
        -:  469:		//set unused player scores to -9999
    #####:  470:		if (i >= state->numPlayers)
        -:  471:		{
    #####:  472:			players[i] = -9999;
        -:  473:		}
        -:  474:		else
        -:  475:		{
    #####:  476:			players[i] = scoreFor(i, state);
        -:  477:		}
        -:  478:	}
        -:  479:
        -:  480:	//find highest score
    #####:  481:	j = 0;
    #####:  482:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  483:	{
    #####:  484:		if (players[i] > players[j])
        -:  485:		{
    #####:  486:			j = i;
        -:  487:		}
        -:  488:	}
    #####:  489:	highScore = players[j];
        -:  490:
        -:  491:	//add 1 to players who had less turns
    #####:  492:	currentPlayer = whoseTurn(state);
    #####:  493:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  494:	{
    #####:  495:		if (players[i] == highScore && i > currentPlayer)
        -:  496:		{
    #####:  497:			players[i]++;
        -:  498:		}
        -:  499:	}
        -:  500:
        -:  501:	//find new highest score
    #####:  502:	j = 0;
    #####:  503:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  504:	{
    #####:  505:		if (players[i] > players[j])
        -:  506:		{
    #####:  507:			j = i;
        -:  508:		}
        -:  509:	}
    #####:  510:	highScore = players[j];
        -:  511:
        -:  512:	//set winners in array to 1 and rest to 0
    #####:  513:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  514:	{
    #####:  515:		if (players[i] == highScore)
        -:  516:		{
    #####:  517:			players[i] = 1;
        -:  518:		}
        -:  519:		else
        -:  520:		{
    #####:  521:			players[i] = 0;
        -:  522:		}
        -:  523:	}
        -:  524:
    #####:  525:	return 0;
        -:  526:}
        -:  527:
      507:  528:int drawCard(int player, struct gameState *state)
        -:  529:{
        -:  530:	int count;
        -:  531:	int deckCounter;
      507:  532:	if (state->deckCount[player] <= 0){//Deck is empty
        -:  533:
        -:  534:		//Step 1 Shuffle the discard pile back into a deck
        -:  535:		int i;
        -:  536:		//Move discard to deck
      559:  537:		for (i = 0; i < state->discardCount[player]; i++){
      536:  538:			state->deck[player][i] = state->discard[player][i];
      536:  539:			state->discard[player][i] = -1;
        -:  540:		}
        -:  541:
       23:  542:		state->deckCount[player] = state->discardCount[player];
       23:  543:		state->discardCount[player] = 0;//Reset discard
        -:  544:
        -:  545:		//Shufffle the deck
       23:  546:		shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  547:
        -:  548:		if (DEBUG){//Debug statements
        -:  549:			printf("Deck count now: %d\n", state->deckCount[player]);
        -:  550:		}
        -:  551:
       23:  552:		state->discardCount[player] = 0;
        -:  553:
        -:  554:		//Step 2 Draw Card
       23:  555:		count = state->handCount[player];//Get current player's hand count
        -:  556:
        -:  557:		if (DEBUG){//Debug statements
        -:  558:			printf("Current hand count: %d\n", count);
        -:  559:		}
        -:  560:
       23:  561:		deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  562:
       23:  563:		if (deckCounter == 0)
    #####:  564:			return -1;
        -:  565:
       23:  566:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
       23:  567:		state->deckCount[player]--;
       23:  568:		state->handCount[player]++;//Increment hand count
        -:  569:	}
        -:  570:
        -:  571:	else{
      484:  572:		int count = state->handCount[player];//Get current hand count for player
        -:  573:		int deckCounter;
        -:  574:		if (DEBUG){//Debug statements
        -:  575:			printf("Current hand count: %d\n", count);
        -:  576:		}
        -:  577:
      484:  578:		deckCounter = state->deckCount[player];//Create holder for the deck count
      484:  579:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
      484:  580:		state->deckCount[player]--;
      484:  581:		state->handCount[player]++;//Increment hand count
        -:  582:	}
        -:  583:
      507:  584:	return 0;
        -:  585:}
        -:  586:
      225:  587:int getCost(int cardNumber)
        -:  588:{
      225:  589:	switch (cardNumber)
        -:  590:	{
        -:  591:	case curse:
       21:  592:		return 0;
        -:  593:	case estate:
       17:  594:		return 2;
        -:  595:	case duchy:
       10:  596:		return 5;
        -:  597:	case province:
       10:  598:		return 8;
        -:  599:	case copper:
       22:  600:		return 0;
        -:  601:	case silver:
        9:  602:		return 3;
        -:  603:	case gold:
       11:  604:		return 6;
        -:  605:	case adventurer:
    #####:  606:		return 6;
        -:  607:	case council_room:
    #####:  608:		return 5;
        -:  609:	case feast:
        4:  610:		return 4;
        -:  611:	case gardens:
    #####:  612:		return 4;
        -:  613:	case mine:
    #####:  614:		return 5;
        -:  615:	case remodel:
       10:  616:		return 4;
        -:  617:	case smithy:
       14:  618:		return 4;
        -:  619:	case village:
    #####:  620:		return 3;
        -:  621:	case baron:
       11:  622:		return 4;
        -:  623:	case great_hall:
       17:  624:		return 3;
        -:  625:	case minion:
    #####:  626:		return 5;
        -:  627:	case steward:
        1:  628:		return 3;
        -:  629:	case tribute:
    #####:  630:		return 5;
        -:  631:	case ambassador:
       11:  632:		return 3;
        -:  633:	case cutpurse:
    #####:  634:		return 4;
        -:  635:	case embargo:
       20:  636:		return 2;
        -:  637:	case outpost:
       19:  638:		return 5;
        -:  639:	case salvager:
    #####:  640:		return 4;
        -:  641:	case sea_hag:
        8:  642:		return 4;
        -:  643:	case treasure_map:
       10:  644:		return 4;
        -:  645:	}
        -:  646:
    #####:  647:	return -1;
        -:  648:}
        -:  649:
    #####:  650:void playAdventurer(struct gameState *state, int currentPlayer)
        -:  651:// Reveal cards from deck until 2 Treasure cards are found.  Put those Treasure cards in the hand and discard the rest.
        -:  652:{
    #####:  653:	int drawntreasure = 0;
        -:  654:	int temphand[MAX_HAND];
        -:  655:	int cardDrawn;
    #####:  656:	int z = 0; // this is the counter for the temp hand
        -:  657:
    #####:  658:	while (drawntreasure < 2){
    #####:  659:		if (state->deckCount[currentPlayer] < 1){//if the deck is empty we need to shuffle discard and add to deck
    #####:  660:			shuffle(currentPlayer, state);
        -:  661:		}
    #####:  662:		drawCard(currentPlayer, state);
    #####:  663:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer] - 1];//top card of hand is most recently drawn card.
    #####:  664:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
    #####:  665:			drawntreasure++;
        -:  666:		else{
    #####:  667:			temphand[z] = cardDrawn;
    #####:  668:			state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####:  669:			z++;
        -:  670:		}
        -:  671:	}
    #####:  672:	while (z - 1 >= 0){
    #####:  673:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; // discard all cards in play that have been drawn
    #####:  674:		z = z - 1;
        -:  675:	}
    #####:  676:}
        -:  677:
        3:  678:int playRemodel(struct gameState *state, int currentPlayer, int choice1, int choice2, int handPos)
        -:  679://Trash a card in the hand, and gain a card costing up to $2 more than the trashed card
        -:  680:{
        -:  681:	int i;
        3:  682:	int j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  683:
        3:  684:	if ((getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2))
        -:  685:	{
    #####:  686:		return -1;
        -:  687:	}
        -:  688:
        3:  689:	gainCard(choice2, state, 0, currentPlayer);
        -:  690:
        -:  691:	//discard card from hand
        3:  692:	discardCard(handPos, currentPlayer, state, 0);
        -:  693:
        -:  694:	//discard trashed card
        5:  695:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  696:	{
        5:  697:		if (state->hand[currentPlayer][i] == j)
        -:  698:		{
        3:  699:			discardCard(i, currentPlayer, state, 0);
        3:  700:			break;
        -:  701:		}
        -:  702:	}
        -:  703:
        3:  704:	return 0;
        -:  705:}
        -:  706:
        2:  707:void playSmithy(struct gameState *state, int currentPlayer, int handPos)
        -:  708:// Draw 3 cards
        -:  709:{
        -:  710:	int i;
        8:  711:	for (i = 0; i < 3; i++)
        -:  712:	{
        6:  713:		drawCard(currentPlayer, state);
        -:  714:	}
        -:  715:
        -:  716:	//discard card from hand
        2:  717:	discardCard(handPos, currentPlayer, state, 0);
        2:  718:}
        -:  719:
    #####:  720:void playBaron(struct gameState *state, int currentPlayer, int choice1, int handPos)
        -:  721://Add a buy.  OPTION:  Discard an Estate card and gain $4.  Otherwise, gain an Estate card.
        -:  722:{
    #####:  723:	state->numBuys++;//Increase buys by 1!
    #####:  724:	if (choice1 > 0){//Boolean true or going to discard an estate
    #####:  725:		int p = 0;//Iterator for hand!
    #####:  726:		int card_not_discarded = 1;//Flag for discard set!
    #####:  727:		while (card_not_discarded){
    #####:  728:			if (state->hand[currentPlayer][p] == estate){ //Found an estate card!
    #####:  729:				state->coins += 4;//Add 4 coins to the amount of coins
    #####:  730:				state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  731:				state->discardCount[currentPlayer]++;
    #####:  732:				for (; p < state->handCount[currentPlayer]; p++){
    #####:  733:					state->hand[currentPlayer][p] = state->hand[currentPlayer][p + 1];
        -:  734:				}
    #####:  735:				state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  736:				state->handCount[currentPlayer]--;
    #####:  737:				card_not_discarded = 0;//Exit the loop
        -:  738:			}
    #####:  739:			else if (p > state->handCount[currentPlayer]){
        -:  740:				if (DEBUG) {
        -:  741:					printf("No estate cards in your hand, invalid choice\n");
        -:  742:					printf("Must gain an estate if there are any\n");
        -:  743:				}
    #####:  744:				if (supplyCount(estate, state) > 0){
    #####:  745:					gainCard(estate, state, 1, currentPlayer);
    #####:  746:					state->supplyCount[estate]--;//Decrement estates
    #####:  747:					if (supplyCount(estate, state) == 0){
    #####:  748:						isGameOver(state);
        -:  749:					}
        -:  750:				}
    #####:  751:				card_not_discarded = 0;//Exit the loop
        -:  752:			}
        -:  753:
        -:  754:			else{
    #####:  755:				p++;//Next card
        -:  756:			}
        -:  757:		}
        -:  758:	}
        -:  759:
        -:  760:	else{
    #####:  761:		if (supplyCount(estate, state) > 0){
    #####:  762:			gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  763:			state->supplyCount[estate]--;//Decrement Estates
    #####:  764:			if (supplyCount(estate, state) == 0){
    #####:  765:				isGameOver(state);
        -:  766:			}
        -:  767:		}
        -:  768:	}
    #####:  769:}
        -:  770:
        3:  771:int playTreasureMap(struct gameState *state, int currentPlayer, int handPos)
        -:  772://Trashing two treasure map cards from the hand = four gold on top of the deck.
        -:  773:{
        -:  774:	int i;
        -:  775:	int index;
        -:  776:
        -:  777:	//search hand for another treasure_map
       18:  778:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  779:	{
       15:  780:		if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -:  781:		{
    #####:  782:			index = i;
    #####:  783:			break;
        -:  784:		}
        -:  785:	}
        3:  786:	if (index > -1)
        -:  787:	{
        -:  788:		//trash both treasure cards
        3:  789:		discardCard(handPos, currentPlayer, state, 1);
        3:  790:		discardCard(index, currentPlayer, state, 1);
        -:  791:
        -:  792:		//gain 4 Gold cards
       15:  793:		for (i = 0; i < 4; i++)
        -:  794:		{
       12:  795:			gainCard(gold, state, 1, currentPlayer);
        -:  796:		}
        -:  797:
        -:  798:		//return success
        3:  799:		return 1;
        -:  800:	}
        -:  801:
        -:  802:	//no second treasure_map found in hand
    #####:  803:	return -1;
        -:  804:}
        -:  805:
       29:  806:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  807:{
        -:  808:	int i;
        -:  809:	int j;
        -:  810:	int k;
        -:  811:	//int x;  //Unused after while loop removed from feast.
       29:  812:	int currentPlayer = whoseTurn(state);
       29:  813:	int nextPlayer = currentPlayer + 1;
        -:  814:	int temphand[MAX_HAND];
        -:  815:
       29:  816:	int tributeRevealedCards[2] = { -1, -1 };
        -:  817:
       29:  818:	if (nextPlayer > (state->numPlayers - 1)){
       15:  819:		nextPlayer = 0;
        -:  820:	}
        -:  821:
        -:  822:	//uses switch to select card and perform actions
       29:  823:	switch (card)
        -:  824:	{
        -:  825:	case adventurer:
        -:  826:
    #####:  827:		playAdventurer(state, currentPlayer);
    #####:  828:		return 0;
        -:  829:
        -:  830:	case council_room:
        -:  831:		//+4 Cards
    #####:  832:		for (i = 0; i < 4; i++)
        -:  833:		{
    #####:  834:			drawCard(currentPlayer, state);
        -:  835:		}
        -:  836:
        -:  837:		//+1 Buy
    #####:  838:		state->numBuys++;
        -:  839:
        -:  840:		//Each other player draws a card
    #####:  841:		for (i = 0; i < state->numPlayers; i++)
        -:  842:		{
    #####:  843:			if (i != currentPlayer)
        -:  844:			{
    #####:  845:				drawCard(i, state);
        -:  846:			}
        -:  847:		}
        -:  848:
        -:  849:		//put played card in played card pile
    #####:  850:		discardCard(handPos, currentPlayer, state, 0);
        -:  851:
    #####:  852:		return 0;
        -:  853:
        -:  854:	case feast:
        -:  855:		//gain card with cost up to 5
        -:  856:		//Backup hand
        7:  857:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
        6:  858:			temphand[i] = state->hand[currentPlayer][i];//Backup card
        6:  859:			state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  860:		}
        -:  861:		//Backup hand
        -:  862:
        -:  863:		//Update Coins for Buy
        1:  864:		updateCoins(currentPlayer, state, 5);
        -:  865://		x = 1;//Condition to loop on
        -:  866://		while (x == 1) {//Buy one card
        1:  867:			if (supplyCount(choice1, state) <= 0){
        -:  868:				if (DEBUG)
        -:  869:					printf("None of that card left, sorry!\n");
        -:  870:
        -:  871:				if (DEBUG){
        -:  872:					printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  873:				}
        -:  874:			}
        1:  875:			else if (state->coins < getCost(choice1)){
    #####:  876:				printf("That card is too expensive!\n");
        -:  877:
        -:  878:				if (DEBUG){
        -:  879:					printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  880:				}
        -:  881:			}
        -:  882:			else{
        -:  883:
        -:  884:				if (DEBUG){
        -:  885:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  886:				}
        -:  887:
        1:  888:				gainCard(choice1, state, 0, currentPlayer);//Gain the card
        -:  889://				x = 0;//No more buying cards
        -:  890:
        -:  891:				if (DEBUG){
        -:  892:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  893:				}
        -:  894:
        -:  895:			}
        -:  896://		}
        -:  897:
        -:  898:		//Reset Hand
        7:  899:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
        6:  900:			state->hand[currentPlayer][i] = temphand[i];
        6:  901:			temphand[i] = -1;
        -:  902:		}
        -:  903:		//Reset Hand
        -:  904:
        1:  905:		return 0;
        -:  906:
        -:  907:	case gardens:
    #####:  908:		return -1;
        -:  909:
        -:  910:	case mine:
    #####:  911:		j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  912:
    #####:  913:		if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  914:		{
    #####:  915:			return -1;
        -:  916:		}
        -:  917:
    #####:  918:		if (choice2 > treasure_map || choice2 < curse)
        -:  919:		{
    #####:  920:			return -1;
        -:  921:		}
        -:  922:
    #####:  923:		if ((getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2))
        -:  924:		{
    #####:  925:			return -1;
        -:  926:		}
        -:  927:
    #####:  928:		gainCard(choice2, state, 2, currentPlayer);
        -:  929:
        -:  930:		//discard card from hand
    #####:  931:		discardCard(handPos, currentPlayer, state, 0);
        -:  932:
        -:  933:		//discard trashed card
    #####:  934:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  935:		{
    #####:  936:			if (state->hand[currentPlayer][i] == j)
        -:  937:			{
    #####:  938:				discardCard(i, currentPlayer, state, 0);
    #####:  939:				break;
        -:  940:			}
        -:  941:		}
        -:  942:
    #####:  943:		return 0;
        -:  944:
        -:  945:	case remodel:
        -:  946:
        3:  947:		return playRemodel(state, currentPlayer, choice1, choice2, handPos);
        -:  948:
        -:  949:	case smithy:
        -:  950:
        2:  951:		playSmithy(state, currentPlayer, handPos);
        2:  952:		return 0;
        -:  953:
        -:  954:	case village:
        -:  955:		//+1 Card
    #####:  956:		drawCard(currentPlayer, state);
        -:  957:
        -:  958:		//+2 Actions
    #####:  959:		state->numActions = state->numActions + 2;
        -:  960:
        -:  961:		//discard played card from hand
    #####:  962:		discardCard(handPos, currentPlayer, state, 0);
    #####:  963:		return 0;
        -:  964:
        -:  965:	case baron:
        -:  966:
    #####:  967:		playBaron(state, currentPlayer, choice1, handPos);
    #####:  968:		return 0;
        -:  969:
        -:  970:	case great_hall:
        -:  971:		//+1 Card
        6:  972:		drawCard(currentPlayer, state);
        -:  973:
        -:  974:		//+1 Actions
        6:  975:		state->numActions++;
        -:  976:
        -:  977:		//discard card from hand
        6:  978:		discardCard(handPos, currentPlayer, state, 0);
        6:  979:		return 0;
        -:  980:
        -:  981:	case minion:
        -:  982:		//+1 action
    #####:  983:		state->numActions++;
        -:  984:
        -:  985:		//discard card from hand
    #####:  986:		discardCard(handPos, currentPlayer, state, 0);
        -:  987:
    #####:  988:		if (choice1)		//+2 coins
        -:  989:		{
    #####:  990:			state->coins = state->coins + 2;
        -:  991:		}
        -:  992:
    #####:  993:		else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  994:		{
        -:  995:			//discard hand
    #####:  996:			while (numHandCards(state) > 0)
        -:  997:			{
    #####:  998:				discardCard(handPos, currentPlayer, state, 0);
        -:  999:			}
        -: 1000:
        -: 1001:			//draw 4
    #####: 1002:			for (i = 0; i < 4; i++)
        -: 1003:			{
    #####: 1004:				drawCard(currentPlayer, state);
        -: 1005:			}
        -: 1006:
        -: 1007:			//other players discard hand and redraw if hand size > 4
    #####: 1008:			for (i = 0; i < state->numPlayers; i++)
        -: 1009:			{
    #####: 1010:				if (i != currentPlayer)
        -: 1011:				{
    #####: 1012:					if (state->handCount[i] > 4)
        -: 1013:					{
        -: 1014:						//discard hand
    #####: 1015:						while (state->handCount[i] > 0)
        -: 1016:						{
    #####: 1017:							discardCard(handPos, i, state, 0);
        -: 1018:						}
        -: 1019:
        -: 1020:						//draw 4
    #####: 1021:						for (j = 0; j < 4; j++)
        -: 1022:						{
    #####: 1023:							drawCard(i, state);
        -: 1024:						}
        -: 1025:					}
        -: 1026:				}
        -: 1027:			}
        -: 1028:
        -: 1029:		}
    #####: 1030:		return 0;
        -: 1031:
        -: 1032:	case steward:
    #####: 1033:		if (choice1 == 1)
        -: 1034:		{
        -: 1035:			//+2 cards
    #####: 1036:			drawCard(currentPlayer, state);
    #####: 1037:			drawCard(currentPlayer, state);
        -: 1038:		}
    #####: 1039:		else if (choice1 == 2)
        -: 1040:		{
        -: 1041:			//+2 coins
    #####: 1042:			state->coins = state->coins + 2;
        -: 1043:		}
        -: 1044:		else
        -: 1045:		{
        -: 1046:			//trash 2 cards in hand
    #####: 1047:			discardCard(choice2, currentPlayer, state, 1);
    #####: 1048:			discardCard(choice3, currentPlayer, state, 1);
        -: 1049:		}
        -: 1050:
        -: 1051:		//discard card from hand
    #####: 1052:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1053:		return 0;
        -: 1054:
        -: 1055:	case tribute:
    #####: 1056:		if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####: 1057:			if (state->deckCount[nextPlayer] > 0){
    #####: 1058:				tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1059:				state->deckCount[nextPlayer]--;
        -: 1060:			}
    #####: 1061:			else if (state->discardCount[nextPlayer] > 0){
    #####: 1062:				tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer] - 1];
    #####: 1063:				state->discardCount[nextPlayer]--;
        -: 1064:			}
        -: 1065:			else{
        -: 1066:				//No Card to Reveal
        -: 1067:				if (DEBUG){
        -: 1068:					printf("No cards to reveal\n");
        -: 1069:				}
        -: 1070:			}
        -: 1071:		}
        -: 1072:
        -: 1073:		else{
    #####: 1074:			if (state->deckCount[nextPlayer] == 0){
    #####: 1075:				for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####: 1076:					state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1077:					state->deckCount[nextPlayer]++;
    #####: 1078:					state->discard[nextPlayer][i] = -1;
    #####: 1079:					state->discardCount[nextPlayer]--;
        -: 1080:				}
        -: 1081:
    #####: 1082:				shuffle(nextPlayer, state);//Shuffle the deck
        -: 1083:			}
    #####: 1084:			tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1085:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1086:			state->deckCount[nextPlayer]--;
    #####: 1087:			tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1088:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1089:			state->deckCount[nextPlayer]--;
        -: 1090:		}
        -: 1091:
    #####: 1092:		if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
    #####: 1093:			state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1094:			state->playedCardCount++;
    #####: 1095:			tributeRevealedCards[1] = -1;
        -: 1096:		}
        -: 1097:
    #####: 1098:		for (i = 0; i <= 2; i++){
    #####: 1099:			if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
    #####: 1100:				state->coins += 2;
        -: 1101:			}
        -: 1102:
    #####: 1103:			else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
    #####: 1104:				drawCard(currentPlayer, state);
    #####: 1105:				drawCard(currentPlayer, state);
        -: 1106:			}
        -: 1107:			else{//Action Card
    #####: 1108:				state->numActions = state->numActions + 2;
        -: 1109:			}
        -: 1110:		}
        -: 1111:
    #####: 1112:		return 0;
        -: 1113:
        -: 1114:	case ambassador:
        1: 1115:		j = 0;		//used to check if player has enough cards to discard
        -: 1116:
        1: 1117:		if (choice2 > 2 || choice2 < 0)
        -: 1118:		{
    #####: 1119:			return -1;
        -: 1120:		}
        -: 1121:
        1: 1122:		if (choice1 == handPos)
        -: 1123:		{
    #####: 1124:			return -1;
        -: 1125:		}
        -: 1126:
        6: 1127:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1128:		{
        5: 1129:			if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1130:			{
        1: 1131:				j++;
        -: 1132:			}
        -: 1133:		}
        1: 1134:		if (j < choice2)
        -: 1135:		{
    #####: 1136:			return -1;
        -: 1137:		}
        -: 1138:
        -: 1139:		if (DEBUG)
        -: 1140:			printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1141:
        -: 1142:		//increase supply count for choosen card by amount being discarded
        1: 1143:		state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1144:
        -: 1145:		//each other player gains a copy of revealed card
        3: 1146:		for (i = 0; i < state->numPlayers; i++)
        -: 1147:		{
        2: 1148:			if (i != currentPlayer)
        -: 1149:			{
        1: 1150:				gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1151:			}
        -: 1152:		}
        -: 1153:
        -: 1154:		//discard played card from hand
        1: 1155:		discardCard(handPos, currentPlayer, state, 0);
        -: 1156:
        -: 1157:		//trash copies of cards returned to supply
        1: 1158:		for (j = 0; j < choice2; j++)
        -: 1159:		{
    #####: 1160:			for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1161:			{
    #####: 1162:				if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1163:				{
    #####: 1164:					discardCard(i, currentPlayer, state, 1);
    #####: 1165:					break;
        -: 1166:				}
        -: 1167:			}
        -: 1168:		}
        -: 1169:
        1: 1170:		return 0;
        -: 1171:
        -: 1172:	case cutpurse:
        -: 1173:
    #####: 1174:		updateCoins(currentPlayer, state, 2);
    #####: 1175:		for (i = 0; i < state->numPlayers; i++)
        -: 1176:		{
    #####: 1177:			if (i != currentPlayer)
        -: 1178:			{
    #####: 1179:				for (j = 0; j < state->handCount[i]; j++)
        -: 1180:				{
    #####: 1181:					if (state->hand[i][j] == copper)
        -: 1182:					{
    #####: 1183:						discardCard(j, i, state, 0);
    #####: 1184:						break;
        -: 1185:					}
    #####: 1186:					if (j == state->handCount[i])
        -: 1187:					{
    #####: 1188:						for (k = 0; k < state->handCount[i]; k++)
        -: 1189:						{
        -: 1190:							if (DEBUG)
        -: 1191:								printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1192:						}
    #####: 1193:						break;
        -: 1194:					}
        -: 1195:				}
        -: 1196:
        -: 1197:			}
        -: 1198:
        -: 1199:		}
        -: 1200:
        -: 1201:		//discard played card from hand
    #####: 1202:		discardCard(handPos, currentPlayer, state, 0);
        -: 1203:
    #####: 1204:		return 0;
        -: 1205:
        -: 1206:
        -: 1207:	case embargo:
        -: 1208:		//+2 Coins
       10: 1209:		state->coins = state->coins + 2;
        -: 1210:
        -: 1211:		//see if selected pile is in play
       10: 1212:		if (state->supplyCount[choice1] == -1)
        -: 1213:		{
        4: 1214:			return -1;
        -: 1215:		}
        -: 1216:
        -: 1217:		//add embargo token to selected supply pile
        6: 1218:		state->embargoTokens[choice1]++;
        -: 1219:
        -: 1220:		//trash card
        6: 1221:		discardCard(handPos, currentPlayer, state, 1);
        6: 1222:		return 0;
        -: 1223:
        -: 1224:	case outpost:
        -: 1225:		//set outpost flag
        1: 1226:		state->outpostPlayed++;
        -: 1227:
        -: 1228:		//discard card
        1: 1229:		discardCard(handPos, currentPlayer, state, 0);
        1: 1230:		return 0;
        -: 1231:
        -: 1232:	case salvager:
        -: 1233:		//+1 buy
    #####: 1234:		state->numBuys++;
        -: 1235:
    #####: 1236:		if (choice1)
        -: 1237:		{
        -: 1238:			//gain coins equal to trashed card
    #####: 1239:			state->coins = state->coins + getCost(handCard(choice1, state));
        -: 1240:			//trash card
    #####: 1241:			discardCard(choice1, currentPlayer, state, 1);
        -: 1242:		}
        -: 1243:
        -: 1244:		//discard card
    #####: 1245:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1246:		return 0;
        -: 1247:
        -: 1248:	case sea_hag:
        6: 1249:		for (i = 0; i < state->numPlayers; i++){
        4: 1250:			if (i != currentPlayer){
        2: 1251:				state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
        2: 1252:				state->discardCount[i]++;
        2: 1253:				state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1254:			}
        -: 1255:		}
        2: 1256:		return 0;
        -: 1257:
        -: 1258:	case treasure_map:
        -: 1259:
        3: 1260:		return playTreasureMap(state, currentPlayer, handPos);
        -: 1261:	}
    #####: 1262:	return -1;
        -: 1263:}
        -: 1264:
       28: 1265:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1266:{
        -: 1267:
        -: 1268:	//if card is not trashed, added to Played pile 
       28: 1269:	if (trashFlag < 1)
        -: 1270:	{
        -: 1271:		//add card to played pile
       16: 1272:		state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
       16: 1273:		state->playedCardCount++;
        -: 1274:	}
        -: 1275:
        -: 1276:	//set played card to -1
       28: 1277:	state->hand[currentPlayer][handPos] = -1;
        -: 1278:
        -: 1279:	//remove card from player's hand
       28: 1280:	if (handPos == (state->handCount[currentPlayer] - 1)) 	//last card in hand array is played
        -: 1281:	{
        -: 1282:		//reduce number of cards in hand
        2: 1283:		state->handCount[currentPlayer]--;
        -: 1284:	}
       26: 1285:	else if (state->handCount[currentPlayer] == 1) //only one card in hand
        -: 1286:	{
        -: 1287:		//reduce number of cards in hand
    #####: 1288:		state->handCount[currentPlayer]--;
        -: 1289:	}
        -: 1290:	else
        -: 1291:	{
        -: 1292:		//replace discarded card with last card in hand
       26: 1293:		state->hand[currentPlayer][handPos] = state->hand[currentPlayer][(state->handCount[currentPlayer] - 1)];
        -: 1294:		//set last card to -1
       26: 1295:		state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1296:		//reduce number of cards in hand
       26: 1297:		state->handCount[currentPlayer]--;
        -: 1298:	}
        -: 1299:
       28: 1300:	return 0;
        -: 1301:}
        -: 1302:
       97: 1303:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1304:{
        -: 1305:	//Note: supplyPos is enum of choosen card
        -: 1306:
        -: 1307:	//check if supply pile is empty (0) or card is not used in game (-1)
       97: 1308:	if (supplyCount(supplyPos, state) < 1)
        -: 1309:	{
        1: 1310:		return -1;
        -: 1311:	}
        -: 1312:
        -: 1313:	//added card for [whoseTurn] current player:
        -: 1314:	// toFlag = 0 : add to discard
        -: 1315:	// toFlag = 1 : add to deck
        -: 1316:	// toFlag = 2 : add to hand
        -: 1317:
       96: 1318:	if (toFlag == 1)
        -: 1319:	{
       12: 1320:		state->deck[player][state->deckCount[player]] = supplyPos;
       12: 1321:		state->deckCount[player]++;
        -: 1322:	}
       84: 1323:	else if (toFlag == 2)
        -: 1324:	{
    #####: 1325:		state->hand[player][state->handCount[player]] = supplyPos;
    #####: 1326:		state->handCount[player]++;
        -: 1327:	}
        -: 1328:	else
        -: 1329:	{
       84: 1330:		state->discard[player][state->discardCount[player]] = supplyPos;
       84: 1331:		state->discardCount[player]++;
        -: 1332:	}
        -: 1333:
        -: 1334:	//decrease number in supply pile
       96: 1335:	state->supplyCount[supplyPos]--;
        -: 1336:
       96: 1337:	return 0;
        -: 1338:}
        -: 1339:
      125: 1340:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1341:{
        -: 1342:	int i;
        -: 1343:
        -: 1344:	//reset coin count
      125: 1345:	state->coins = 0;
        -: 1346:
        -: 1347:	//add coins for each Treasure card in player's hand
      734: 1348:	for (i = 0; i < state->handCount[player]; i++)
        -: 1349:	{
      609: 1350:		if (state->hand[player][i] == copper)
        -: 1351:		{
      217: 1352:			state->coins += 1;
        -: 1353:		}
      392: 1354:		else if (state->hand[player][i] == silver)
        -: 1355:		{
        7: 1356:			state->coins += 2;
        -: 1357:		}
      385: 1358:		else if (state->hand[player][i] == gold)
        -: 1359:		{
       63: 1360:			state->coins += 3;
        -: 1361:		}
        -: 1362:	}
        -: 1363:
        -: 1364:	//add bonus
      125: 1365:	state->coins += bonus;
        -: 1366:
      125: 1367:	return 0;
        -: 1368:}
        -: 1369:
        -: 1370:
        -: 1371://end of dominion.c
File 'dominion.c'
Lines executed:71.45% of 557
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
     3011:    8:int compare(const void* a, const void* b) {
     3011:    9:	if (*(int*)a > *(int*)b)
     1048:   10:		return 1;
     1963:   11:	if (*(int*)a < *(int*)b)
      906:   12:		return -1;
     1057:   13:	return 0;
        -:   14:}
        -:   15:
        4:   16:struct gameState* newGame() {
        4:   17:	struct gameState* g = malloc(sizeof(struct gameState));
        4:   18:	return g;
        -:   19:}
        -:   20:
       36:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:	int k8, int k9, int k10) {
       36:   23:	int* k = malloc(10 * sizeof(int));
       36:   24:	k[0] = k1;
       36:   25:	k[1] = k2;
       36:   26:	k[2] = k3;
       36:   27:	k[3] = k4;
       36:   28:	k[4] = k5;
       36:   29:	k[5] = k6;
       36:   30:	k[6] = k7;
       36:   31:	k[7] = k8;
       36:   32:	k[8] = k9;
       36:   33:	k[9] = k10;
       36:   34:	return k;
        -:   35:}
        -:   36:
       36:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		struct gameState *state) {
        -:   39:
        -:   40:	int i;
        -:   41:	int j;
        -:   42:	int it;
        -:   43:	//set up random number generator
       36:   44:	SelectStream(1);
       36:   45:	PutSeed((long)randomSeed);
        -:   46:
        -:   47:	//check number of players
       36:   48:	if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:	{
    #####:   50:		return -1;
        -:   51:	}
        -:   52:
        -:   53:	//set number of players
       36:   54:	state->numPlayers = numPlayers;
        -:   55:
        -:   56:	//check selected kingdom cards are different
      101:   57:	for (i = 0; i < 10; i++)
        -:   58:	{
      953:   59:		for (j = 0; j < 10; j++)
        -:   60:		{
      888:   61:			if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:			{
       34:   63:				return -1;
        -:   64:			}
        -:   65:		}
        -:   66:	}
        -:   67:
        -:   68:
        -:   69:	//initialize supply
        -:   70:	///////////////////////////////
        -:   71:
        -:   72:	//set number of Curse cards
        2:   73:	if (numPlayers == 2)
        -:   74:	{
    #####:   75:		state->supplyCount[curse] = 10;
        -:   76:	}
        2:   77:	else if (numPlayers == 3)
        -:   78:	{
        2:   79:		state->supplyCount[curse] = 20;
        -:   80:	}
        -:   81:	else
        -:   82:	{
    #####:   83:		state->supplyCount[curse] = 30;
        -:   84:	}
        -:   85:
        -:   86:	//set number of Victory cards
        2:   87:	if (numPlayers == 2)
        -:   88:	{
    #####:   89:		state->supplyCount[estate] = 8;
    #####:   90:		state->supplyCount[duchy] = 8;
    #####:   91:		state->supplyCount[province] = 8;
        -:   92:	}
        -:   93:	else
        -:   94:	{
        2:   95:		state->supplyCount[estate] = 12;
        2:   96:		state->supplyCount[duchy] = 12;
        2:   97:		state->supplyCount[province] = 12;
        -:   98:	}
        -:   99:
        -:  100:	//set number of Treasure cards
        2:  101:	state->supplyCount[copper] = 60 - (7 * numPlayers);
        2:  102:	state->supplyCount[silver] = 40;
        2:  103:	state->supplyCount[gold] = 30;
        -:  104:
        -:  105:	//set number of Kingdom cards
       42:  106:	for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:	{
      330:  108:		for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:		{
      310:  110:			if (kingdomCards[j] == i)
        -:  111:			{
        -:  112:				//check if card is a 'Victory' Kingdom card
       20:  113:				if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:				{
        2:  115:					if (numPlayers == 2){
    #####:  116:						state->supplyCount[i] = 8;
        -:  117:					}
        1:  118:					else{ state->supplyCount[i] = 12; }
        -:  119:				}
        -:  120:				else
        -:  121:				{
       19:  122:					state->supplyCount[i] = 10;
        -:  123:				}
       20:  124:				break;
        -:  125:			}
        -:  126:			else    //card is not in the set choosen for the game
        -:  127:			{
      290:  128:				state->supplyCount[i] = -1;
        -:  129:			}
        -:  130:		}
        -:  131:
        -:  132:	}
        -:  133:
        -:  134:	////////////////////////
        -:  135:	//supply intilization complete
        -:  136:
        -:  137:	//set player decks
        8:  138:	for (i = 0; i < numPlayers; i++)
        -:  139:	{
        6:  140:		state->deckCount[i] = 0;
       24:  141:		for (j = 0; j < 3; j++)
        -:  142:		{
       18:  143:			state->deck[i][j] = estate;
       18:  144:			state->deckCount[i]++;
        -:  145:		}
       48:  146:		for (j = 3; j < 10; j++)
        -:  147:		{
       42:  148:			state->deck[i][j] = copper;
       42:  149:			state->deckCount[i]++;
        -:  150:		}
        -:  151:	}
        -:  152:
        -:  153:	//shuffle player decks
        8:  154:	for (i = 0; i < numPlayers; i++)
        -:  155:	{
        6:  156:		if (shuffle(i, state) < 0)
        -:  157:		{
    #####:  158:			return -1;
        -:  159:		}
        -:  160:	}
        -:  161:
        -:  162:	//draw player hands
        8:  163:	for (i = 0; i < numPlayers; i++)
        -:  164:	{
        -:  165:		//initialize hand size to zero
        6:  166:		state->handCount[i] = 0;
        6:  167:		state->discardCount[i] = 0;
        -:  168:		//draw 5 cards
        -:  169:		// for (j = 0; j < 5; j++)
        -:  170:		//	{
        -:  171:		//	  drawCard(i, state);
        -:  172:		//	}
        -:  173:	}
        -:  174:
        -:  175:	//set embargo tokens to 0 for all supply piles
       56:  176:	for (i = 0; i <= treasure_map; i++)
        -:  177:	{
       54:  178:		state->embargoTokens[i] = 0;
        -:  179:	}
        -:  180:
        -:  181:	//initialize first player's turn
        2:  182:	state->outpostPlayed = 0;
        2:  183:	state->phase = 0;
        2:  184:	state->numActions = 1;
        2:  185:	state->numBuys = 1;
        2:  186:	state->playedCardCount = 0;
        2:  187:	state->whoseTurn = 0;
        2:  188:	state->handCount[state->whoseTurn] = 0;
        -:  189:	//int it; move to top
        -:  190:
        -:  191:	//Moved draw cards to here, only drawing at the start of a turn
       12:  192:	for (it = 0; it < 5; it++){
       10:  193:		drawCard(state->whoseTurn, state);
        -:  194:	}
        -:  195:
        2:  196:	updateCoins(state->whoseTurn, state, 0);
        -:  197:
        2:  198:	return 0;
        -:  199:}
        -:  200:
       80:  201:int shuffle(int player, struct gameState *state) {
        -:  202:
        -:  203:
        -:  204:	int newDeck[MAX_DECK];
       80:  205:	int newDeckPos = 0;
        -:  206:	int card;
        -:  207:	int i;
        -:  208:
       80:  209:	if (state->deckCount[player] < 1)
    #####:  210:		return -1;
       80:  211:	qsort((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
        -:  212:	/* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
     1535:  214:	while (state->deckCount[player] > 0) {
     1375:  215:		card = floor(Random() * state->deckCount[player]);
     1375:  216:		newDeck[newDeckPos] = state->deck[player][card];
     1375:  217:		newDeckPos++;
     7813:  218:		for (i = card; i < state->deckCount[player] - 1; i++) {
     6438:  219:			state->deck[player][i] = state->deck[player][i + 1];
        -:  220:		}
     1375:  221:		state->deckCount[player]--;
        -:  222:	}
     1455:  223:	for (i = 0; i < newDeckPos; i++) {
     1375:  224:		state->deck[player][i] = newDeck[i];
     1375:  225:		state->deckCount[player]++;
        -:  226:	}
        -:  227:
       80:  228:	return 0;
        -:  229:}
        -:  230:
     1177:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state)
        -:  232:{
        -:  233:	int card;
     1177:  234:	int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:	//check if it is the right phase
     1177:  237:	if (state->phase != 0)
        -:  238:	{
      195:  239:		return -1;
        -:  240:	}
        -:  241:
        -:  242:	//check if player has enough actions
      982:  243:	if (state->numActions < 1)
        -:  244:	{
       28:  245:		return -1;
        -:  246:	}
        -:  247:
        -:  248:	//get card played
      954:  249:	card = handCard(handPos, state);
        -:  250:
        -:  251:	//check if selected card is an action
      954:  252:	if (card < adventurer || card > treasure_map)
        -:  253:	{
      881:  254:		return -1;
        -:  255:	}
        -:  256:
        -:  257:	//play card
       73:  258:	if (cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0)
        -:  259:	{
       22:  260:		return -1;
        -:  261:	}
        -:  262:
        -:  263:	//reduce number of actions
       51:  264:	state->numActions--;
        -:  265:
        -:  266:	//update coins (Treasure cards may be added with card draws)
       51:  267:	updateCoins(state->whoseTurn, state, coin_bonus);
        -:  268:
       51:  269:	return 0;
        -:  270:}
        -:  271:
     1204:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:	int who;
        -:  274:	if (DEBUG){
        -:  275:		printf("Entering buyCard...\n");
        -:  276:	}
        -:  277:
        -:  278:	// I don't know what to do about the phase thing.
        -:  279:
     1204:  280:	who = state->whoseTurn;
        -:  281:
     1204:  282:	if (state->numBuys < 1){
        -:  283:		if (DEBUG)
        -:  284:			printf("You do not have any buys left\n");
      208:  285:		return -1;
        -:  286:	}
      996:  287:	else if (supplyCount(supplyPos, state) < 1){
        -:  288:		if (DEBUG)
        -:  289:			printf("There are not any of that type of card left\n");
      402:  290:		return -1;
        -:  291:	}
      594:  292:	else if (state->coins < getCost(supplyPos)){
        -:  293:		if (DEBUG)
        -:  294:			printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
      387:  295:		return -1;
        -:  296:	}
        -:  297:	else {
      207:  298:		state->phase = 1;
        -:  299:		//state->supplyCount[supplyPos]--;
      207:  300:		gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  301:
      207:  302:		state->coins = (state->coins) - (getCost(supplyPos));
      207:  303:		state->numBuys--;
        -:  304:		if (DEBUG)
        -:  305:			printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  306:	}
        -:  307:
        -:  308:	//state->discard[who][state->discardCount[who]] = supplyPos;
        -:  309:	//state->discardCount[who]++;
        -:  310:
      207:  311:	return 0;
        -:  312:}
        -:  313:
    #####:  314:int numHandCards(struct gameState *state) {
    #####:  315:	return state->handCount[whoseTurn(state)];
        -:  316:}
        -:  317:
      957:  318:int handCard(int handPos, struct gameState *state) {
      957:  319:	int currentPlayer = whoseTurn(state);
      957:  320:	return state->hand[currentPlayer][handPos];
        -:  321:}
        -:  322:
     1219:  323:int supplyCount(int card, struct gameState *state) {
     1219:  324:	return state->supplyCount[card];
        -:  325:}
        -:  326:
        1:  327:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  328:	int i;
        1:  329:	int count = 0;
        -:  330:
       24:  331:	for (i = 0; i < state->deckCount[player]; i++)
        -:  332:	{
       23:  333:		if (state->deck[player][i] == card) count++;
        -:  334:	}
        -:  335:
        1:  336:	for (i = 0; i < state->handCount[player]; i++)
        -:  337:	{
    #####:  338:		if (state->hand[player][i] == card) count++;
        -:  339:	}
        -:  340:
       13:  341:	for (i = 0; i < state->discardCount[player]; i++)
        -:  342:	{
       12:  343:		if (state->discard[player][i] == card) count++;
        -:  344:	}
        -:  345:
        1:  346:	return count;
        -:  347:}
        -:  348:
     1272:  349:int whoseTurn(struct gameState *state) {
     1272:  350:	return state->whoseTurn;
        -:  351:}
        -:  352:
      242:  353:int endTurn(struct gameState *state) {
        -:  354:	int k;
        -:  355:	int i;
      242:  356:	int currentPlayer = whoseTurn(state);
        -:  357:
        -:  358:	//Discard hand
     1414:  359:	for (i = 0; i < state->handCount[currentPlayer]; i++){
     1172:  360:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
     1172:  361:		state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  362:	}
      242:  363:	state->handCount[currentPlayer] = 0;//Reset hand count
        -:  364:
        -:  365:	//Code for determining the player
      242:  366:	if (currentPlayer < (state->numPlayers - 1)){
      162:  367:		state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  368:	}
        -:  369:	else{
       80:  370:		state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  371:	}
        -:  372:
      242:  373:	state->outpostPlayed = 0;
      242:  374:	state->phase = 0;
      242:  375:	state->numActions = 1;
      242:  376:	state->coins = 0;
      242:  377:	state->numBuys = 1;
      242:  378:	state->playedCardCount = 0;
      242:  379:	state->handCount[state->whoseTurn] = 0;
        -:  380:
        -:  381:	//int k; move to top
        -:  382:	//Next player draws hand
     1452:  383:	for (k = 0; k < 5; k++){
     1210:  384:		drawCard(state->whoseTurn, state);//Draw a card
        -:  385:	}
        -:  386:
        -:  387:	//Update money
      242:  388:	updateCoins(state->whoseTurn, state, 0);
        -:  389:
      242:  390:	return 0;
        -:  391:}
        -:  392:
     3574:  393:int isGameOver(struct gameState *state) {
        -:  394:	int i;
        -:  395:	int j;
        -:  396:
        -:  397:	//if stack of Province cards is empty, the game ends
     3574:  398:	if (state->supplyCount[province] == 0)
        -:  399:	{
    #####:  400:		return 1;
        -:  401:	}
        -:  402:
        -:  403:	//if three supply pile are at 0, the game ends
     3574:  404:	j = 0;
    92924:  405:	for (i = 0; i < 25; i++)
        -:  406:	{
    89350:  407:		if (state->supplyCount[i] == 0)
        -:  408:		{
     2565:  409:			j++;
        -:  410:		}
        -:  411:	}
     3574:  412:	if (j >= 3)
        -:  413:	{
        2:  414:		return 1;
        -:  415:	}
        -:  416:
     3572:  417:	return 0;
        -:  418:}
        -:  419:
        6:  420:int scoreFor(int player, struct gameState *state) {
        -:  421:
        -:  422:	int i;
        6:  423:	int score = 0;
        -:  424:	//score from hand
       16:  425:	for (i = 0; i < state->handCount[player]; i++)
        -:  426:	{
       10:  427:		if (state->hand[player][i] == curse) { score = score - 1; };
       10:  428:		if (state->hand[player][i] == estate) { score = score + 1; };
       10:  429:		if (state->hand[player][i] == duchy) { score = score + 3; };
       10:  430:		if (state->hand[player][i] == province) { score = score + 6; };
       10:  431:		if (state->hand[player][i] == great_hall) { score = score + 1; };
       10:  432:		if (state->hand[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  433:	}
        -:  434:
        -:  435:	//score from discard
       90:  436:	for (i = 0; i < state->discardCount[player]; i++)
        -:  437:	{
       84:  438:		if (state->discard[player][i] == curse) { score = score - 1; };
       84:  439:		if (state->discard[player][i] == estate) { score = score + 1; };
       84:  440:		if (state->discard[player][i] == duchy) { score = score + 3; };
       84:  441:		if (state->discard[player][i] == province) { score = score + 6; };
       84:  442:		if (state->discard[player][i] == great_hall) { score = score + 1; };
       84:  443:		if (state->discard[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  444:	}
        -:  445:
        -:  446:	//score from deck
       90:  447:	for (i = 0; i < state->discardCount[player]; i++)
        -:  448:	{
       84:  449:		if (state->deck[player][i] == curse) { score = score - 1; };
       84:  450:		if (state->deck[player][i] == estate) { score = score + 1; };
       84:  451:		if (state->deck[player][i] == duchy) { score = score + 3; };
       84:  452:		if (state->deck[player][i] == province) { score = score + 6; };
       84:  453:		if (state->deck[player][i] == great_hall) { score = score + 1; };
       84:  454:		if (state->deck[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  455:	}
        -:  456:
        6:  457:	return score;
        -:  458:}
        -:  459:
    #####:  460:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  461:	int i;
        -:  462:	int j;
        -:  463:	int highScore;
        -:  464:	int currentPlayer;
        -:  465:
        -:  466:	//get score for each player
    #####:  467:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  468:	{
        -:  469:		//set unused player scores to -9999
    #####:  470:		if (i >= state->numPlayers)
        -:  471:		{
    #####:  472:			players[i] = -9999;
        -:  473:		}
        -:  474:		else
        -:  475:		{
    #####:  476:			players[i] = scoreFor(i, state);
        -:  477:		}
        -:  478:	}
        -:  479:
        -:  480:	//find highest score
    #####:  481:	j = 0;
    #####:  482:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  483:	{
    #####:  484:		if (players[i] > players[j])
        -:  485:		{
    #####:  486:			j = i;
        -:  487:		}
        -:  488:	}
    #####:  489:	highScore = players[j];
        -:  490:
        -:  491:	//add 1 to players who had less turns
    #####:  492:	currentPlayer = whoseTurn(state);
    #####:  493:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  494:	{
    #####:  495:		if (players[i] == highScore && i > currentPlayer)
        -:  496:		{
    #####:  497:			players[i]++;
        -:  498:		}
        -:  499:	}
        -:  500:
        -:  501:	//find new highest score
    #####:  502:	j = 0;
    #####:  503:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  504:	{
    #####:  505:		if (players[i] > players[j])
        -:  506:		{
    #####:  507:			j = i;
        -:  508:		}
        -:  509:	}
    #####:  510:	highScore = players[j];
        -:  511:
        -:  512:	//set winners in array to 1 and rest to 0
    #####:  513:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  514:	{
    #####:  515:		if (players[i] == highScore)
        -:  516:		{
    #####:  517:			players[i] = 1;
        -:  518:		}
        -:  519:		else
        -:  520:		{
    #####:  521:			players[i] = 0;
        -:  522:		}
        -:  523:	}
        -:  524:
    #####:  525:	return 0;
        -:  526:}
        -:  527:
     1254:  528:int drawCard(int player, struct gameState *state)
        -:  529:{
        -:  530:	int count;
        -:  531:	int deckCounter;
     1254:  532:	if (state->deckCount[player] <= 0){//Deck is empty
        -:  533:
        -:  534:		//Step 1 Shuffle the discard pile back into a deck
        -:  535:		int i;
        -:  536:		//Move discard to deck
     1373:  537:		for (i = 0; i < state->discardCount[player]; i++){
     1300:  538:			state->deck[player][i] = state->discard[player][i];
     1300:  539:			state->discard[player][i] = -1;
        -:  540:		}
        -:  541:
       73:  542:		state->deckCount[player] = state->discardCount[player];
       73:  543:		state->discardCount[player] = 0;//Reset discard
        -:  544:
        -:  545:		//Shufffle the deck
       73:  546:		shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  547:
        -:  548:		if (DEBUG){//Debug statements
        -:  549:			printf("Deck count now: %d\n", state->deckCount[player]);
        -:  550:		}
        -:  551:
       73:  552:		state->discardCount[player] = 0;
        -:  553:
        -:  554:		//Step 2 Draw Card
       73:  555:		count = state->handCount[player];//Get current player's hand count
        -:  556:
        -:  557:		if (DEBUG){//Debug statements
        -:  558:			printf("Current hand count: %d\n", count);
        -:  559:		}
        -:  560:
       73:  561:		deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  562:
       73:  563:		if (deckCounter == 0)
    #####:  564:			return -1;
        -:  565:
       73:  566:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
       73:  567:		state->deckCount[player]--;
       73:  568:		state->handCount[player]++;//Increment hand count
        -:  569:	}
        -:  570:
        -:  571:	else{
     1181:  572:		int count = state->handCount[player];//Get current hand count for player
        -:  573:		int deckCounter;
        -:  574:		if (DEBUG){//Debug statements
        -:  575:			printf("Current hand count: %d\n", count);
        -:  576:		}
        -:  577:
     1181:  578:		deckCounter = state->deckCount[player];//Create holder for the deck count
     1181:  579:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
     1181:  580:		state->deckCount[player]--;
     1181:  581:		state->handCount[player]++;//Increment hand count
        -:  582:	}
        -:  583:
     1254:  584:	return 0;
        -:  585:}
        -:  586:
      814:  587:int getCost(int cardNumber)
        -:  588:{
      814:  589:	switch (cardNumber)
        -:  590:	{
        -:  591:	case curse:
       86:  592:		return 0;
        -:  593:	case estate:
       53:  594:		return 2;
        -:  595:	case duchy:
       42:  596:		return 5;
        -:  597:	case province:
       34:  598:		return 8;
        -:  599:	case copper:
       88:  600:		return 0;
        -:  601:	case silver:
       57:  602:		return 3;
        -:  603:	case gold:
       39:  604:		return 6;
        -:  605:	case adventurer:
       23:  606:		return 6;
        -:  607:	case council_room:
       28:  608:		return 5;
        -:  609:	case feast:
    #####:  610:		return 4;
        -:  611:	case gardens:
       13:  612:		return 4;
        -:  613:	case mine:
       19:  614:		return 5;
        -:  615:	case remodel:
       26:  616:		return 4;
        -:  617:	case smithy:
       20:  618:		return 4;
        -:  619:	case village:
       19:  620:		return 3;
        -:  621:	case baron:
       17:  622:		return 4;
        -:  623:	case great_hall:
    #####:  624:		return 3;
        -:  625:	case minion:
       21:  626:		return 5;
        -:  627:	case steward:
       25:  628:		return 3;
        -:  629:	case tribute:
       31:  630:		return 5;
        -:  631:	case ambassador:
    #####:  632:		return 3;
        -:  633:	case cutpurse:
       13:  634:		return 4;
        -:  635:	case embargo:
       54:  636:		return 2;
        -:  637:	case outpost:
       40:  638:		return 5;
        -:  639:	case salvager:
       22:  640:		return 4;
        -:  641:	case sea_hag:
       18:  642:		return 4;
        -:  643:	case treasure_map:
       26:  644:		return 4;
        -:  645:	}
        -:  646:
    #####:  647:	return -1;
        -:  648:}
        -:  649:
    #####:  650:void playAdventurer(struct gameState *state, int currentPlayer)
        -:  651:// Reveal cards from deck until 2 Treasure cards are found.  Put those Treasure cards in the hand and discard the rest.
        -:  652:{
    #####:  653:	int drawntreasure = 0;
        -:  654:	int temphand[MAX_HAND];
        -:  655:	int cardDrawn;
    #####:  656:	int z = 0; // this is the counter for the temp hand
        -:  657:
    #####:  658:	while (drawntreasure < 2){
    #####:  659:		if (state->deckCount[currentPlayer] < 1){//if the deck is empty we need to shuffle discard and add to deck
    #####:  660:			shuffle(currentPlayer, state);
        -:  661:		}
    #####:  662:		drawCard(currentPlayer, state);
    #####:  663:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer] - 1];//top card of hand is most recently drawn card.
    #####:  664:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
    #####:  665:			drawntreasure++;
        -:  666:		else{
    #####:  667:			temphand[z] = cardDrawn;
    #####:  668:			state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####:  669:			z++;
        -:  670:		}
        -:  671:	}
    #####:  672:	while (z - 1 >= 0){
    #####:  673:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; // discard all cards in play that have been drawn
    #####:  674:		z = z - 1;
        -:  675:	}
    #####:  676:}
        -:  677:
        5:  678:int playRemodel(struct gameState *state, int currentPlayer, int choice1, int choice2, int handPos)
        -:  679://Trash a card in the hand, and gain a card costing up to $2 more than the trashed card
        -:  680:{
        -:  681:	int i;
        5:  682:	int j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  683:
        5:  684:	if ((getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2))
        -:  685:	{
        2:  686:		return -1;
        -:  687:	}
        -:  688:
        3:  689:	gainCard(choice2, state, 0, currentPlayer);
        -:  690:
        -:  691:	//discard card from hand
        3:  692:	discardCard(handPos, currentPlayer, state, 0);
        -:  693:
        -:  694:	//discard trashed card
        8:  695:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  696:	{
        7:  697:		if (state->hand[currentPlayer][i] == j)
        -:  698:		{
        2:  699:			discardCard(i, currentPlayer, state, 0);
        2:  700:			break;
        -:  701:		}
        -:  702:	}
        -:  703:
        3:  704:	return 0;
        -:  705:}
        -:  706:
        4:  707:void playSmithy(struct gameState *state, int currentPlayer, int handPos)
        -:  708:// Draw 3 cards
        -:  709:{
        -:  710:	int i;
       16:  711:	for (i = 0; i < 3; i++)
        -:  712:	{
       12:  713:		drawCard(currentPlayer, state);
        -:  714:	}
        -:  715:
        -:  716:	//discard card from hand
        4:  717:	discardCard(handPos, currentPlayer, state, 0);
        4:  718:}
        -:  719:
        2:  720:void playBaron(struct gameState *state, int currentPlayer, int choice1, int handPos)
        -:  721://Add a buy.  OPTION:  Discard an Estate card and gain $4.  Otherwise, gain an Estate card.
        -:  722:{
        2:  723:	state->numBuys++;//Increase buys by 1!
        2:  724:	if (choice1 > 0){//Boolean true or going to discard an estate
        2:  725:		int p = 0;//Iterator for hand!
        2:  726:		int card_not_discarded = 1;//Flag for discard set!
       13:  727:		while (card_not_discarded){
        9:  728:			if (state->hand[currentPlayer][p] == estate){ //Found an estate card!
        1:  729:				state->coins += 4;//Add 4 coins to the amount of coins
        1:  730:				state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
        1:  731:				state->discardCount[currentPlayer]++;
        5:  732:				for (; p < state->handCount[currentPlayer]; p++){
        4:  733:					state->hand[currentPlayer][p] = state->hand[currentPlayer][p + 1];
        -:  734:				}
        1:  735:				state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
        1:  736:				state->handCount[currentPlayer]--;
        1:  737:				card_not_discarded = 0;//Exit the loop
        -:  738:			}
        8:  739:			else if (p > state->handCount[currentPlayer]){
        -:  740:				if (DEBUG) {
        -:  741:					printf("No estate cards in your hand, invalid choice\n");
        -:  742:					printf("Must gain an estate if there are any\n");
        -:  743:				}
        1:  744:				if (supplyCount(estate, state) > 0){
    #####:  745:					gainCard(estate, state, 1, currentPlayer);
    #####:  746:					state->supplyCount[estate]--;//Decrement estates
    #####:  747:					if (supplyCount(estate, state) == 0){
    #####:  748:						isGameOver(state);
        -:  749:					}
        -:  750:				}
        1:  751:				card_not_discarded = 0;//Exit the loop
        -:  752:			}
        -:  753:
        -:  754:			else{
        7:  755:				p++;//Next card
        -:  756:			}
        -:  757:		}
        -:  758:	}
        -:  759:
        -:  760:	else{
    #####:  761:		if (supplyCount(estate, state) > 0){
    #####:  762:			gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  763:			state->supplyCount[estate]--;//Decrement Estates
    #####:  764:			if (supplyCount(estate, state) == 0){
    #####:  765:				isGameOver(state);
        -:  766:			}
        -:  767:		}
        -:  768:	}
        2:  769:}
        -:  770:
        3:  771:int playTreasureMap(struct gameState *state, int currentPlayer, int handPos)
        -:  772://Trashing two treasure map cards from the hand = four gold on top of the deck.
        -:  773:{
        -:  774:	int i;
        -:  775:	int index;
        -:  776:
        -:  777:	//search hand for another treasure_map
       18:  778:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  779:	{
       15:  780:		if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -:  781:		{
    #####:  782:			index = i;
    #####:  783:			break;
        -:  784:		}
        -:  785:	}
        3:  786:	if (index > -1)
        -:  787:	{
        -:  788:		//trash both treasure cards
        3:  789:		discardCard(handPos, currentPlayer, state, 1);
        3:  790:		discardCard(index, currentPlayer, state, 1);
        -:  791:
        -:  792:		//gain 4 Gold cards
       15:  793:		for (i = 0; i < 4; i++)
        -:  794:		{
       12:  795:			gainCard(gold, state, 1, currentPlayer);
        -:  796:		}
        -:  797:
        -:  798:		//return success
        3:  799:		return 1;
        -:  800:	}
        -:  801:
        -:  802:	//no second treasure_map found in hand
    #####:  803:	return -1;
        -:  804:}
        -:  805:
       73:  806:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  807:{
        -:  808:	int i;
        -:  809:	int j;
        -:  810:	int k;
        -:  811:	//int x;  //Unused after while loop removed from feast.
       73:  812:	int currentPlayer = whoseTurn(state);
       73:  813:	int nextPlayer = currentPlayer + 1;
        -:  814:	int temphand[MAX_HAND];
        -:  815:
       73:  816:	int tributeRevealedCards[2] = { -1, -1 };
        -:  817:
       73:  818:	if (nextPlayer > (state->numPlayers - 1)){
       20:  819:		nextPlayer = 0;
        -:  820:	}
        -:  821:
        -:  822:	//uses switch to select card and perform actions
       73:  823:	switch (card)
        -:  824:	{
        -:  825:	case adventurer:
        -:  826:
    #####:  827:		playAdventurer(state, currentPlayer);
    #####:  828:		return 0;
        -:  829:
        -:  830:	case council_room:
        -:  831:		//+4 Cards
       15:  832:		for (i = 0; i < 4; i++)
        -:  833:		{
       12:  834:			drawCard(currentPlayer, state);
        -:  835:		}
        -:  836:
        -:  837:		//+1 Buy
        3:  838:		state->numBuys++;
        -:  839:
        -:  840:		//Each other player draws a card
       12:  841:		for (i = 0; i < state->numPlayers; i++)
        -:  842:		{
        9:  843:			if (i != currentPlayer)
        -:  844:			{
        6:  845:				drawCard(i, state);
        -:  846:			}
        -:  847:		}
        -:  848:
        -:  849:		//put played card in played card pile
        3:  850:		discardCard(handPos, currentPlayer, state, 0);
        -:  851:
        3:  852:		return 0;
        -:  853:
        -:  854:	case feast:
        -:  855:		//gain card with cost up to 5
        -:  856:		//Backup hand
    #####:  857:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  858:			temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  859:			state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  860:		}
        -:  861:		//Backup hand
        -:  862:
        -:  863:		//Update Coins for Buy
    #####:  864:		updateCoins(currentPlayer, state, 5);
        -:  865://		x = 1;//Condition to loop on
        -:  866://		while (x == 1) {//Buy one card
    #####:  867:			if (supplyCount(choice1, state) <= 0){
        -:  868:				if (DEBUG)
        -:  869:					printf("None of that card left, sorry!\n");
        -:  870:
        -:  871:				if (DEBUG){
        -:  872:					printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  873:				}
        -:  874:			}
    #####:  875:			else if (state->coins < getCost(choice1)){
    #####:  876:				printf("That card is too expensive!\n");
        -:  877:
        -:  878:				if (DEBUG){
        -:  879:					printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  880:				}
        -:  881:			}
        -:  882:			else{
        -:  883:
        -:  884:				if (DEBUG){
        -:  885:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  886:				}
        -:  887:
    #####:  888:				gainCard(choice1, state, 0, currentPlayer);//Gain the card
        -:  889://				x = 0;//No more buying cards
        -:  890:
        -:  891:				if (DEBUG){
        -:  892:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  893:				}
        -:  894:
        -:  895:			}
        -:  896://		}
        -:  897:
        -:  898:		//Reset Hand
    #####:  899:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  900:			state->hand[currentPlayer][i] = temphand[i];
    #####:  901:			temphand[i] = -1;
        -:  902:		}
        -:  903:		//Reset Hand
        -:  904:
    #####:  905:		return 0;
        -:  906:
        -:  907:	case gardens:
        7:  908:		return -1;
        -:  909:
        -:  910:	case mine:
    #####:  911:		j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  912:
    #####:  913:		if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  914:		{
    #####:  915:			return -1;
        -:  916:		}
        -:  917:
    #####:  918:		if (choice2 > treasure_map || choice2 < curse)
        -:  919:		{
    #####:  920:			return -1;
        -:  921:		}
        -:  922:
    #####:  923:		if ((getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2))
        -:  924:		{
    #####:  925:			return -1;
        -:  926:		}
        -:  927:
    #####:  928:		gainCard(choice2, state, 2, currentPlayer);
        -:  929:
        -:  930:		//discard card from hand
    #####:  931:		discardCard(handPos, currentPlayer, state, 0);
        -:  932:
        -:  933:		//discard trashed card
    #####:  934:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  935:		{
    #####:  936:			if (state->hand[currentPlayer][i] == j)
        -:  937:			{
    #####:  938:				discardCard(i, currentPlayer, state, 0);
    #####:  939:				break;
        -:  940:			}
        -:  941:		}
        -:  942:
    #####:  943:		return 0;
        -:  944:
        -:  945:	case remodel:
        -:  946:
        5:  947:		return playRemodel(state, currentPlayer, choice1, choice2, handPos);
        -:  948:
        -:  949:	case smithy:
        -:  950:
        4:  951:		playSmithy(state, currentPlayer, handPos);
        4:  952:		return 0;
        -:  953:
        -:  954:	case village:
        -:  955:		//+1 Card
        2:  956:		drawCard(currentPlayer, state);
        -:  957:
        -:  958:		//+2 Actions
        2:  959:		state->numActions = state->numActions + 2;
        -:  960:
        -:  961:		//discard played card from hand
        2:  962:		discardCard(handPos, currentPlayer, state, 0);
        2:  963:		return 0;
        -:  964:
        -:  965:	case baron:
        -:  966:
        2:  967:		playBaron(state, currentPlayer, choice1, handPos);
        2:  968:		return 0;
        -:  969:
        -:  970:	case great_hall:
        -:  971:		//+1 Card
    #####:  972:		drawCard(currentPlayer, state);
        -:  973:
        -:  974:		//+1 Actions
    #####:  975:		state->numActions++;
        -:  976:
        -:  977:		//discard card from hand
    #####:  978:		discardCard(handPos, currentPlayer, state, 0);
    #####:  979:		return 0;
        -:  980:
        -:  981:	case minion:
        -:  982:		//+1 action
        1:  983:		state->numActions++;
        -:  984:
        -:  985:		//discard card from hand
        1:  986:		discardCard(handPos, currentPlayer, state, 0);
        -:  987:
        1:  988:		if (choice1)		//+2 coins
        -:  989:		{
        1:  990:			state->coins = state->coins + 2;
        -:  991:		}
        -:  992:
    #####:  993:		else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  994:		{
        -:  995:			//discard hand
    #####:  996:			while (numHandCards(state) > 0)
        -:  997:			{
    #####:  998:				discardCard(handPos, currentPlayer, state, 0);
        -:  999:			}
        -: 1000:
        -: 1001:			//draw 4
    #####: 1002:			for (i = 0; i < 4; i++)
        -: 1003:			{
    #####: 1004:				drawCard(currentPlayer, state);
        -: 1005:			}
        -: 1006:
        -: 1007:			//other players discard hand and redraw if hand size > 4
    #####: 1008:			for (i = 0; i < state->numPlayers; i++)
        -: 1009:			{
    #####: 1010:				if (i != currentPlayer)
        -: 1011:				{
    #####: 1012:					if (state->handCount[i] > 4)
        -: 1013:					{
        -: 1014:						//discard hand
    #####: 1015:						while (state->handCount[i] > 0)
        -: 1016:						{
    #####: 1017:							discardCard(handPos, i, state, 0);
        -: 1018:						}
        -: 1019:
        -: 1020:						//draw 4
    #####: 1021:						for (j = 0; j < 4; j++)
        -: 1022:						{
    #####: 1023:							drawCard(i, state);
        -: 1024:						}
        -: 1025:					}
        -: 1026:				}
        -: 1027:			}
        -: 1028:
        -: 1029:		}
        1: 1030:		return 0;
        -: 1031:
        -: 1032:	case steward:
        7: 1033:		if (choice1 == 1)
        -: 1034:		{
        -: 1035:			//+2 cards
    #####: 1036:			drawCard(currentPlayer, state);
    #####: 1037:			drawCard(currentPlayer, state);
        -: 1038:		}
        7: 1039:		else if (choice1 == 2)
        -: 1040:		{
        -: 1041:			//+2 coins
    #####: 1042:			state->coins = state->coins + 2;
        -: 1043:		}
        -: 1044:		else
        -: 1045:		{
        -: 1046:			//trash 2 cards in hand
        7: 1047:			discardCard(choice2, currentPlayer, state, 1);
        7: 1048:			discardCard(choice3, currentPlayer, state, 1);
        -: 1049:		}
        -: 1050:
        -: 1051:		//discard card from hand
        7: 1052:		discardCard(handPos, currentPlayer, state, 0);
        7: 1053:		return 0;
        -: 1054:
        -: 1055:	case tribute:
        3: 1056:		if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####: 1057:			if (state->deckCount[nextPlayer] > 0){
    #####: 1058:				tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1059:				state->deckCount[nextPlayer]--;
        -: 1060:			}
    #####: 1061:			else if (state->discardCount[nextPlayer] > 0){
    #####: 1062:				tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer] - 1];
    #####: 1063:				state->discardCount[nextPlayer]--;
        -: 1064:			}
        -: 1065:			else{
        -: 1066:				//No Card to Reveal
        -: 1067:				if (DEBUG){
        -: 1068:					printf("No cards to reveal\n");
        -: 1069:				}
        -: 1070:			}
        -: 1071:		}
        -: 1072:
        -: 1073:		else{
        3: 1074:			if (state->deckCount[nextPlayer] == 0){
       16: 1075:				for (i = 0; i < state->discardCount[nextPlayer]; i++){
       15: 1076:					state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
       15: 1077:					state->deckCount[nextPlayer]++;
       15: 1078:					state->discard[nextPlayer][i] = -1;
       15: 1079:					state->discardCount[nextPlayer]--;
        -: 1080:				}
        -: 1081:
        1: 1082:				shuffle(nextPlayer, state);//Shuffle the deck
        -: 1083:			}
        3: 1084:			tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
        3: 1085:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
        3: 1086:			state->deckCount[nextPlayer]--;
        3: 1087:			tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
        3: 1088:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
        3: 1089:			state->deckCount[nextPlayer]--;
        -: 1090:		}
        -: 1091:
        3: 1092:		if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
        2: 1093:			state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
        2: 1094:			state->playedCardCount++;
        2: 1095:			tributeRevealedCards[1] = -1;
        -: 1096:		}
        -: 1097:
       12: 1098:		for (i = 0; i <= 2; i++){
        9: 1099:			if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
        4: 1100:				state->coins += 2;
        -: 1101:			}
        -: 1102:
        5: 1103:			else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
        1: 1104:				drawCard(currentPlayer, state);
        1: 1105:				drawCard(currentPlayer, state);
        -: 1106:			}
        -: 1107:			else{//Action Card
        4: 1108:				state->numActions = state->numActions + 2;
        -: 1109:			}
        -: 1110:		}
        -: 1111:
        3: 1112:		return 0;
        -: 1113:
        -: 1114:	case ambassador:
    #####: 1115:		j = 0;		//used to check if player has enough cards to discard
        -: 1116:
    #####: 1117:		if (choice2 > 2 || choice2 < 0)
        -: 1118:		{
    #####: 1119:			return -1;
        -: 1120:		}
        -: 1121:
    #####: 1122:		if (choice1 == handPos)
        -: 1123:		{
    #####: 1124:			return -1;
        -: 1125:		}
        -: 1126:
    #####: 1127:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1128:		{
    #####: 1129:			if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1130:			{
    #####: 1131:				j++;
        -: 1132:			}
        -: 1133:		}
    #####: 1134:		if (j < choice2)
        -: 1135:		{
    #####: 1136:			return -1;
        -: 1137:		}
        -: 1138:
        -: 1139:		if (DEBUG)
        -: 1140:			printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1141:
        -: 1142:		//increase supply count for choosen card by amount being discarded
    #####: 1143:		state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1144:
        -: 1145:		//each other player gains a copy of revealed card
    #####: 1146:		for (i = 0; i < state->numPlayers; i++)
        -: 1147:		{
    #####: 1148:			if (i != currentPlayer)
        -: 1149:			{
    #####: 1150:				gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1151:			}
        -: 1152:		}
        -: 1153:
        -: 1154:		//discard played card from hand
    #####: 1155:		discardCard(handPos, currentPlayer, state, 0);
        -: 1156:
        -: 1157:		//trash copies of cards returned to supply
    #####: 1158:		for (j = 0; j < choice2; j++)
        -: 1159:		{
    #####: 1160:			for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1161:			{
    #####: 1162:				if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1163:				{
    #####: 1164:					discardCard(i, currentPlayer, state, 1);
    #####: 1165:					break;
        -: 1166:				}
        -: 1167:			}
        -: 1168:		}
        -: 1169:
    #####: 1170:		return 0;
        -: 1171:
        -: 1172:	case cutpurse:
        -: 1173:
        1: 1174:		updateCoins(currentPlayer, state, 2);
        4: 1175:		for (i = 0; i < state->numPlayers; i++)
        -: 1176:		{
        3: 1177:			if (i != currentPlayer)
        -: 1178:			{
        2: 1179:				for (j = 0; j < state->handCount[i]; j++)
        -: 1180:				{
    #####: 1181:					if (state->hand[i][j] == copper)
        -: 1182:					{
    #####: 1183:						discardCard(j, i, state, 0);
    #####: 1184:						break;
        -: 1185:					}
    #####: 1186:					if (j == state->handCount[i])
        -: 1187:					{
    #####: 1188:						for (k = 0; k < state->handCount[i]; k++)
        -: 1189:						{
        -: 1190:							if (DEBUG)
        -: 1191:								printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1192:						}
    #####: 1193:						break;
        -: 1194:					}
        -: 1195:				}
        -: 1196:
        -: 1197:			}
        -: 1198:
        -: 1199:		}
        -: 1200:
        -: 1201:		//discard played card from hand
        1: 1202:		discardCard(handPos, currentPlayer, state, 0);
        -: 1203:
        1: 1204:		return 0;
        -: 1205:
        -: 1206:
        -: 1207:	case embargo:
        -: 1208:		//+2 Coins
       24: 1209:		state->coins = state->coins + 2;
        -: 1210:
        -: 1211:		//see if selected pile is in play
       24: 1212:		if (state->supplyCount[choice1] == -1)
        -: 1213:		{
       13: 1214:			return -1;
        -: 1215:		}
        -: 1216:
        -: 1217:		//add embargo token to selected supply pile
       11: 1218:		state->embargoTokens[choice1]++;
        -: 1219:
        -: 1220:		//trash card
       11: 1221:		discardCard(handPos, currentPlayer, state, 1);
       11: 1222:		return 0;
        -: 1223:
        -: 1224:	case outpost:
        -: 1225:		//set outpost flag
    #####: 1226:		state->outpostPlayed++;
        -: 1227:
        -: 1228:		//discard card
    #####: 1229:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1230:		return 0;
        -: 1231:
        -: 1232:	case salvager:
        -: 1233:		//+1 buy
        3: 1234:		state->numBuys++;
        -: 1235:
        3: 1236:		if (choice1)
        -: 1237:		{
        -: 1238:			//gain coins equal to trashed card
        3: 1239:			state->coins = state->coins + getCost(handCard(choice1, state));
        -: 1240:			//trash card
        3: 1241:			discardCard(choice1, currentPlayer, state, 1);
        -: 1242:		}
        -: 1243:
        -: 1244:		//discard card
        3: 1245:		discardCard(handPos, currentPlayer, state, 0);
        3: 1246:		return 0;
        -: 1247:
        -: 1248:	case sea_hag:
       32: 1249:		for (i = 0; i < state->numPlayers; i++){
       24: 1250:			if (i != currentPlayer){
       16: 1251:				state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
       16: 1252:				state->discardCount[i]++;
       16: 1253:				state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1254:			}
        -: 1255:		}
        8: 1256:		return 0;
        -: 1257:
        -: 1258:	case treasure_map:
        -: 1259:
        3: 1260:		return playTreasureMap(state, currentPlayer, handPos);
        -: 1261:	}
    #####: 1262:	return -1;
        -: 1263:}
        -: 1264:
       60: 1265:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1266:{
        -: 1267:
        -: 1268:	//if card is not trashed, added to Played pile 
       60: 1269:	if (trashFlag < 1)
        -: 1270:	{
        -: 1271:		//add card to played pile
       26: 1272:		state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
       26: 1273:		state->playedCardCount++;
        -: 1274:	}
        -: 1275:
        -: 1276:	//set played card to -1
       60: 1277:	state->hand[currentPlayer][handPos] = -1;
        -: 1278:
        -: 1279:	//remove card from player's hand
       60: 1280:	if (handPos == (state->handCount[currentPlayer] - 1)) 	//last card in hand array is played
        -: 1281:	{
        -: 1282:		//reduce number of cards in hand
        5: 1283:		state->handCount[currentPlayer]--;
        -: 1284:	}
       55: 1285:	else if (state->handCount[currentPlayer] == 1) //only one card in hand
        -: 1286:	{
        -: 1287:		//reduce number of cards in hand
    #####: 1288:		state->handCount[currentPlayer]--;
        -: 1289:	}
        -: 1290:	else
        -: 1291:	{
        -: 1292:		//replace discarded card with last card in hand
       55: 1293:		state->hand[currentPlayer][handPos] = state->hand[currentPlayer][(state->handCount[currentPlayer] - 1)];
        -: 1294:		//set last card to -1
       55: 1295:		state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1296:		//reduce number of cards in hand
       55: 1297:		state->handCount[currentPlayer]--;
        -: 1298:	}
        -: 1299:
       60: 1300:	return 0;
        -: 1301:}
        -: 1302:
      222: 1303:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1304:{
        -: 1305:	//Note: supplyPos is enum of choosen card
        -: 1306:
        -: 1307:	//check if supply pile is empty (0) or card is not used in game (-1)
      222: 1308:	if (supplyCount(supplyPos, state) < 1)
        -: 1309:	{
    #####: 1310:		return -1;
        -: 1311:	}
        -: 1312:
        -: 1313:	//added card for [whoseTurn] current player:
        -: 1314:	// toFlag = 0 : add to discard
        -: 1315:	// toFlag = 1 : add to deck
        -: 1316:	// toFlag = 2 : add to hand
        -: 1317:
      222: 1318:	if (toFlag == 1)
        -: 1319:	{
       12: 1320:		state->deck[player][state->deckCount[player]] = supplyPos;
       12: 1321:		state->deckCount[player]++;
        -: 1322:	}
      210: 1323:	else if (toFlag == 2)
        -: 1324:	{
    #####: 1325:		state->hand[player][state->handCount[player]] = supplyPos;
    #####: 1326:		state->handCount[player]++;
        -: 1327:	}
        -: 1328:	else
        -: 1329:	{
      210: 1330:		state->discard[player][state->discardCount[player]] = supplyPos;
      210: 1331:		state->discardCount[player]++;
        -: 1332:	}
        -: 1333:
        -: 1334:	//decrease number in supply pile
      222: 1335:	state->supplyCount[supplyPos]--;
        -: 1336:
      222: 1337:	return 0;
        -: 1338:}
        -: 1339:
      296: 1340:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1341:{
        -: 1342:	int i;
        -: 1343:
        -: 1344:	//reset coin count
      296: 1345:	state->coins = 0;
        -: 1346:
        -: 1347:	//add coins for each Treasure card in player's hand
     1737: 1348:	for (i = 0; i < state->handCount[player]; i++)
        -: 1349:	{
     1441: 1350:		if (state->hand[player][i] == copper)
        -: 1351:		{
      613: 1352:			state->coins += 1;
        -: 1353:		}
      828: 1354:		else if (state->hand[player][i] == silver)
        -: 1355:		{
       64: 1356:			state->coins += 2;
        -: 1357:		}
      764: 1358:		else if (state->hand[player][i] == gold)
        -: 1359:		{
       64: 1360:			state->coins += 3;
        -: 1361:		}
        -: 1362:	}
        -: 1363:
        -: 1364:	//add bonus
      296: 1365:	state->coins += bonus;
        -: 1366:
      296: 1367:	return 0;
        -: 1368:}
        -: 1369:
        -: 1370:
        -: 1371://end of dominion.c
File 'dominion.c'
Lines executed:68.22% of 557
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
     2753:    8:int compare(const void* a, const void* b) {
     2753:    9:	if (*(int*)a > *(int*)b)
      985:   10:		return 1;
     1768:   11:	if (*(int*)a < *(int*)b)
      739:   12:		return -1;
     1029:   13:	return 0;
        -:   14:}
        -:   15:
        4:   16:struct gameState* newGame() {
        4:   17:	struct gameState* g = malloc(sizeof(struct gameState));
        4:   18:	return g;
        -:   19:}
        -:   20:
       11:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:	int k8, int k9, int k10) {
       11:   23:	int* k = malloc(10 * sizeof(int));
       11:   24:	k[0] = k1;
       11:   25:	k[1] = k2;
       11:   26:	k[2] = k3;
       11:   27:	k[3] = k4;
       11:   28:	k[4] = k5;
       11:   29:	k[5] = k6;
       11:   30:	k[6] = k7;
       11:   31:	k[7] = k8;
       11:   32:	k[8] = k9;
       11:   33:	k[9] = k10;
       11:   34:	return k;
        -:   35:}
        -:   36:
       11:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		struct gameState *state) {
        -:   39:
        -:   40:	int i;
        -:   41:	int j;
        -:   42:	int it;
        -:   43:	//set up random number generator
       11:   44:	SelectStream(1);
       11:   45:	PutSeed((long)randomSeed);
        -:   46:
        -:   47:	//check number of players
       11:   48:	if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:	{
    #####:   50:		return -1;
        -:   51:	}
        -:   52:
        -:   53:	//set number of players
       11:   54:	state->numPlayers = numPlayers;
        -:   55:
        -:   56:	//check selected kingdom cards are different
       47:   57:	for (i = 0; i < 10; i++)
        -:   58:	{
      453:   59:		for (j = 0; j < 10; j++)
        -:   60:		{
      417:   61:			if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:			{
        9:   63:				return -1;
        -:   64:			}
        -:   65:		}
        -:   66:	}
        -:   67:
        -:   68:
        -:   69:	//initialize supply
        -:   70:	///////////////////////////////
        -:   71:
        -:   72:	//set number of Curse cards
        2:   73:	if (numPlayers == 2)
        -:   74:	{
        1:   75:		state->supplyCount[curse] = 10;
        -:   76:	}
        1:   77:	else if (numPlayers == 3)
        -:   78:	{
        1:   79:		state->supplyCount[curse] = 20;
        -:   80:	}
        -:   81:	else
        -:   82:	{
    #####:   83:		state->supplyCount[curse] = 30;
        -:   84:	}
        -:   85:
        -:   86:	//set number of Victory cards
        2:   87:	if (numPlayers == 2)
        -:   88:	{
        1:   89:		state->supplyCount[estate] = 8;
        1:   90:		state->supplyCount[duchy] = 8;
        1:   91:		state->supplyCount[province] = 8;
        -:   92:	}
        -:   93:	else
        -:   94:	{
        1:   95:		state->supplyCount[estate] = 12;
        1:   96:		state->supplyCount[duchy] = 12;
        1:   97:		state->supplyCount[province] = 12;
        -:   98:	}
        -:   99:
        -:  100:	//set number of Treasure cards
        2:  101:	state->supplyCount[copper] = 60 - (7 * numPlayers);
        2:  102:	state->supplyCount[silver] = 40;
        2:  103:	state->supplyCount[gold] = 30;
        -:  104:
        -:  105:	//set number of Kingdom cards
       42:  106:	for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:	{
      330:  108:		for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:		{
      310:  110:			if (kingdomCards[j] == i)
        -:  111:			{
        -:  112:				//check if card is a 'Victory' Kingdom card
       20:  113:				if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:				{
        4:  115:					if (numPlayers == 2){
        1:  116:						state->supplyCount[i] = 8;
        -:  117:					}
        1:  118:					else{ state->supplyCount[i] = 12; }
        -:  119:				}
        -:  120:				else
        -:  121:				{
       18:  122:					state->supplyCount[i] = 10;
        -:  123:				}
       20:  124:				break;
        -:  125:			}
        -:  126:			else    //card is not in the set choosen for the game
        -:  127:			{
      290:  128:				state->supplyCount[i] = -1;
        -:  129:			}
        -:  130:		}
        -:  131:
        -:  132:	}
        -:  133:
        -:  134:	////////////////////////
        -:  135:	//supply intilization complete
        -:  136:
        -:  137:	//set player decks
        7:  138:	for (i = 0; i < numPlayers; i++)
        -:  139:	{
        5:  140:		state->deckCount[i] = 0;
       20:  141:		for (j = 0; j < 3; j++)
        -:  142:		{
       15:  143:			state->deck[i][j] = estate;
       15:  144:			state->deckCount[i]++;
        -:  145:		}
       40:  146:		for (j = 3; j < 10; j++)
        -:  147:		{
       35:  148:			state->deck[i][j] = copper;
       35:  149:			state->deckCount[i]++;
        -:  150:		}
        -:  151:	}
        -:  152:
        -:  153:	//shuffle player decks
        7:  154:	for (i = 0; i < numPlayers; i++)
        -:  155:	{
        5:  156:		if (shuffle(i, state) < 0)
        -:  157:		{
    #####:  158:			return -1;
        -:  159:		}
        -:  160:	}
        -:  161:
        -:  162:	//draw player hands
        7:  163:	for (i = 0; i < numPlayers; i++)
        -:  164:	{
        -:  165:		//initialize hand size to zero
        5:  166:		state->handCount[i] = 0;
        5:  167:		state->discardCount[i] = 0;
        -:  168:		//draw 5 cards
        -:  169:		// for (j = 0; j < 5; j++)
        -:  170:		//	{
        -:  171:		//	  drawCard(i, state);
        -:  172:		//	}
        -:  173:	}
        -:  174:
        -:  175:	//set embargo tokens to 0 for all supply piles
       56:  176:	for (i = 0; i <= treasure_map; i++)
        -:  177:	{
       54:  178:		state->embargoTokens[i] = 0;
        -:  179:	}
        -:  180:
        -:  181:	//initialize first player's turn
        2:  182:	state->outpostPlayed = 0;
        2:  183:	state->phase = 0;
        2:  184:	state->numActions = 1;
        2:  185:	state->numBuys = 1;
        2:  186:	state->playedCardCount = 0;
        2:  187:	state->whoseTurn = 0;
        2:  188:	state->handCount[state->whoseTurn] = 0;
        -:  189:	//int it; move to top
        -:  190:
        -:  191:	//Moved draw cards to here, only drawing at the start of a turn
       12:  192:	for (it = 0; it < 5; it++){
       10:  193:		drawCard(state->whoseTurn, state);
        -:  194:	}
        -:  195:
        2:  196:	updateCoins(state->whoseTurn, state, 0);
        -:  197:
        2:  198:	return 0;
        -:  199:}
        -:  200:
       69:  201:int shuffle(int player, struct gameState *state) {
        -:  202:
        -:  203:
        -:  204:	int newDeck[MAX_DECK];
       69:  205:	int newDeckPos = 0;
        -:  206:	int card;
        -:  207:	int i;
        -:  208:
       69:  209:	if (state->deckCount[player] < 1)
    #####:  210:		return -1;
       69:  211:	qsort((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
        -:  212:	/* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
     1426:  214:	while (state->deckCount[player] > 0) {
     1288:  215:		card = floor(Random() * state->deckCount[player]);
     1288:  216:		newDeck[newDeckPos] = state->deck[player][card];
     1288:  217:		newDeckPos++;
     8237:  218:		for (i = card; i < state->deckCount[player] - 1; i++) {
     6949:  219:			state->deck[player][i] = state->deck[player][i + 1];
        -:  220:		}
     1288:  221:		state->deckCount[player]--;
        -:  222:	}
     1357:  223:	for (i = 0; i < newDeckPos; i++) {
     1288:  224:		state->deck[player][i] = newDeck[i];
     1288:  225:		state->deckCount[player]++;
        -:  226:	}
        -:  227:
       69:  228:	return 0;
        -:  229:}
        -:  230:
     1152:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state)
        -:  232:{
        -:  233:	int card;
     1152:  234:	int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:	//check if it is the right phase
     1152:  237:	if (state->phase != 0)
        -:  238:	{
      170:  239:		return -1;
        -:  240:	}
        -:  241:
        -:  242:	//check if player has enough actions
      982:  243:	if (state->numActions < 1)
        -:  244:	{
       30:  245:		return -1;
        -:  246:	}
        -:  247:
        -:  248:	//get card played
      952:  249:	card = handCard(handPos, state);
        -:  250:
        -:  251:	//check if selected card is an action
      952:  252:	if (card < adventurer || card > treasure_map)
        -:  253:	{
      852:  254:		return -1;
        -:  255:	}
        -:  256:
        -:  257:	//play card
      100:  258:	if (cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0)
        -:  259:	{
       45:  260:		return -1;
        -:  261:	}
        -:  262:
        -:  263:	//reduce number of actions
       55:  264:	state->numActions--;
        -:  265:
        -:  266:	//update coins (Treasure cards may be added with card draws)
       55:  267:	updateCoins(state->whoseTurn, state, coin_bonus);
        -:  268:
       55:  269:	return 0;
        -:  270:}
        -:  271:
     1235:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:	int who;
        -:  274:	if (DEBUG){
        -:  275:		printf("Entering buyCard...\n");
        -:  276:	}
        -:  277:
        -:  278:	// I don't know what to do about the phase thing.
        -:  279:
     1235:  280:	who = state->whoseTurn;
        -:  281:
     1235:  282:	if (state->numBuys < 1){
        -:  283:		if (DEBUG)
        -:  284:			printf("You do not have any buys left\n");
      172:  285:		return -1;
        -:  286:	}
     1063:  287:	else if (supplyCount(supplyPos, state) < 1){
        -:  288:		if (DEBUG)
        -:  289:			printf("There are not any of that type of card left\n");
      436:  290:		return -1;
        -:  291:	}
      627:  292:	else if (state->coins < getCost(supplyPos)){
        -:  293:		if (DEBUG)
        -:  294:			printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
      447:  295:		return -1;
        -:  296:	}
        -:  297:	else {
      180:  298:		state->phase = 1;
        -:  299:		//state->supplyCount[supplyPos]--;
      180:  300:		gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  301:
      180:  302:		state->coins = (state->coins) - (getCost(supplyPos));
      180:  303:		state->numBuys--;
        -:  304:		if (DEBUG)
        -:  305:			printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  306:	}
        -:  307:
        -:  308:	//state->discard[who][state->discardCount[who]] = supplyPos;
        -:  309:	//state->discardCount[who]++;
        -:  310:
      180:  311:	return 0;
        -:  312:}
        -:  313:
    #####:  314:int numHandCards(struct gameState *state) {
    #####:  315:	return state->handCount[whoseTurn(state)];
        -:  316:}
        -:  317:
      952:  318:int handCard(int handPos, struct gameState *state) {
      952:  319:	int currentPlayer = whoseTurn(state);
      952:  320:	return state->hand[currentPlayer][handPos];
        -:  321:}
        -:  322:
     1271:  323:int supplyCount(int card, struct gameState *state) {
     1271:  324:	return state->supplyCount[card];
        -:  325:}
        -:  326:
    #####:  327:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  328:	int i;
    #####:  329:	int count = 0;
        -:  330:
    #####:  331:	for (i = 0; i < state->deckCount[player]; i++)
        -:  332:	{
    #####:  333:		if (state->deck[player][i] == card) count++;
        -:  334:	}
        -:  335:
    #####:  336:	for (i = 0; i < state->handCount[player]; i++)
        -:  337:	{
    #####:  338:		if (state->hand[player][i] == card) count++;
        -:  339:	}
        -:  340:
    #####:  341:	for (i = 0; i < state->discardCount[player]; i++)
        -:  342:	{
    #####:  343:		if (state->discard[player][i] == card) count++;
        -:  344:	}
        -:  345:
    #####:  346:	return count;
        -:  347:}
        -:  348:
     1279:  349:int whoseTurn(struct gameState *state) {
     1279:  350:	return state->whoseTurn;
        -:  351:}
        -:  352:
      227:  353:int endTurn(struct gameState *state) {
        -:  354:	int k;
        -:  355:	int i;
      227:  356:	int currentPlayer = whoseTurn(state);
        -:  357:
        -:  358:	//Discard hand
     1337:  359:	for (i = 0; i < state->handCount[currentPlayer]; i++){
     1110:  360:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
     1110:  361:		state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  362:	}
      227:  363:	state->handCount[currentPlayer] = 0;//Reset hand count
        -:  364:
        -:  365:	//Code for determining the player
      227:  366:	if (currentPlayer < (state->numPlayers - 1)){
      138:  367:		state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  368:	}
        -:  369:	else{
       89:  370:		state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  371:	}
        -:  372:
      227:  373:	state->outpostPlayed = 0;
      227:  374:	state->phase = 0;
      227:  375:	state->numActions = 1;
      227:  376:	state->coins = 0;
      227:  377:	state->numBuys = 1;
      227:  378:	state->playedCardCount = 0;
      227:  379:	state->handCount[state->whoseTurn] = 0;
        -:  380:
        -:  381:	//int k; move to top
        -:  382:	//Next player draws hand
     1362:  383:	for (k = 0; k < 5; k++){
     1135:  384:		drawCard(state->whoseTurn, state);//Draw a card
        -:  385:	}
        -:  386:
        -:  387:	//Update money
      227:  388:	updateCoins(state->whoseTurn, state, 0);
        -:  389:
      227:  390:	return 0;
        -:  391:}
        -:  392:
     3604:  393:int isGameOver(struct gameState *state) {
        -:  394:	int i;
        -:  395:	int j;
        -:  396:
        -:  397:	//if stack of Province cards is empty, the game ends
     3604:  398:	if (state->supplyCount[province] == 0)
        -:  399:	{
    #####:  400:		return 1;
        -:  401:	}
        -:  402:
        -:  403:	//if three supply pile are at 0, the game ends
     3604:  404:	j = 0;
    93704:  405:	for (i = 0; i < 25; i++)
        -:  406:	{
    90100:  407:		if (state->supplyCount[i] == 0)
        -:  408:		{
     3132:  409:			j++;
        -:  410:		}
        -:  411:	}
     3604:  412:	if (j >= 3)
        -:  413:	{
        2:  414:		return 1;
        -:  415:	}
        -:  416:
     3602:  417:	return 0;
        -:  418:}
        -:  419:
        5:  420:int scoreFor(int player, struct gameState *state) {
        -:  421:
        -:  422:	int i;
        5:  423:	int score = 0;
        -:  424:	//score from hand
       15:  425:	for (i = 0; i < state->handCount[player]; i++)
        -:  426:	{
       10:  427:		if (state->hand[player][i] == curse) { score = score - 1; };
       10:  428:		if (state->hand[player][i] == estate) { score = score + 1; };
       10:  429:		if (state->hand[player][i] == duchy) { score = score + 3; };
       10:  430:		if (state->hand[player][i] == province) { score = score + 6; };
       10:  431:		if (state->hand[player][i] == great_hall) { score = score + 1; };
       10:  432:		if (state->hand[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  433:	}
        -:  434:
        -:  435:	//score from discard
       74:  436:	for (i = 0; i < state->discardCount[player]; i++)
        -:  437:	{
       69:  438:		if (state->discard[player][i] == curse) { score = score - 1; };
       69:  439:		if (state->discard[player][i] == estate) { score = score + 1; };
       69:  440:		if (state->discard[player][i] == duchy) { score = score + 3; };
       69:  441:		if (state->discard[player][i] == province) { score = score + 6; };
       69:  442:		if (state->discard[player][i] == great_hall) { score = score + 1; };
       69:  443:		if (state->discard[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  444:	}
        -:  445:
        -:  446:	//score from deck
       74:  447:	for (i = 0; i < state->discardCount[player]; i++)
        -:  448:	{
       69:  449:		if (state->deck[player][i] == curse) { score = score - 1; };
       69:  450:		if (state->deck[player][i] == estate) { score = score + 1; };
       69:  451:		if (state->deck[player][i] == duchy) { score = score + 3; };
       69:  452:		if (state->deck[player][i] == province) { score = score + 6; };
       69:  453:		if (state->deck[player][i] == great_hall) { score = score + 1; };
       69:  454:		if (state->deck[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  455:	}
        -:  456:
        5:  457:	return score;
        -:  458:}
        -:  459:
    #####:  460:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  461:	int i;
        -:  462:	int j;
        -:  463:	int highScore;
        -:  464:	int currentPlayer;
        -:  465:
        -:  466:	//get score for each player
    #####:  467:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  468:	{
        -:  469:		//set unused player scores to -9999
    #####:  470:		if (i >= state->numPlayers)
        -:  471:		{
    #####:  472:			players[i] = -9999;
        -:  473:		}
        -:  474:		else
        -:  475:		{
    #####:  476:			players[i] = scoreFor(i, state);
        -:  477:		}
        -:  478:	}
        -:  479:
        -:  480:	//find highest score
    #####:  481:	j = 0;
    #####:  482:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  483:	{
    #####:  484:		if (players[i] > players[j])
        -:  485:		{
    #####:  486:			j = i;
        -:  487:		}
        -:  488:	}
    #####:  489:	highScore = players[j];
        -:  490:
        -:  491:	//add 1 to players who had less turns
    #####:  492:	currentPlayer = whoseTurn(state);
    #####:  493:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  494:	{
    #####:  495:		if (players[i] == highScore && i > currentPlayer)
        -:  496:		{
    #####:  497:			players[i]++;
        -:  498:		}
        -:  499:	}
        -:  500:
        -:  501:	//find new highest score
    #####:  502:	j = 0;
    #####:  503:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  504:	{
    #####:  505:		if (players[i] > players[j])
        -:  506:		{
    #####:  507:			j = i;
        -:  508:		}
        -:  509:	}
    #####:  510:	highScore = players[j];
        -:  511:
        -:  512:	//set winners in array to 1 and rest to 0
    #####:  513:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  514:	{
    #####:  515:		if (players[i] == highScore)
        -:  516:		{
    #####:  517:			players[i] = 1;
        -:  518:		}
        -:  519:		else
        -:  520:		{
    #####:  521:			players[i] = 0;
        -:  522:		}
        -:  523:	}
        -:  524:
    #####:  525:	return 0;
        -:  526:}
        -:  527:
     1179:  528:int drawCard(int player, struct gameState *state)
        -:  529:{
        -:  530:	int count;
        -:  531:	int deckCounter;
     1179:  532:	if (state->deckCount[player] <= 0){//Deck is empty
        -:  533:
        -:  534:		//Step 1 Shuffle the discard pile back into a deck
        -:  535:		int i;
        -:  536:		//Move discard to deck
     1302:  537:		for (i = 0; i < state->discardCount[player]; i++){
     1238:  538:			state->deck[player][i] = state->discard[player][i];
     1238:  539:			state->discard[player][i] = -1;
        -:  540:		}
        -:  541:
       64:  542:		state->deckCount[player] = state->discardCount[player];
       64:  543:		state->discardCount[player] = 0;//Reset discard
        -:  544:
        -:  545:		//Shufffle the deck
       64:  546:		shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  547:
        -:  548:		if (DEBUG){//Debug statements
        -:  549:			printf("Deck count now: %d\n", state->deckCount[player]);
        -:  550:		}
        -:  551:
       64:  552:		state->discardCount[player] = 0;
        -:  553:
        -:  554:		//Step 2 Draw Card
       64:  555:		count = state->handCount[player];//Get current player's hand count
        -:  556:
        -:  557:		if (DEBUG){//Debug statements
        -:  558:			printf("Current hand count: %d\n", count);
        -:  559:		}
        -:  560:
       64:  561:		deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  562:
       64:  563:		if (deckCounter == 0)
    #####:  564:			return -1;
        -:  565:
       64:  566:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
       64:  567:		state->deckCount[player]--;
       64:  568:		state->handCount[player]++;//Increment hand count
        -:  569:	}
        -:  570:
        -:  571:	else{
     1115:  572:		int count = state->handCount[player];//Get current hand count for player
        -:  573:		int deckCounter;
        -:  574:		if (DEBUG){//Debug statements
        -:  575:			printf("Current hand count: %d\n", count);
        -:  576:		}
        -:  577:
     1115:  578:		deckCounter = state->deckCount[player];//Create holder for the deck count
     1115:  579:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
     1115:  580:		state->deckCount[player]--;
     1115:  581:		state->handCount[player]++;//Increment hand count
        -:  582:	}
        -:  583:
     1179:  584:	return 0;
        -:  585:}
        -:  586:
      822:  587:int getCost(int cardNumber)
        -:  588:{
      822:  589:	switch (cardNumber)
        -:  590:	{
        -:  591:	case curse:
       54:  592:		return 0;
        -:  593:	case estate:
       34:  594:		return 2;
        -:  595:	case duchy:
       32:  596:		return 5;
        -:  597:	case province:
       35:  598:		return 8;
        -:  599:	case copper:
       92:  600:		return 0;
        -:  601:	case silver:
       55:  602:		return 3;
        -:  603:	case gold:
       40:  604:		return 6;
        -:  605:	case adventurer:
       18:  606:		return 6;
        -:  607:	case council_room:
    #####:  608:		return 5;
        -:  609:	case feast:
       48:  610:		return 4;
        -:  611:	case gardens:
       15:  612:		return 4;
        -:  613:	case mine:
       43:  614:		return 5;
        -:  615:	case remodel:
       49:  616:		return 4;
        -:  617:	case smithy:
       31:  618:		return 4;
        -:  619:	case village:
    #####:  620:		return 3;
        -:  621:	case baron:
       46:  622:		return 4;
        -:  623:	case great_hall:
       35:  624:		return 3;
        -:  625:	case minion:
    #####:  626:		return 5;
        -:  627:	case steward:
       45:  628:		return 3;
        -:  629:	case tribute:
       18:  630:		return 5;
        -:  631:	case ambassador:
       63:  632:		return 3;
        -:  633:	case cutpurse:
    #####:  634:		return 4;
        -:  635:	case embargo:
       23:  636:		return 2;
        -:  637:	case outpost:
    #####:  638:		return 5;
        -:  639:	case salvager:
       13:  640:		return 4;
        -:  641:	case sea_hag:
       33:  642:		return 4;
        -:  643:	case treasure_map:
    #####:  644:		return 4;
        -:  645:	}
        -:  646:
    #####:  647:	return -1;
        -:  648:}
        -:  649:
    #####:  650:void playAdventurer(struct gameState *state, int currentPlayer)
        -:  651:// Reveal cards from deck until 2 Treasure cards are found.  Put those Treasure cards in the hand and discard the rest.
        -:  652:{
    #####:  653:	int drawntreasure = 0;
        -:  654:	int temphand[MAX_HAND];
        -:  655:	int cardDrawn;
    #####:  656:	int z = 0; // this is the counter for the temp hand
        -:  657:
    #####:  658:	while (drawntreasure < 2){
    #####:  659:		if (state->deckCount[currentPlayer] < 1){//if the deck is empty we need to shuffle discard and add to deck
    #####:  660:			shuffle(currentPlayer, state);
        -:  661:		}
    #####:  662:		drawCard(currentPlayer, state);
    #####:  663:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer] - 1];//top card of hand is most recently drawn card.
    #####:  664:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
    #####:  665:			drawntreasure++;
        -:  666:		else{
    #####:  667:			temphand[z] = cardDrawn;
    #####:  668:			state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####:  669:			z++;
        -:  670:		}
        -:  671:	}
    #####:  672:	while (z - 1 >= 0){
    #####:  673:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; // discard all cards in play that have been drawn
    #####:  674:		z = z - 1;
        -:  675:	}
    #####:  676:}
        -:  677:
        5:  678:int playRemodel(struct gameState *state, int currentPlayer, int choice1, int choice2, int handPos)
        -:  679://Trash a card in the hand, and gain a card costing up to $2 more than the trashed card
        -:  680:{
        -:  681:	int i;
        5:  682:	int j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  683:
        5:  684:	if ((getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2))
        -:  685:	{
        2:  686:		return -1;
        -:  687:	}
        -:  688:
        3:  689:	gainCard(choice2, state, 0, currentPlayer);
        -:  690:
        -:  691:	//discard card from hand
        3:  692:	discardCard(handPos, currentPlayer, state, 0);
        -:  693:
        -:  694:	//discard trashed card
       11:  695:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  696:	{
       10:  697:		if (state->hand[currentPlayer][i] == j)
        -:  698:		{
        2:  699:			discardCard(i, currentPlayer, state, 0);
        2:  700:			break;
        -:  701:		}
        -:  702:	}
        -:  703:
        3:  704:	return 0;
        -:  705:}
        -:  706:
        8:  707:void playSmithy(struct gameState *state, int currentPlayer, int handPos)
        -:  708:// Draw 3 cards
        -:  709:{
        -:  710:	int i;
       32:  711:	for (i = 0; i < 3; i++)
        -:  712:	{
       24:  713:		drawCard(currentPlayer, state);
        -:  714:	}
        -:  715:
        -:  716:	//discard card from hand
        8:  717:	discardCard(handPos, currentPlayer, state, 0);
        8:  718:}
        -:  719:
       10:  720:void playBaron(struct gameState *state, int currentPlayer, int choice1, int handPos)
        -:  721://Add a buy.  OPTION:  Discard an Estate card and gain $4.  Otherwise, gain an Estate card.
        -:  722:{
       10:  723:	state->numBuys++;//Increase buys by 1!
       10:  724:	if (choice1 > 0){//Boolean true or going to discard an estate
       10:  725:		int p = 0;//Iterator for hand!
       10:  726:		int card_not_discarded = 1;//Flag for discard set!
       68:  727:		while (card_not_discarded){
       48:  728:			if (state->hand[currentPlayer][p] == estate){ //Found an estate card!
        5:  729:				state->coins += 4;//Add 4 coins to the amount of coins
        5:  730:				state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
        5:  731:				state->discardCount[currentPlayer]++;
       22:  732:				for (; p < state->handCount[currentPlayer]; p++){
       17:  733:					state->hand[currentPlayer][p] = state->hand[currentPlayer][p + 1];
        -:  734:				}
        5:  735:				state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
        5:  736:				state->handCount[currentPlayer]--;
        5:  737:				card_not_discarded = 0;//Exit the loop
        -:  738:			}
       43:  739:			else if (p > state->handCount[currentPlayer]){
        -:  740:				if (DEBUG) {
        -:  741:					printf("No estate cards in your hand, invalid choice\n");
        -:  742:					printf("Must gain an estate if there are any\n");
        -:  743:				}
        5:  744:				if (supplyCount(estate, state) > 0){
        2:  745:					gainCard(estate, state, 1, currentPlayer);
        2:  746:					state->supplyCount[estate]--;//Decrement estates
        2:  747:					if (supplyCount(estate, state) == 0){
    #####:  748:						isGameOver(state);
        -:  749:					}
        -:  750:				}
        5:  751:				card_not_discarded = 0;//Exit the loop
        -:  752:			}
        -:  753:
        -:  754:			else{
       38:  755:				p++;//Next card
        -:  756:			}
        -:  757:		}
        -:  758:	}
        -:  759:
        -:  760:	else{
    #####:  761:		if (supplyCount(estate, state) > 0){
    #####:  762:			gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  763:			state->supplyCount[estate]--;//Decrement Estates
    #####:  764:			if (supplyCount(estate, state) == 0){
    #####:  765:				isGameOver(state);
        -:  766:			}
        -:  767:		}
        -:  768:	}
       10:  769:}
        -:  770:
    #####:  771:int playTreasureMap(struct gameState *state, int currentPlayer, int handPos)
        -:  772://Trashing two treasure map cards from the hand = four gold on top of the deck.
        -:  773:{
        -:  774:	int i;
        -:  775:	int index;
        -:  776:
        -:  777:	//search hand for another treasure_map
    #####:  778:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  779:	{
    #####:  780:		if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -:  781:		{
    #####:  782:			index = i;
    #####:  783:			break;
        -:  784:		}
        -:  785:	}
    #####:  786:	if (index > -1)
        -:  787:	{
        -:  788:		//trash both treasure cards
    #####:  789:		discardCard(handPos, currentPlayer, state, 1);
    #####:  790:		discardCard(index, currentPlayer, state, 1);
        -:  791:
        -:  792:		//gain 4 Gold cards
    #####:  793:		for (i = 0; i < 4; i++)
        -:  794:		{
    #####:  795:			gainCard(gold, state, 1, currentPlayer);
        -:  796:		}
        -:  797:
        -:  798:		//return success
    #####:  799:		return 1;
        -:  800:	}
        -:  801:
        -:  802:	//no second treasure_map found in hand
    #####:  803:	return -1;
        -:  804:}
        -:  805:
      100:  806:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  807:{
        -:  808:	int i;
        -:  809:	int j;
        -:  810:	int k;
        -:  811:	//int x;  //Unused after while loop removed from feast.
      100:  812:	int currentPlayer = whoseTurn(state);
      100:  813:	int nextPlayer = currentPlayer + 1;
        -:  814:	int temphand[MAX_HAND];
        -:  815:
      100:  816:	int tributeRevealedCards[2] = { -1, -1 };
        -:  817:
      100:  818:	if (nextPlayer > (state->numPlayers - 1)){
       25:  819:		nextPlayer = 0;
        -:  820:	}
        -:  821:
        -:  822:	//uses switch to select card and perform actions
      100:  823:	switch (card)
        -:  824:	{
        -:  825:	case adventurer:
        -:  826:
    #####:  827:		playAdventurer(state, currentPlayer);
    #####:  828:		return 0;
        -:  829:
        -:  830:	case council_room:
        -:  831:		//+4 Cards
    #####:  832:		for (i = 0; i < 4; i++)
        -:  833:		{
    #####:  834:			drawCard(currentPlayer, state);
        -:  835:		}
        -:  836:
        -:  837:		//+1 Buy
    #####:  838:		state->numBuys++;
        -:  839:
        -:  840:		//Each other player draws a card
    #####:  841:		for (i = 0; i < state->numPlayers; i++)
        -:  842:		{
    #####:  843:			if (i != currentPlayer)
        -:  844:			{
    #####:  845:				drawCard(i, state);
        -:  846:			}
        -:  847:		}
        -:  848:
        -:  849:		//put played card in played card pile
    #####:  850:		discardCard(handPos, currentPlayer, state, 0);
        -:  851:
    #####:  852:		return 0;
        -:  853:
        -:  854:	case feast:
        -:  855:		//gain card with cost up to 5
        -:  856:		//Backup hand
       56:  857:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
       48:  858:			temphand[i] = state->hand[currentPlayer][i];//Backup card
       48:  859:			state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  860:		}
        -:  861:		//Backup hand
        -:  862:
        -:  863:		//Update Coins for Buy
        8:  864:		updateCoins(currentPlayer, state, 5);
        -:  865://		x = 1;//Condition to loop on
        -:  866://		while (x == 1) {//Buy one card
        8:  867:			if (supplyCount(choice1, state) <= 0){
        -:  868:				if (DEBUG)
        -:  869:					printf("None of that card left, sorry!\n");
        -:  870:
        -:  871:				if (DEBUG){
        -:  872:					printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  873:				}
        -:  874:			}
        3:  875:			else if (state->coins < getCost(choice1)){
    #####:  876:				printf("That card is too expensive!\n");
        -:  877:
        -:  878:				if (DEBUG){
        -:  879:					printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  880:				}
        -:  881:			}
        -:  882:			else{
        -:  883:
        -:  884:				if (DEBUG){
        -:  885:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  886:				}
        -:  887:
        3:  888:				gainCard(choice1, state, 0, currentPlayer);//Gain the card
        -:  889://				x = 0;//No more buying cards
        -:  890:
        -:  891:				if (DEBUG){
        -:  892:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  893:				}
        -:  894:
        -:  895:			}
        -:  896://		}
        -:  897:
        -:  898:		//Reset Hand
       56:  899:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
       48:  900:			state->hand[currentPlayer][i] = temphand[i];
       48:  901:			temphand[i] = -1;
        -:  902:		}
        -:  903:		//Reset Hand
        -:  904:
        8:  905:		return 0;
        -:  906:
        -:  907:	case gardens:
    #####:  908:		return -1;
        -:  909:
        -:  910:	case mine:
        3:  911:		j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  912:
        3:  913:		if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  914:		{
        2:  915:			return -1;
        -:  916:		}
        -:  917:
        1:  918:		if (choice2 > treasure_map || choice2 < curse)
        -:  919:		{
    #####:  920:			return -1;
        -:  921:		}
        -:  922:
        1:  923:		if ((getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2))
        -:  924:		{
    #####:  925:			return -1;
        -:  926:		}
        -:  927:
        1:  928:		gainCard(choice2, state, 2, currentPlayer);
        -:  929:
        -:  930:		//discard card from hand
        1:  931:		discardCard(handPos, currentPlayer, state, 0);
        -:  932:
        -:  933:		//discard trashed card
        1:  934:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  935:		{
        1:  936:			if (state->hand[currentPlayer][i] == j)
        -:  937:			{
        1:  938:				discardCard(i, currentPlayer, state, 0);
        1:  939:				break;
        -:  940:			}
        -:  941:		}
        -:  942:
        1:  943:		return 0;
        -:  944:
        -:  945:	case remodel:
        -:  946:
        5:  947:		return playRemodel(state, currentPlayer, choice1, choice2, handPos);
        -:  948:
        -:  949:	case smithy:
        -:  950:
        8:  951:		playSmithy(state, currentPlayer, handPos);
        8:  952:		return 0;
        -:  953:
        -:  954:	case village:
        -:  955:		//+1 Card
    #####:  956:		drawCard(currentPlayer, state);
        -:  957:
        -:  958:		//+2 Actions
    #####:  959:		state->numActions = state->numActions + 2;
        -:  960:
        -:  961:		//discard played card from hand
    #####:  962:		discardCard(handPos, currentPlayer, state, 0);
    #####:  963:		return 0;
        -:  964:
        -:  965:	case baron:
        -:  966:
       10:  967:		playBaron(state, currentPlayer, choice1, handPos);
       10:  968:		return 0;
        -:  969:
        -:  970:	case great_hall:
        -:  971:		//+1 Card
       10:  972:		drawCard(currentPlayer, state);
        -:  973:
        -:  974:		//+1 Actions
       10:  975:		state->numActions++;
        -:  976:
        -:  977:		//discard card from hand
       10:  978:		discardCard(handPos, currentPlayer, state, 0);
       10:  979:		return 0;
        -:  980:
        -:  981:	case minion:
        -:  982:		//+1 action
    #####:  983:		state->numActions++;
        -:  984:
        -:  985:		//discard card from hand
    #####:  986:		discardCard(handPos, currentPlayer, state, 0);
        -:  987:
    #####:  988:		if (choice1)		//+2 coins
        -:  989:		{
    #####:  990:			state->coins = state->coins + 2;
        -:  991:		}
        -:  992:
    #####:  993:		else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  994:		{
        -:  995:			//discard hand
    #####:  996:			while (numHandCards(state) > 0)
        -:  997:			{
    #####:  998:				discardCard(handPos, currentPlayer, state, 0);
        -:  999:			}
        -: 1000:
        -: 1001:			//draw 4
    #####: 1002:			for (i = 0; i < 4; i++)
        -: 1003:			{
    #####: 1004:				drawCard(currentPlayer, state);
        -: 1005:			}
        -: 1006:
        -: 1007:			//other players discard hand and redraw if hand size > 4
    #####: 1008:			for (i = 0; i < state->numPlayers; i++)
        -: 1009:			{
    #####: 1010:				if (i != currentPlayer)
        -: 1011:				{
    #####: 1012:					if (state->handCount[i] > 4)
        -: 1013:					{
        -: 1014:						//discard hand
    #####: 1015:						while (state->handCount[i] > 0)
        -: 1016:						{
    #####: 1017:							discardCard(handPos, i, state, 0);
        -: 1018:						}
        -: 1019:
        -: 1020:						//draw 4
    #####: 1021:						for (j = 0; j < 4; j++)
        -: 1022:						{
    #####: 1023:							drawCard(i, state);
        -: 1024:						}
        -: 1025:					}
        -: 1026:				}
        -: 1027:			}
        -: 1028:
        -: 1029:		}
    #####: 1030:		return 0;
        -: 1031:
        -: 1032:	case steward:
        9: 1033:		if (choice1 == 1)
        -: 1034:		{
        -: 1035:			//+2 cards
    #####: 1036:			drawCard(currentPlayer, state);
    #####: 1037:			drawCard(currentPlayer, state);
        -: 1038:		}
        9: 1039:		else if (choice1 == 2)
        -: 1040:		{
        -: 1041:			//+2 coins
        1: 1042:			state->coins = state->coins + 2;
        -: 1043:		}
        -: 1044:		else
        -: 1045:		{
        -: 1046:			//trash 2 cards in hand
        8: 1047:			discardCard(choice2, currentPlayer, state, 1);
        8: 1048:			discardCard(choice3, currentPlayer, state, 1);
        -: 1049:		}
        -: 1050:
        -: 1051:		//discard card from hand
        9: 1052:		discardCard(handPos, currentPlayer, state, 0);
        9: 1053:		return 0;
        -: 1054:
        -: 1055:	case tribute:
    #####: 1056:		if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####: 1057:			if (state->deckCount[nextPlayer] > 0){
    #####: 1058:				tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1059:				state->deckCount[nextPlayer]--;
        -: 1060:			}
    #####: 1061:			else if (state->discardCount[nextPlayer] > 0){
    #####: 1062:				tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer] - 1];
    #####: 1063:				state->discardCount[nextPlayer]--;
        -: 1064:			}
        -: 1065:			else{
        -: 1066:				//No Card to Reveal
        -: 1067:				if (DEBUG){
        -: 1068:					printf("No cards to reveal\n");
        -: 1069:				}
        -: 1070:			}
        -: 1071:		}
        -: 1072:
        -: 1073:		else{
    #####: 1074:			if (state->deckCount[nextPlayer] == 0){
    #####: 1075:				for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####: 1076:					state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1077:					state->deckCount[nextPlayer]++;
    #####: 1078:					state->discard[nextPlayer][i] = -1;
    #####: 1079:					state->discardCount[nextPlayer]--;
        -: 1080:				}
        -: 1081:
    #####: 1082:				shuffle(nextPlayer, state);//Shuffle the deck
        -: 1083:			}
    #####: 1084:			tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1085:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1086:			state->deckCount[nextPlayer]--;
    #####: 1087:			tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1088:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1089:			state->deckCount[nextPlayer]--;
        -: 1090:		}
        -: 1091:
    #####: 1092:		if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
    #####: 1093:			state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1094:			state->playedCardCount++;
    #####: 1095:			tributeRevealedCards[1] = -1;
        -: 1096:		}
        -: 1097:
    #####: 1098:		for (i = 0; i <= 2; i++){
    #####: 1099:			if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
    #####: 1100:				state->coins += 2;
        -: 1101:			}
        -: 1102:
    #####: 1103:			else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
    #####: 1104:				drawCard(currentPlayer, state);
    #####: 1105:				drawCard(currentPlayer, state);
        -: 1106:			}
        -: 1107:			else{//Action Card
    #####: 1108:				state->numActions = state->numActions + 2;
        -: 1109:			}
        -: 1110:		}
        -: 1111:
    #####: 1112:		return 0;
        -: 1113:
        -: 1114:	case ambassador:
       40: 1115:		j = 0;		//used to check if player has enough cards to discard
        -: 1116:
       40: 1117:		if (choice2 > 2 || choice2 < 0)
        -: 1118:		{
       36: 1119:			return -1;
        -: 1120:		}
        -: 1121:
        4: 1122:		if (choice1 == handPos)
        -: 1123:		{
        1: 1124:			return -1;
        -: 1125:		}
        -: 1126:
       18: 1127:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1128:		{
       15: 1129:			if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1130:			{
        1: 1131:				j++;
        -: 1132:			}
        -: 1133:		}
        3: 1134:		if (j < choice2)
        -: 1135:		{
    #####: 1136:			return -1;
        -: 1137:		}
        -: 1138:
        -: 1139:		if (DEBUG)
        -: 1140:			printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1141:
        -: 1142:		//increase supply count for choosen card by amount being discarded
        3: 1143:		state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1144:
        -: 1145:		//each other player gains a copy of revealed card
       10: 1146:		for (i = 0; i < state->numPlayers; i++)
        -: 1147:		{
        7: 1148:			if (i != currentPlayer)
        -: 1149:			{
        4: 1150:				gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1151:			}
        -: 1152:		}
        -: 1153:
        -: 1154:		//discard played card from hand
        3: 1155:		discardCard(handPos, currentPlayer, state, 0);
        -: 1156:
        -: 1157:		//trash copies of cards returned to supply
        4: 1158:		for (j = 0; j < choice2; j++)
        -: 1159:		{
        4: 1160:			for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1161:			{
        4: 1162:				if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1163:				{
        1: 1164:					discardCard(i, currentPlayer, state, 1);
        1: 1165:					break;
        -: 1166:				}
        -: 1167:			}
        -: 1168:		}
        -: 1169:
        3: 1170:		return 0;
        -: 1171:
        -: 1172:	case cutpurse:
        -: 1173:
    #####: 1174:		updateCoins(currentPlayer, state, 2);
    #####: 1175:		for (i = 0; i < state->numPlayers; i++)
        -: 1176:		{
    #####: 1177:			if (i != currentPlayer)
        -: 1178:			{
    #####: 1179:				for (j = 0; j < state->handCount[i]; j++)
        -: 1180:				{
    #####: 1181:					if (state->hand[i][j] == copper)
        -: 1182:					{
    #####: 1183:						discardCard(j, i, state, 0);
    #####: 1184:						break;
        -: 1185:					}
    #####: 1186:					if (j == state->handCount[i])
        -: 1187:					{
    #####: 1188:						for (k = 0; k < state->handCount[i]; k++)
        -: 1189:						{
        -: 1190:							if (DEBUG)
        -: 1191:								printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1192:						}
    #####: 1193:						break;
        -: 1194:					}
        -: 1195:				}
        -: 1196:
        -: 1197:			}
        -: 1198:
        -: 1199:		}
        -: 1200:
        -: 1201:		//discard played card from hand
    #####: 1202:		discardCard(handPos, currentPlayer, state, 0);
        -: 1203:
    #####: 1204:		return 0;
        -: 1205:
        -: 1206:
        -: 1207:	case embargo:
        -: 1208:		//+2 Coins
        5: 1209:		state->coins = state->coins + 2;
        -: 1210:
        -: 1211:		//see if selected pile is in play
        5: 1212:		if (state->supplyCount[choice1] == -1)
        -: 1213:		{
        4: 1214:			return -1;
        -: 1215:		}
        -: 1216:
        -: 1217:		//add embargo token to selected supply pile
        1: 1218:		state->embargoTokens[choice1]++;
        -: 1219:
        -: 1220:		//trash card
        1: 1221:		discardCard(handPos, currentPlayer, state, 1);
        1: 1222:		return 0;
        -: 1223:
        -: 1224:	case outpost:
        -: 1225:		//set outpost flag
    #####: 1226:		state->outpostPlayed++;
        -: 1227:
        -: 1228:		//discard card
    #####: 1229:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1230:		return 0;
        -: 1231:
        -: 1232:	case salvager:
        -: 1233:		//+1 buy
    #####: 1234:		state->numBuys++;
        -: 1235:
    #####: 1236:		if (choice1)
        -: 1237:		{
        -: 1238:			//gain coins equal to trashed card
    #####: 1239:			state->coins = state->coins + getCost(handCard(choice1, state));
        -: 1240:			//trash card
    #####: 1241:			discardCard(choice1, currentPlayer, state, 1);
        -: 1242:		}
        -: 1243:
        -: 1244:		//discard card
    #####: 1245:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1246:		return 0;
        -: 1247:
        -: 1248:	case sea_hag:
        8: 1249:		for (i = 0; i < state->numPlayers; i++){
        6: 1250:			if (i != currentPlayer){
        4: 1251:				state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
        4: 1252:				state->discardCount[i]++;
        4: 1253:				state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1254:			}
        -: 1255:		}
        2: 1256:		return 0;
        -: 1257:
        -: 1258:	case treasure_map:
        -: 1259:
    #####: 1260:		return playTreasureMap(state, currentPlayer, handPos);
        -: 1261:	}
    #####: 1262:	return -1;
        -: 1263:}
        -: 1264:
       55: 1265:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1266:{
        -: 1267:
        -: 1268:	//if card is not trashed, added to Played pile 
       55: 1269:	if (trashFlag < 1)
        -: 1270:	{
        -: 1271:		//add card to played pile
       37: 1272:		state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
       37: 1273:		state->playedCardCount++;
        -: 1274:	}
        -: 1275:
        -: 1276:	//set played card to -1
       55: 1277:	state->hand[currentPlayer][handPos] = -1;
        -: 1278:
        -: 1279:	//remove card from player's hand
       55: 1280:	if (handPos == (state->handCount[currentPlayer] - 1)) 	//last card in hand array is played
        -: 1281:	{
        -: 1282:		//reduce number of cards in hand
        3: 1283:		state->handCount[currentPlayer]--;
        -: 1284:	}
       52: 1285:	else if (state->handCount[currentPlayer] == 1) //only one card in hand
        -: 1286:	{
        -: 1287:		//reduce number of cards in hand
    #####: 1288:		state->handCount[currentPlayer]--;
        -: 1289:	}
        -: 1290:	else
        -: 1291:	{
        -: 1292:		//replace discarded card with last card in hand
       52: 1293:		state->hand[currentPlayer][handPos] = state->hand[currentPlayer][(state->handCount[currentPlayer] - 1)];
        -: 1294:		//set last card to -1
       52: 1295:		state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1296:		//reduce number of cards in hand
       52: 1297:		state->handCount[currentPlayer]--;
        -: 1298:	}
        -: 1299:
       55: 1300:	return 0;
        -: 1301:}
        -: 1302:
      193: 1303:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1304:{
        -: 1305:	//Note: supplyPos is enum of choosen card
        -: 1306:
        -: 1307:	//check if supply pile is empty (0) or card is not used in game (-1)
      193: 1308:	if (supplyCount(supplyPos, state) < 1)
        -: 1309:	{
        2: 1310:		return -1;
        -: 1311:	}
        -: 1312:
        -: 1313:	//added card for [whoseTurn] current player:
        -: 1314:	// toFlag = 0 : add to discard
        -: 1315:	// toFlag = 1 : add to deck
        -: 1316:	// toFlag = 2 : add to hand
        -: 1317:
      191: 1318:	if (toFlag == 1)
        -: 1319:	{
        2: 1320:		state->deck[player][state->deckCount[player]] = supplyPos;
        2: 1321:		state->deckCount[player]++;
        -: 1322:	}
      189: 1323:	else if (toFlag == 2)
        -: 1324:	{
        1: 1325:		state->hand[player][state->handCount[player]] = supplyPos;
        1: 1326:		state->handCount[player]++;
        -: 1327:	}
        -: 1328:	else
        -: 1329:	{
      188: 1330:		state->discard[player][state->discardCount[player]] = supplyPos;
      188: 1331:		state->discardCount[player]++;
        -: 1332:	}
        -: 1333:
        -: 1334:	//decrease number in supply pile
      191: 1335:	state->supplyCount[supplyPos]--;
        -: 1336:
      191: 1337:	return 0;
        -: 1338:}
        -: 1339:
      292: 1340:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1341:{
        -: 1342:	int i;
        -: 1343:
        -: 1344:	//reset coin count
      292: 1345:	state->coins = 0;
        -: 1346:
        -: 1347:	//add coins for each Treasure card in player's hand
     1727: 1348:	for (i = 0; i < state->handCount[player]; i++)
        -: 1349:	{
     1435: 1350:		if (state->hand[player][i] == copper)
        -: 1351:		{
      640: 1352:			state->coins += 1;
        -: 1353:		}
      795: 1354:		else if (state->hand[player][i] == silver)
        -: 1355:		{
       79: 1356:			state->coins += 2;
        -: 1357:		}
      716: 1358:		else if (state->hand[player][i] == gold)
        -: 1359:		{
        3: 1360:			state->coins += 3;
        -: 1361:		}
        -: 1362:	}
        -: 1363:
        -: 1364:	//add bonus
      292: 1365:	state->coins += bonus;
        -: 1366:
      292: 1367:	return 0;
        -: 1368:}
        -: 1369:
        -: 1370:
        -: 1371://end of dominion.c
File 'dominion.c'
Lines executed:75.40% of 557
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
     3917:    8:int compare(const void* a, const void* b) {
     3917:    9:	if (*(int*)a > *(int*)b)
     1464:   10:		return 1;
     2453:   11:	if (*(int*)a < *(int*)b)
     1131:   12:		return -1;
     1322:   13:	return 0;
        -:   14:}
        -:   15:
        4:   16:struct gameState* newGame() {
        4:   17:	struct gameState* g = malloc(sizeof(struct gameState));
        4:   18:	return g;
        -:   19:}
        -:   20:
        5:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:	int k8, int k9, int k10) {
        5:   23:	int* k = malloc(10 * sizeof(int));
        5:   24:	k[0] = k1;
        5:   25:	k[1] = k2;
        5:   26:	k[2] = k3;
        5:   27:	k[3] = k4;
        5:   28:	k[4] = k5;
        5:   29:	k[5] = k6;
        5:   30:	k[6] = k7;
        5:   31:	k[7] = k8;
        5:   32:	k[8] = k9;
        5:   33:	k[9] = k10;
        5:   34:	return k;
        -:   35:}
        -:   36:
        5:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		struct gameState *state) {
        -:   39:
        -:   40:	int i;
        -:   41:	int j;
        -:   42:	int it;
        -:   43:	//set up random number generator
        5:   44:	SelectStream(1);
        5:   45:	PutSeed((long)randomSeed);
        -:   46:
        -:   47:	//check number of players
        5:   48:	if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:	{
    #####:   50:		return -1;
        -:   51:	}
        -:   52:
        -:   53:	//set number of players
        5:   54:	state->numPlayers = numPlayers;
        -:   55:
        -:   56:	//check selected kingdom cards are different
       31:   57:	for (i = 0; i < 10; i++)
        -:   58:	{
      308:   59:		for (j = 0; j < 10; j++)
        -:   60:		{
      282:   61:			if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:			{
        3:   63:				return -1;
        -:   64:			}
        -:   65:		}
        -:   66:	}
        -:   67:
        -:   68:
        -:   69:	//initialize supply
        -:   70:	///////////////////////////////
        -:   71:
        -:   72:	//set number of Curse cards
        2:   73:	if (numPlayers == 2)
        -:   74:	{
    #####:   75:		state->supplyCount[curse] = 10;
        -:   76:	}
        2:   77:	else if (numPlayers == 3)
        -:   78:	{
        1:   79:		state->supplyCount[curse] = 20;
        -:   80:	}
        -:   81:	else
        -:   82:	{
        1:   83:		state->supplyCount[curse] = 30;
        -:   84:	}
        -:   85:
        -:   86:	//set number of Victory cards
        2:   87:	if (numPlayers == 2)
        -:   88:	{
    #####:   89:		state->supplyCount[estate] = 8;
    #####:   90:		state->supplyCount[duchy] = 8;
    #####:   91:		state->supplyCount[province] = 8;
        -:   92:	}
        -:   93:	else
        -:   94:	{
        2:   95:		state->supplyCount[estate] = 12;
        2:   96:		state->supplyCount[duchy] = 12;
        2:   97:		state->supplyCount[province] = 12;
        -:   98:	}
        -:   99:
        -:  100:	//set number of Treasure cards
        2:  101:	state->supplyCount[copper] = 60 - (7 * numPlayers);
        2:  102:	state->supplyCount[silver] = 40;
        2:  103:	state->supplyCount[gold] = 30;
        -:  104:
        -:  105:	//set number of Kingdom cards
       42:  106:	for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:	{
      330:  108:		for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:		{
      310:  110:			if (kingdomCards[j] == i)
        -:  111:			{
        -:  112:				//check if card is a 'Victory' Kingdom card
       20:  113:				if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:				{
        2:  115:					if (numPlayers == 2){
    #####:  116:						state->supplyCount[i] = 8;
        -:  117:					}
        1:  118:					else{ state->supplyCount[i] = 12; }
        -:  119:				}
        -:  120:				else
        -:  121:				{
       19:  122:					state->supplyCount[i] = 10;
        -:  123:				}
       20:  124:				break;
        -:  125:			}
        -:  126:			else    //card is not in the set choosen for the game
        -:  127:			{
      290:  128:				state->supplyCount[i] = -1;
        -:  129:			}
        -:  130:		}
        -:  131:
        -:  132:	}
        -:  133:
        -:  134:	////////////////////////
        -:  135:	//supply intilization complete
        -:  136:
        -:  137:	//set player decks
        9:  138:	for (i = 0; i < numPlayers; i++)
        -:  139:	{
        7:  140:		state->deckCount[i] = 0;
       28:  141:		for (j = 0; j < 3; j++)
        -:  142:		{
       21:  143:			state->deck[i][j] = estate;
       21:  144:			state->deckCount[i]++;
        -:  145:		}
       56:  146:		for (j = 3; j < 10; j++)
        -:  147:		{
       49:  148:			state->deck[i][j] = copper;
       49:  149:			state->deckCount[i]++;
        -:  150:		}
        -:  151:	}
        -:  152:
        -:  153:	//shuffle player decks
        9:  154:	for (i = 0; i < numPlayers; i++)
        -:  155:	{
        7:  156:		if (shuffle(i, state) < 0)
        -:  157:		{
    #####:  158:			return -1;
        -:  159:		}
        -:  160:	}
        -:  161:
        -:  162:	//draw player hands
        9:  163:	for (i = 0; i < numPlayers; i++)
        -:  164:	{
        -:  165:		//initialize hand size to zero
        7:  166:		state->handCount[i] = 0;
        7:  167:		state->discardCount[i] = 0;
        -:  168:		//draw 5 cards
        -:  169:		// for (j = 0; j < 5; j++)
        -:  170:		//	{
        -:  171:		//	  drawCard(i, state);
        -:  172:		//	}
        -:  173:	}
        -:  174:
        -:  175:	//set embargo tokens to 0 for all supply piles
       56:  176:	for (i = 0; i <= treasure_map; i++)
        -:  177:	{
       54:  178:		state->embargoTokens[i] = 0;
        -:  179:	}
        -:  180:
        -:  181:	//initialize first player's turn
        2:  182:	state->outpostPlayed = 0;
        2:  183:	state->phase = 0;
        2:  184:	state->numActions = 1;
        2:  185:	state->numBuys = 1;
        2:  186:	state->playedCardCount = 0;
        2:  187:	state->whoseTurn = 0;
        2:  188:	state->handCount[state->whoseTurn] = 0;
        -:  189:	//int it; move to top
        -:  190:
        -:  191:	//Moved draw cards to here, only drawing at the start of a turn
       12:  192:	for (it = 0; it < 5; it++){
       10:  193:		drawCard(state->whoseTurn, state);
        -:  194:	}
        -:  195:
        2:  196:	updateCoins(state->whoseTurn, state, 0);
        -:  197:
        2:  198:	return 0;
        -:  199:}
        -:  200:
       95:  201:int shuffle(int player, struct gameState *state) {
        -:  202:
        -:  203:
        -:  204:	int newDeck[MAX_DECK];
       95:  205:	int newDeckPos = 0;
        -:  206:	int card;
        -:  207:	int i;
        -:  208:
       95:  209:	if (state->deckCount[player] < 1)
    #####:  210:		return -1;
       95:  211:	qsort((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
        -:  212:	/* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
     1898:  214:	while (state->deckCount[player] > 0) {
     1708:  215:		card = floor(Random() * state->deckCount[player]);
     1708:  216:		newDeck[newDeckPos] = state->deck[player][card];
     1708:  217:		newDeckPos++;
    10257:  218:		for (i = card; i < state->deckCount[player] - 1; i++) {
     8549:  219:			state->deck[player][i] = state->deck[player][i + 1];
        -:  220:		}
     1708:  221:		state->deckCount[player]--;
        -:  222:	}
     1803:  223:	for (i = 0; i < newDeckPos; i++) {
     1708:  224:		state->deck[player][i] = newDeck[i];
     1708:  225:		state->deckCount[player]++;
        -:  226:	}
        -:  227:
       95:  228:	return 0;
        -:  229:}
        -:  230:
     1867:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state)
        -:  232:{
        -:  233:	int card;
     1867:  234:	int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:	//check if it is the right phase
     1867:  237:	if (state->phase != 0)
        -:  238:	{
      278:  239:		return -1;
        -:  240:	}
        -:  241:
        -:  242:	//check if player has enough actions
     1589:  243:	if (state->numActions < 1)
        -:  244:	{
       52:  245:		return -1;
        -:  246:	}
        -:  247:
        -:  248:	//get card played
     1537:  249:	card = handCard(handPos, state);
        -:  250:
        -:  251:	//check if selected card is an action
     1537:  252:	if (card < adventurer || card > treasure_map)
        -:  253:	{
     1407:  254:		return -1;
        -:  255:	}
        -:  256:
        -:  257:	//play card
      130:  258:	if (cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0)
        -:  259:	{
       66:  260:		return -1;
        -:  261:	}
        -:  262:
        -:  263:	//reduce number of actions
       64:  264:	state->numActions--;
        -:  265:
        -:  266:	//update coins (Treasure cards may be added with card draws)
       64:  267:	updateCoins(state->whoseTurn, state, coin_bonus);
        -:  268:
       64:  269:	return 0;
        -:  270:}
        -:  271:
     1820:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:	int who;
        -:  274:	if (DEBUG){
        -:  275:		printf("Entering buyCard...\n");
        -:  276:	}
        -:  277:
        -:  278:	// I don't know what to do about the phase thing.
        -:  279:
     1820:  280:	who = state->whoseTurn;
        -:  281:
     1820:  282:	if (state->numBuys < 1){
        -:  283:		if (DEBUG)
        -:  284:			printf("You do not have any buys left\n");
      227:  285:		return -1;
        -:  286:	}
     1593:  287:	else if (supplyCount(supplyPos, state) < 1){
        -:  288:		if (DEBUG)
        -:  289:			printf("There are not any of that type of card left\n");
      628:  290:		return -1;
        -:  291:	}
      965:  292:	else if (state->coins < getCost(supplyPos)){
        -:  293:		if (DEBUG)
        -:  294:			printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
      718:  295:		return -1;
        -:  296:	}
        -:  297:	else {
      247:  298:		state->phase = 1;
        -:  299:		//state->supplyCount[supplyPos]--;
      247:  300:		gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  301:
      247:  302:		state->coins = (state->coins) - (getCost(supplyPos));
      247:  303:		state->numBuys--;
        -:  304:		if (DEBUG)
        -:  305:			printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  306:	}
        -:  307:
        -:  308:	//state->discard[who][state->discardCount[who]] = supplyPos;
        -:  309:	//state->discardCount[who]++;
        -:  310:
      247:  311:	return 0;
        -:  312:}
        -:  313:
    #####:  314:int numHandCards(struct gameState *state) {
    #####:  315:	return state->handCount[whoseTurn(state)];
        -:  316:}
        -:  317:
     1538:  318:int handCard(int handPos, struct gameState *state) {
     1538:  319:	int currentPlayer = whoseTurn(state);
     1538:  320:	return state->hand[currentPlayer][handPos];
        -:  321:}
        -:  322:
     1865:  323:int supplyCount(int card, struct gameState *state) {
     1865:  324:	return state->supplyCount[card];
        -:  325:}
        -:  326:
        4:  327:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  328:	int i;
        4:  329:	int count = 0;
        -:  330:
       69:  331:	for (i = 0; i < state->deckCount[player]; i++)
        -:  332:	{
       65:  333:		if (state->deck[player][i] == card) count++;
        -:  334:	}
        -:  335:
        9:  336:	for (i = 0; i < state->handCount[player]; i++)
        -:  337:	{
        5:  338:		if (state->hand[player][i] == card) count++;
        -:  339:	}
        -:  340:
       82:  341:	for (i = 0; i < state->discardCount[player]; i++)
        -:  342:	{
       78:  343:		if (state->discard[player][i] == card) count++;
        -:  344:	}
        -:  345:
        4:  346:	return count;
        -:  347:}
        -:  348:
     1969:  349:int whoseTurn(struct gameState *state) {
     1969:  350:	return state->whoseTurn;
        -:  351:}
        -:  352:
      301:  353:int endTurn(struct gameState *state) {
        -:  354:	int k;
        -:  355:	int i;
      301:  356:	int currentPlayer = whoseTurn(state);
        -:  357:
        -:  358:	//Discard hand
     1774:  359:	for (i = 0; i < state->handCount[currentPlayer]; i++){
     1473:  360:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
     1473:  361:		state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  362:	}
      301:  363:	state->handCount[currentPlayer] = 0;//Reset hand count
        -:  364:
        -:  365:	//Code for determining the player
      301:  366:	if (currentPlayer < (state->numPlayers - 1)){
      213:  367:		state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  368:	}
        -:  369:	else{
       88:  370:		state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  371:	}
        -:  372:
      301:  373:	state->outpostPlayed = 0;
      301:  374:	state->phase = 0;
      301:  375:	state->numActions = 1;
      301:  376:	state->coins = 0;
      301:  377:	state->numBuys = 1;
      301:  378:	state->playedCardCount = 0;
      301:  379:	state->handCount[state->whoseTurn] = 0;
        -:  380:
        -:  381:	//int k; move to top
        -:  382:	//Next player draws hand
     1806:  383:	for (k = 0; k < 5; k++){
     1505:  384:		drawCard(state->whoseTurn, state);//Draw a card
        -:  385:	}
        -:  386:
        -:  387:	//Update money
      301:  388:	updateCoins(state->whoseTurn, state, 0);
        -:  389:
      301:  390:	return 0;
        -:  391:}
        -:  392:
     5529:  393:int isGameOver(struct gameState *state) {
        -:  394:	int i;
        -:  395:	int j;
        -:  396:
        -:  397:	//if stack of Province cards is empty, the game ends
     5529:  398:	if (state->supplyCount[province] == 0)
        -:  399:	{
    #####:  400:		return 1;
        -:  401:	}
        -:  402:
        -:  403:	//if three supply pile are at 0, the game ends
     5529:  404:	j = 0;
   143754:  405:	for (i = 0; i < 25; i++)
        -:  406:	{
   138225:  407:		if (state->supplyCount[i] == 0)
        -:  408:		{
     6459:  409:			j++;
        -:  410:		}
        -:  411:	}
     5529:  412:	if (j >= 3)
        -:  413:	{
        2:  414:		return 1;
        -:  415:	}
        -:  416:
     5527:  417:	return 0;
        -:  418:}
        -:  419:
        7:  420:int scoreFor(int player, struct gameState *state) {
        -:  421:
        -:  422:	int i;
        7:  423:	int score = 0;
        -:  424:	//score from hand
       17:  425:	for (i = 0; i < state->handCount[player]; i++)
        -:  426:	{
       10:  427:		if (state->hand[player][i] == curse) { score = score - 1; };
       10:  428:		if (state->hand[player][i] == estate) { score = score + 1; };
       10:  429:		if (state->hand[player][i] == duchy) { score = score + 3; };
       10:  430:		if (state->hand[player][i] == province) { score = score + 6; };
       10:  431:		if (state->hand[player][i] == great_hall) { score = score + 1; };
       10:  432:		if (state->hand[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  433:	}
        -:  434:
        -:  435:	//score from discard
      113:  436:	for (i = 0; i < state->discardCount[player]; i++)
        -:  437:	{
      106:  438:		if (state->discard[player][i] == curse) { score = score - 1; };
      106:  439:		if (state->discard[player][i] == estate) { score = score + 1; };
      106:  440:		if (state->discard[player][i] == duchy) { score = score + 3; };
      106:  441:		if (state->discard[player][i] == province) { score = score + 6; };
      106:  442:		if (state->discard[player][i] == great_hall) { score = score + 1; };
      106:  443:		if (state->discard[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  444:	}
        -:  445:
        -:  446:	//score from deck
      113:  447:	for (i = 0; i < state->discardCount[player]; i++)
        -:  448:	{
      106:  449:		if (state->deck[player][i] == curse) { score = score - 1; };
      106:  450:		if (state->deck[player][i] == estate) { score = score + 1; };
      106:  451:		if (state->deck[player][i] == duchy) { score = score + 3; };
      106:  452:		if (state->deck[player][i] == province) { score = score + 6; };
      106:  453:		if (state->deck[player][i] == great_hall) { score = score + 1; };
      106:  454:		if (state->deck[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  455:	}
        -:  456:
        7:  457:	return score;
        -:  458:}
        -:  459:
    #####:  460:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  461:	int i;
        -:  462:	int j;
        -:  463:	int highScore;
        -:  464:	int currentPlayer;
        -:  465:
        -:  466:	//get score for each player
    #####:  467:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  468:	{
        -:  469:		//set unused player scores to -9999
    #####:  470:		if (i >= state->numPlayers)
        -:  471:		{
    #####:  472:			players[i] = -9999;
        -:  473:		}
        -:  474:		else
        -:  475:		{
    #####:  476:			players[i] = scoreFor(i, state);
        -:  477:		}
        -:  478:	}
        -:  479:
        -:  480:	//find highest score
    #####:  481:	j = 0;
    #####:  482:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  483:	{
    #####:  484:		if (players[i] > players[j])
        -:  485:		{
    #####:  486:			j = i;
        -:  487:		}
        -:  488:	}
    #####:  489:	highScore = players[j];
        -:  490:
        -:  491:	//add 1 to players who had less turns
    #####:  492:	currentPlayer = whoseTurn(state);
    #####:  493:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  494:	{
    #####:  495:		if (players[i] == highScore && i > currentPlayer)
        -:  496:		{
    #####:  497:			players[i]++;
        -:  498:		}
        -:  499:	}
        -:  500:
        -:  501:	//find new highest score
    #####:  502:	j = 0;
    #####:  503:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  504:	{
    #####:  505:		if (players[i] > players[j])
        -:  506:		{
    #####:  507:			j = i;
        -:  508:		}
        -:  509:	}
    #####:  510:	highScore = players[j];
        -:  511:
        -:  512:	//set winners in array to 1 and rest to 0
    #####:  513:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  514:	{
    #####:  515:		if (players[i] == highScore)
        -:  516:		{
    #####:  517:			players[i] = 1;
        -:  518:		}
        -:  519:		else
        -:  520:		{
    #####:  521:			players[i] = 0;
        -:  522:		}
        -:  523:	}
        -:  524:
    #####:  525:	return 0;
        -:  526:}
        -:  527:
     1555:  528:int drawCard(int player, struct gameState *state)
        -:  529:{
        -:  530:	int count;
        -:  531:	int deckCounter;
     1555:  532:	if (state->deckCount[player] <= 0){//Deck is empty
        -:  533:
        -:  534:		//Step 1 Shuffle the discard pile back into a deck
        -:  535:		int i;
        -:  536:		//Move discard to deck
     1726:  537:		for (i = 0; i < state->discardCount[player]; i++){
     1638:  538:			state->deck[player][i] = state->discard[player][i];
     1638:  539:			state->discard[player][i] = -1;
        -:  540:		}
        -:  541:
       88:  542:		state->deckCount[player] = state->discardCount[player];
       88:  543:		state->discardCount[player] = 0;//Reset discard
        -:  544:
        -:  545:		//Shufffle the deck
       88:  546:		shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  547:
        -:  548:		if (DEBUG){//Debug statements
        -:  549:			printf("Deck count now: %d\n", state->deckCount[player]);
        -:  550:		}
        -:  551:
       88:  552:		state->discardCount[player] = 0;
        -:  553:
        -:  554:		//Step 2 Draw Card
       88:  555:		count = state->handCount[player];//Get current player's hand count
        -:  556:
        -:  557:		if (DEBUG){//Debug statements
        -:  558:			printf("Current hand count: %d\n", count);
        -:  559:		}
        -:  560:
       88:  561:		deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  562:
       88:  563:		if (deckCounter == 0)
    #####:  564:			return -1;
        -:  565:
       88:  566:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
       88:  567:		state->deckCount[player]--;
       88:  568:		state->handCount[player]++;//Increment hand count
        -:  569:	}
        -:  570:
        -:  571:	else{
     1467:  572:		int count = state->handCount[player];//Get current hand count for player
        -:  573:		int deckCounter;
        -:  574:		if (DEBUG){//Debug statements
        -:  575:			printf("Current hand count: %d\n", count);
        -:  576:		}
        -:  577:
     1467:  578:		deckCounter = state->deckCount[player];//Create holder for the deck count
     1467:  579:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
     1467:  580:		state->deckCount[player]--;
     1467:  581:		state->handCount[player]++;//Increment hand count
        -:  582:	}
        -:  583:
     1555:  584:	return 0;
        -:  585:}
        -:  586:
     1242:  587:int getCost(int cardNumber)
        -:  588:{
     1242:  589:	switch (cardNumber)
        -:  590:	{
        -:  591:	case curse:
      109:  592:		return 0;
        -:  593:	case estate:
       49:  594:		return 2;
        -:  595:	case duchy:
       75:  596:		return 5;
        -:  597:	case province:
       59:  598:		return 8;
        -:  599:	case copper:
      109:  600:		return 0;
        -:  601:	case silver:
       97:  602:		return 3;
        -:  603:	case gold:
       65:  604:		return 6;
        -:  605:	case adventurer:
       28:  606:		return 6;
        -:  607:	case council_room:
       36:  608:		return 5;
        -:  609:	case feast:
       31:  610:		return 4;
        -:  611:	case gardens:
       41:  612:		return 4;
        -:  613:	case mine:
       63:  614:		return 5;
        -:  615:	case remodel:
       75:  616:		return 4;
        -:  617:	case smithy:
       33:  618:		return 4;
        -:  619:	case village:
       39:  620:		return 3;
        -:  621:	case baron:
       43:  622:		return 4;
        -:  623:	case great_hall:
    #####:  624:		return 3;
        -:  625:	case minion:
    #####:  626:		return 5;
        -:  627:	case steward:
       38:  628:		return 3;
        -:  629:	case tribute:
       29:  630:		return 5;
        -:  631:	case ambassador:
    #####:  632:		return 3;
        -:  633:	case cutpurse:
       62:  634:		return 4;
        -:  635:	case embargo:
       20:  636:		return 2;
        -:  637:	case outpost:
       39:  638:		return 5;
        -:  639:	case salvager:
       43:  640:		return 4;
        -:  641:	case sea_hag:
       58:  642:		return 4;
        -:  643:	case treasure_map:
    #####:  644:		return 4;
        -:  645:	}
        -:  646:
        1:  647:	return -1;
        -:  648:}
        -:  649:
        5:  650:void playAdventurer(struct gameState *state, int currentPlayer)
        -:  651:// Reveal cards from deck until 2 Treasure cards are found.  Put those Treasure cards in the hand and discard the rest.
        -:  652:{
        5:  653:	int drawntreasure = 0;
        -:  654:	int temphand[MAX_HAND];
        -:  655:	int cardDrawn;
        5:  656:	int z = 0; // this is the counter for the temp hand
        -:  657:
       21:  658:	while (drawntreasure < 2){
       11:  659:		if (state->deckCount[currentPlayer] < 1){//if the deck is empty we need to shuffle discard and add to deck
    #####:  660:			shuffle(currentPlayer, state);
        -:  661:		}
       11:  662:		drawCard(currentPlayer, state);
       11:  663:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer] - 1];//top card of hand is most recently drawn card.
       11:  664:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
       10:  665:			drawntreasure++;
        -:  666:		else{
        1:  667:			temphand[z] = cardDrawn;
        1:  668:			state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
        1:  669:			z++;
        -:  670:		}
        -:  671:	}
       11:  672:	while (z - 1 >= 0){
        1:  673:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; // discard all cards in play that have been drawn
        1:  674:		z = z - 1;
        -:  675:	}
        5:  676:}
        -:  677:
       10:  678:int playRemodel(struct gameState *state, int currentPlayer, int choice1, int choice2, int handPos)
        -:  679://Trash a card in the hand, and gain a card costing up to $2 more than the trashed card
        -:  680:{
        -:  681:	int i;
       10:  682:	int j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  683:
       10:  684:	if ((getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2))
        -:  685:	{
        1:  686:		return -1;
        -:  687:	}
        -:  688:
        9:  689:	gainCard(choice2, state, 0, currentPlayer);
        -:  690:
        -:  691:	//discard card from hand
        9:  692:	discardCard(handPos, currentPlayer, state, 0);
        -:  693:
        -:  694:	//discard trashed card
       35:  695:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  696:	{
       30:  697:		if (state->hand[currentPlayer][i] == j)
        -:  698:		{
        4:  699:			discardCard(i, currentPlayer, state, 0);
        4:  700:			break;
        -:  701:		}
        -:  702:	}
        -:  703:
        9:  704:	return 0;
        -:  705:}
        -:  706:
        2:  707:void playSmithy(struct gameState *state, int currentPlayer, int handPos)
        -:  708:// Draw 3 cards
        -:  709:{
        -:  710:	int i;
        8:  711:	for (i = 0; i < 3; i++)
        -:  712:	{
        6:  713:		drawCard(currentPlayer, state);
        -:  714:	}
        -:  715:
        -:  716:	//discard card from hand
        2:  717:	discardCard(handPos, currentPlayer, state, 0);
        2:  718:}
        -:  719:
        4:  720:void playBaron(struct gameState *state, int currentPlayer, int choice1, int handPos)
        -:  721://Add a buy.  OPTION:  Discard an Estate card and gain $4.  Otherwise, gain an Estate card.
        -:  722:{
        4:  723:	state->numBuys++;//Increase buys by 1!
        4:  724:	if (choice1 > 0){//Boolean true or going to discard an estate
        4:  725:		int p = 0;//Iterator for hand!
        4:  726:		int card_not_discarded = 1;//Flag for discard set!
       25:  727:		while (card_not_discarded){
       17:  728:			if (state->hand[currentPlayer][p] == estate){ //Found an estate card!
        3:  729:				state->coins += 4;//Add 4 coins to the amount of coins
        3:  730:				state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
        3:  731:				state->discardCount[currentPlayer]++;
       11:  732:				for (; p < state->handCount[currentPlayer]; p++){
        8:  733:					state->hand[currentPlayer][p] = state->hand[currentPlayer][p + 1];
        -:  734:				}
        3:  735:				state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
        3:  736:				state->handCount[currentPlayer]--;
        3:  737:				card_not_discarded = 0;//Exit the loop
        -:  738:			}
       14:  739:			else if (p > state->handCount[currentPlayer]){
        -:  740:				if (DEBUG) {
        -:  741:					printf("No estate cards in your hand, invalid choice\n");
        -:  742:					printf("Must gain an estate if there are any\n");
        -:  743:				}
        1:  744:				if (supplyCount(estate, state) > 0){
        1:  745:					gainCard(estate, state, 1, currentPlayer);
        1:  746:					state->supplyCount[estate]--;//Decrement estates
        1:  747:					if (supplyCount(estate, state) == 0){
    #####:  748:						isGameOver(state);
        -:  749:					}
        -:  750:				}
        1:  751:				card_not_discarded = 0;//Exit the loop
        -:  752:			}
        -:  753:
        -:  754:			else{
       13:  755:				p++;//Next card
        -:  756:			}
        -:  757:		}
        -:  758:	}
        -:  759:
        -:  760:	else{
    #####:  761:		if (supplyCount(estate, state) > 0){
    #####:  762:			gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  763:			state->supplyCount[estate]--;//Decrement Estates
    #####:  764:			if (supplyCount(estate, state) == 0){
    #####:  765:				isGameOver(state);
        -:  766:			}
        -:  767:		}
        -:  768:	}
        4:  769:}
        -:  770:
    #####:  771:int playTreasureMap(struct gameState *state, int currentPlayer, int handPos)
        -:  772://Trashing two treasure map cards from the hand = four gold on top of the deck.
        -:  773:{
        -:  774:	int i;
        -:  775:	int index;
        -:  776:
        -:  777:	//search hand for another treasure_map
    #####:  778:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  779:	{
    #####:  780:		if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -:  781:		{
    #####:  782:			index = i;
    #####:  783:			break;
        -:  784:		}
        -:  785:	}
    #####:  786:	if (index > -1)
        -:  787:	{
        -:  788:		//trash both treasure cards
    #####:  789:		discardCard(handPos, currentPlayer, state, 1);
    #####:  790:		discardCard(index, currentPlayer, state, 1);
        -:  791:
        -:  792:		//gain 4 Gold cards
    #####:  793:		for (i = 0; i < 4; i++)
        -:  794:		{
    #####:  795:			gainCard(gold, state, 1, currentPlayer);
        -:  796:		}
        -:  797:
        -:  798:		//return success
    #####:  799:		return 1;
        -:  800:	}
        -:  801:
        -:  802:	//no second treasure_map found in hand
    #####:  803:	return -1;
        -:  804:}
        -:  805:
      130:  806:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  807:{
        -:  808:	int i;
        -:  809:	int j;
        -:  810:	int k;
        -:  811:	//int x;  //Unused after while loop removed from feast.
      130:  812:	int currentPlayer = whoseTurn(state);
      130:  813:	int nextPlayer = currentPlayer + 1;
        -:  814:	int temphand[MAX_HAND];
        -:  815:
      130:  816:	int tributeRevealedCards[2] = { -1, -1 };
        -:  817:
      130:  818:	if (nextPlayer > (state->numPlayers - 1)){
       32:  819:		nextPlayer = 0;
        -:  820:	}
        -:  821:
        -:  822:	//uses switch to select card and perform actions
      130:  823:	switch (card)
        -:  824:	{
        -:  825:	case adventurer:
        -:  826:
        5:  827:		playAdventurer(state, currentPlayer);
        5:  828:		return 0;
        -:  829:
        -:  830:	case council_room:
        -:  831:		//+4 Cards
       15:  832:		for (i = 0; i < 4; i++)
        -:  833:		{
       12:  834:			drawCard(currentPlayer, state);
        -:  835:		}
        -:  836:
        -:  837:		//+1 Buy
        3:  838:		state->numBuys++;
        -:  839:
        -:  840:		//Each other player draws a card
       12:  841:		for (i = 0; i < state->numPlayers; i++)
        -:  842:		{
        9:  843:			if (i != currentPlayer)
        -:  844:			{
        6:  845:				drawCard(i, state);
        -:  846:			}
        -:  847:		}
        -:  848:
        -:  849:		//put played card in played card pile
        3:  850:		discardCard(handPos, currentPlayer, state, 0);
        -:  851:
        3:  852:		return 0;
        -:  853:
        -:  854:	case feast:
        -:  855:		//gain card with cost up to 5
        -:  856:		//Backup hand
       49:  857:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
       42:  858:			temphand[i] = state->hand[currentPlayer][i];//Backup card
       42:  859:			state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  860:		}
        -:  861:		//Backup hand
        -:  862:
        -:  863:		//Update Coins for Buy
        7:  864:		updateCoins(currentPlayer, state, 5);
        -:  865://		x = 1;//Condition to loop on
        -:  866://		while (x == 1) {//Buy one card
        7:  867:			if (supplyCount(choice1, state) <= 0){
        -:  868:				if (DEBUG)
        -:  869:					printf("None of that card left, sorry!\n");
        -:  870:
        -:  871:				if (DEBUG){
        -:  872:					printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  873:				}
        -:  874:			}
        3:  875:			else if (state->coins < getCost(choice1)){
    #####:  876:				printf("That card is too expensive!\n");
        -:  877:
        -:  878:				if (DEBUG){
        -:  879:					printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  880:				}
        -:  881:			}
        -:  882:			else{
        -:  883:
        -:  884:				if (DEBUG){
        -:  885:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  886:				}
        -:  887:
        3:  888:				gainCard(choice1, state, 0, currentPlayer);//Gain the card
        -:  889://				x = 0;//No more buying cards
        -:  890:
        -:  891:				if (DEBUG){
        -:  892:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  893:				}
        -:  894:
        -:  895:			}
        -:  896://		}
        -:  897:
        -:  898:		//Reset Hand
       49:  899:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
       42:  900:			state->hand[currentPlayer][i] = temphand[i];
       42:  901:			temphand[i] = -1;
        -:  902:		}
        -:  903:		//Reset Hand
        -:  904:
        7:  905:		return 0;
        -:  906:
        -:  907:	case gardens:
       43:  908:		return -1;
        -:  909:
        -:  910:	case mine:
       16:  911:		j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  912:
       16:  913:		if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  914:		{
       13:  915:			return -1;
        -:  916:		}
        -:  917:
        3:  918:		if (choice2 > treasure_map || choice2 < curse)
        -:  919:		{
    #####:  920:			return -1;
        -:  921:		}
        -:  922:
        3:  923:		if ((getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2))
        -:  924:		{
    #####:  925:			return -1;
        -:  926:		}
        -:  927:
        3:  928:		gainCard(choice2, state, 2, currentPlayer);
        -:  929:
        -:  930:		//discard card from hand
        3:  931:		discardCard(handPos, currentPlayer, state, 0);
        -:  932:
        -:  933:		//discard trashed card
        8:  934:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  935:		{
        8:  936:			if (state->hand[currentPlayer][i] == j)
        -:  937:			{
        3:  938:				discardCard(i, currentPlayer, state, 0);
        3:  939:				break;
        -:  940:			}
        -:  941:		}
        -:  942:
        3:  943:		return 0;
        -:  944:
        -:  945:	case remodel:
        -:  946:
       10:  947:		return playRemodel(state, currentPlayer, choice1, choice2, handPos);
        -:  948:
        -:  949:	case smithy:
        -:  950:
        2:  951:		playSmithy(state, currentPlayer, handPos);
        2:  952:		return 0;
        -:  953:
        -:  954:	case village:
        -:  955:		//+1 Card
        5:  956:		drawCard(currentPlayer, state);
        -:  957:
        -:  958:		//+2 Actions
        5:  959:		state->numActions = state->numActions + 2;
        -:  960:
        -:  961:		//discard played card from hand
        5:  962:		discardCard(handPos, currentPlayer, state, 0);
        5:  963:		return 0;
        -:  964:
        -:  965:	case baron:
        -:  966:
        4:  967:		playBaron(state, currentPlayer, choice1, handPos);
        4:  968:		return 0;
        -:  969:
        -:  970:	case great_hall:
        -:  971:		//+1 Card
    #####:  972:		drawCard(currentPlayer, state);
        -:  973:
        -:  974:		//+1 Actions
    #####:  975:		state->numActions++;
        -:  976:
        -:  977:		//discard card from hand
    #####:  978:		discardCard(handPos, currentPlayer, state, 0);
    #####:  979:		return 0;
        -:  980:
        -:  981:	case minion:
        -:  982:		//+1 action
    #####:  983:		state->numActions++;
        -:  984:
        -:  985:		//discard card from hand
    #####:  986:		discardCard(handPos, currentPlayer, state, 0);
        -:  987:
    #####:  988:		if (choice1)		//+2 coins
        -:  989:		{
    #####:  990:			state->coins = state->coins + 2;
        -:  991:		}
        -:  992:
    #####:  993:		else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  994:		{
        -:  995:			//discard hand
    #####:  996:			while (numHandCards(state) > 0)
        -:  997:			{
    #####:  998:				discardCard(handPos, currentPlayer, state, 0);
        -:  999:			}
        -: 1000:
        -: 1001:			//draw 4
    #####: 1002:			for (i = 0; i < 4; i++)
        -: 1003:			{
    #####: 1004:				drawCard(currentPlayer, state);
        -: 1005:			}
        -: 1006:
        -: 1007:			//other players discard hand and redraw if hand size > 4
    #####: 1008:			for (i = 0; i < state->numPlayers; i++)
        -: 1009:			{
    #####: 1010:				if (i != currentPlayer)
        -: 1011:				{
    #####: 1012:					if (state->handCount[i] > 4)
        -: 1013:					{
        -: 1014:						//discard hand
    #####: 1015:						while (state->handCount[i] > 0)
        -: 1016:						{
    #####: 1017:							discardCard(handPos, i, state, 0);
        -: 1018:						}
        -: 1019:
        -: 1020:						//draw 4
    #####: 1021:						for (j = 0; j < 4; j++)
        -: 1022:						{
    #####: 1023:							drawCard(i, state);
        -: 1024:						}
        -: 1025:					}
        -: 1026:				}
        -: 1027:			}
        -: 1028:
        -: 1029:		}
    #####: 1030:		return 0;
        -: 1031:
        -: 1032:	case steward:
        7: 1033:		if (choice1 == 1)
        -: 1034:		{
        -: 1035:			//+2 cards
    #####: 1036:			drawCard(currentPlayer, state);
    #####: 1037:			drawCard(currentPlayer, state);
        -: 1038:		}
        7: 1039:		else if (choice1 == 2)
        -: 1040:		{
        -: 1041:			//+2 coins
    #####: 1042:			state->coins = state->coins + 2;
        -: 1043:		}
        -: 1044:		else
        -: 1045:		{
        -: 1046:			//trash 2 cards in hand
        7: 1047:			discardCard(choice2, currentPlayer, state, 1);
        7: 1048:			discardCard(choice3, currentPlayer, state, 1);
        -: 1049:		}
        -: 1050:
        -: 1051:		//discard card from hand
        7: 1052:		discardCard(handPos, currentPlayer, state, 0);
        7: 1053:		return 0;
        -: 1054:
        -: 1055:	case tribute:
        1: 1056:		if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####: 1057:			if (state->deckCount[nextPlayer] > 0){
    #####: 1058:				tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1059:				state->deckCount[nextPlayer]--;
        -: 1060:			}
    #####: 1061:			else if (state->discardCount[nextPlayer] > 0){
    #####: 1062:				tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer] - 1];
    #####: 1063:				state->discardCount[nextPlayer]--;
        -: 1064:			}
        -: 1065:			else{
        -: 1066:				//No Card to Reveal
        -: 1067:				if (DEBUG){
        -: 1068:					printf("No cards to reveal\n");
        -: 1069:				}
        -: 1070:			}
        -: 1071:		}
        -: 1072:
        -: 1073:		else{
        1: 1074:			if (state->deckCount[nextPlayer] == 0){
    #####: 1075:				for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####: 1076:					state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1077:					state->deckCount[nextPlayer]++;
    #####: 1078:					state->discard[nextPlayer][i] = -1;
    #####: 1079:					state->discardCount[nextPlayer]--;
        -: 1080:				}
        -: 1081:
    #####: 1082:				shuffle(nextPlayer, state);//Shuffle the deck
        -: 1083:			}
        1: 1084:			tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
        1: 1085:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
        1: 1086:			state->deckCount[nextPlayer]--;
        1: 1087:			tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
        1: 1088:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
        1: 1089:			state->deckCount[nextPlayer]--;
        -: 1090:		}
        -: 1091:
        1: 1092:		if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
    #####: 1093:			state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1094:			state->playedCardCount++;
    #####: 1095:			tributeRevealedCards[1] = -1;
        -: 1096:		}
        -: 1097:
        4: 1098:		for (i = 0; i <= 2; i++){
        3: 1099:			if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
        1: 1100:				state->coins += 2;
        -: 1101:			}
        -: 1102:
        2: 1103:			else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
    #####: 1104:				drawCard(currentPlayer, state);
    #####: 1105:				drawCard(currentPlayer, state);
        -: 1106:			}
        -: 1107:			else{//Action Card
        2: 1108:				state->numActions = state->numActions + 2;
        -: 1109:			}
        -: 1110:		}
        -: 1111:
        1: 1112:		return 0;
        -: 1113:
        -: 1114:	case ambassador:
    #####: 1115:		j = 0;		//used to check if player has enough cards to discard
        -: 1116:
    #####: 1117:		if (choice2 > 2 || choice2 < 0)
        -: 1118:		{
    #####: 1119:			return -1;
        -: 1120:		}
        -: 1121:
    #####: 1122:		if (choice1 == handPos)
        -: 1123:		{
    #####: 1124:			return -1;
        -: 1125:		}
        -: 1126:
    #####: 1127:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1128:		{
    #####: 1129:			if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1130:			{
    #####: 1131:				j++;
        -: 1132:			}
        -: 1133:		}
    #####: 1134:		if (j < choice2)
        -: 1135:		{
    #####: 1136:			return -1;
        -: 1137:		}
        -: 1138:
        -: 1139:		if (DEBUG)
        -: 1140:			printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1141:
        -: 1142:		//increase supply count for choosen card by amount being discarded
    #####: 1143:		state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1144:
        -: 1145:		//each other player gains a copy of revealed card
    #####: 1146:		for (i = 0; i < state->numPlayers; i++)
        -: 1147:		{
    #####: 1148:			if (i != currentPlayer)
        -: 1149:			{
    #####: 1150:				gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1151:			}
        -: 1152:		}
        -: 1153:
        -: 1154:		//discard played card from hand
    #####: 1155:		discardCard(handPos, currentPlayer, state, 0);
        -: 1156:
        -: 1157:		//trash copies of cards returned to supply
    #####: 1158:		for (j = 0; j < choice2; j++)
        -: 1159:		{
    #####: 1160:			for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1161:			{
    #####: 1162:				if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1163:				{
    #####: 1164:					discardCard(i, currentPlayer, state, 1);
    #####: 1165:					break;
        -: 1166:				}
        -: 1167:			}
        -: 1168:		}
        -: 1169:
    #####: 1170:		return 0;
        -: 1171:
        -: 1172:	case cutpurse:
        -: 1173:
        5: 1174:		updateCoins(currentPlayer, state, 2);
       24: 1175:		for (i = 0; i < state->numPlayers; i++)
        -: 1176:		{
       19: 1177:			if (i != currentPlayer)
        -: 1178:			{
       14: 1179:				for (j = 0; j < state->handCount[i]; j++)
        -: 1180:				{
    #####: 1181:					if (state->hand[i][j] == copper)
        -: 1182:					{
    #####: 1183:						discardCard(j, i, state, 0);
    #####: 1184:						break;
        -: 1185:					}
    #####: 1186:					if (j == state->handCount[i])
        -: 1187:					{
    #####: 1188:						for (k = 0; k < state->handCount[i]; k++)
        -: 1189:						{
        -: 1190:							if (DEBUG)
        -: 1191:								printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1192:						}
    #####: 1193:						break;
        -: 1194:					}
        -: 1195:				}
        -: 1196:
        -: 1197:			}
        -: 1198:
        -: 1199:		}
        -: 1200:
        -: 1201:		//discard played card from hand
        5: 1202:		discardCard(handPos, currentPlayer, state, 0);
        -: 1203:
        5: 1204:		return 0;
        -: 1205:
        -: 1206:
        -: 1207:	case embargo:
        -: 1208:		//+2 Coins
       16: 1209:		state->coins = state->coins + 2;
        -: 1210:
        -: 1211:		//see if selected pile is in play
       16: 1212:		if (state->supplyCount[choice1] == -1)
        -: 1213:		{
        9: 1214:			return -1;
        -: 1215:		}
        -: 1216:
        -: 1217:		//add embargo token to selected supply pile
        7: 1218:		state->embargoTokens[choice1]++;
        -: 1219:
        -: 1220:		//trash card
        7: 1221:		discardCard(handPos, currentPlayer, state, 1);
        7: 1222:		return 0;
        -: 1223:
        -: 1224:	case outpost:
        -: 1225:		//set outpost flag
    #####: 1226:		state->outpostPlayed++;
        -: 1227:
        -: 1228:		//discard card
    #####: 1229:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1230:		return 0;
        -: 1231:
        -: 1232:	case salvager:
        -: 1233:		//+1 buy
        1: 1234:		state->numBuys++;
        -: 1235:
        1: 1236:		if (choice1)
        -: 1237:		{
        -: 1238:			//gain coins equal to trashed card
        1: 1239:			state->coins = state->coins + getCost(handCard(choice1, state));
        -: 1240:			//trash card
        1: 1241:			discardCard(choice1, currentPlayer, state, 1);
        -: 1242:		}
        -: 1243:
        -: 1244:		//discard card
        1: 1245:		discardCard(handPos, currentPlayer, state, 0);
        1: 1246:		return 0;
        -: 1247:
        -: 1248:	case sea_hag:
       20: 1249:		for (i = 0; i < state->numPlayers; i++){
       15: 1250:			if (i != currentPlayer){
       10: 1251:				state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
       10: 1252:				state->discardCount[i]++;
       10: 1253:				state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1254:			}
        -: 1255:		}
        5: 1256:		return 0;
        -: 1257:
        -: 1258:	case treasure_map:
        -: 1259:
    #####: 1260:		return playTreasureMap(state, currentPlayer, handPos);
        -: 1261:	}
    #####: 1262:	return -1;
        -: 1263:}
        -: 1264:
       64: 1265:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1266:{
        -: 1267:
        -: 1268:	//if card is not trashed, added to Played pile 
       64: 1269:	if (trashFlag < 1)
        -: 1270:	{
        -: 1271:		//add card to played pile
       42: 1272:		state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
       42: 1273:		state->playedCardCount++;
        -: 1274:	}
        -: 1275:
        -: 1276:	//set played card to -1
       64: 1277:	state->hand[currentPlayer][handPos] = -1;
        -: 1278:
        -: 1279:	//remove card from player's hand
       64: 1280:	if (handPos == (state->handCount[currentPlayer] - 1)) 	//last card in hand array is played
        -: 1281:	{
        -: 1282:		//reduce number of cards in hand
        8: 1283:		state->handCount[currentPlayer]--;
        -: 1284:	}
       56: 1285:	else if (state->handCount[currentPlayer] == 1) //only one card in hand
        -: 1286:	{
        -: 1287:		//reduce number of cards in hand
    #####: 1288:		state->handCount[currentPlayer]--;
        -: 1289:	}
        -: 1290:	else
        -: 1291:	{
        -: 1292:		//replace discarded card with last card in hand
       56: 1293:		state->hand[currentPlayer][handPos] = state->hand[currentPlayer][(state->handCount[currentPlayer] - 1)];
        -: 1294:		//set last card to -1
       56: 1295:		state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1296:		//reduce number of cards in hand
       56: 1297:		state->handCount[currentPlayer]--;
        -: 1298:	}
        -: 1299:
       64: 1300:	return 0;
        -: 1301:}
        -: 1302:
      263: 1303:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1304:{
        -: 1305:	//Note: supplyPos is enum of choosen card
        -: 1306:
        -: 1307:	//check if supply pile is empty (0) or card is not used in game (-1)
      263: 1308:	if (supplyCount(supplyPos, state) < 1)
        -: 1309:	{
        3: 1310:		return -1;
        -: 1311:	}
        -: 1312:
        -: 1313:	//added card for [whoseTurn] current player:
        -: 1314:	// toFlag = 0 : add to discard
        -: 1315:	// toFlag = 1 : add to deck
        -: 1316:	// toFlag = 2 : add to hand
        -: 1317:
      260: 1318:	if (toFlag == 1)
        -: 1319:	{
        1: 1320:		state->deck[player][state->deckCount[player]] = supplyPos;
        1: 1321:		state->deckCount[player]++;
        -: 1322:	}
      259: 1323:	else if (toFlag == 2)
        -: 1324:	{
        2: 1325:		state->hand[player][state->handCount[player]] = supplyPos;
        2: 1326:		state->handCount[player]++;
        -: 1327:	}
        -: 1328:	else
        -: 1329:	{
      257: 1330:		state->discard[player][state->discardCount[player]] = supplyPos;
      257: 1331:		state->discardCount[player]++;
        -: 1332:	}
        -: 1333:
        -: 1334:	//decrease number in supply pile
      260: 1335:	state->supplyCount[supplyPos]--;
        -: 1336:
      260: 1337:	return 0;
        -: 1338:}
        -: 1339:
      379: 1340:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1341:{
        -: 1342:	int i;
        -: 1343:
        -: 1344:	//reset coin count
      379: 1345:	state->coins = 0;
        -: 1346:
        -: 1347:	//add coins for each Treasure card in player's hand
     2242: 1348:	for (i = 0; i < state->handCount[player]; i++)
        -: 1349:	{
     1863: 1350:		if (state->hand[player][i] == copper)
        -: 1351:		{
      762: 1352:			state->coins += 1;
        -: 1353:		}
     1101: 1354:		else if (state->hand[player][i] == silver)
        -: 1355:		{
      148: 1356:			state->coins += 2;
        -: 1357:		}
      953: 1358:		else if (state->hand[player][i] == gold)
        -: 1359:		{
    #####: 1360:			state->coins += 3;
        -: 1361:		}
        -: 1362:	}
        -: 1363:
        -: 1364:	//add bonus
      379: 1365:	state->coins += bonus;
        -: 1366:
      379: 1367:	return 0;
        -: 1368:}
        -: 1369:
        -: 1370:
        -: 1371://end of dominion.c
File 'dominion.c'
Lines executed:62.12% of 557
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
     3822:    8:int compare(const void* a, const void* b) {
     3822:    9:	if (*(int*)a > *(int*)b)
     1400:   10:		return 1;
     2422:   11:	if (*(int*)a < *(int*)b)
     1054:   12:		return -1;
     1368:   13:	return 0;
        -:   14:}
        -:   15:
        4:   16:struct gameState* newGame() {
        4:   17:	struct gameState* g = malloc(sizeof(struct gameState));
        4:   18:	return g;
        -:   19:}
        -:   20:
       81:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:	int k8, int k9, int k10) {
       81:   23:	int* k = malloc(10 * sizeof(int));
       81:   24:	k[0] = k1;
       81:   25:	k[1] = k2;
       81:   26:	k[2] = k3;
       81:   27:	k[3] = k4;
       81:   28:	k[4] = k5;
       81:   29:	k[5] = k6;
       81:   30:	k[6] = k7;
       81:   31:	k[7] = k8;
       81:   32:	k[8] = k9;
       81:   33:	k[9] = k10;
       81:   34:	return k;
        -:   35:}
        -:   36:
       81:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		struct gameState *state) {
        -:   39:
        -:   40:	int i;
        -:   41:	int j;
        -:   42:	int it;
        -:   43:	//set up random number generator
       81:   44:	SelectStream(1);
       81:   45:	PutSeed((long)randomSeed);
        -:   46:
        -:   47:	//check number of players
       81:   48:	if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:	{
    #####:   50:		return -1;
        -:   51:	}
        -:   52:
        -:   53:	//set number of players
       81:   54:	state->numPlayers = numPlayers;
        -:   55:
        -:   56:	//check selected kingdom cards are different
      189:   57:	for (i = 0; i < 10; i++)
        -:   58:	{
     1673:   59:		for (j = 0; j < 10; j++)
        -:   60:		{
     1565:   61:			if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:			{
       79:   63:				return -1;
        -:   64:			}
        -:   65:		}
        -:   66:	}
        -:   67:
        -:   68:
        -:   69:	//initialize supply
        -:   70:	///////////////////////////////
        -:   71:
        -:   72:	//set number of Curse cards
        2:   73:	if (numPlayers == 2)
        -:   74:	{
    #####:   75:		state->supplyCount[curse] = 10;
        -:   76:	}
        2:   77:	else if (numPlayers == 3)
        -:   78:	{
    #####:   79:		state->supplyCount[curse] = 20;
        -:   80:	}
        -:   81:	else
        -:   82:	{
        2:   83:		state->supplyCount[curse] = 30;
        -:   84:	}
        -:   85:
        -:   86:	//set number of Victory cards
        2:   87:	if (numPlayers == 2)
        -:   88:	{
    #####:   89:		state->supplyCount[estate] = 8;
    #####:   90:		state->supplyCount[duchy] = 8;
    #####:   91:		state->supplyCount[province] = 8;
        -:   92:	}
        -:   93:	else
        -:   94:	{
        2:   95:		state->supplyCount[estate] = 12;
        2:   96:		state->supplyCount[duchy] = 12;
        2:   97:		state->supplyCount[province] = 12;
        -:   98:	}
        -:   99:
        -:  100:	//set number of Treasure cards
        2:  101:	state->supplyCount[copper] = 60 - (7 * numPlayers);
        2:  102:	state->supplyCount[silver] = 40;
        2:  103:	state->supplyCount[gold] = 30;
        -:  104:
        -:  105:	//set number of Kingdom cards
       42:  106:	for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:	{
      330:  108:		for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:		{
      310:  110:			if (kingdomCards[j] == i)
        -:  111:			{
        -:  112:				//check if card is a 'Victory' Kingdom card
       20:  113:				if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:				{
        8:  115:					if (numPlayers == 2){
    #####:  116:						state->supplyCount[i] = 8;
        -:  117:					}
        4:  118:					else{ state->supplyCount[i] = 12; }
        -:  119:				}
        -:  120:				else
        -:  121:				{
       16:  122:					state->supplyCount[i] = 10;
        -:  123:				}
       20:  124:				break;
        -:  125:			}
        -:  126:			else    //card is not in the set choosen for the game
        -:  127:			{
      290:  128:				state->supplyCount[i] = -1;
        -:  129:			}
        -:  130:		}
        -:  131:
        -:  132:	}
        -:  133:
        -:  134:	////////////////////////
        -:  135:	//supply intilization complete
        -:  136:
        -:  137:	//set player decks
       10:  138:	for (i = 0; i < numPlayers; i++)
        -:  139:	{
        8:  140:		state->deckCount[i] = 0;
       32:  141:		for (j = 0; j < 3; j++)
        -:  142:		{
       24:  143:			state->deck[i][j] = estate;
       24:  144:			state->deckCount[i]++;
        -:  145:		}
       64:  146:		for (j = 3; j < 10; j++)
        -:  147:		{
       56:  148:			state->deck[i][j] = copper;
       56:  149:			state->deckCount[i]++;
        -:  150:		}
        -:  151:	}
        -:  152:
        -:  153:	//shuffle player decks
       10:  154:	for (i = 0; i < numPlayers; i++)
        -:  155:	{
        8:  156:		if (shuffle(i, state) < 0)
        -:  157:		{
    #####:  158:			return -1;
        -:  159:		}
        -:  160:	}
        -:  161:
        -:  162:	//draw player hands
       10:  163:	for (i = 0; i < numPlayers; i++)
        -:  164:	{
        -:  165:		//initialize hand size to zero
        8:  166:		state->handCount[i] = 0;
        8:  167:		state->discardCount[i] = 0;
        -:  168:		//draw 5 cards
        -:  169:		// for (j = 0; j < 5; j++)
        -:  170:		//	{
        -:  171:		//	  drawCard(i, state);
        -:  172:		//	}
        -:  173:	}
        -:  174:
        -:  175:	//set embargo tokens to 0 for all supply piles
       56:  176:	for (i = 0; i <= treasure_map; i++)
        -:  177:	{
       54:  178:		state->embargoTokens[i] = 0;
        -:  179:	}
        -:  180:
        -:  181:	//initialize first player's turn
        2:  182:	state->outpostPlayed = 0;
        2:  183:	state->phase = 0;
        2:  184:	state->numActions = 1;
        2:  185:	state->numBuys = 1;
        2:  186:	state->playedCardCount = 0;
        2:  187:	state->whoseTurn = 0;
        2:  188:	state->handCount[state->whoseTurn] = 0;
        -:  189:	//int it; move to top
        -:  190:
        -:  191:	//Moved draw cards to here, only drawing at the start of a turn
       12:  192:	for (it = 0; it < 5; it++){
       10:  193:		drawCard(state->whoseTurn, state);
        -:  194:	}
        -:  195:
        2:  196:	updateCoins(state->whoseTurn, state, 0);
        -:  197:
        2:  198:	return 0;
        -:  199:}
        -:  200:
       93:  201:int shuffle(int player, struct gameState *state) {
        -:  202:
        -:  203:
        -:  204:	int newDeck[MAX_DECK];
       93:  205:	int newDeckPos = 0;
        -:  206:	int card;
        -:  207:	int i;
        -:  208:
       93:  209:	if (state->deckCount[player] < 1)
    #####:  210:		return -1;
       93:  211:	qsort((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
        -:  212:	/* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
     1923:  214:	while (state->deckCount[player] > 0) {
     1737:  215:		card = floor(Random() * state->deckCount[player]);
     1737:  216:		newDeck[newDeckPos] = state->deck[player][card];
     1737:  217:		newDeckPos++;
    11224:  218:		for (i = card; i < state->deckCount[player] - 1; i++) {
     9487:  219:			state->deck[player][i] = state->deck[player][i + 1];
        -:  220:		}
     1737:  221:		state->deckCount[player]--;
        -:  222:	}
     1830:  223:	for (i = 0; i < newDeckPos; i++) {
     1737:  224:		state->deck[player][i] = newDeck[i];
     1737:  225:		state->deckCount[player]++;
        -:  226:	}
        -:  227:
       93:  228:	return 0;
        -:  229:}
        -:  230:
     1690:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state)
        -:  232:{
        -:  233:	int card;
     1690:  234:	int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:	//check if it is the right phase
     1690:  237:	if (state->phase != 0)
        -:  238:	{
      221:  239:		return -1;
        -:  240:	}
        -:  241:
        -:  242:	//check if player has enough actions
     1469:  243:	if (state->numActions < 1)
        -:  244:	{
       32:  245:		return -1;
        -:  246:	}
        -:  247:
        -:  248:	//get card played
     1437:  249:	card = handCard(handPos, state);
        -:  250:
        -:  251:	//check if selected card is an action
     1437:  252:	if (card < adventurer || card > treasure_map)
        -:  253:	{
     1268:  254:		return -1;
        -:  255:	}
        -:  256:
        -:  257:	//play card
      169:  258:	if (cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0)
        -:  259:	{
      100:  260:		return -1;
        -:  261:	}
        -:  262:
        -:  263:	//reduce number of actions
       69:  264:	state->numActions--;
        -:  265:
        -:  266:	//update coins (Treasure cards may be added with card draws)
       69:  267:	updateCoins(state->whoseTurn, state, coin_bonus);
        -:  268:
       69:  269:	return 0;
        -:  270:}
        -:  271:
     1728:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:	int who;
        -:  274:	if (DEBUG){
        -:  275:		printf("Entering buyCard...\n");
        -:  276:	}
        -:  277:
        -:  278:	// I don't know what to do about the phase thing.
        -:  279:
     1728:  280:	who = state->whoseTurn;
        -:  281:
     1728:  282:	if (state->numBuys < 1){
        -:  283:		if (DEBUG)
        -:  284:			printf("You do not have any buys left\n");
      253:  285:		return -1;
        -:  286:	}
     1475:  287:	else if (supplyCount(supplyPos, state) < 1){
        -:  288:		if (DEBUG)
        -:  289:			printf("There are not any of that type of card left\n");
      582:  290:		return -1;
        -:  291:	}
      893:  292:	else if (state->coins < getCost(supplyPos)){
        -:  293:		if (DEBUG)
        -:  294:			printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
      642:  295:		return -1;
        -:  296:	}
        -:  297:	else {
      251:  298:		state->phase = 1;
        -:  299:		//state->supplyCount[supplyPos]--;
      251:  300:		gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  301:
      251:  302:		state->coins = (state->coins) - (getCost(supplyPos));
      251:  303:		state->numBuys--;
        -:  304:		if (DEBUG)
        -:  305:			printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  306:	}
        -:  307:
        -:  308:	//state->discard[who][state->discardCount[who]] = supplyPos;
        -:  309:	//state->discardCount[who]++;
        -:  310:
      251:  311:	return 0;
        -:  312:}
        -:  313:
    #####:  314:int numHandCards(struct gameState *state) {
    #####:  315:	return state->handCount[whoseTurn(state)];
        -:  316:}
        -:  317:
     1443:  318:int handCard(int handPos, struct gameState *state) {
     1443:  319:	int currentPlayer = whoseTurn(state);
     1443:  320:	return state->hand[currentPlayer][handPos];
        -:  321:}
        -:  322:
     1768:  323:int supplyCount(int card, struct gameState *state) {
     1768:  324:	return state->supplyCount[card];
        -:  325:}
        -:  326:
        9:  327:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  328:	int i;
        9:  329:	int count = 0;
        -:  330:
      138:  331:	for (i = 0; i < state->deckCount[player]; i++)
        -:  332:	{
      129:  333:		if (state->deck[player][i] == card) count++;
        -:  334:	}
        -:  335:
       19:  336:	for (i = 0; i < state->handCount[player]; i++)
        -:  337:	{
       10:  338:		if (state->hand[player][i] == card) count++;
        -:  339:	}
        -:  340:
      195:  341:	for (i = 0; i < state->discardCount[player]; i++)
        -:  342:	{
      186:  343:		if (state->discard[player][i] == card) count++;
        -:  344:	}
        -:  345:
        9:  346:	return count;
        -:  347:}
        -:  348:
     1922:  349:int whoseTurn(struct gameState *state) {
     1922:  350:	return state->whoseTurn;
        -:  351:}
        -:  352:
      310:  353:int endTurn(struct gameState *state) {
        -:  354:	int k;
        -:  355:	int i;
      310:  356:	int currentPlayer = whoseTurn(state);
        -:  357:
        -:  358:	//Discard hand
     1831:  359:	for (i = 0; i < state->handCount[currentPlayer]; i++){
     1521:  360:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
     1521:  361:		state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  362:	}
      310:  363:	state->handCount[currentPlayer] = 0;//Reset hand count
        -:  364:
        -:  365:	//Code for determining the player
      310:  366:	if (currentPlayer < (state->numPlayers - 1)){
      233:  367:		state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  368:	}
        -:  369:	else{
       77:  370:		state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  371:	}
        -:  372:
      310:  373:	state->outpostPlayed = 0;
      310:  374:	state->phase = 0;
      310:  375:	state->numActions = 1;
      310:  376:	state->coins = 0;
      310:  377:	state->numBuys = 1;
      310:  378:	state->playedCardCount = 0;
      310:  379:	state->handCount[state->whoseTurn] = 0;
        -:  380:
        -:  381:	//int k; move to top
        -:  382:	//Next player draws hand
     1860:  383:	for (k = 0; k < 5; k++){
     1550:  384:		drawCard(state->whoseTurn, state);//Draw a card
        -:  385:	}
        -:  386:
        -:  387:	//Update money
      310:  388:	updateCoins(state->whoseTurn, state, 0);
        -:  389:
      310:  390:	return 0;
        -:  391:}
        -:  392:
     5102:  393:int isGameOver(struct gameState *state) {
        -:  394:	int i;
        -:  395:	int j;
        -:  396:
        -:  397:	//if stack of Province cards is empty, the game ends
     5102:  398:	if (state->supplyCount[province] == 0)
        -:  399:	{
    #####:  400:		return 1;
        -:  401:	}
        -:  402:
        -:  403:	//if three supply pile are at 0, the game ends
     5102:  404:	j = 0;
   132652:  405:	for (i = 0; i < 25; i++)
        -:  406:	{
   127550:  407:		if (state->supplyCount[i] == 0)
        -:  408:		{
     2362:  409:			j++;
        -:  410:		}
        -:  411:	}
     5102:  412:	if (j >= 3)
        -:  413:	{
        2:  414:		return 1;
        -:  415:	}
        -:  416:
     5100:  417:	return 0;
        -:  418:}
        -:  419:
        8:  420:int scoreFor(int player, struct gameState *state) {
        -:  421:
        -:  422:	int i;
        8:  423:	int score = 0;
        -:  424:	//score from hand
       18:  425:	for (i = 0; i < state->handCount[player]; i++)
        -:  426:	{
       10:  427:		if (state->hand[player][i] == curse) { score = score - 1; };
       10:  428:		if (state->hand[player][i] == estate) { score = score + 1; };
       10:  429:		if (state->hand[player][i] == duchy) { score = score + 3; };
       10:  430:		if (state->hand[player][i] == province) { score = score + 6; };
       10:  431:		if (state->hand[player][i] == great_hall) { score = score + 1; };
       10:  432:		if (state->hand[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  433:	}
        -:  434:
        -:  435:	//score from discard
      138:  436:	for (i = 0; i < state->discardCount[player]; i++)
        -:  437:	{
      130:  438:		if (state->discard[player][i] == curse) { score = score - 1; };
      130:  439:		if (state->discard[player][i] == estate) { score = score + 1; };
      130:  440:		if (state->discard[player][i] == duchy) { score = score + 3; };
      130:  441:		if (state->discard[player][i] == province) { score = score + 6; };
      130:  442:		if (state->discard[player][i] == great_hall) { score = score + 1; };
      130:  443:		if (state->discard[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  444:	}
        -:  445:
        -:  446:	//score from deck
      138:  447:	for (i = 0; i < state->discardCount[player]; i++)
        -:  448:	{
      130:  449:		if (state->deck[player][i] == curse) { score = score - 1; };
      130:  450:		if (state->deck[player][i] == estate) { score = score + 1; };
      130:  451:		if (state->deck[player][i] == duchy) { score = score + 3; };
      130:  452:		if (state->deck[player][i] == province) { score = score + 6; };
      130:  453:		if (state->deck[player][i] == great_hall) { score = score + 1; };
      130:  454:		if (state->deck[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  455:	}
        -:  456:
        8:  457:	return score;
        -:  458:}
        -:  459:
    #####:  460:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  461:	int i;
        -:  462:	int j;
        -:  463:	int highScore;
        -:  464:	int currentPlayer;
        -:  465:
        -:  466:	//get score for each player
    #####:  467:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  468:	{
        -:  469:		//set unused player scores to -9999
    #####:  470:		if (i >= state->numPlayers)
        -:  471:		{
    #####:  472:			players[i] = -9999;
        -:  473:		}
        -:  474:		else
        -:  475:		{
    #####:  476:			players[i] = scoreFor(i, state);
        -:  477:		}
        -:  478:	}
        -:  479:
        -:  480:	//find highest score
    #####:  481:	j = 0;
    #####:  482:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  483:	{
    #####:  484:		if (players[i] > players[j])
        -:  485:		{
    #####:  486:			j = i;
        -:  487:		}
        -:  488:	}
    #####:  489:	highScore = players[j];
        -:  490:
        -:  491:	//add 1 to players who had less turns
    #####:  492:	currentPlayer = whoseTurn(state);
    #####:  493:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  494:	{
    #####:  495:		if (players[i] == highScore && i > currentPlayer)
        -:  496:		{
    #####:  497:			players[i]++;
        -:  498:		}
        -:  499:	}
        -:  500:
        -:  501:	//find new highest score
    #####:  502:	j = 0;
    #####:  503:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  504:	{
    #####:  505:		if (players[i] > players[j])
        -:  506:		{
    #####:  507:			j = i;
        -:  508:		}
        -:  509:	}
    #####:  510:	highScore = players[j];
        -:  511:
        -:  512:	//set winners in array to 1 and rest to 0
    #####:  513:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  514:	{
    #####:  515:		if (players[i] == highScore)
        -:  516:		{
    #####:  517:			players[i] = 1;
        -:  518:		}
        -:  519:		else
        -:  520:		{
    #####:  521:			players[i] = 0;
        -:  522:		}
        -:  523:	}
        -:  524:
    #####:  525:	return 0;
        -:  526:}
        -:  527:
     1589:  528:int drawCard(int player, struct gameState *state)
        -:  529:{
        -:  530:	int count;
        -:  531:	int deckCounter;
     1589:  532:	if (state->deckCount[player] <= 0){//Deck is empty
        -:  533:
        -:  534:		//Step 1 Shuffle the discard pile back into a deck
        -:  535:		int i;
        -:  536:		//Move discard to deck
     1742:  537:		for (i = 0; i < state->discardCount[player]; i++){
     1657:  538:			state->deck[player][i] = state->discard[player][i];
     1657:  539:			state->discard[player][i] = -1;
        -:  540:		}
        -:  541:
       85:  542:		state->deckCount[player] = state->discardCount[player];
       85:  543:		state->discardCount[player] = 0;//Reset discard
        -:  544:
        -:  545:		//Shufffle the deck
       85:  546:		shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  547:
        -:  548:		if (DEBUG){//Debug statements
        -:  549:			printf("Deck count now: %d\n", state->deckCount[player]);
        -:  550:		}
        -:  551:
       85:  552:		state->discardCount[player] = 0;
        -:  553:
        -:  554:		//Step 2 Draw Card
       85:  555:		count = state->handCount[player];//Get current player's hand count
        -:  556:
        -:  557:		if (DEBUG){//Debug statements
        -:  558:			printf("Current hand count: %d\n", count);
        -:  559:		}
        -:  560:
       85:  561:		deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  562:
       85:  563:		if (deckCounter == 0)
    #####:  564:			return -1;
        -:  565:
       85:  566:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
       85:  567:		state->deckCount[player]--;
       85:  568:		state->handCount[player]++;//Increment hand count
        -:  569:	}
        -:  570:
        -:  571:	else{
     1504:  572:		int count = state->handCount[player];//Get current hand count for player
        -:  573:		int deckCounter;
        -:  574:		if (DEBUG){//Debug statements
        -:  575:			printf("Current hand count: %d\n", count);
        -:  576:		}
        -:  577:
     1504:  578:		deckCounter = state->deckCount[player];//Create holder for the deck count
     1504:  579:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
     1504:  580:		state->deckCount[player]--;
     1504:  581:		state->handCount[player]++;//Increment hand count
        -:  582:	}
        -:  583:
     1589:  584:	return 0;
        -:  585:}
        -:  586:
     1163:  587:int getCost(int cardNumber)
        -:  588:{
     1163:  589:	switch (cardNumber)
        -:  590:	{
        -:  591:	case curse:
      114:  592:		return 0;
        -:  593:	case estate:
       55:  594:		return 2;
        -:  595:	case duchy:
       51:  596:		return 5;
        -:  597:	case province:
       69:  598:		return 8;
        -:  599:	case copper:
      117:  600:		return 0;
        -:  601:	case silver:
       82:  602:		return 3;
        -:  603:	case gold:
       67:  604:		return 6;
        -:  605:	case adventurer:
       30:  606:		return 6;
        -:  607:	case council_room:
       27:  608:		return 5;
        -:  609:	case feast:
       69:  610:		return 4;
        -:  611:	case gardens:
       38:  612:		return 4;
        -:  613:	case mine:
    #####:  614:		return 5;
        -:  615:	case remodel:
    #####:  616:		return 4;
        -:  617:	case smithy:
       23:  618:		return 4;
        -:  619:	case village:
       71:  620:		return 3;
        -:  621:	case baron:
    #####:  622:		return 4;
        -:  623:	case great_hall:
       75:  624:		return 3;
        -:  625:	case minion:
       66:  626:		return 5;
        -:  627:	case steward:
    #####:  628:		return 3;
        -:  629:	case tribute:
    #####:  630:		return 5;
        -:  631:	case ambassador:
       22:  632:		return 3;
        -:  633:	case cutpurse:
       33:  634:		return 4;
        -:  635:	case embargo:
    #####:  636:		return 2;
        -:  637:	case outpost:
       59:  638:		return 5;
        -:  639:	case salvager:
       68:  640:		return 4;
        -:  641:	case sea_hag:
    #####:  642:		return 4;
        -:  643:	case treasure_map:
       27:  644:		return 4;
        -:  645:	}
        -:  646:
    #####:  647:	return -1;
        -:  648:}
        -:  649:
    #####:  650:void playAdventurer(struct gameState *state, int currentPlayer)
        -:  651:// Reveal cards from deck until 2 Treasure cards are found.  Put those Treasure cards in the hand and discard the rest.
        -:  652:{
    #####:  653:	int drawntreasure = 0;
        -:  654:	int temphand[MAX_HAND];
        -:  655:	int cardDrawn;
    #####:  656:	int z = 0; // this is the counter for the temp hand
        -:  657:
    #####:  658:	while (drawntreasure < 2){
    #####:  659:		if (state->deckCount[currentPlayer] < 1){//if the deck is empty we need to shuffle discard and add to deck
    #####:  660:			shuffle(currentPlayer, state);
        -:  661:		}
    #####:  662:		drawCard(currentPlayer, state);
    #####:  663:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer] - 1];//top card of hand is most recently drawn card.
    #####:  664:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
    #####:  665:			drawntreasure++;
        -:  666:		else{
    #####:  667:			temphand[z] = cardDrawn;
    #####:  668:			state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####:  669:			z++;
        -:  670:		}
        -:  671:	}
    #####:  672:	while (z - 1 >= 0){
    #####:  673:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; // discard all cards in play that have been drawn
    #####:  674:		z = z - 1;
        -:  675:	}
    #####:  676:}
        -:  677:
    #####:  678:int playRemodel(struct gameState *state, int currentPlayer, int choice1, int choice2, int handPos)
        -:  679://Trash a card in the hand, and gain a card costing up to $2 more than the trashed card
        -:  680:{
        -:  681:	int i;
    #####:  682:	int j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  683:
    #####:  684:	if ((getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2))
        -:  685:	{
    #####:  686:		return -1;
        -:  687:	}
        -:  688:
    #####:  689:	gainCard(choice2, state, 0, currentPlayer);
        -:  690:
        -:  691:	//discard card from hand
    #####:  692:	discardCard(handPos, currentPlayer, state, 0);
        -:  693:
        -:  694:	//discard trashed card
    #####:  695:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  696:	{
    #####:  697:		if (state->hand[currentPlayer][i] == j)
        -:  698:		{
    #####:  699:			discardCard(i, currentPlayer, state, 0);
    #####:  700:			break;
        -:  701:		}
        -:  702:	}
        -:  703:
    #####:  704:	return 0;
        -:  705:}
        -:  706:
        1:  707:void playSmithy(struct gameState *state, int currentPlayer, int handPos)
        -:  708:// Draw 3 cards
        -:  709:{
        -:  710:	int i;
        4:  711:	for (i = 0; i < 3; i++)
        -:  712:	{
        3:  713:		drawCard(currentPlayer, state);
        -:  714:	}
        -:  715:
        -:  716:	//discard card from hand
        1:  717:	discardCard(handPos, currentPlayer, state, 0);
        1:  718:}
        -:  719:
    #####:  720:void playBaron(struct gameState *state, int currentPlayer, int choice1, int handPos)
        -:  721://Add a buy.  OPTION:  Discard an Estate card and gain $4.  Otherwise, gain an Estate card.
        -:  722:{
    #####:  723:	state->numBuys++;//Increase buys by 1!
    #####:  724:	if (choice1 > 0){//Boolean true or going to discard an estate
    #####:  725:		int p = 0;//Iterator for hand!
    #####:  726:		int card_not_discarded = 1;//Flag for discard set!
    #####:  727:		while (card_not_discarded){
    #####:  728:			if (state->hand[currentPlayer][p] == estate){ //Found an estate card!
    #####:  729:				state->coins += 4;//Add 4 coins to the amount of coins
    #####:  730:				state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  731:				state->discardCount[currentPlayer]++;
    #####:  732:				for (; p < state->handCount[currentPlayer]; p++){
    #####:  733:					state->hand[currentPlayer][p] = state->hand[currentPlayer][p + 1];
        -:  734:				}
    #####:  735:				state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  736:				state->handCount[currentPlayer]--;
    #####:  737:				card_not_discarded = 0;//Exit the loop
        -:  738:			}
    #####:  739:			else if (p > state->handCount[currentPlayer]){
        -:  740:				if (DEBUG) {
        -:  741:					printf("No estate cards in your hand, invalid choice\n");
        -:  742:					printf("Must gain an estate if there are any\n");
        -:  743:				}
    #####:  744:				if (supplyCount(estate, state) > 0){
    #####:  745:					gainCard(estate, state, 1, currentPlayer);
    #####:  746:					state->supplyCount[estate]--;//Decrement estates
    #####:  747:					if (supplyCount(estate, state) == 0){
    #####:  748:						isGameOver(state);
        -:  749:					}
        -:  750:				}
    #####:  751:				card_not_discarded = 0;//Exit the loop
        -:  752:			}
        -:  753:
        -:  754:			else{
    #####:  755:				p++;//Next card
        -:  756:			}
        -:  757:		}
        -:  758:	}
        -:  759:
        -:  760:	else{
    #####:  761:		if (supplyCount(estate, state) > 0){
    #####:  762:			gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  763:			state->supplyCount[estate]--;//Decrement Estates
    #####:  764:			if (supplyCount(estate, state) == 0){
    #####:  765:				isGameOver(state);
        -:  766:			}
        -:  767:		}
        -:  768:	}
    #####:  769:}
        -:  770:
        2:  771:int playTreasureMap(struct gameState *state, int currentPlayer, int handPos)
        -:  772://Trashing two treasure map cards from the hand = four gold on top of the deck.
        -:  773:{
        -:  774:	int i;
        -:  775:	int index;
        -:  776:
        -:  777:	//search hand for another treasure_map
       12:  778:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  779:	{
       10:  780:		if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -:  781:		{
    #####:  782:			index = i;
    #####:  783:			break;
        -:  784:		}
        -:  785:	}
        2:  786:	if (index > -1)
        -:  787:	{
        -:  788:		//trash both treasure cards
        2:  789:		discardCard(handPos, currentPlayer, state, 1);
        2:  790:		discardCard(index, currentPlayer, state, 1);
        -:  791:
        -:  792:		//gain 4 Gold cards
       10:  793:		for (i = 0; i < 4; i++)
        -:  794:		{
        8:  795:			gainCard(gold, state, 1, currentPlayer);
        -:  796:		}
        -:  797:
        -:  798:		//return success
        2:  799:		return 1;
        -:  800:	}
        -:  801:
        -:  802:	//no second treasure_map found in hand
    #####:  803:	return -1;
        -:  804:}
        -:  805:
      169:  806:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  807:{
        -:  808:	int i;
        -:  809:	int j;
        -:  810:	int k;
        -:  811:	//int x;  //Unused after while loop removed from feast.
      169:  812:	int currentPlayer = whoseTurn(state);
      169:  813:	int nextPlayer = currentPlayer + 1;
        -:  814:	int temphand[MAX_HAND];
        -:  815:
      169:  816:	int tributeRevealedCards[2] = { -1, -1 };
        -:  817:
      169:  818:	if (nextPlayer > (state->numPlayers - 1)){
       44:  819:		nextPlayer = 0;
        -:  820:	}
        -:  821:
        -:  822:	//uses switch to select card and perform actions
      169:  823:	switch (card)
        -:  824:	{
        -:  825:	case adventurer:
        -:  826:
    #####:  827:		playAdventurer(state, currentPlayer);
    #####:  828:		return 0;
        -:  829:
        -:  830:	case council_room:
        -:  831:		//+4 Cards
    #####:  832:		for (i = 0; i < 4; i++)
        -:  833:		{
    #####:  834:			drawCard(currentPlayer, state);
        -:  835:		}
        -:  836:
        -:  837:		//+1 Buy
    #####:  838:		state->numBuys++;
        -:  839:
        -:  840:		//Each other player draws a card
    #####:  841:		for (i = 0; i < state->numPlayers; i++)
        -:  842:		{
    #####:  843:			if (i != currentPlayer)
        -:  844:			{
    #####:  845:				drawCard(i, state);
        -:  846:			}
        -:  847:		}
        -:  848:
        -:  849:		//put played card in played card pile
    #####:  850:		discardCard(handPos, currentPlayer, state, 0);
        -:  851:
    #####:  852:		return 0;
        -:  853:
        -:  854:	case feast:
        -:  855:		//gain card with cost up to 5
        -:  856:		//Backup hand
      132:  857:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
      113:  858:			temphand[i] = state->hand[currentPlayer][i];//Backup card
      113:  859:			state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  860:		}
        -:  861:		//Backup hand
        -:  862:
        -:  863:		//Update Coins for Buy
       19:  864:		updateCoins(currentPlayer, state, 5);
        -:  865://		x = 1;//Condition to loop on
        -:  866://		while (x == 1) {//Buy one card
       19:  867:			if (supplyCount(choice1, state) <= 0){
        -:  868:				if (DEBUG)
        -:  869:					printf("None of that card left, sorry!\n");
        -:  870:
        -:  871:				if (DEBUG){
        -:  872:					printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  873:				}
        -:  874:			}
       13:  875:			else if (state->coins < getCost(choice1)){
        1:  876:				printf("That card is too expensive!\n");
        -:  877:
        -:  878:				if (DEBUG){
        -:  879:					printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  880:				}
        -:  881:			}
        -:  882:			else{
        -:  883:
        -:  884:				if (DEBUG){
        -:  885:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  886:				}
        -:  887:
       12:  888:				gainCard(choice1, state, 0, currentPlayer);//Gain the card
        -:  889://				x = 0;//No more buying cards
        -:  890:
        -:  891:				if (DEBUG){
        -:  892:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  893:				}
        -:  894:
        -:  895:			}
        -:  896://		}
        -:  897:
        -:  898:		//Reset Hand
      132:  899:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
      113:  900:			state->hand[currentPlayer][i] = temphand[i];
      113:  901:			temphand[i] = -1;
        -:  902:		}
        -:  903:		//Reset Hand
        -:  904:
       19:  905:		return 0;
        -:  906:
        -:  907:	case gardens:
       84:  908:		return -1;
        -:  909:
        -:  910:	case mine:
    #####:  911:		j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  912:
    #####:  913:		if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  914:		{
    #####:  915:			return -1;
        -:  916:		}
        -:  917:
    #####:  918:		if (choice2 > treasure_map || choice2 < curse)
        -:  919:		{
    #####:  920:			return -1;
        -:  921:		}
        -:  922:
    #####:  923:		if ((getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2))
        -:  924:		{
    #####:  925:			return -1;
        -:  926:		}
        -:  927:
    #####:  928:		gainCard(choice2, state, 2, currentPlayer);
        -:  929:
        -:  930:		//discard card from hand
    #####:  931:		discardCard(handPos, currentPlayer, state, 0);
        -:  932:
        -:  933:		//discard trashed card
    #####:  934:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  935:		{
    #####:  936:			if (state->hand[currentPlayer][i] == j)
        -:  937:			{
    #####:  938:				discardCard(i, currentPlayer, state, 0);
    #####:  939:				break;
        -:  940:			}
        -:  941:		}
        -:  942:
    #####:  943:		return 0;
        -:  944:
        -:  945:	case remodel:
        -:  946:
    #####:  947:		return playRemodel(state, currentPlayer, choice1, choice2, handPos);
        -:  948:
        -:  949:	case smithy:
        -:  950:
        1:  951:		playSmithy(state, currentPlayer, handPos);
        1:  952:		return 0;
        -:  953:
        -:  954:	case village:
        -:  955:		//+1 Card
       11:  956:		drawCard(currentPlayer, state);
        -:  957:
        -:  958:		//+2 Actions
       11:  959:		state->numActions = state->numActions + 2;
        -:  960:
        -:  961:		//discard played card from hand
       11:  962:		discardCard(handPos, currentPlayer, state, 0);
       11:  963:		return 0;
        -:  964:
        -:  965:	case baron:
        -:  966:
    #####:  967:		playBaron(state, currentPlayer, choice1, handPos);
    #####:  968:		return 0;
        -:  969:
        -:  970:	case great_hall:
        -:  971:		//+1 Card
       15:  972:		drawCard(currentPlayer, state);
        -:  973:
        -:  974:		//+1 Actions
       15:  975:		state->numActions++;
        -:  976:
        -:  977:		//discard card from hand
       15:  978:		discardCard(handPos, currentPlayer, state, 0);
       15:  979:		return 0;
        -:  980:
        -:  981:	case minion:
        -:  982:		//+1 action
        7:  983:		state->numActions++;
        -:  984:
        -:  985:		//discard card from hand
        7:  986:		discardCard(handPos, currentPlayer, state, 0);
        -:  987:
        7:  988:		if (choice1)		//+2 coins
        -:  989:		{
        7:  990:			state->coins = state->coins + 2;
        -:  991:		}
        -:  992:
    #####:  993:		else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  994:		{
        -:  995:			//discard hand
    #####:  996:			while (numHandCards(state) > 0)
        -:  997:			{
    #####:  998:				discardCard(handPos, currentPlayer, state, 0);
        -:  999:			}
        -: 1000:
        -: 1001:			//draw 4
    #####: 1002:			for (i = 0; i < 4; i++)
        -: 1003:			{
    #####: 1004:				drawCard(currentPlayer, state);
        -: 1005:			}
        -: 1006:
        -: 1007:			//other players discard hand and redraw if hand size > 4
    #####: 1008:			for (i = 0; i < state->numPlayers; i++)
        -: 1009:			{
    #####: 1010:				if (i != currentPlayer)
        -: 1011:				{
    #####: 1012:					if (state->handCount[i] > 4)
        -: 1013:					{
        -: 1014:						//discard hand
    #####: 1015:						while (state->handCount[i] > 0)
        -: 1016:						{
    #####: 1017:							discardCard(handPos, i, state, 0);
        -: 1018:						}
        -: 1019:
        -: 1020:						//draw 4
    #####: 1021:						for (j = 0; j < 4; j++)
        -: 1022:						{
    #####: 1023:							drawCard(i, state);
        -: 1024:						}
        -: 1025:					}
        -: 1026:				}
        -: 1027:			}
        -: 1028:
        -: 1029:		}
        7: 1030:		return 0;
        -: 1031:
        -: 1032:	case steward:
    #####: 1033:		if (choice1 == 1)
        -: 1034:		{
        -: 1035:			//+2 cards
    #####: 1036:			drawCard(currentPlayer, state);
    #####: 1037:			drawCard(currentPlayer, state);
        -: 1038:		}
    #####: 1039:		else if (choice1 == 2)
        -: 1040:		{
        -: 1041:			//+2 coins
    #####: 1042:			state->coins = state->coins + 2;
        -: 1043:		}
        -: 1044:		else
        -: 1045:		{
        -: 1046:			//trash 2 cards in hand
    #####: 1047:			discardCard(choice2, currentPlayer, state, 1);
    #####: 1048:			discardCard(choice3, currentPlayer, state, 1);
        -: 1049:		}
        -: 1050:
        -: 1051:		//discard card from hand
    #####: 1052:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1053:		return 0;
        -: 1054:
        -: 1055:	case tribute:
    #####: 1056:		if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####: 1057:			if (state->deckCount[nextPlayer] > 0){
    #####: 1058:				tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1059:				state->deckCount[nextPlayer]--;
        -: 1060:			}
    #####: 1061:			else if (state->discardCount[nextPlayer] > 0){
    #####: 1062:				tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer] - 1];
    #####: 1063:				state->discardCount[nextPlayer]--;
        -: 1064:			}
        -: 1065:			else{
        -: 1066:				//No Card to Reveal
        -: 1067:				if (DEBUG){
        -: 1068:					printf("No cards to reveal\n");
        -: 1069:				}
        -: 1070:			}
        -: 1071:		}
        -: 1072:
        -: 1073:		else{
    #####: 1074:			if (state->deckCount[nextPlayer] == 0){
    #####: 1075:				for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####: 1076:					state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1077:					state->deckCount[nextPlayer]++;
    #####: 1078:					state->discard[nextPlayer][i] = -1;
    #####: 1079:					state->discardCount[nextPlayer]--;
        -: 1080:				}
        -: 1081:
    #####: 1082:				shuffle(nextPlayer, state);//Shuffle the deck
        -: 1083:			}
    #####: 1084:			tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1085:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1086:			state->deckCount[nextPlayer]--;
    #####: 1087:			tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1088:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1089:			state->deckCount[nextPlayer]--;
        -: 1090:		}
        -: 1091:
    #####: 1092:		if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
    #####: 1093:			state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1094:			state->playedCardCount++;
    #####: 1095:			tributeRevealedCards[1] = -1;
        -: 1096:		}
        -: 1097:
    #####: 1098:		for (i = 0; i <= 2; i++){
    #####: 1099:			if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
    #####: 1100:				state->coins += 2;
        -: 1101:			}
        -: 1102:
    #####: 1103:			else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
    #####: 1104:				drawCard(currentPlayer, state);
    #####: 1105:				drawCard(currentPlayer, state);
        -: 1106:			}
        -: 1107:			else{//Action Card
    #####: 1108:				state->numActions = state->numActions + 2;
        -: 1109:			}
        -: 1110:		}
        -: 1111:
    #####: 1112:		return 0;
        -: 1113:
        -: 1114:	case ambassador:
       17: 1115:		j = 0;		//used to check if player has enough cards to discard
        -: 1116:
       17: 1117:		if (choice2 > 2 || choice2 < 0)
        -: 1118:		{
       15: 1119:			return -1;
        -: 1120:		}
        -: 1121:
        2: 1122:		if (choice1 == handPos)
        -: 1123:		{
    #####: 1124:			return -1;
        -: 1125:		}
        -: 1126:
       12: 1127:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1128:		{
       10: 1129:			if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1130:			{
        1: 1131:				j++;
        -: 1132:			}
        -: 1133:		}
        2: 1134:		if (j < choice2)
        -: 1135:		{
        1: 1136:			return -1;
        -: 1137:		}
        -: 1138:
        -: 1139:		if (DEBUG)
        -: 1140:			printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1141:
        -: 1142:		//increase supply count for choosen card by amount being discarded
        1: 1143:		state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1144:
        -: 1145:		//each other player gains a copy of revealed card
        5: 1146:		for (i = 0; i < state->numPlayers; i++)
        -: 1147:		{
        4: 1148:			if (i != currentPlayer)
        -: 1149:			{
        3: 1150:				gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1151:			}
        -: 1152:		}
        -: 1153:
        -: 1154:		//discard played card from hand
        1: 1155:		discardCard(handPos, currentPlayer, state, 0);
        -: 1156:
        -: 1157:		//trash copies of cards returned to supply
        2: 1158:		for (j = 0; j < choice2; j++)
        -: 1159:		{
        5: 1160:			for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1161:			{
        4: 1162:				if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1163:				{
    #####: 1164:					discardCard(i, currentPlayer, state, 1);
    #####: 1165:					break;
        -: 1166:				}
        -: 1167:			}
        -: 1168:		}
        -: 1169:
        1: 1170:		return 0;
        -: 1171:
        -: 1172:	case cutpurse:
        -: 1173:
        5: 1174:		updateCoins(currentPlayer, state, 2);
       25: 1175:		for (i = 0; i < state->numPlayers; i++)
        -: 1176:		{
       20: 1177:			if (i != currentPlayer)
        -: 1178:			{
       15: 1179:				for (j = 0; j < state->handCount[i]; j++)
        -: 1180:				{
    #####: 1181:					if (state->hand[i][j] == copper)
        -: 1182:					{
    #####: 1183:						discardCard(j, i, state, 0);
    #####: 1184:						break;
        -: 1185:					}
    #####: 1186:					if (j == state->handCount[i])
        -: 1187:					{
    #####: 1188:						for (k = 0; k < state->handCount[i]; k++)
        -: 1189:						{
        -: 1190:							if (DEBUG)
        -: 1191:								printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1192:						}
    #####: 1193:						break;
        -: 1194:					}
        -: 1195:				}
        -: 1196:
        -: 1197:			}
        -: 1198:
        -: 1199:		}
        -: 1200:
        -: 1201:		//discard played card from hand
        5: 1202:		discardCard(handPos, currentPlayer, state, 0);
        -: 1203:
        5: 1204:		return 0;
        -: 1205:
        -: 1206:
        -: 1207:	case embargo:
        -: 1208:		//+2 Coins
    #####: 1209:		state->coins = state->coins + 2;
        -: 1210:
        -: 1211:		//see if selected pile is in play
    #####: 1212:		if (state->supplyCount[choice1] == -1)
        -: 1213:		{
    #####: 1214:			return -1;
        -: 1215:		}
        -: 1216:
        -: 1217:		//add embargo token to selected supply pile
    #####: 1218:		state->embargoTokens[choice1]++;
        -: 1219:
        -: 1220:		//trash card
    #####: 1221:		discardCard(handPos, currentPlayer, state, 1);
    #####: 1222:		return 0;
        -: 1223:
        -: 1224:	case outpost:
        -: 1225:		//set outpost flag
        1: 1226:		state->outpostPlayed++;
        -: 1227:
        -: 1228:		//discard card
        1: 1229:		discardCard(handPos, currentPlayer, state, 0);
        1: 1230:		return 0;
        -: 1231:
        -: 1232:	case salvager:
        -: 1233:		//+1 buy
        7: 1234:		state->numBuys++;
        -: 1235:
        7: 1236:		if (choice1)
        -: 1237:		{
        -: 1238:			//gain coins equal to trashed card
        6: 1239:			state->coins = state->coins + getCost(handCard(choice1, state));
        -: 1240:			//trash card
        6: 1241:			discardCard(choice1, currentPlayer, state, 1);
        -: 1242:		}
        -: 1243:
        -: 1244:		//discard card
        7: 1245:		discardCard(handPos, currentPlayer, state, 0);
        7: 1246:		return 0;
        -: 1247:
        -: 1248:	case sea_hag:
    #####: 1249:		for (i = 0; i < state->numPlayers; i++){
    #####: 1250:			if (i != currentPlayer){
    #####: 1251:				state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1252:				state->discardCount[i]++;
    #####: 1253:				state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1254:			}
        -: 1255:		}
    #####: 1256:		return 0;
        -: 1257:
        -: 1258:	case treasure_map:
        -: 1259:
        2: 1260:		return playTreasureMap(state, currentPlayer, handPos);
        -: 1261:	}
    #####: 1262:	return -1;
        -: 1263:}
        -: 1264:
       58: 1265:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1266:{
        -: 1267:
        -: 1268:	//if card is not trashed, added to Played pile 
       58: 1269:	if (trashFlag < 1)
        -: 1270:	{
        -: 1271:		//add card to played pile
       48: 1272:		state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
       48: 1273:		state->playedCardCount++;
        -: 1274:	}
        -: 1275:
        -: 1276:	//set played card to -1
       58: 1277:	state->hand[currentPlayer][handPos] = -1;
        -: 1278:
        -: 1279:	//remove card from player's hand
       58: 1280:	if (handPos == (state->handCount[currentPlayer] - 1)) 	//last card in hand array is played
        -: 1281:	{
        -: 1282:		//reduce number of cards in hand
        7: 1283:		state->handCount[currentPlayer]--;
        -: 1284:	}
       51: 1285:	else if (state->handCount[currentPlayer] == 1) //only one card in hand
        -: 1286:	{
        -: 1287:		//reduce number of cards in hand
    #####: 1288:		state->handCount[currentPlayer]--;
        -: 1289:	}
        -: 1290:	else
        -: 1291:	{
        -: 1292:		//replace discarded card with last card in hand
       51: 1293:		state->hand[currentPlayer][handPos] = state->hand[currentPlayer][(state->handCount[currentPlayer] - 1)];
        -: 1294:		//set last card to -1
       51: 1295:		state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1296:		//reduce number of cards in hand
       51: 1297:		state->handCount[currentPlayer]--;
        -: 1298:	}
        -: 1299:
       58: 1300:	return 0;
        -: 1301:}
        -: 1302:
      274: 1303:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1304:{
        -: 1305:	//Note: supplyPos is enum of choosen card
        -: 1306:
        -: 1307:	//check if supply pile is empty (0) or card is not used in game (-1)
      274: 1308:	if (supplyCount(supplyPos, state) < 1)
        -: 1309:	{
    #####: 1310:		return -1;
        -: 1311:	}
        -: 1312:
        -: 1313:	//added card for [whoseTurn] current player:
        -: 1314:	// toFlag = 0 : add to discard
        -: 1315:	// toFlag = 1 : add to deck
        -: 1316:	// toFlag = 2 : add to hand
        -: 1317:
      274: 1318:	if (toFlag == 1)
        -: 1319:	{
        8: 1320:		state->deck[player][state->deckCount[player]] = supplyPos;
        8: 1321:		state->deckCount[player]++;
        -: 1322:	}
      266: 1323:	else if (toFlag == 2)
        -: 1324:	{
    #####: 1325:		state->hand[player][state->handCount[player]] = supplyPos;
    #####: 1326:		state->handCount[player]++;
        -: 1327:	}
        -: 1328:	else
        -: 1329:	{
      266: 1330:		state->discard[player][state->discardCount[player]] = supplyPos;
      266: 1331:		state->discardCount[player]++;
        -: 1332:	}
        -: 1333:
        -: 1334:	//decrease number in supply pile
      274: 1335:	state->supplyCount[supplyPos]--;
        -: 1336:
      274: 1337:	return 0;
        -: 1338:}
        -: 1339:
      405: 1340:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1341:{
        -: 1342:	int i;
        -: 1343:
        -: 1344:	//reset coin count
      405: 1345:	state->coins = 0;
        -: 1346:
        -: 1347:	//add coins for each Treasure card in player's hand
     2399: 1348:	for (i = 0; i < state->handCount[player]; i++)
        -: 1349:	{
     1994: 1350:		if (state->hand[player][i] == copper)
        -: 1351:		{
      838: 1352:			state->coins += 1;
        -: 1353:		}
     1156: 1354:		else if (state->hand[player][i] == silver)
        -: 1355:		{
      138: 1356:			state->coins += 2;
        -: 1357:		}
     1018: 1358:		else if (state->hand[player][i] == gold)
        -: 1359:		{
       37: 1360:			state->coins += 3;
        -: 1361:		}
        -: 1362:	}
        -: 1363:
        -: 1364:	//add bonus
      405: 1365:	state->coins += bonus;
        -: 1366:
      405: 1367:	return 0;
        -: 1368:}
        -: 1369:
        -: 1370:
        -: 1371://end of dominion.c
File 'dominion.c'
Lines executed:63.73% of 557
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
     3273:    8:int compare(const void* a, const void* b) {
     3273:    9:	if (*(int*)a > *(int*)b)
     1241:   10:		return 1;
     2032:   11:	if (*(int*)a < *(int*)b)
     1084:   12:		return -1;
      948:   13:	return 0;
        -:   14:}
        -:   15:
        4:   16:struct gameState* newGame() {
        4:   17:	struct gameState* g = malloc(sizeof(struct gameState));
        4:   18:	return g;
        -:   19:}
        -:   20:
       36:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:	int k8, int k9, int k10) {
       36:   23:	int* k = malloc(10 * sizeof(int));
       36:   24:	k[0] = k1;
       36:   25:	k[1] = k2;
       36:   26:	k[2] = k3;
       36:   27:	k[3] = k4;
       36:   28:	k[4] = k5;
       36:   29:	k[5] = k6;
       36:   30:	k[6] = k7;
       36:   31:	k[7] = k8;
       36:   32:	k[8] = k9;
       36:   33:	k[9] = k10;
       36:   34:	return k;
        -:   35:}
        -:   36:
       36:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		struct gameState *state) {
        -:   39:
        -:   40:	int i;
        -:   41:	int j;
        -:   42:	int it;
        -:   43:	//set up random number generator
       36:   44:	SelectStream(1);
       36:   45:	PutSeed((long)randomSeed);
        -:   46:
        -:   47:	//check number of players
       36:   48:	if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:	{
    #####:   50:		return -1;
        -:   51:	}
        -:   52:
        -:   53:	//set number of players
       36:   54:	state->numPlayers = numPlayers;
        -:   55:
        -:   56:	//check selected kingdom cards are different
      118:   57:	for (i = 0; i < 10; i++)
        -:   58:	{
     1135:   59:		for (j = 0; j < 10; j++)
        -:   60:		{
     1053:   61:			if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:			{
       34:   63:				return -1;
        -:   64:			}
        -:   65:		}
        -:   66:	}
        -:   67:
        -:   68:
        -:   69:	//initialize supply
        -:   70:	///////////////////////////////
        -:   71:
        -:   72:	//set number of Curse cards
        2:   73:	if (numPlayers == 2)
        -:   74:	{
        1:   75:		state->supplyCount[curse] = 10;
        -:   76:	}
        1:   77:	else if (numPlayers == 3)
        -:   78:	{
        1:   79:		state->supplyCount[curse] = 20;
        -:   80:	}
        -:   81:	else
        -:   82:	{
    #####:   83:		state->supplyCount[curse] = 30;
        -:   84:	}
        -:   85:
        -:   86:	//set number of Victory cards
        2:   87:	if (numPlayers == 2)
        -:   88:	{
        1:   89:		state->supplyCount[estate] = 8;
        1:   90:		state->supplyCount[duchy] = 8;
        1:   91:		state->supplyCount[province] = 8;
        -:   92:	}
        -:   93:	else
        -:   94:	{
        1:   95:		state->supplyCount[estate] = 12;
        1:   96:		state->supplyCount[duchy] = 12;
        1:   97:		state->supplyCount[province] = 12;
        -:   98:	}
        -:   99:
        -:  100:	//set number of Treasure cards
        2:  101:	state->supplyCount[copper] = 60 - (7 * numPlayers);
        2:  102:	state->supplyCount[silver] = 40;
        2:  103:	state->supplyCount[gold] = 30;
        -:  104:
        -:  105:	//set number of Kingdom cards
       42:  106:	for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:	{
      330:  108:		for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:		{
      310:  110:			if (kingdomCards[j] == i)
        -:  111:			{
        -:  112:				//check if card is a 'Victory' Kingdom card
       20:  113:				if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:				{
        4:  115:					if (numPlayers == 2){
        2:  116:						state->supplyCount[i] = 8;
        -:  117:					}
    #####:  118:					else{ state->supplyCount[i] = 12; }
        -:  119:				}
        -:  120:				else
        -:  121:				{
       18:  122:					state->supplyCount[i] = 10;
        -:  123:				}
       20:  124:				break;
        -:  125:			}
        -:  126:			else    //card is not in the set choosen for the game
        -:  127:			{
      290:  128:				state->supplyCount[i] = -1;
        -:  129:			}
        -:  130:		}
        -:  131:
        -:  132:	}
        -:  133:
        -:  134:	////////////////////////
        -:  135:	//supply intilization complete
        -:  136:
        -:  137:	//set player decks
        7:  138:	for (i = 0; i < numPlayers; i++)
        -:  139:	{
        5:  140:		state->deckCount[i] = 0;
       20:  141:		for (j = 0; j < 3; j++)
        -:  142:		{
       15:  143:			state->deck[i][j] = estate;
       15:  144:			state->deckCount[i]++;
        -:  145:		}
       40:  146:		for (j = 3; j < 10; j++)
        -:  147:		{
       35:  148:			state->deck[i][j] = copper;
       35:  149:			state->deckCount[i]++;
        -:  150:		}
        -:  151:	}
        -:  152:
        -:  153:	//shuffle player decks
        7:  154:	for (i = 0; i < numPlayers; i++)
        -:  155:	{
        5:  156:		if (shuffle(i, state) < 0)
        -:  157:		{
    #####:  158:			return -1;
        -:  159:		}
        -:  160:	}
        -:  161:
        -:  162:	//draw player hands
        7:  163:	for (i = 0; i < numPlayers; i++)
        -:  164:	{
        -:  165:		//initialize hand size to zero
        5:  166:		state->handCount[i] = 0;
        5:  167:		state->discardCount[i] = 0;
        -:  168:		//draw 5 cards
        -:  169:		// for (j = 0; j < 5; j++)
        -:  170:		//	{
        -:  171:		//	  drawCard(i, state);
        -:  172:		//	}
        -:  173:	}
        -:  174:
        -:  175:	//set embargo tokens to 0 for all supply piles
       56:  176:	for (i = 0; i <= treasure_map; i++)
        -:  177:	{
       54:  178:		state->embargoTokens[i] = 0;
        -:  179:	}
        -:  180:
        -:  181:	//initialize first player's turn
        2:  182:	state->outpostPlayed = 0;
        2:  183:	state->phase = 0;
        2:  184:	state->numActions = 1;
        2:  185:	state->numBuys = 1;
        2:  186:	state->playedCardCount = 0;
        2:  187:	state->whoseTurn = 0;
        2:  188:	state->handCount[state->whoseTurn] = 0;
        -:  189:	//int it; move to top
        -:  190:
        -:  191:	//Moved draw cards to here, only drawing at the start of a turn
       12:  192:	for (it = 0; it < 5; it++){
       10:  193:		drawCard(state->whoseTurn, state);
        -:  194:	}
        -:  195:
        2:  196:	updateCoins(state->whoseTurn, state, 0);
        -:  197:
        2:  198:	return 0;
        -:  199:}
        -:  200:
      101:  201:int shuffle(int player, struct gameState *state) {
        -:  202:
        -:  203:
        -:  204:	int newDeck[MAX_DECK];
      101:  205:	int newDeckPos = 0;
        -:  206:	int card;
        -:  207:	int i;
        -:  208:
      101:  209:	if (state->deckCount[player] < 1)
        7:  210:		return -1;
       94:  211:	qsort((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
        -:  212:	/* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
     1573:  214:	while (state->deckCount[player] > 0) {
     1385:  215:		card = floor(Random() * state->deckCount[player]);
     1385:  216:		newDeck[newDeckPos] = state->deck[player][card];
     1385:  217:		newDeckPos++;
     7294:  218:		for (i = card; i < state->deckCount[player] - 1; i++) {
     5909:  219:			state->deck[player][i] = state->deck[player][i + 1];
        -:  220:		}
     1385:  221:		state->deckCount[player]--;
        -:  222:	}
     1479:  223:	for (i = 0; i < newDeckPos; i++) {
     1385:  224:		state->deck[player][i] = newDeck[i];
     1385:  225:		state->deckCount[player]++;
        -:  226:	}
        -:  227:
       94:  228:	return 0;
        -:  229:}
        -:  230:
     1071:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state)
        -:  232:{
        -:  233:	int card;
     1071:  234:	int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:	//check if it is the right phase
     1071:  237:	if (state->phase != 0)
        -:  238:	{
      189:  239:		return -1;
        -:  240:	}
        -:  241:
        -:  242:	//check if player has enough actions
      882:  243:	if (state->numActions < 1)
        -:  244:	{
       33:  245:		return -1;
        -:  246:	}
        -:  247:
        -:  248:	//get card played
      849:  249:	card = handCard(handPos, state);
        -:  250:
        -:  251:	//check if selected card is an action
      849:  252:	if (card < adventurer || card > treasure_map)
        -:  253:	{
      774:  254:		return -1;
        -:  255:	}
        -:  256:
        -:  257:	//play card
       75:  258:	if (cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0)
        -:  259:	{
        1:  260:		return -1;
        -:  261:	}
        -:  262:
        -:  263:	//reduce number of actions
       74:  264:	state->numActions--;
        -:  265:
        -:  266:	//update coins (Treasure cards may be added with card draws)
       74:  267:	updateCoins(state->whoseTurn, state, coin_bonus);
        -:  268:
       74:  269:	return 0;
        -:  270:}
        -:  271:
     1126:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:	int who;
        -:  274:	if (DEBUG){
        -:  275:		printf("Entering buyCard...\n");
        -:  276:	}
        -:  277:
        -:  278:	// I don't know what to do about the phase thing.
        -:  279:
     1126:  280:	who = state->whoseTurn;
        -:  281:
     1126:  282:	if (state->numBuys < 1){
        -:  283:		if (DEBUG)
        -:  284:			printf("You do not have any buys left\n");
      187:  285:		return -1;
        -:  286:	}
      939:  287:	else if (supplyCount(supplyPos, state) < 1){
        -:  288:		if (DEBUG)
        -:  289:			printf("There are not any of that type of card left\n");
      356:  290:		return -1;
        -:  291:	}
      583:  292:	else if (state->coins < getCost(supplyPos)){
        -:  293:		if (DEBUG)
        -:  294:			printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
      395:  295:		return -1;
        -:  296:	}
        -:  297:	else {
      188:  298:		state->phase = 1;
        -:  299:		//state->supplyCount[supplyPos]--;
      188:  300:		gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  301:
      188:  302:		state->coins = (state->coins) - (getCost(supplyPos));
      188:  303:		state->numBuys--;
        -:  304:		if (DEBUG)
        -:  305:			printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  306:	}
        -:  307:
        -:  308:	//state->discard[who][state->discardCount[who]] = supplyPos;
        -:  309:	//state->discardCount[who]++;
        -:  310:
      188:  311:	return 0;
        -:  312:}
        -:  313:
    #####:  314:int numHandCards(struct gameState *state) {
    #####:  315:	return state->handCount[whoseTurn(state)];
        -:  316:}
        -:  317:
      851:  318:int handCard(int handPos, struct gameState *state) {
      851:  319:	int currentPlayer = whoseTurn(state);
      851:  320:	return state->hand[currentPlayer][handPos];
        -:  321:}
        -:  322:
     1155:  323:int supplyCount(int card, struct gameState *state) {
     1155:  324:	return state->supplyCount[card];
        -:  325:}
        -:  326:
    #####:  327:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  328:	int i;
    #####:  329:	int count = 0;
        -:  330:
    #####:  331:	for (i = 0; i < state->deckCount[player]; i++)
        -:  332:	{
    #####:  333:		if (state->deck[player][i] == card) count++;
        -:  334:	}
        -:  335:
    #####:  336:	for (i = 0; i < state->handCount[player]; i++)
        -:  337:	{
    #####:  338:		if (state->hand[player][i] == card) count++;
        -:  339:	}
        -:  340:
    #####:  341:	for (i = 0; i < state->discardCount[player]; i++)
        -:  342:	{
    #####:  343:		if (state->discard[player][i] == card) count++;
        -:  344:	}
        -:  345:
    #####:  346:	return count;
        -:  347:}
        -:  348:
     1173:  349:int whoseTurn(struct gameState *state) {
     1173:  350:	return state->whoseTurn;
        -:  351:}
        -:  352:
      247:  353:int endTurn(struct gameState *state) {
        -:  354:	int k;
        -:  355:	int i;
      247:  356:	int currentPlayer = whoseTurn(state);
        -:  357:
        -:  358:	//Discard hand
     1446:  359:	for (i = 0; i < state->handCount[currentPlayer]; i++){
     1199:  360:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
     1199:  361:		state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  362:	}
      247:  363:	state->handCount[currentPlayer] = 0;//Reset hand count
        -:  364:
        -:  365:	//Code for determining the player
      247:  366:	if (currentPlayer < (state->numPlayers - 1)){
      143:  367:		state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  368:	}
        -:  369:	else{
      104:  370:		state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  371:	}
        -:  372:
      247:  373:	state->outpostPlayed = 0;
      247:  374:	state->phase = 0;
      247:  375:	state->numActions = 1;
      247:  376:	state->coins = 0;
      247:  377:	state->numBuys = 1;
      247:  378:	state->playedCardCount = 0;
      247:  379:	state->handCount[state->whoseTurn] = 0;
        -:  380:
        -:  381:	//int k; move to top
        -:  382:	//Next player draws hand
     1482:  383:	for (k = 0; k < 5; k++){
     1235:  384:		drawCard(state->whoseTurn, state);//Draw a card
        -:  385:	}
        -:  386:
        -:  387:	//Update money
      247:  388:	updateCoins(state->whoseTurn, state, 0);
        -:  389:
      247:  390:	return 0;
        -:  391:}
        -:  392:
     3281:  393:int isGameOver(struct gameState *state) {
        -:  394:	int i;
        -:  395:	int j;
        -:  396:
        -:  397:	//if stack of Province cards is empty, the game ends
     3281:  398:	if (state->supplyCount[province] == 0)
        -:  399:	{
    #####:  400:		return 1;
        -:  401:	}
        -:  402:
        -:  403:	//if three supply pile are at 0, the game ends
     3281:  404:	j = 0;
    85306:  405:	for (i = 0; i < 25; i++)
        -:  406:	{
    82025:  407:		if (state->supplyCount[i] == 0)
        -:  408:		{
     1864:  409:			j++;
        -:  410:		}
        -:  411:	}
     3281:  412:	if (j >= 3)
        -:  413:	{
        2:  414:		return 1;
        -:  415:	}
        -:  416:
     3279:  417:	return 0;
        -:  418:}
        -:  419:
        5:  420:int scoreFor(int player, struct gameState *state) {
        -:  421:
        -:  422:	int i;
        5:  423:	int score = 0;
        -:  424:	//score from hand
       15:  425:	for (i = 0; i < state->handCount[player]; i++)
        -:  426:	{
       10:  427:		if (state->hand[player][i] == curse) { score = score - 1; };
       10:  428:		if (state->hand[player][i] == estate) { score = score + 1; };
       10:  429:		if (state->hand[player][i] == duchy) { score = score + 3; };
       10:  430:		if (state->hand[player][i] == province) { score = score + 6; };
       10:  431:		if (state->hand[player][i] == great_hall) { score = score + 1; };
       10:  432:		if (state->hand[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  433:	}
        -:  434:
        -:  435:	//score from discard
       58:  436:	for (i = 0; i < state->discardCount[player]; i++)
        -:  437:	{
       53:  438:		if (state->discard[player][i] == curse) { score = score - 1; };
       53:  439:		if (state->discard[player][i] == estate) { score = score + 1; };
       53:  440:		if (state->discard[player][i] == duchy) { score = score + 3; };
       53:  441:		if (state->discard[player][i] == province) { score = score + 6; };
       53:  442:		if (state->discard[player][i] == great_hall) { score = score + 1; };
       53:  443:		if (state->discard[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  444:	}
        -:  445:
        -:  446:	//score from deck
       58:  447:	for (i = 0; i < state->discardCount[player]; i++)
        -:  448:	{
       53:  449:		if (state->deck[player][i] == curse) { score = score - 1; };
       53:  450:		if (state->deck[player][i] == estate) { score = score + 1; };
       53:  451:		if (state->deck[player][i] == duchy) { score = score + 3; };
       53:  452:		if (state->deck[player][i] == province) { score = score + 6; };
       53:  453:		if (state->deck[player][i] == great_hall) { score = score + 1; };
       53:  454:		if (state->deck[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  455:	}
        -:  456:
        5:  457:	return score;
        -:  458:}
        -:  459:
    #####:  460:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  461:	int i;
        -:  462:	int j;
        -:  463:	int highScore;
        -:  464:	int currentPlayer;
        -:  465:
        -:  466:	//get score for each player
    #####:  467:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  468:	{
        -:  469:		//set unused player scores to -9999
    #####:  470:		if (i >= state->numPlayers)
        -:  471:		{
    #####:  472:			players[i] = -9999;
        -:  473:		}
        -:  474:		else
        -:  475:		{
    #####:  476:			players[i] = scoreFor(i, state);
        -:  477:		}
        -:  478:	}
        -:  479:
        -:  480:	//find highest score
    #####:  481:	j = 0;
    #####:  482:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  483:	{
    #####:  484:		if (players[i] > players[j])
        -:  485:		{
    #####:  486:			j = i;
        -:  487:		}
        -:  488:	}
    #####:  489:	highScore = players[j];
        -:  490:
        -:  491:	//add 1 to players who had less turns
    #####:  492:	currentPlayer = whoseTurn(state);
    #####:  493:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  494:	{
    #####:  495:		if (players[i] == highScore && i > currentPlayer)
        -:  496:		{
    #####:  497:			players[i]++;
        -:  498:		}
        -:  499:	}
        -:  500:
        -:  501:	//find new highest score
    #####:  502:	j = 0;
    #####:  503:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  504:	{
    #####:  505:		if (players[i] > players[j])
        -:  506:		{
    #####:  507:			j = i;
        -:  508:		}
        -:  509:	}
    #####:  510:	highScore = players[j];
        -:  511:
        -:  512:	//set winners in array to 1 and rest to 0
    #####:  513:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  514:	{
    #####:  515:		if (players[i] == highScore)
        -:  516:		{
    #####:  517:			players[i] = 1;
        -:  518:		}
        -:  519:		else
        -:  520:		{
    #####:  521:			players[i] = 0;
        -:  522:		}
        -:  523:	}
        -:  524:
    #####:  525:	return 0;
        -:  526:}
        -:  527:
     1298:  528:int drawCard(int player, struct gameState *state)
        -:  529:{
        -:  530:	int count;
        -:  531:	int deckCounter;
     1298:  532:	if (state->deckCount[player] <= 0){//Deck is empty
        -:  533:
        -:  534:		//Step 1 Shuffle the discard pile back into a deck
        -:  535:		int i;
        -:  536:		//Move discard to deck
     1420:  537:		for (i = 0; i < state->discardCount[player]; i++){
     1326:  538:			state->deck[player][i] = state->discard[player][i];
     1326:  539:			state->discard[player][i] = -1;
        -:  540:		}
        -:  541:
       94:  542:		state->deckCount[player] = state->discardCount[player];
       94:  543:		state->discardCount[player] = 0;//Reset discard
        -:  544:
        -:  545:		//Shufffle the deck
       94:  546:		shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  547:
        -:  548:		if (DEBUG){//Debug statements
        -:  549:			printf("Deck count now: %d\n", state->deckCount[player]);
        -:  550:		}
        -:  551:
       94:  552:		state->discardCount[player] = 0;
        -:  553:
        -:  554:		//Step 2 Draw Card
       94:  555:		count = state->handCount[player];//Get current player's hand count
        -:  556:
        -:  557:		if (DEBUG){//Debug statements
        -:  558:			printf("Current hand count: %d\n", count);
        -:  559:		}
        -:  560:
       94:  561:		deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  562:
       94:  563:		if (deckCounter == 0)
        7:  564:			return -1;
        -:  565:
       87:  566:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
       87:  567:		state->deckCount[player]--;
       87:  568:		state->handCount[player]++;//Increment hand count
        -:  569:	}
        -:  570:
        -:  571:	else{
     1204:  572:		int count = state->handCount[player];//Get current hand count for player
        -:  573:		int deckCounter;
        -:  574:		if (DEBUG){//Debug statements
        -:  575:			printf("Current hand count: %d\n", count);
        -:  576:		}
        -:  577:
     1204:  578:		deckCounter = state->deckCount[player];//Create holder for the deck count
     1204:  579:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
     1204:  580:		state->deckCount[player]--;
     1204:  581:		state->handCount[player]++;//Increment hand count
        -:  582:	}
        -:  583:
     1291:  584:	return 0;
        -:  585:}
        -:  586:
      775:  587:int getCost(int cardNumber)
        -:  588:{
      775:  589:	switch (cardNumber)
        -:  590:	{
        -:  591:	case curse:
       51:  592:		return 0;
        -:  593:	case estate:
       49:  594:		return 2;
        -:  595:	case duchy:
       39:  596:		return 5;
        -:  597:	case province:
       48:  598:		return 8;
        -:  599:	case copper:
       60:  600:		return 0;
        -:  601:	case silver:
       50:  602:		return 3;
        -:  603:	case gold:
       32:  604:		return 6;
        -:  605:	case adventurer:
    #####:  606:		return 6;
        -:  607:	case council_room:
       28:  608:		return 5;
        -:  609:	case feast:
       22:  610:		return 4;
        -:  611:	case gardens:
       17:  612:		return 4;
        -:  613:	case mine:
       29:  614:		return 5;
        -:  615:	case remodel:
    #####:  616:		return 4;
        -:  617:	case smithy:
       23:  618:		return 4;
        -:  619:	case village:
       51:  620:		return 3;
        -:  621:	case baron:
       11:  622:		return 4;
        -:  623:	case great_hall:
       23:  624:		return 3;
        -:  625:	case minion:
    #####:  626:		return 5;
        -:  627:	case steward:
       50:  628:		return 3;
        -:  629:	case tribute:
       50:  630:		return 5;
        -:  631:	case ambassador:
    #####:  632:		return 3;
        -:  633:	case cutpurse:
       60:  634:		return 4;
        -:  635:	case embargo:
    #####:  636:		return 2;
        -:  637:	case outpost:
       19:  638:		return 5;
        -:  639:	case salvager:
       24:  640:		return 4;
        -:  641:	case sea_hag:
    #####:  642:		return 4;
        -:  643:	case treasure_map:
       38:  644:		return 4;
        -:  645:	}
        -:  646:
        1:  647:	return -1;
        -:  648:}
        -:  649:
    #####:  650:void playAdventurer(struct gameState *state, int currentPlayer)
        -:  651:// Reveal cards from deck until 2 Treasure cards are found.  Put those Treasure cards in the hand and discard the rest.
        -:  652:{
    #####:  653:	int drawntreasure = 0;
        -:  654:	int temphand[MAX_HAND];
        -:  655:	int cardDrawn;
    #####:  656:	int z = 0; // this is the counter for the temp hand
        -:  657:
    #####:  658:	while (drawntreasure < 2){
    #####:  659:		if (state->deckCount[currentPlayer] < 1){//if the deck is empty we need to shuffle discard and add to deck
    #####:  660:			shuffle(currentPlayer, state);
        -:  661:		}
    #####:  662:		drawCard(currentPlayer, state);
    #####:  663:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer] - 1];//top card of hand is most recently drawn card.
    #####:  664:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
    #####:  665:			drawntreasure++;
        -:  666:		else{
    #####:  667:			temphand[z] = cardDrawn;
    #####:  668:			state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####:  669:			z++;
        -:  670:		}
        -:  671:	}
    #####:  672:	while (z - 1 >= 0){
    #####:  673:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; // discard all cards in play that have been drawn
    #####:  674:		z = z - 1;
        -:  675:	}
    #####:  676:}
        -:  677:
    #####:  678:int playRemodel(struct gameState *state, int currentPlayer, int choice1, int choice2, int handPos)
        -:  679://Trash a card in the hand, and gain a card costing up to $2 more than the trashed card
        -:  680:{
        -:  681:	int i;
    #####:  682:	int j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  683:
    #####:  684:	if ((getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2))
        -:  685:	{
    #####:  686:		return -1;
        -:  687:	}
        -:  688:
    #####:  689:	gainCard(choice2, state, 0, currentPlayer);
        -:  690:
        -:  691:	//discard card from hand
    #####:  692:	discardCard(handPos, currentPlayer, state, 0);
        -:  693:
        -:  694:	//discard trashed card
    #####:  695:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  696:	{
    #####:  697:		if (state->hand[currentPlayer][i] == j)
        -:  698:		{
    #####:  699:			discardCard(i, currentPlayer, state, 0);
    #####:  700:			break;
        -:  701:		}
        -:  702:	}
        -:  703:
    #####:  704:	return 0;
        -:  705:}
        -:  706:
        3:  707:void playSmithy(struct gameState *state, int currentPlayer, int handPos)
        -:  708:// Draw 3 cards
        -:  709:{
        -:  710:	int i;
       12:  711:	for (i = 0; i < 3; i++)
        -:  712:	{
        9:  713:		drawCard(currentPlayer, state);
        -:  714:	}
        -:  715:
        -:  716:	//discard card from hand
        3:  717:	discardCard(handPos, currentPlayer, state, 0);
        3:  718:}
        -:  719:
    #####:  720:void playBaron(struct gameState *state, int currentPlayer, int choice1, int handPos)
        -:  721://Add a buy.  OPTION:  Discard an Estate card and gain $4.  Otherwise, gain an Estate card.
        -:  722:{
    #####:  723:	state->numBuys++;//Increase buys by 1!
    #####:  724:	if (choice1 > 0){//Boolean true or going to discard an estate
    #####:  725:		int p = 0;//Iterator for hand!
    #####:  726:		int card_not_discarded = 1;//Flag for discard set!
    #####:  727:		while (card_not_discarded){
    #####:  728:			if (state->hand[currentPlayer][p] == estate){ //Found an estate card!
    #####:  729:				state->coins += 4;//Add 4 coins to the amount of coins
    #####:  730:				state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  731:				state->discardCount[currentPlayer]++;
    #####:  732:				for (; p < state->handCount[currentPlayer]; p++){
    #####:  733:					state->hand[currentPlayer][p] = state->hand[currentPlayer][p + 1];
        -:  734:				}
    #####:  735:				state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  736:				state->handCount[currentPlayer]--;
    #####:  737:				card_not_discarded = 0;//Exit the loop
        -:  738:			}
    #####:  739:			else if (p > state->handCount[currentPlayer]){
        -:  740:				if (DEBUG) {
        -:  741:					printf("No estate cards in your hand, invalid choice\n");
        -:  742:					printf("Must gain an estate if there are any\n");
        -:  743:				}
    #####:  744:				if (supplyCount(estate, state) > 0){
    #####:  745:					gainCard(estate, state, 1, currentPlayer);
    #####:  746:					state->supplyCount[estate]--;//Decrement estates
    #####:  747:					if (supplyCount(estate, state) == 0){
    #####:  748:						isGameOver(state);
        -:  749:					}
        -:  750:				}
    #####:  751:				card_not_discarded = 0;//Exit the loop
        -:  752:			}
        -:  753:
        -:  754:			else{
    #####:  755:				p++;//Next card
        -:  756:			}
        -:  757:		}
        -:  758:	}
        -:  759:
        -:  760:	else{
    #####:  761:		if (supplyCount(estate, state) > 0){
    #####:  762:			gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  763:			state->supplyCount[estate]--;//Decrement Estates
    #####:  764:			if (supplyCount(estate, state) == 0){
    #####:  765:				isGameOver(state);
        -:  766:			}
        -:  767:		}
        -:  768:	}
    #####:  769:}
        -:  770:
        6:  771:int playTreasureMap(struct gameState *state, int currentPlayer, int handPos)
        -:  772://Trashing two treasure map cards from the hand = four gold on top of the deck.
        -:  773:{
        -:  774:	int i;
        -:  775:	int index;
        -:  776:
        -:  777:	//search hand for another treasure_map
       36:  778:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  779:	{
       30:  780:		if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -:  781:		{
    #####:  782:			index = i;
    #####:  783:			break;
        -:  784:		}
        -:  785:	}
        6:  786:	if (index > -1)
        -:  787:	{
        -:  788:		//trash both treasure cards
        6:  789:		discardCard(handPos, currentPlayer, state, 1);
        6:  790:		discardCard(index, currentPlayer, state, 1);
        -:  791:
        -:  792:		//gain 4 Gold cards
       30:  793:		for (i = 0; i < 4; i++)
        -:  794:		{
       24:  795:			gainCard(gold, state, 1, currentPlayer);
        -:  796:		}
        -:  797:
        -:  798:		//return success
        6:  799:		return 1;
        -:  800:	}
        -:  801:
        -:  802:	//no second treasure_map found in hand
    #####:  803:	return -1;
        -:  804:}
        -:  805:
       75:  806:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  807:{
        -:  808:	int i;
        -:  809:	int j;
        -:  810:	int k;
        -:  811:	//int x;  //Unused after while loop removed from feast.
       75:  812:	int currentPlayer = whoseTurn(state);
       75:  813:	int nextPlayer = currentPlayer + 1;
        -:  814:	int temphand[MAX_HAND];
        -:  815:
       75:  816:	int tributeRevealedCards[2] = { -1, -1 };
        -:  817:
       75:  818:	if (nextPlayer > (state->numPlayers - 1)){
       27:  819:		nextPlayer = 0;
        -:  820:	}
        -:  821:
        -:  822:	//uses switch to select card and perform actions
       75:  823:	switch (card)
        -:  824:	{
        -:  825:	case adventurer:
        -:  826:
    #####:  827:		playAdventurer(state, currentPlayer);
    #####:  828:		return 0;
        -:  829:
        -:  830:	case council_room:
        -:  831:		//+4 Cards
    #####:  832:		for (i = 0; i < 4; i++)
        -:  833:		{
    #####:  834:			drawCard(currentPlayer, state);
        -:  835:		}
        -:  836:
        -:  837:		//+1 Buy
    #####:  838:		state->numBuys++;
        -:  839:
        -:  840:		//Each other player draws a card
    #####:  841:		for (i = 0; i < state->numPlayers; i++)
        -:  842:		{
    #####:  843:			if (i != currentPlayer)
        -:  844:			{
    #####:  845:				drawCard(i, state);
        -:  846:			}
        -:  847:		}
        -:  848:
        -:  849:		//put played card in played card pile
    #####:  850:		discardCard(handPos, currentPlayer, state, 0);
        -:  851:
    #####:  852:		return 0;
        -:  853:
        -:  854:	case feast:
        -:  855:		//gain card with cost up to 5
        -:  856:		//Backup hand
       21:  857:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
       18:  858:			temphand[i] = state->hand[currentPlayer][i];//Backup card
       18:  859:			state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  860:		}
        -:  861:		//Backup hand
        -:  862:
        -:  863:		//Update Coins for Buy
        3:  864:		updateCoins(currentPlayer, state, 5);
        -:  865://		x = 1;//Condition to loop on
        -:  866://		while (x == 1) {//Buy one card
        3:  867:			if (supplyCount(choice1, state) <= 0){
        -:  868:				if (DEBUG)
        -:  869:					printf("None of that card left, sorry!\n");
        -:  870:
        -:  871:				if (DEBUG){
        -:  872:					printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  873:				}
        -:  874:			}
        2:  875:			else if (state->coins < getCost(choice1)){
        1:  876:				printf("That card is too expensive!\n");
        -:  877:
        -:  878:				if (DEBUG){
        -:  879:					printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  880:				}
        -:  881:			}
        -:  882:			else{
        -:  883:
        -:  884:				if (DEBUG){
        -:  885:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  886:				}
        -:  887:
        1:  888:				gainCard(choice1, state, 0, currentPlayer);//Gain the card
        -:  889://				x = 0;//No more buying cards
        -:  890:
        -:  891:				if (DEBUG){
        -:  892:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  893:				}
        -:  894:
        -:  895:			}
        -:  896://		}
        -:  897:
        -:  898:		//Reset Hand
       21:  899:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
       18:  900:			state->hand[currentPlayer][i] = temphand[i];
       18:  901:			temphand[i] = -1;
        -:  902:		}
        -:  903:		//Reset Hand
        -:  904:
        3:  905:		return 0;
        -:  906:
        -:  907:	case gardens:
    #####:  908:		return -1;
        -:  909:
        -:  910:	case mine:
        1:  911:		j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  912:
        1:  913:		if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  914:		{
        1:  915:			return -1;
        -:  916:		}
        -:  917:
    #####:  918:		if (choice2 > treasure_map || choice2 < curse)
        -:  919:		{
    #####:  920:			return -1;
        -:  921:		}
        -:  922:
    #####:  923:		if ((getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2))
        -:  924:		{
    #####:  925:			return -1;
        -:  926:		}
        -:  927:
    #####:  928:		gainCard(choice2, state, 2, currentPlayer);
        -:  929:
        -:  930:		//discard card from hand
    #####:  931:		discardCard(handPos, currentPlayer, state, 0);
        -:  932:
        -:  933:		//discard trashed card
    #####:  934:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  935:		{
    #####:  936:			if (state->hand[currentPlayer][i] == j)
        -:  937:			{
    #####:  938:				discardCard(i, currentPlayer, state, 0);
    #####:  939:				break;
        -:  940:			}
        -:  941:		}
        -:  942:
    #####:  943:		return 0;
        -:  944:
        -:  945:	case remodel:
        -:  946:
    #####:  947:		return playRemodel(state, currentPlayer, choice1, choice2, handPos);
        -:  948:
        -:  949:	case smithy:
        -:  950:
        3:  951:		playSmithy(state, currentPlayer, handPos);
        3:  952:		return 0;
        -:  953:
        -:  954:	case village:
        -:  955:		//+1 Card
       13:  956:		drawCard(currentPlayer, state);
        -:  957:
        -:  958:		//+2 Actions
       13:  959:		state->numActions = state->numActions + 2;
        -:  960:
        -:  961:		//discard played card from hand
       13:  962:		discardCard(handPos, currentPlayer, state, 0);
       13:  963:		return 0;
        -:  964:
        -:  965:	case baron:
        -:  966:
    #####:  967:		playBaron(state, currentPlayer, choice1, handPos);
    #####:  968:		return 0;
        -:  969:
        -:  970:	case great_hall:
        -:  971:		//+1 Card
        5:  972:		drawCard(currentPlayer, state);
        -:  973:
        -:  974:		//+1 Actions
        5:  975:		state->numActions++;
        -:  976:
        -:  977:		//discard card from hand
        5:  978:		discardCard(handPos, currentPlayer, state, 0);
        5:  979:		return 0;
        -:  980:
        -:  981:	case minion:
        -:  982:		//+1 action
    #####:  983:		state->numActions++;
        -:  984:
        -:  985:		//discard card from hand
    #####:  986:		discardCard(handPos, currentPlayer, state, 0);
        -:  987:
    #####:  988:		if (choice1)		//+2 coins
        -:  989:		{
    #####:  990:			state->coins = state->coins + 2;
        -:  991:		}
        -:  992:
    #####:  993:		else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  994:		{
        -:  995:			//discard hand
    #####:  996:			while (numHandCards(state) > 0)
        -:  997:			{
    #####:  998:				discardCard(handPos, currentPlayer, state, 0);
        -:  999:			}
        -: 1000:
        -: 1001:			//draw 4
    #####: 1002:			for (i = 0; i < 4; i++)
        -: 1003:			{
    #####: 1004:				drawCard(currentPlayer, state);
        -: 1005:			}
        -: 1006:
        -: 1007:			//other players discard hand and redraw if hand size > 4
    #####: 1008:			for (i = 0; i < state->numPlayers; i++)
        -: 1009:			{
    #####: 1010:				if (i != currentPlayer)
        -: 1011:				{
    #####: 1012:					if (state->handCount[i] > 4)
        -: 1013:					{
        -: 1014:						//discard hand
    #####: 1015:						while (state->handCount[i] > 0)
        -: 1016:						{
    #####: 1017:							discardCard(handPos, i, state, 0);
        -: 1018:						}
        -: 1019:
        -: 1020:						//draw 4
    #####: 1021:						for (j = 0; j < 4; j++)
        -: 1022:						{
    #####: 1023:							drawCard(i, state);
        -: 1024:						}
        -: 1025:					}
        -: 1026:				}
        -: 1027:			}
        -: 1028:
        -: 1029:		}
    #####: 1030:		return 0;
        -: 1031:
        -: 1032:	case steward:
       12: 1033:		if (choice1 == 1)
        -: 1034:		{
        -: 1035:			//+2 cards
        1: 1036:			drawCard(currentPlayer, state);
        1: 1037:			drawCard(currentPlayer, state);
        -: 1038:		}
       11: 1039:		else if (choice1 == 2)
        -: 1040:		{
        -: 1041:			//+2 coins
    #####: 1042:			state->coins = state->coins + 2;
        -: 1043:		}
        -: 1044:		else
        -: 1045:		{
        -: 1046:			//trash 2 cards in hand
       11: 1047:			discardCard(choice2, currentPlayer, state, 1);
       11: 1048:			discardCard(choice3, currentPlayer, state, 1);
        -: 1049:		}
        -: 1050:
        -: 1051:		//discard card from hand
       12: 1052:		discardCard(handPos, currentPlayer, state, 0);
       12: 1053:		return 0;
        -: 1054:
        -: 1055:	case tribute:
       19: 1056:		if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####: 1057:			if (state->deckCount[nextPlayer] > 0){
    #####: 1058:				tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1059:				state->deckCount[nextPlayer]--;
        -: 1060:			}
    #####: 1061:			else if (state->discardCount[nextPlayer] > 0){
    #####: 1062:				tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer] - 1];
    #####: 1063:				state->discardCount[nextPlayer]--;
        -: 1064:			}
        -: 1065:			else{
        -: 1066:				//No Card to Reveal
        -: 1067:				if (DEBUG){
        -: 1068:					printf("No cards to reveal\n");
        -: 1069:				}
        -: 1070:			}
        -: 1071:		}
        -: 1072:
        -: 1073:		else{
       19: 1074:			if (state->deckCount[nextPlayer] == 0){
       11: 1075:				for (i = 0; i < state->discardCount[nextPlayer]; i++){
        9: 1076:					state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
        9: 1077:					state->deckCount[nextPlayer]++;
        9: 1078:					state->discard[nextPlayer][i] = -1;
        9: 1079:					state->discardCount[nextPlayer]--;
        -: 1080:				}
        -: 1081:
        2: 1082:				shuffle(nextPlayer, state);//Shuffle the deck
        -: 1083:			}
       19: 1084:			tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
       19: 1085:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
       19: 1086:			state->deckCount[nextPlayer]--;
       19: 1087:			tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
       19: 1088:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
       19: 1089:			state->deckCount[nextPlayer]--;
        -: 1090:		}
        -: 1091:
       19: 1092:		if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
        4: 1093:			state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
        4: 1094:			state->playedCardCount++;
        4: 1095:			tributeRevealedCards[1] = -1;
        -: 1096:		}
        -: 1097:
       76: 1098:		for (i = 0; i <= 2; i++){
       57: 1099:			if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
       24: 1100:				state->coins += 2;
        -: 1101:			}
        -: 1102:
       33: 1103:			else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
       12: 1104:				drawCard(currentPlayer, state);
       12: 1105:				drawCard(currentPlayer, state);
        -: 1106:			}
        -: 1107:			else{//Action Card
       21: 1108:				state->numActions = state->numActions + 2;
        -: 1109:			}
        -: 1110:		}
        -: 1111:
       19: 1112:		return 0;
        -: 1113:
        -: 1114:	case ambassador:
    #####: 1115:		j = 0;		//used to check if player has enough cards to discard
        -: 1116:
    #####: 1117:		if (choice2 > 2 || choice2 < 0)
        -: 1118:		{
    #####: 1119:			return -1;
        -: 1120:		}
        -: 1121:
    #####: 1122:		if (choice1 == handPos)
        -: 1123:		{
    #####: 1124:			return -1;
        -: 1125:		}
        -: 1126:
    #####: 1127:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1128:		{
    #####: 1129:			if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1130:			{
    #####: 1131:				j++;
        -: 1132:			}
        -: 1133:		}
    #####: 1134:		if (j < choice2)
        -: 1135:		{
    #####: 1136:			return -1;
        -: 1137:		}
        -: 1138:
        -: 1139:		if (DEBUG)
        -: 1140:			printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1141:
        -: 1142:		//increase supply count for choosen card by amount being discarded
    #####: 1143:		state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1144:
        -: 1145:		//each other player gains a copy of revealed card
    #####: 1146:		for (i = 0; i < state->numPlayers; i++)
        -: 1147:		{
    #####: 1148:			if (i != currentPlayer)
        -: 1149:			{
    #####: 1150:				gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1151:			}
        -: 1152:		}
        -: 1153:
        -: 1154:		//discard played card from hand
    #####: 1155:		discardCard(handPos, currentPlayer, state, 0);
        -: 1156:
        -: 1157:		//trash copies of cards returned to supply
    #####: 1158:		for (j = 0; j < choice2; j++)
        -: 1159:		{
    #####: 1160:			for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1161:			{
    #####: 1162:				if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1163:				{
    #####: 1164:					discardCard(i, currentPlayer, state, 1);
    #####: 1165:					break;
        -: 1166:				}
        -: 1167:			}
        -: 1168:		}
        -: 1169:
    #####: 1170:		return 0;
        -: 1171:
        -: 1172:	case cutpurse:
        -: 1173:
       11: 1174:		updateCoins(currentPlayer, state, 2);
       38: 1175:		for (i = 0; i < state->numPlayers; i++)
        -: 1176:		{
       27: 1177:			if (i != currentPlayer)
        -: 1178:			{
       16: 1179:				for (j = 0; j < state->handCount[i]; j++)
        -: 1180:				{
    #####: 1181:					if (state->hand[i][j] == copper)
        -: 1182:					{
    #####: 1183:						discardCard(j, i, state, 0);
    #####: 1184:						break;
        -: 1185:					}
    #####: 1186:					if (j == state->handCount[i])
        -: 1187:					{
    #####: 1188:						for (k = 0; k < state->handCount[i]; k++)
        -: 1189:						{
        -: 1190:							if (DEBUG)
        -: 1191:								printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1192:						}
    #####: 1193:						break;
        -: 1194:					}
        -: 1195:				}
        -: 1196:
        -: 1197:			}
        -: 1198:
        -: 1199:		}
        -: 1200:
        -: 1201:		//discard played card from hand
       11: 1202:		discardCard(handPos, currentPlayer, state, 0);
        -: 1203:
       11: 1204:		return 0;
        -: 1205:
        -: 1206:
        -: 1207:	case embargo:
        -: 1208:		//+2 Coins
    #####: 1209:		state->coins = state->coins + 2;
        -: 1210:
        -: 1211:		//see if selected pile is in play
    #####: 1212:		if (state->supplyCount[choice1] == -1)
        -: 1213:		{
    #####: 1214:			return -1;
        -: 1215:		}
        -: 1216:
        -: 1217:		//add embargo token to selected supply pile
    #####: 1218:		state->embargoTokens[choice1]++;
        -: 1219:
        -: 1220:		//trash card
    #####: 1221:		discardCard(handPos, currentPlayer, state, 1);
    #####: 1222:		return 0;
        -: 1223:
        -: 1224:	case outpost:
        -: 1225:		//set outpost flag
    #####: 1226:		state->outpostPlayed++;
        -: 1227:
        -: 1228:		//discard card
    #####: 1229:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1230:		return 0;
        -: 1231:
        -: 1232:	case salvager:
        -: 1233:		//+1 buy
        2: 1234:		state->numBuys++;
        -: 1235:
        2: 1236:		if (choice1)
        -: 1237:		{
        -: 1238:			//gain coins equal to trashed card
        2: 1239:			state->coins = state->coins + getCost(handCard(choice1, state));
        -: 1240:			//trash card
        2: 1241:			discardCard(choice1, currentPlayer, state, 1);
        -: 1242:		}
        -: 1243:
        -: 1244:		//discard card
        2: 1245:		discardCard(handPos, currentPlayer, state, 0);
        2: 1246:		return 0;
        -: 1247:
        -: 1248:	case sea_hag:
    #####: 1249:		for (i = 0; i < state->numPlayers; i++){
    #####: 1250:			if (i != currentPlayer){
    #####: 1251:				state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1252:				state->discardCount[i]++;
    #####: 1253:				state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1254:			}
        -: 1255:		}
    #####: 1256:		return 0;
        -: 1257:
        -: 1258:	case treasure_map:
        -: 1259:
        6: 1260:		return playTreasureMap(state, currentPlayer, handPos);
        -: 1261:	}
    #####: 1262:	return -1;
        -: 1263:}
        -: 1264:
       82: 1265:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1266:{
        -: 1267:
        -: 1268:	//if card is not trashed, added to Played pile 
       82: 1269:	if (trashFlag < 1)
        -: 1270:	{
        -: 1271:		//add card to played pile
       46: 1272:		state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
       46: 1273:		state->playedCardCount++;
        -: 1274:	}
        -: 1275:
        -: 1276:	//set played card to -1
       82: 1277:	state->hand[currentPlayer][handPos] = -1;
        -: 1278:
        -: 1279:	//remove card from player's hand
       82: 1280:	if (handPos == (state->handCount[currentPlayer] - 1)) 	//last card in hand array is played
        -: 1281:	{
        -: 1282:		//reduce number of cards in hand
        3: 1283:		state->handCount[currentPlayer]--;
        -: 1284:	}
       79: 1285:	else if (state->handCount[currentPlayer] == 1) //only one card in hand
        -: 1286:	{
        -: 1287:		//reduce number of cards in hand
    #####: 1288:		state->handCount[currentPlayer]--;
        -: 1289:	}
        -: 1290:	else
        -: 1291:	{
        -: 1292:		//replace discarded card with last card in hand
       79: 1293:		state->hand[currentPlayer][handPos] = state->hand[currentPlayer][(state->handCount[currentPlayer] - 1)];
        -: 1294:		//set last card to -1
       79: 1295:		state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1296:		//reduce number of cards in hand
       79: 1297:		state->handCount[currentPlayer]--;
        -: 1298:	}
        -: 1299:
       82: 1300:	return 0;
        -: 1301:}
        -: 1302:
      213: 1303:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1304:{
        -: 1305:	//Note: supplyPos is enum of choosen card
        -: 1306:
        -: 1307:	//check if supply pile is empty (0) or card is not used in game (-1)
      213: 1308:	if (supplyCount(supplyPos, state) < 1)
        -: 1309:	{
    #####: 1310:		return -1;
        -: 1311:	}
        -: 1312:
        -: 1313:	//added card for [whoseTurn] current player:
        -: 1314:	// toFlag = 0 : add to discard
        -: 1315:	// toFlag = 1 : add to deck
        -: 1316:	// toFlag = 2 : add to hand
        -: 1317:
      213: 1318:	if (toFlag == 1)
        -: 1319:	{
       24: 1320:		state->deck[player][state->deckCount[player]] = supplyPos;
       24: 1321:		state->deckCount[player]++;
        -: 1322:	}
      189: 1323:	else if (toFlag == 2)
        -: 1324:	{
    #####: 1325:		state->hand[player][state->handCount[player]] = supplyPos;
    #####: 1326:		state->handCount[player]++;
        -: 1327:	}
        -: 1328:	else
        -: 1329:	{
      189: 1330:		state->discard[player][state->discardCount[player]] = supplyPos;
      189: 1331:		state->discardCount[player]++;
        -: 1332:	}
        -: 1333:
        -: 1334:	//decrease number in supply pile
      213: 1335:	state->supplyCount[supplyPos]--;
        -: 1336:
      213: 1337:	return 0;
        -: 1338:}
        -: 1339:
      337: 1340:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1341:{
        -: 1342:	int i;
        -: 1343:
        -: 1344:	//reset coin count
      337: 1345:	state->coins = 0;
        -: 1346:
        -: 1347:	//add coins for each Treasure card in player's hand
     1986: 1348:	for (i = 0; i < state->handCount[player]; i++)
        -: 1349:	{
     1649: 1350:		if (state->hand[player][i] == copper)
        -: 1351:		{
      560: 1352:			state->coins += 1;
        -: 1353:		}
     1089: 1354:		else if (state->hand[player][i] == silver)
        -: 1355:		{
       94: 1356:			state->coins += 2;
        -: 1357:		}
      995: 1358:		else if (state->hand[player][i] == gold)
        -: 1359:		{
      116: 1360:			state->coins += 3;
        -: 1361:		}
        -: 1362:	}
        -: 1363:
        -: 1364:	//add bonus
      337: 1365:	state->coins += bonus;
        -: 1366:
      337: 1367:	return 0;
        -: 1368:}
        -: 1369:
        -: 1370:
        -: 1371://end of dominion.c
File 'dominion.c'
Lines executed:71.45% of 557
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
     4418:    8:int compare(const void* a, const void* b) {
     4418:    9:	if (*(int*)a > *(int*)b)
     1584:   10:		return 1;
     2834:   11:	if (*(int*)a < *(int*)b)
     1394:   12:		return -1;
     1440:   13:	return 0;
        -:   14:}
        -:   15:
        4:   16:struct gameState* newGame() {
        4:   17:	struct gameState* g = malloc(sizeof(struct gameState));
        4:   18:	return g;
        -:   19:}
        -:   20:
       17:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:	int k8, int k9, int k10) {
       17:   23:	int* k = malloc(10 * sizeof(int));
       17:   24:	k[0] = k1;
       17:   25:	k[1] = k2;
       17:   26:	k[2] = k3;
       17:   27:	k[3] = k4;
       17:   28:	k[4] = k5;
       17:   29:	k[5] = k6;
       17:   30:	k[6] = k7;
       17:   31:	k[7] = k8;
       17:   32:	k[8] = k9;
       17:   33:	k[9] = k10;
       17:   34:	return k;
        -:   35:}
        -:   36:
       17:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		struct gameState *state) {
        -:   39:
        -:   40:	int i;
        -:   41:	int j;
        -:   42:	int it;
        -:   43:	//set up random number generator
       17:   44:	SelectStream(1);
       17:   45:	PutSeed((long)randomSeed);
        -:   46:
        -:   47:	//check number of players
       17:   48:	if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:	{
    #####:   50:		return -1;
        -:   51:	}
        -:   52:
        -:   53:	//set number of players
       17:   54:	state->numPlayers = numPlayers;
        -:   55:
        -:   56:	//check selected kingdom cards are different
       60:   57:	for (i = 0; i < 10; i++)
        -:   58:	{
      562:   59:		for (j = 0; j < 10; j++)
        -:   60:		{
      519:   61:			if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:			{
       15:   63:				return -1;
        -:   64:			}
        -:   65:		}
        -:   66:	}
        -:   67:
        -:   68:
        -:   69:	//initialize supply
        -:   70:	///////////////////////////////
        -:   71:
        -:   72:	//set number of Curse cards
        2:   73:	if (numPlayers == 2)
        -:   74:	{
    #####:   75:		state->supplyCount[curse] = 10;
        -:   76:	}
        2:   77:	else if (numPlayers == 3)
        -:   78:	{
    #####:   79:		state->supplyCount[curse] = 20;
        -:   80:	}
        -:   81:	else
        -:   82:	{
        2:   83:		state->supplyCount[curse] = 30;
        -:   84:	}
        -:   85:
        -:   86:	//set number of Victory cards
        2:   87:	if (numPlayers == 2)
        -:   88:	{
    #####:   89:		state->supplyCount[estate] = 8;
    #####:   90:		state->supplyCount[duchy] = 8;
    #####:   91:		state->supplyCount[province] = 8;
        -:   92:	}
        -:   93:	else
        -:   94:	{
        2:   95:		state->supplyCount[estate] = 12;
        2:   96:		state->supplyCount[duchy] = 12;
        2:   97:		state->supplyCount[province] = 12;
        -:   98:	}
        -:   99:
        -:  100:	//set number of Treasure cards
        2:  101:	state->supplyCount[copper] = 60 - (7 * numPlayers);
        2:  102:	state->supplyCount[silver] = 40;
        2:  103:	state->supplyCount[gold] = 30;
        -:  104:
        -:  105:	//set number of Kingdom cards
       42:  106:	for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:	{
      330:  108:		for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:		{
      310:  110:			if (kingdomCards[j] == i)
        -:  111:			{
        -:  112:				//check if card is a 'Victory' Kingdom card
       20:  113:				if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:				{
        2:  115:					if (numPlayers == 2){
    #####:  116:						state->supplyCount[i] = 8;
        -:  117:					}
        1:  118:					else{ state->supplyCount[i] = 12; }
        -:  119:				}
        -:  120:				else
        -:  121:				{
       19:  122:					state->supplyCount[i] = 10;
        -:  123:				}
       20:  124:				break;
        -:  125:			}
        -:  126:			else    //card is not in the set choosen for the game
        -:  127:			{
      290:  128:				state->supplyCount[i] = -1;
        -:  129:			}
        -:  130:		}
        -:  131:
        -:  132:	}
        -:  133:
        -:  134:	////////////////////////
        -:  135:	//supply intilization complete
        -:  136:
        -:  137:	//set player decks
       10:  138:	for (i = 0; i < numPlayers; i++)
        -:  139:	{
        8:  140:		state->deckCount[i] = 0;
       32:  141:		for (j = 0; j < 3; j++)
        -:  142:		{
       24:  143:			state->deck[i][j] = estate;
       24:  144:			state->deckCount[i]++;
        -:  145:		}
       64:  146:		for (j = 3; j < 10; j++)
        -:  147:		{
       56:  148:			state->deck[i][j] = copper;
       56:  149:			state->deckCount[i]++;
        -:  150:		}
        -:  151:	}
        -:  152:
        -:  153:	//shuffle player decks
       10:  154:	for (i = 0; i < numPlayers; i++)
        -:  155:	{
        8:  156:		if (shuffle(i, state) < 0)
        -:  157:		{
    #####:  158:			return -1;
        -:  159:		}
        -:  160:	}
        -:  161:
        -:  162:	//draw player hands
       10:  163:	for (i = 0; i < numPlayers; i++)
        -:  164:	{
        -:  165:		//initialize hand size to zero
        8:  166:		state->handCount[i] = 0;
        8:  167:		state->discardCount[i] = 0;
        -:  168:		//draw 5 cards
        -:  169:		// for (j = 0; j < 5; j++)
        -:  170:		//	{
        -:  171:		//	  drawCard(i, state);
        -:  172:		//	}
        -:  173:	}
        -:  174:
        -:  175:	//set embargo tokens to 0 for all supply piles
       56:  176:	for (i = 0; i <= treasure_map; i++)
        -:  177:	{
       54:  178:		state->embargoTokens[i] = 0;
        -:  179:	}
        -:  180:
        -:  181:	//initialize first player's turn
        2:  182:	state->outpostPlayed = 0;
        2:  183:	state->phase = 0;
        2:  184:	state->numActions = 1;
        2:  185:	state->numBuys = 1;
        2:  186:	state->playedCardCount = 0;
        2:  187:	state->whoseTurn = 0;
        2:  188:	state->handCount[state->whoseTurn] = 0;
        -:  189:	//int it; move to top
        -:  190:
        -:  191:	//Moved draw cards to here, only drawing at the start of a turn
       12:  192:	for (it = 0; it < 5; it++){
       10:  193:		drawCard(state->whoseTurn, state);
        -:  194:	}
        -:  195:
        2:  196:	updateCoins(state->whoseTurn, state, 0);
        -:  197:
        2:  198:	return 0;
        -:  199:}
        -:  200:
      176:  201:int shuffle(int player, struct gameState *state) {
        -:  202:
        -:  203:
        -:  204:	int newDeck[MAX_DECK];
      176:  205:	int newDeckPos = 0;
        -:  206:	int card;
        -:  207:	int i;
        -:  208:
      176:  209:	if (state->deckCount[player] < 1)
        7:  210:		return -1;
      169:  211:	qsort((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
        -:  212:	/* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
     2470:  214:	while (state->deckCount[player] > 0) {
     2132:  215:		card = floor(Random() * state->deckCount[player]);
     2132:  216:		newDeck[newDeckPos] = state->deck[player][card];
     2132:  217:		newDeckPos++;
     9955:  218:		for (i = card; i < state->deckCount[player] - 1; i++) {
     7823:  219:			state->deck[player][i] = state->deck[player][i + 1];
        -:  220:		}
     2132:  221:		state->deckCount[player]--;
        -:  222:	}
     2301:  223:	for (i = 0; i < newDeckPos; i++) {
     2132:  224:		state->deck[player][i] = newDeck[i];
     2132:  225:		state->deckCount[player]++;
        -:  226:	}
        -:  227:
      169:  228:	return 0;
        -:  229:}
        -:  230:
     1546:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state)
        -:  232:{
        -:  233:	int card;
     1546:  234:	int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:	//check if it is the right phase
     1546:  237:	if (state->phase != 0)
        -:  238:	{
      251:  239:		return -1;
        -:  240:	}
        -:  241:
        -:  242:	//check if player has enough actions
     1295:  243:	if (state->numActions < 1)
        -:  244:	{
       90:  245:		return -1;
        -:  246:	}
        -:  247:
        -:  248:	//get card played
     1205:  249:	card = handCard(handPos, state);
        -:  250:
        -:  251:	//check if selected card is an action
     1205:  252:	if (card < adventurer || card > treasure_map)
        -:  253:	{
     1052:  254:		return -1;
        -:  255:	}
        -:  256:
        -:  257:	//play card
      153:  258:	if (cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0)
        -:  259:	{
       37:  260:		return -1;
        -:  261:	}
        -:  262:
        -:  263:	//reduce number of actions
      116:  264:	state->numActions--;
        -:  265:
        -:  266:	//update coins (Treasure cards may be added with card draws)
      116:  267:	updateCoins(state->whoseTurn, state, coin_bonus);
        -:  268:
      116:  269:	return 0;
        -:  270:}
        -:  271:
     1634:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:	int who;
        -:  274:	if (DEBUG){
        -:  275:		printf("Entering buyCard...\n");
        -:  276:	}
        -:  277:
        -:  278:	// I don't know what to do about the phase thing.
        -:  279:
     1634:  280:	who = state->whoseTurn;
        -:  281:
     1634:  282:	if (state->numBuys < 1){
        -:  283:		if (DEBUG)
        -:  284:			printf("You do not have any buys left\n");
      269:  285:		return -1;
        -:  286:	}
     1365:  287:	else if (supplyCount(supplyPos, state) < 1){
        -:  288:		if (DEBUG)
        -:  289:			printf("There are not any of that type of card left\n");
      581:  290:		return -1;
        -:  291:	}
      784:  292:	else if (state->coins < getCost(supplyPos)){
        -:  293:		if (DEBUG)
        -:  294:			printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
      520:  295:		return -1;
        -:  296:	}
        -:  297:	else {
      264:  298:		state->phase = 1;
        -:  299:		//state->supplyCount[supplyPos]--;
      264:  300:		gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  301:
      264:  302:		state->coins = (state->coins) - (getCost(supplyPos));
      264:  303:		state->numBuys--;
        -:  304:		if (DEBUG)
        -:  305:			printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  306:	}
        -:  307:
        -:  308:	//state->discard[who][state->discardCount[who]] = supplyPos;
        -:  309:	//state->discardCount[who]++;
        -:  310:
      264:  311:	return 0;
        -:  312:}
        -:  313:
    #####:  314:int numHandCards(struct gameState *state) {
    #####:  315:	return state->handCount[whoseTurn(state)];
        -:  316:}
        -:  317:
     1216:  318:int handCard(int handPos, struct gameState *state) {
     1216:  319:	int currentPlayer = whoseTurn(state);
     1216:  320:	return state->hand[currentPlayer][handPos];
        -:  321:}
        -:  322:
     1683:  323:int supplyCount(int card, struct gameState *state) {
     1683:  324:	return state->supplyCount[card];
        -:  325:}
        -:  326:
        1:  327:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  328:	int i;
        1:  329:	int count = 0;
        -:  330:
        5:  331:	for (i = 0; i < state->deckCount[player]; i++)
        -:  332:	{
        4:  333:		if (state->deck[player][i] == card) count++;
        -:  334:	}
        -:  335:
        1:  336:	for (i = 0; i < state->handCount[player]; i++)
        -:  337:	{
    #####:  338:		if (state->hand[player][i] == card) count++;
        -:  339:	}
        -:  340:
       25:  341:	for (i = 0; i < state->discardCount[player]; i++)
        -:  342:	{
       24:  343:		if (state->discard[player][i] == card) count++;
        -:  344:	}
        -:  345:
        1:  346:	return count;
        -:  347:}
        -:  348:
     1734:  349:int whoseTurn(struct gameState *state) {
     1734:  350:	return state->whoseTurn;
        -:  351:}
        -:  352:
      365:  353:int endTurn(struct gameState *state) {
        -:  354:	int k;
        -:  355:	int i;
      365:  356:	int currentPlayer = whoseTurn(state);
        -:  357:
        -:  358:	//Discard hand
     2104:  359:	for (i = 0; i < state->handCount[currentPlayer]; i++){
     1739:  360:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
     1739:  361:		state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  362:	}
      365:  363:	state->handCount[currentPlayer] = 0;//Reset hand count
        -:  364:
        -:  365:	//Code for determining the player
      365:  366:	if (currentPlayer < (state->numPlayers - 1)){
      274:  367:		state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  368:	}
        -:  369:	else{
       91:  370:		state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  371:	}
        -:  372:
      365:  373:	state->outpostPlayed = 0;
      365:  374:	state->phase = 0;
      365:  375:	state->numActions = 1;
      365:  376:	state->coins = 0;
      365:  377:	state->numBuys = 1;
      365:  378:	state->playedCardCount = 0;
      365:  379:	state->handCount[state->whoseTurn] = 0;
        -:  380:
        -:  381:	//int k; move to top
        -:  382:	//Next player draws hand
     2190:  383:	for (k = 0; k < 5; k++){
     1825:  384:		drawCard(state->whoseTurn, state);//Draw a card
        -:  385:	}
        -:  386:
        -:  387:	//Update money
      365:  388:	updateCoins(state->whoseTurn, state, 0);
        -:  389:
      365:  390:	return 0;
        -:  391:}
        -:  392:
     4811:  393:int isGameOver(struct gameState *state) {
        -:  394:	int i;
        -:  395:	int j;
        -:  396:
        -:  397:	//if stack of Province cards is empty, the game ends
     4811:  398:	if (state->supplyCount[province] == 0)
        -:  399:	{
    #####:  400:		return 1;
        -:  401:	}
        -:  402:
        -:  403:	//if three supply pile are at 0, the game ends
     4811:  404:	j = 0;
   125086:  405:	for (i = 0; i < 25; i++)
        -:  406:	{
   120275:  407:		if (state->supplyCount[i] == 0)
        -:  408:		{
     4434:  409:			j++;
        -:  410:		}
        -:  411:	}
     4811:  412:	if (j >= 3)
        -:  413:	{
        2:  414:		return 1;
        -:  415:	}
        -:  416:
     4809:  417:	return 0;
        -:  418:}
        -:  419:
        8:  420:int scoreFor(int player, struct gameState *state) {
        -:  421:
        -:  422:	int i;
        8:  423:	int score = 0;
        -:  424:	//score from hand
       17:  425:	for (i = 0; i < state->handCount[player]; i++)
        -:  426:	{
        9:  427:		if (state->hand[player][i] == curse) { score = score - 1; };
        9:  428:		if (state->hand[player][i] == estate) { score = score + 1; };
        9:  429:		if (state->hand[player][i] == duchy) { score = score + 3; };
        9:  430:		if (state->hand[player][i] == province) { score = score + 6; };
        9:  431:		if (state->hand[player][i] == great_hall) { score = score + 1; };
        9:  432:		if (state->hand[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  433:	}
        -:  434:
        -:  435:	//score from discard
       72:  436:	for (i = 0; i < state->discardCount[player]; i++)
        -:  437:	{
       64:  438:		if (state->discard[player][i] == curse) { score = score - 1; };
       64:  439:		if (state->discard[player][i] == estate) { score = score + 1; };
       64:  440:		if (state->discard[player][i] == duchy) { score = score + 3; };
       64:  441:		if (state->discard[player][i] == province) { score = score + 6; };
       64:  442:		if (state->discard[player][i] == great_hall) { score = score + 1; };
       64:  443:		if (state->discard[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  444:	}
        -:  445:
        -:  446:	//score from deck
       72:  447:	for (i = 0; i < state->discardCount[player]; i++)
        -:  448:	{
       64:  449:		if (state->deck[player][i] == curse) { score = score - 1; };
       64:  450:		if (state->deck[player][i] == estate) { score = score + 1; };
       64:  451:		if (state->deck[player][i] == duchy) { score = score + 3; };
       64:  452:		if (state->deck[player][i] == province) { score = score + 6; };
       64:  453:		if (state->deck[player][i] == great_hall) { score = score + 1; };
       64:  454:		if (state->deck[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  455:	}
        -:  456:
        8:  457:	return score;
        -:  458:}
        -:  459:
    #####:  460:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  461:	int i;
        -:  462:	int j;
        -:  463:	int highScore;
        -:  464:	int currentPlayer;
        -:  465:
        -:  466:	//get score for each player
    #####:  467:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  468:	{
        -:  469:		//set unused player scores to -9999
    #####:  470:		if (i >= state->numPlayers)
        -:  471:		{
    #####:  472:			players[i] = -9999;
        -:  473:		}
        -:  474:		else
        -:  475:		{
    #####:  476:			players[i] = scoreFor(i, state);
        -:  477:		}
        -:  478:	}
        -:  479:
        -:  480:	//find highest score
    #####:  481:	j = 0;
    #####:  482:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  483:	{
    #####:  484:		if (players[i] > players[j])
        -:  485:		{
    #####:  486:			j = i;
        -:  487:		}
        -:  488:	}
    #####:  489:	highScore = players[j];
        -:  490:
        -:  491:	//add 1 to players who had less turns
    #####:  492:	currentPlayer = whoseTurn(state);
    #####:  493:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  494:	{
    #####:  495:		if (players[i] == highScore && i > currentPlayer)
        -:  496:		{
    #####:  497:			players[i]++;
        -:  498:		}
        -:  499:	}
        -:  500:
        -:  501:	//find new highest score
    #####:  502:	j = 0;
    #####:  503:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  504:	{
    #####:  505:		if (players[i] > players[j])
        -:  506:		{
    #####:  507:			j = i;
        -:  508:		}
        -:  509:	}
    #####:  510:	highScore = players[j];
        -:  511:
        -:  512:	//set winners in array to 1 and rest to 0
    #####:  513:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  514:	{
    #####:  515:		if (players[i] == highScore)
        -:  516:		{
    #####:  517:			players[i] = 1;
        -:  518:		}
        -:  519:		else
        -:  520:		{
    #####:  521:			players[i] = 0;
        -:  522:		}
        -:  523:	}
        -:  524:
    #####:  525:	return 0;
        -:  526:}
        -:  527:
     1859:  528:int drawCard(int player, struct gameState *state)
        -:  529:{
        -:  530:	int count;
        -:  531:	int deckCounter;
     1859:  532:	if (state->deckCount[player] <= 0){//Deck is empty
        -:  533:
        -:  534:		//Step 1 Shuffle the discard pile back into a deck
        -:  535:		int i;
        -:  536:		//Move discard to deck
     2220:  537:		for (i = 0; i < state->discardCount[player]; i++){
     2052:  538:			state->deck[player][i] = state->discard[player][i];
     2052:  539:			state->discard[player][i] = -1;
        -:  540:		}
        -:  541:
      168:  542:		state->deckCount[player] = state->discardCount[player];
      168:  543:		state->discardCount[player] = 0;//Reset discard
        -:  544:
        -:  545:		//Shufffle the deck
      168:  546:		shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  547:
        -:  548:		if (DEBUG){//Debug statements
        -:  549:			printf("Deck count now: %d\n", state->deckCount[player]);
        -:  550:		}
        -:  551:
      168:  552:		state->discardCount[player] = 0;
        -:  553:
        -:  554:		//Step 2 Draw Card
      168:  555:		count = state->handCount[player];//Get current player's hand count
        -:  556:
        -:  557:		if (DEBUG){//Debug statements
        -:  558:			printf("Current hand count: %d\n", count);
        -:  559:		}
        -:  560:
      168:  561:		deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  562:
      168:  563:		if (deckCounter == 0)
        7:  564:			return -1;
        -:  565:
      161:  566:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
      161:  567:		state->deckCount[player]--;
      161:  568:		state->handCount[player]++;//Increment hand count
        -:  569:	}
        -:  570:
        -:  571:	else{
     1691:  572:		int count = state->handCount[player];//Get current hand count for player
        -:  573:		int deckCounter;
        -:  574:		if (DEBUG){//Debug statements
        -:  575:			printf("Current hand count: %d\n", count);
        -:  576:		}
        -:  577:
     1691:  578:		deckCounter = state->deckCount[player];//Create holder for the deck count
     1691:  579:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
     1691:  580:		state->deckCount[player]--;
     1691:  581:		state->handCount[player]++;//Increment hand count
        -:  582:	}
        -:  583:
     1852:  584:	return 0;
        -:  585:}
        -:  586:
     1071:  587:int getCost(int cardNumber)
        -:  588:{
     1071:  589:	switch (cardNumber)
        -:  590:	{
        -:  591:	case curse:
      100:  592:		return 0;
        -:  593:	case estate:
       26:  594:		return 2;
        -:  595:	case duchy:
       41:  596:		return 5;
        -:  597:	case province:
       50:  598:		return 8;
        -:  599:	case copper:
      118:  600:		return 0;
        -:  601:	case silver:
       68:  602:		return 3;
        -:  603:	case gold:
       62:  604:		return 6;
        -:  605:	case adventurer:
       29:  606:		return 6;
        -:  607:	case council_room:
       45:  608:		return 5;
        -:  609:	case feast:
    #####:  610:		return 4;
        -:  611:	case gardens:
       31:  612:		return 4;
        -:  613:	case mine:
       36:  614:		return 5;
        -:  615:	case remodel:
       56:  616:		return 4;
        -:  617:	case smithy:
    #####:  618:		return 4;
        -:  619:	case village:
       27:  620:		return 3;
        -:  621:	case baron:
       71:  622:		return 4;
        -:  623:	case great_hall:
    #####:  624:		return 3;
        -:  625:	case minion:
       28:  626:		return 5;
        -:  627:	case steward:
       38:  628:		return 3;
        -:  629:	case tribute:
       21:  630:		return 5;
        -:  631:	case ambassador:
    #####:  632:		return 3;
        -:  633:	case cutpurse:
       54:  634:		return 4;
        -:  635:	case embargo:
       21:  636:		return 2;
        -:  637:	case outpost:
    #####:  638:		return 5;
        -:  639:	case salvager:
       75:  640:		return 4;
        -:  641:	case sea_hag:
       32:  642:		return 4;
        -:  643:	case treasure_map:
       40:  644:		return 4;
        -:  645:	}
        -:  646:
        2:  647:	return -1;
        -:  648:}
        -:  649:
    #####:  650:void playAdventurer(struct gameState *state, int currentPlayer)
        -:  651:// Reveal cards from deck until 2 Treasure cards are found.  Put those Treasure cards in the hand and discard the rest.
        -:  652:{
    #####:  653:	int drawntreasure = 0;
        -:  654:	int temphand[MAX_HAND];
        -:  655:	int cardDrawn;
    #####:  656:	int z = 0; // this is the counter for the temp hand
        -:  657:
    #####:  658:	while (drawntreasure < 2){
    #####:  659:		if (state->deckCount[currentPlayer] < 1){//if the deck is empty we need to shuffle discard and add to deck
    #####:  660:			shuffle(currentPlayer, state);
        -:  661:		}
    #####:  662:		drawCard(currentPlayer, state);
    #####:  663:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer] - 1];//top card of hand is most recently drawn card.
    #####:  664:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
    #####:  665:			drawntreasure++;
        -:  666:		else{
    #####:  667:			temphand[z] = cardDrawn;
    #####:  668:			state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####:  669:			z++;
        -:  670:		}
        -:  671:	}
    #####:  672:	while (z - 1 >= 0){
    #####:  673:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; // discard all cards in play that have been drawn
    #####:  674:		z = z - 1;
        -:  675:	}
    #####:  676:}
        -:  677:
        5:  678:int playRemodel(struct gameState *state, int currentPlayer, int choice1, int choice2, int handPos)
        -:  679://Trash a card in the hand, and gain a card costing up to $2 more than the trashed card
        -:  680:{
        -:  681:	int i;
        5:  682:	int j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  683:
        5:  684:	if ((getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2))
        -:  685:	{
    #####:  686:		return -1;
        -:  687:	}
        -:  688:
        5:  689:	gainCard(choice2, state, 0, currentPlayer);
        -:  690:
        -:  691:	//discard card from hand
        5:  692:	discardCard(handPos, currentPlayer, state, 0);
        -:  693:
        -:  694:	//discard trashed card
       22:  695:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  696:	{
       18:  697:		if (state->hand[currentPlayer][i] == j)
        -:  698:		{
        1:  699:			discardCard(i, currentPlayer, state, 0);
        1:  700:			break;
        -:  701:		}
        -:  702:	}
        -:  703:
        5:  704:	return 0;
        -:  705:}
        -:  706:
    #####:  707:void playSmithy(struct gameState *state, int currentPlayer, int handPos)
        -:  708:// Draw 3 cards
        -:  709:{
        -:  710:	int i;
    #####:  711:	for (i = 0; i < 3; i++)
        -:  712:	{
    #####:  713:		drawCard(currentPlayer, state);
        -:  714:	}
        -:  715:
        -:  716:	//discard card from hand
    #####:  717:	discardCard(handPos, currentPlayer, state, 0);
    #####:  718:}
        -:  719:
       25:  720:void playBaron(struct gameState *state, int currentPlayer, int choice1, int handPos)
        -:  721://Add a buy.  OPTION:  Discard an Estate card and gain $4.  Otherwise, gain an Estate card.
        -:  722:{
       25:  723:	state->numBuys++;//Increase buys by 1!
       25:  724:	if (choice1 > 0){//Boolean true or going to discard an estate
       22:  725:		int p = 0;//Iterator for hand!
       22:  726:		int card_not_discarded = 1;//Flag for discard set!
      156:  727:		while (card_not_discarded){
      112:  728:			if (state->hand[currentPlayer][p] == estate){ //Found an estate card!
       10:  729:				state->coins += 4;//Add 4 coins to the amount of coins
       10:  730:				state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
       10:  731:				state->discardCount[currentPlayer]++;
       42:  732:				for (; p < state->handCount[currentPlayer]; p++){
       32:  733:					state->hand[currentPlayer][p] = state->hand[currentPlayer][p + 1];
        -:  734:				}
       10:  735:				state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
       10:  736:				state->handCount[currentPlayer]--;
       10:  737:				card_not_discarded = 0;//Exit the loop
        -:  738:			}
      102:  739:			else if (p > state->handCount[currentPlayer]){
        -:  740:				if (DEBUG) {
        -:  741:					printf("No estate cards in your hand, invalid choice\n");
        -:  742:					printf("Must gain an estate if there are any\n");
        -:  743:				}
       12:  744:				if (supplyCount(estate, state) > 0){
        5:  745:					gainCard(estate, state, 1, currentPlayer);
        5:  746:					state->supplyCount[estate]--;//Decrement estates
        5:  747:					if (supplyCount(estate, state) == 0){
    #####:  748:						isGameOver(state);
        -:  749:					}
        -:  750:				}
       12:  751:				card_not_discarded = 0;//Exit the loop
        -:  752:			}
        -:  753:
        -:  754:			else{
       90:  755:				p++;//Next card
        -:  756:			}
        -:  757:		}
        -:  758:	}
        -:  759:
        -:  760:	else{
        3:  761:		if (supplyCount(estate, state) > 0){
        2:  762:			gainCard(estate, state, 0, currentPlayer);//Gain an estate
        2:  763:			state->supplyCount[estate]--;//Decrement Estates
        2:  764:			if (supplyCount(estate, state) == 0){
    #####:  765:				isGameOver(state);
        -:  766:			}
        -:  767:		}
        -:  768:	}
       25:  769:}
        -:  770:
        5:  771:int playTreasureMap(struct gameState *state, int currentPlayer, int handPos)
        -:  772://Trashing two treasure map cards from the hand = four gold on top of the deck.
        -:  773:{
        -:  774:	int i;
        -:  775:	int index;
        -:  776:
        -:  777:	//search hand for another treasure_map
       25:  778:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  779:	{
       21:  780:		if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -:  781:		{
        1:  782:			index = i;
        1:  783:			break;
        -:  784:		}
        -:  785:	}
        5:  786:	if (index > -1)
        -:  787:	{
        -:  788:		//trash both treasure cards
        5:  789:		discardCard(handPos, currentPlayer, state, 1);
        5:  790:		discardCard(index, currentPlayer, state, 1);
        -:  791:
        -:  792:		//gain 4 Gold cards
       25:  793:		for (i = 0; i < 4; i++)
        -:  794:		{
       20:  795:			gainCard(gold, state, 1, currentPlayer);
        -:  796:		}
        -:  797:
        -:  798:		//return success
        5:  799:		return 1;
        -:  800:	}
        -:  801:
        -:  802:	//no second treasure_map found in hand
    #####:  803:	return -1;
        -:  804:}
        -:  805:
      153:  806:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  807:{
        -:  808:	int i;
        -:  809:	int j;
        -:  810:	int k;
        -:  811:	//int x;  //Unused after while loop removed from feast.
      153:  812:	int currentPlayer = whoseTurn(state);
      153:  813:	int nextPlayer = currentPlayer + 1;
        -:  814:	int temphand[MAX_HAND];
        -:  815:
      153:  816:	int tributeRevealedCards[2] = { -1, -1 };
        -:  817:
      153:  818:	if (nextPlayer > (state->numPlayers - 1)){
       49:  819:		nextPlayer = 0;
        -:  820:	}
        -:  821:
        -:  822:	//uses switch to select card and perform actions
      153:  823:	switch (card)
        -:  824:	{
        -:  825:	case adventurer:
        -:  826:
    #####:  827:		playAdventurer(state, currentPlayer);
    #####:  828:		return 0;
        -:  829:
        -:  830:	case council_room:
        -:  831:		//+4 Cards
       10:  832:		for (i = 0; i < 4; i++)
        -:  833:		{
        8:  834:			drawCard(currentPlayer, state);
        -:  835:		}
        -:  836:
        -:  837:		//+1 Buy
        2:  838:		state->numBuys++;
        -:  839:
        -:  840:		//Each other player draws a card
       10:  841:		for (i = 0; i < state->numPlayers; i++)
        -:  842:		{
        8:  843:			if (i != currentPlayer)
        -:  844:			{
        6:  845:				drawCard(i, state);
        -:  846:			}
        -:  847:		}
        -:  848:
        -:  849:		//put played card in played card pile
        2:  850:		discardCard(handPos, currentPlayer, state, 0);
        -:  851:
        2:  852:		return 0;
        -:  853:
        -:  854:	case feast:
        -:  855:		//gain card with cost up to 5
        -:  856:		//Backup hand
    #####:  857:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  858:			temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  859:			state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  860:		}
        -:  861:		//Backup hand
        -:  862:
        -:  863:		//Update Coins for Buy
    #####:  864:		updateCoins(currentPlayer, state, 5);
        -:  865://		x = 1;//Condition to loop on
        -:  866://		while (x == 1) {//Buy one card
    #####:  867:			if (supplyCount(choice1, state) <= 0){
        -:  868:				if (DEBUG)
        -:  869:					printf("None of that card left, sorry!\n");
        -:  870:
        -:  871:				if (DEBUG){
        -:  872:					printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  873:				}
        -:  874:			}
    #####:  875:			else if (state->coins < getCost(choice1)){
    #####:  876:				printf("That card is too expensive!\n");
        -:  877:
        -:  878:				if (DEBUG){
        -:  879:					printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  880:				}
        -:  881:			}
        -:  882:			else{
        -:  883:
        -:  884:				if (DEBUG){
        -:  885:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  886:				}
        -:  887:
    #####:  888:				gainCard(choice1, state, 0, currentPlayer);//Gain the card
        -:  889://				x = 0;//No more buying cards
        -:  890:
        -:  891:				if (DEBUG){
        -:  892:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  893:				}
        -:  894:
        -:  895:			}
        -:  896://		}
        -:  897:
        -:  898:		//Reset Hand
    #####:  899:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  900:			state->hand[currentPlayer][i] = temphand[i];
    #####:  901:			temphand[i] = -1;
        -:  902:		}
        -:  903:		//Reset Hand
        -:  904:
    #####:  905:		return 0;
        -:  906:
        -:  907:	case gardens:
       19:  908:		return -1;
        -:  909:
        -:  910:	case mine:
       14:  911:		j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  912:
       14:  913:		if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  914:		{
       13:  915:			return -1;
        -:  916:		}
        -:  917:
        1:  918:		if (choice2 > treasure_map || choice2 < curse)
        -:  919:		{
    #####:  920:			return -1;
        -:  921:		}
        -:  922:
        1:  923:		if ((getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2))
        -:  924:		{
        1:  925:			return -1;
        -:  926:		}
        -:  927:
    #####:  928:		gainCard(choice2, state, 2, currentPlayer);
        -:  929:
        -:  930:		//discard card from hand
    #####:  931:		discardCard(handPos, currentPlayer, state, 0);
        -:  932:
        -:  933:		//discard trashed card
    #####:  934:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  935:		{
    #####:  936:			if (state->hand[currentPlayer][i] == j)
        -:  937:			{
    #####:  938:				discardCard(i, currentPlayer, state, 0);
    #####:  939:				break;
        -:  940:			}
        -:  941:		}
        -:  942:
    #####:  943:		return 0;
        -:  944:
        -:  945:	case remodel:
        -:  946:
        5:  947:		return playRemodel(state, currentPlayer, choice1, choice2, handPos);
        -:  948:
        -:  949:	case smithy:
        -:  950:
    #####:  951:		playSmithy(state, currentPlayer, handPos);
    #####:  952:		return 0;
        -:  953:
        -:  954:	case village:
        -:  955:		//+1 Card
        8:  956:		drawCard(currentPlayer, state);
        -:  957:
        -:  958:		//+2 Actions
        8:  959:		state->numActions = state->numActions + 2;
        -:  960:
        -:  961:		//discard played card from hand
        8:  962:		discardCard(handPos, currentPlayer, state, 0);
        8:  963:		return 0;
        -:  964:
        -:  965:	case baron:
        -:  966:
       25:  967:		playBaron(state, currentPlayer, choice1, handPos);
       25:  968:		return 0;
        -:  969:
        -:  970:	case great_hall:
        -:  971:		//+1 Card
    #####:  972:		drawCard(currentPlayer, state);
        -:  973:
        -:  974:		//+1 Actions
    #####:  975:		state->numActions++;
        -:  976:
        -:  977:		//discard card from hand
    #####:  978:		discardCard(handPos, currentPlayer, state, 0);
    #####:  979:		return 0;
        -:  980:
        -:  981:	case minion:
        -:  982:		//+1 action
        1:  983:		state->numActions++;
        -:  984:
        -:  985:		//discard card from hand
        1:  986:		discardCard(handPos, currentPlayer, state, 0);
        -:  987:
        1:  988:		if (choice1)		//+2 coins
        -:  989:		{
        1:  990:			state->coins = state->coins + 2;
        -:  991:		}
        -:  992:
    #####:  993:		else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  994:		{
        -:  995:			//discard hand
    #####:  996:			while (numHandCards(state) > 0)
        -:  997:			{
    #####:  998:				discardCard(handPos, currentPlayer, state, 0);
        -:  999:			}
        -: 1000:
        -: 1001:			//draw 4
    #####: 1002:			for (i = 0; i < 4; i++)
        -: 1003:			{
    #####: 1004:				drawCard(currentPlayer, state);
        -: 1005:			}
        -: 1006:
        -: 1007:			//other players discard hand and redraw if hand size > 4
    #####: 1008:			for (i = 0; i < state->numPlayers; i++)
        -: 1009:			{
    #####: 1010:				if (i != currentPlayer)
        -: 1011:				{
    #####: 1012:					if (state->handCount[i] > 4)
        -: 1013:					{
        -: 1014:						//discard hand
    #####: 1015:						while (state->handCount[i] > 0)
        -: 1016:						{
    #####: 1017:							discardCard(handPos, i, state, 0);
        -: 1018:						}
        -: 1019:
        -: 1020:						//draw 4
    #####: 1021:						for (j = 0; j < 4; j++)
        -: 1022:						{
    #####: 1023:							drawCard(i, state);
        -: 1024:						}
        -: 1025:					}
        -: 1026:				}
        -: 1027:			}
        -: 1028:
        -: 1029:		}
        1: 1030:		return 0;
        -: 1031:
        -: 1032:	case steward:
        8: 1033:		if (choice1 == 1)
        -: 1034:		{
        -: 1035:			//+2 cards
    #####: 1036:			drawCard(currentPlayer, state);
    #####: 1037:			drawCard(currentPlayer, state);
        -: 1038:		}
        8: 1039:		else if (choice1 == 2)
        -: 1040:		{
        -: 1041:			//+2 coins
    #####: 1042:			state->coins = state->coins + 2;
        -: 1043:		}
        -: 1044:		else
        -: 1045:		{
        -: 1046:			//trash 2 cards in hand
        8: 1047:			discardCard(choice2, currentPlayer, state, 1);
        8: 1048:			discardCard(choice3, currentPlayer, state, 1);
        -: 1049:		}
        -: 1050:
        -: 1051:		//discard card from hand
        8: 1052:		discardCard(handPos, currentPlayer, state, 0);
        8: 1053:		return 0;
        -: 1054:
        -: 1055:	case tribute:
        3: 1056:		if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####: 1057:			if (state->deckCount[nextPlayer] > 0){
    #####: 1058:				tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1059:				state->deckCount[nextPlayer]--;
        -: 1060:			}
    #####: 1061:			else if (state->discardCount[nextPlayer] > 0){
    #####: 1062:				tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer] - 1];
    #####: 1063:				state->discardCount[nextPlayer]--;
        -: 1064:			}
        -: 1065:			else{
        -: 1066:				//No Card to Reveal
        -: 1067:				if (DEBUG){
        -: 1068:					printf("No cards to reveal\n");
        -: 1069:				}
        -: 1070:			}
        -: 1071:		}
        -: 1072:
        -: 1073:		else{
        3: 1074:			if (state->deckCount[nextPlayer] == 0){
    #####: 1075:				for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####: 1076:					state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1077:					state->deckCount[nextPlayer]++;
    #####: 1078:					state->discard[nextPlayer][i] = -1;
    #####: 1079:					state->discardCount[nextPlayer]--;
        -: 1080:				}
        -: 1081:
    #####: 1082:				shuffle(nextPlayer, state);//Shuffle the deck
        -: 1083:			}
        3: 1084:			tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
        3: 1085:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
        3: 1086:			state->deckCount[nextPlayer]--;
        3: 1087:			tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
        3: 1088:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
        3: 1089:			state->deckCount[nextPlayer]--;
        -: 1090:		}
        -: 1091:
        3: 1092:		if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
    #####: 1093:			state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1094:			state->playedCardCount++;
    #####: 1095:			tributeRevealedCards[1] = -1;
        -: 1096:		}
        -: 1097:
       12: 1098:		for (i = 0; i <= 2; i++){
        9: 1099:			if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
        6: 1100:				state->coins += 2;
        -: 1101:			}
        -: 1102:
        3: 1103:			else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
        1: 1104:				drawCard(currentPlayer, state);
        1: 1105:				drawCard(currentPlayer, state);
        -: 1106:			}
        -: 1107:			else{//Action Card
        2: 1108:				state->numActions = state->numActions + 2;
        -: 1109:			}
        -: 1110:		}
        -: 1111:
        3: 1112:		return 0;
        -: 1113:
        -: 1114:	case ambassador:
    #####: 1115:		j = 0;		//used to check if player has enough cards to discard
        -: 1116:
    #####: 1117:		if (choice2 > 2 || choice2 < 0)
        -: 1118:		{
    #####: 1119:			return -1;
        -: 1120:		}
        -: 1121:
    #####: 1122:		if (choice1 == handPos)
        -: 1123:		{
    #####: 1124:			return -1;
        -: 1125:		}
        -: 1126:
    #####: 1127:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1128:		{
    #####: 1129:			if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1130:			{
    #####: 1131:				j++;
        -: 1132:			}
        -: 1133:		}
    #####: 1134:		if (j < choice2)
        -: 1135:		{
    #####: 1136:			return -1;
        -: 1137:		}
        -: 1138:
        -: 1139:		if (DEBUG)
        -: 1140:			printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1141:
        -: 1142:		//increase supply count for choosen card by amount being discarded
    #####: 1143:		state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1144:
        -: 1145:		//each other player gains a copy of revealed card
    #####: 1146:		for (i = 0; i < state->numPlayers; i++)
        -: 1147:		{
    #####: 1148:			if (i != currentPlayer)
        -: 1149:			{
    #####: 1150:				gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1151:			}
        -: 1152:		}
        -: 1153:
        -: 1154:		//discard played card from hand
    #####: 1155:		discardCard(handPos, currentPlayer, state, 0);
        -: 1156:
        -: 1157:		//trash copies of cards returned to supply
    #####: 1158:		for (j = 0; j < choice2; j++)
        -: 1159:		{
    #####: 1160:			for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1161:			{
    #####: 1162:				if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1163:				{
    #####: 1164:					discardCard(i, currentPlayer, state, 1);
    #####: 1165:					break;
        -: 1166:				}
        -: 1167:			}
        -: 1168:		}
        -: 1169:
    #####: 1170:		return 0;
        -: 1171:
        -: 1172:	case cutpurse:
        -: 1173:
        5: 1174:		updateCoins(currentPlayer, state, 2);
       25: 1175:		for (i = 0; i < state->numPlayers; i++)
        -: 1176:		{
       20: 1177:			if (i != currentPlayer)
        -: 1178:			{
       15: 1179:				for (j = 0; j < state->handCount[i]; j++)
        -: 1180:				{
    #####: 1181:					if (state->hand[i][j] == copper)
        -: 1182:					{
    #####: 1183:						discardCard(j, i, state, 0);
    #####: 1184:						break;
        -: 1185:					}
    #####: 1186:					if (j == state->handCount[i])
        -: 1187:					{
    #####: 1188:						for (k = 0; k < state->handCount[i]; k++)
        -: 1189:						{
        -: 1190:							if (DEBUG)
        -: 1191:								printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1192:						}
    #####: 1193:						break;
        -: 1194:					}
        -: 1195:				}
        -: 1196:
        -: 1197:			}
        -: 1198:
        -: 1199:		}
        -: 1200:
        -: 1201:		//discard played card from hand
        5: 1202:		discardCard(handPos, currentPlayer, state, 0);
        -: 1203:
        5: 1204:		return 0;
        -: 1205:
        -: 1206:
        -: 1207:	case embargo:
        -: 1208:		//+2 Coins
       14: 1209:		state->coins = state->coins + 2;
        -: 1210:
        -: 1211:		//see if selected pile is in play
       14: 1212:		if (state->supplyCount[choice1] == -1)
        -: 1213:		{
        4: 1214:			return -1;
        -: 1215:		}
        -: 1216:
        -: 1217:		//add embargo token to selected supply pile
       10: 1218:		state->embargoTokens[choice1]++;
        -: 1219:
        -: 1220:		//trash card
       10: 1221:		discardCard(handPos, currentPlayer, state, 1);
       10: 1222:		return 0;
        -: 1223:
        -: 1224:	case outpost:
        -: 1225:		//set outpost flag
    #####: 1226:		state->outpostPlayed++;
        -: 1227:
        -: 1228:		//discard card
    #####: 1229:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1230:		return 0;
        -: 1231:
        -: 1232:	case salvager:
        -: 1233:		//+1 buy
       11: 1234:		state->numBuys++;
        -: 1235:
       11: 1236:		if (choice1)
        -: 1237:		{
        -: 1238:			//gain coins equal to trashed card
       11: 1239:			state->coins = state->coins + getCost(handCard(choice1, state));
        -: 1240:			//trash card
       11: 1241:			discardCard(choice1, currentPlayer, state, 1);
        -: 1242:		}
        -: 1243:
        -: 1244:		//discard card
       11: 1245:		discardCard(handPos, currentPlayer, state, 0);
       11: 1246:		return 0;
        -: 1247:
        -: 1248:	case sea_hag:
      165: 1249:		for (i = 0; i < state->numPlayers; i++){
      132: 1250:			if (i != currentPlayer){
       99: 1251:				state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
       99: 1252:				state->discardCount[i]++;
       99: 1253:				state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1254:			}
        -: 1255:		}
       33: 1256:		return 0;
        -: 1257:
        -: 1258:	case treasure_map:
        -: 1259:
        5: 1260:		return playTreasureMap(state, currentPlayer, handPos);
        -: 1261:	}
    #####: 1262:	return -1;
        -: 1263:}
        -: 1264:
       88: 1265:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1266:{
        -: 1267:
        -: 1268:	//if card is not trashed, added to Played pile 
       88: 1269:	if (trashFlag < 1)
        -: 1270:	{
        -: 1271:		//add card to played pile
       41: 1272:		state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
       41: 1273:		state->playedCardCount++;
        -: 1274:	}
        -: 1275:
        -: 1276:	//set played card to -1
       88: 1277:	state->hand[currentPlayer][handPos] = -1;
        -: 1278:
        -: 1279:	//remove card from player's hand
       88: 1280:	if (handPos == (state->handCount[currentPlayer] - 1)) 	//last card in hand array is played
        -: 1281:	{
        -: 1282:		//reduce number of cards in hand
       10: 1283:		state->handCount[currentPlayer]--;
        -: 1284:	}
       78: 1285:	else if (state->handCount[currentPlayer] == 1) //only one card in hand
        -: 1286:	{
        -: 1287:		//reduce number of cards in hand
    #####: 1288:		state->handCount[currentPlayer]--;
        -: 1289:	}
        -: 1290:	else
        -: 1291:	{
        -: 1292:		//replace discarded card with last card in hand
       78: 1293:		state->hand[currentPlayer][handPos] = state->hand[currentPlayer][(state->handCount[currentPlayer] - 1)];
        -: 1294:		//set last card to -1
       78: 1295:		state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1296:		//reduce number of cards in hand
       78: 1297:		state->handCount[currentPlayer]--;
        -: 1298:	}
        -: 1299:
       88: 1300:	return 0;
        -: 1301:}
        -: 1302:
      296: 1303:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1304:{
        -: 1305:	//Note: supplyPos is enum of choosen card
        -: 1306:
        -: 1307:	//check if supply pile is empty (0) or card is not used in game (-1)
      296: 1308:	if (supplyCount(supplyPos, state) < 1)
        -: 1309:	{
        3: 1310:		return -1;
        -: 1311:	}
        -: 1312:
        -: 1313:	//added card for [whoseTurn] current player:
        -: 1314:	// toFlag = 0 : add to discard
        -: 1315:	// toFlag = 1 : add to deck
        -: 1316:	// toFlag = 2 : add to hand
        -: 1317:
      293: 1318:	if (toFlag == 1)
        -: 1319:	{
       25: 1320:		state->deck[player][state->deckCount[player]] = supplyPos;
       25: 1321:		state->deckCount[player]++;
        -: 1322:	}
      268: 1323:	else if (toFlag == 2)
        -: 1324:	{
    #####: 1325:		state->hand[player][state->handCount[player]] = supplyPos;
    #####: 1326:		state->handCount[player]++;
        -: 1327:	}
        -: 1328:	else
        -: 1329:	{
      268: 1330:		state->discard[player][state->discardCount[player]] = supplyPos;
      268: 1331:		state->discardCount[player]++;
        -: 1332:	}
        -: 1333:
        -: 1334:	//decrease number in supply pile
      293: 1335:	state->supplyCount[supplyPos]--;
        -: 1336:
      293: 1337:	return 0;
        -: 1338:}
        -: 1339:
      488: 1340:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1341:{
        -: 1342:	int i;
        -: 1343:
        -: 1344:	//reset coin count
      488: 1345:	state->coins = 0;
        -: 1346:
        -: 1347:	//add coins for each Treasure card in player's hand
     2840: 1348:	for (i = 0; i < state->handCount[player]; i++)
        -: 1349:	{
     2352: 1350:		if (state->hand[player][i] == copper)
        -: 1351:		{
      914: 1352:			state->coins += 1;
        -: 1353:		}
     1438: 1354:		else if (state->hand[player][i] == silver)
        -: 1355:		{
      142: 1356:			state->coins += 2;
        -: 1357:		}
     1296: 1358:		else if (state->hand[player][i] == gold)
        -: 1359:		{
      103: 1360:			state->coins += 3;
        -: 1361:		}
        -: 1362:	}
        -: 1363:
        -: 1364:	//add bonus
      488: 1365:	state->coins += bonus;
        -: 1366:
      488: 1367:	return 0;
        -: 1368:}
        -: 1369:
        -: 1370:
        -: 1371://end of dominion.c
File 'dominion.c'
Lines executed:64.27% of 557
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
     3156:    8:int compare(const void* a, const void* b) {
     3156:    9:	if (*(int*)a > *(int*)b)
      989:   10:		return 1;
     2167:   11:	if (*(int*)a < *(int*)b)
      928:   12:		return -1;
     1239:   13:	return 0;
        -:   14:}
        -:   15:
        4:   16:struct gameState* newGame() {
        4:   17:	struct gameState* g = malloc(sizeof(struct gameState));
        4:   18:	return g;
        -:   19:}
        -:   20:
       46:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:	int k8, int k9, int k10) {
       46:   23:	int* k = malloc(10 * sizeof(int));
       46:   24:	k[0] = k1;
       46:   25:	k[1] = k2;
       46:   26:	k[2] = k3;
       46:   27:	k[3] = k4;
       46:   28:	k[4] = k5;
       46:   29:	k[5] = k6;
       46:   30:	k[6] = k7;
       46:   31:	k[7] = k8;
       46:   32:	k[8] = k9;
       46:   33:	k[9] = k10;
       46:   34:	return k;
        -:   35:}
        -:   36:
       46:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		struct gameState *state) {
        -:   39:
        -:   40:	int i;
        -:   41:	int j;
        -:   42:	int it;
        -:   43:	//set up random number generator
       46:   44:	SelectStream(1);
       46:   45:	PutSeed((long)randomSeed);
        -:   46:
        -:   47:	//check number of players
       46:   48:	if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:	{
    #####:   50:		return -1;
        -:   51:	}
        -:   52:
        -:   53:	//set number of players
       46:   54:	state->numPlayers = numPlayers;
        -:   55:
        -:   56:	//check selected kingdom cards are different
      123:   57:	for (i = 0; i < 10; i++)
        -:   58:	{
     1123:   59:		for (j = 0; j < 10; j++)
        -:   60:		{
     1046:   61:			if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:			{
       44:   63:				return -1;
        -:   64:			}
        -:   65:		}
        -:   66:	}
        -:   67:
        -:   68:
        -:   69:	//initialize supply
        -:   70:	///////////////////////////////
        -:   71:
        -:   72:	//set number of Curse cards
        2:   73:	if (numPlayers == 2)
        -:   74:	{
    #####:   75:		state->supplyCount[curse] = 10;
        -:   76:	}
        2:   77:	else if (numPlayers == 3)
        -:   78:	{
        2:   79:		state->supplyCount[curse] = 20;
        -:   80:	}
        -:   81:	else
        -:   82:	{
    #####:   83:		state->supplyCount[curse] = 30;
        -:   84:	}
        -:   85:
        -:   86:	//set number of Victory cards
        2:   87:	if (numPlayers == 2)
        -:   88:	{
    #####:   89:		state->supplyCount[estate] = 8;
    #####:   90:		state->supplyCount[duchy] = 8;
    #####:   91:		state->supplyCount[province] = 8;
        -:   92:	}
        -:   93:	else
        -:   94:	{
        2:   95:		state->supplyCount[estate] = 12;
        2:   96:		state->supplyCount[duchy] = 12;
        2:   97:		state->supplyCount[province] = 12;
        -:   98:	}
        -:   99:
        -:  100:	//set number of Treasure cards
        2:  101:	state->supplyCount[copper] = 60 - (7 * numPlayers);
        2:  102:	state->supplyCount[silver] = 40;
        2:  103:	state->supplyCount[gold] = 30;
        -:  104:
        -:  105:	//set number of Kingdom cards
       42:  106:	for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:	{
      330:  108:		for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:		{
      310:  110:			if (kingdomCards[j] == i)
        -:  111:			{
        -:  112:				//check if card is a 'Victory' Kingdom card
       20:  113:				if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:				{
        2:  115:					if (numPlayers == 2){
    #####:  116:						state->supplyCount[i] = 8;
        -:  117:					}
        1:  118:					else{ state->supplyCount[i] = 12; }
        -:  119:				}
        -:  120:				else
        -:  121:				{
       19:  122:					state->supplyCount[i] = 10;
        -:  123:				}
       20:  124:				break;
        -:  125:			}
        -:  126:			else    //card is not in the set choosen for the game
        -:  127:			{
      290:  128:				state->supplyCount[i] = -1;
        -:  129:			}
        -:  130:		}
        -:  131:
        -:  132:	}
        -:  133:
        -:  134:	////////////////////////
        -:  135:	//supply intilization complete
        -:  136:
        -:  137:	//set player decks
        8:  138:	for (i = 0; i < numPlayers; i++)
        -:  139:	{
        6:  140:		state->deckCount[i] = 0;
       24:  141:		for (j = 0; j < 3; j++)
        -:  142:		{
       18:  143:			state->deck[i][j] = estate;
       18:  144:			state->deckCount[i]++;
        -:  145:		}
       48:  146:		for (j = 3; j < 10; j++)
        -:  147:		{
       42:  148:			state->deck[i][j] = copper;
       42:  149:			state->deckCount[i]++;
        -:  150:		}
        -:  151:	}
        -:  152:
        -:  153:	//shuffle player decks
        8:  154:	for (i = 0; i < numPlayers; i++)
        -:  155:	{
        6:  156:		if (shuffle(i, state) < 0)
        -:  157:		{
    #####:  158:			return -1;
        -:  159:		}
        -:  160:	}
        -:  161:
        -:  162:	//draw player hands
        8:  163:	for (i = 0; i < numPlayers; i++)
        -:  164:	{
        -:  165:		//initialize hand size to zero
        6:  166:		state->handCount[i] = 0;
        6:  167:		state->discardCount[i] = 0;
        -:  168:		//draw 5 cards
        -:  169:		// for (j = 0; j < 5; j++)
        -:  170:		//	{
        -:  171:		//	  drawCard(i, state);
        -:  172:		//	}
        -:  173:	}
        -:  174:
        -:  175:	//set embargo tokens to 0 for all supply piles
       56:  176:	for (i = 0; i <= treasure_map; i++)
        -:  177:	{
       54:  178:		state->embargoTokens[i] = 0;
        -:  179:	}
        -:  180:
        -:  181:	//initialize first player's turn
        2:  182:	state->outpostPlayed = 0;
        2:  183:	state->phase = 0;
        2:  184:	state->numActions = 1;
        2:  185:	state->numBuys = 1;
        2:  186:	state->playedCardCount = 0;
        2:  187:	state->whoseTurn = 0;
        2:  188:	state->handCount[state->whoseTurn] = 0;
        -:  189:	//int it; move to top
        -:  190:
        -:  191:	//Moved draw cards to here, only drawing at the start of a turn
       12:  192:	for (it = 0; it < 5; it++){
       10:  193:		drawCard(state->whoseTurn, state);
        -:  194:	}
        -:  195:
        2:  196:	updateCoins(state->whoseTurn, state, 0);
        -:  197:
        2:  198:	return 0;
        -:  199:}
        -:  200:
       81:  201:int shuffle(int player, struct gameState *state) {
        -:  202:
        -:  203:
        -:  204:	int newDeck[MAX_DECK];
       81:  205:	int newDeckPos = 0;
        -:  206:	int card;
        -:  207:	int i;
        -:  208:
       81:  209:	if (state->deckCount[player] < 1)
    #####:  210:		return -1;
       81:  211:	qsort((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
        -:  212:	/* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
     1627:  214:	while (state->deckCount[player] > 0) {
     1465:  215:		card = floor(Random() * state->deckCount[player]);
     1465:  216:		newDeck[newDeckPos] = state->deck[player][card];
     1465:  217:		newDeckPos++;
     9630:  218:		for (i = card; i < state->deckCount[player] - 1; i++) {
     8165:  219:			state->deck[player][i] = state->deck[player][i + 1];
        -:  220:		}
     1465:  221:		state->deckCount[player]--;
        -:  222:	}
     1546:  223:	for (i = 0; i < newDeckPos; i++) {
     1465:  224:		state->deck[player][i] = newDeck[i];
     1465:  225:		state->deckCount[player]++;
        -:  226:	}
        -:  227:
       81:  228:	return 0;
        -:  229:}
        -:  230:
     1566:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state)
        -:  232:{
        -:  233:	int card;
     1566:  234:	int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:	//check if it is the right phase
     1566:  237:	if (state->phase != 0)
        -:  238:	{
      257:  239:		return -1;
        -:  240:	}
        -:  241:
        -:  242:	//check if player has enough actions
     1309:  243:	if (state->numActions < 1)
        -:  244:	{
       49:  245:		return -1;
        -:  246:	}
        -:  247:
        -:  248:	//get card played
     1260:  249:	card = handCard(handPos, state);
        -:  250:
        -:  251:	//check if selected card is an action
     1260:  252:	if (card < adventurer || card > treasure_map)
        -:  253:	{
     1188:  254:		return -1;
        -:  255:	}
        -:  256:
        -:  257:	//play card
       72:  258:	if (cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0)
        -:  259:	{
       12:  260:		return -1;
        -:  261:	}
        -:  262:
        -:  263:	//reduce number of actions
       60:  264:	state->numActions--;
        -:  265:
        -:  266:	//update coins (Treasure cards may be added with card draws)
       60:  267:	updateCoins(state->whoseTurn, state, coin_bonus);
        -:  268:
       60:  269:	return 0;
        -:  270:}
        -:  271:
     1593:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:	int who;
        -:  274:	if (DEBUG){
        -:  275:		printf("Entering buyCard...\n");
        -:  276:	}
        -:  277:
        -:  278:	// I don't know what to do about the phase thing.
        -:  279:
     1593:  280:	who = state->whoseTurn;
        -:  281:
     1593:  282:	if (state->numBuys < 1){
        -:  283:		if (DEBUG)
        -:  284:			printf("You do not have any buys left\n");
      231:  285:		return -1;
        -:  286:	}
     1362:  287:	else if (supplyCount(supplyPos, state) < 1){
        -:  288:		if (DEBUG)
        -:  289:			printf("There are not any of that type of card left\n");
      585:  290:		return -1;
        -:  291:	}
      777:  292:	else if (state->coins < getCost(supplyPos)){
        -:  293:		if (DEBUG)
        -:  294:			printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
      558:  295:		return -1;
        -:  296:	}
        -:  297:	else {
      219:  298:		state->phase = 1;
        -:  299:		//state->supplyCount[supplyPos]--;
      219:  300:		gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  301:
      219:  302:		state->coins = (state->coins) - (getCost(supplyPos));
      219:  303:		state->numBuys--;
        -:  304:		if (DEBUG)
        -:  305:			printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  306:	}
        -:  307:
        -:  308:	//state->discard[who][state->discardCount[who]] = supplyPos;
        -:  309:	//state->discardCount[who]++;
        -:  310:
      219:  311:	return 0;
        -:  312:}
        -:  313:
    #####:  314:int numHandCards(struct gameState *state) {
    #####:  315:	return state->handCount[whoseTurn(state)];
        -:  316:}
        -:  317:
     1266:  318:int handCard(int handPos, struct gameState *state) {
     1266:  319:	int currentPlayer = whoseTurn(state);
     1266:  320:	return state->hand[currentPlayer][handPos];
        -:  321:}
        -:  322:
     1618:  323:int supplyCount(int card, struct gameState *state) {
     1618:  324:	return state->supplyCount[card];
        -:  325:}
        -:  326:
    #####:  327:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  328:	int i;
    #####:  329:	int count = 0;
        -:  330:
    #####:  331:	for (i = 0; i < state->deckCount[player]; i++)
        -:  332:	{
    #####:  333:		if (state->deck[player][i] == card) count++;
        -:  334:	}
        -:  335:
    #####:  336:	for (i = 0; i < state->handCount[player]; i++)
        -:  337:	{
    #####:  338:		if (state->hand[player][i] == card) count++;
        -:  339:	}
        -:  340:
    #####:  341:	for (i = 0; i < state->discardCount[player]; i++)
        -:  342:	{
    #####:  343:		if (state->discard[player][i] == card) count++;
        -:  344:	}
        -:  345:
    #####:  346:	return count;
        -:  347:}
        -:  348:
     1611:  349:int whoseTurn(struct gameState *state) {
     1611:  350:	return state->whoseTurn;
        -:  351:}
        -:  352:
      273:  353:int endTurn(struct gameState *state) {
        -:  354:	int k;
        -:  355:	int i;
      273:  356:	int currentPlayer = whoseTurn(state);
        -:  357:
        -:  358:	//Discard hand
     1585:  359:	for (i = 0; i < state->handCount[currentPlayer]; i++){
     1312:  360:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
     1312:  361:		state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  362:	}
      273:  363:	state->handCount[currentPlayer] = 0;//Reset hand count
        -:  364:
        -:  365:	//Code for determining the player
      273:  366:	if (currentPlayer < (state->numPlayers - 1)){
      183:  367:		state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  368:	}
        -:  369:	else{
       90:  370:		state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  371:	}
        -:  372:
      273:  373:	state->outpostPlayed = 0;
      273:  374:	state->phase = 0;
      273:  375:	state->numActions = 1;
      273:  376:	state->coins = 0;
      273:  377:	state->numBuys = 1;
      273:  378:	state->playedCardCount = 0;
      273:  379:	state->handCount[state->whoseTurn] = 0;
        -:  380:
        -:  381:	//int k; move to top
        -:  382:	//Next player draws hand
     1638:  383:	for (k = 0; k < 5; k++){
     1365:  384:		drawCard(state->whoseTurn, state);//Draw a card
        -:  385:	}
        -:  386:
        -:  387:	//Update money
      273:  388:	updateCoins(state->whoseTurn, state, 0);
        -:  389:
      273:  390:	return 0;
        -:  391:}
        -:  392:
     4734:  393:int isGameOver(struct gameState *state) {
        -:  394:	int i;
        -:  395:	int j;
        -:  396:
        -:  397:	//if stack of Province cards is empty, the game ends
     4734:  398:	if (state->supplyCount[province] == 0)
        -:  399:	{
    #####:  400:		return 1;
        -:  401:	}
        -:  402:
        -:  403:	//if three supply pile are at 0, the game ends
     4734:  404:	j = 0;
   123084:  405:	for (i = 0; i < 25; i++)
        -:  406:	{
   118350:  407:		if (state->supplyCount[i] == 0)
        -:  408:		{
     5085:  409:			j++;
        -:  410:		}
        -:  411:	}
     4734:  412:	if (j >= 3)
        -:  413:	{
        2:  414:		return 1;
        -:  415:	}
        -:  416:
     4732:  417:	return 0;
        -:  418:}
        -:  419:
    #####:  420:int scoreFor(int player, struct gameState *state) {
        -:  421:
        -:  422:	int i;
    #####:  423:	int score = 0;
        -:  424:	//score from hand
    #####:  425:	for (i = 0; i < state->handCount[player]; i++)
        -:  426:	{
    #####:  427:		if (state->hand[player][i] == curse) { score = score - 1; };
    #####:  428:		if (state->hand[player][i] == estate) { score = score + 1; };
    #####:  429:		if (state->hand[player][i] == duchy) { score = score + 3; };
    #####:  430:		if (state->hand[player][i] == province) { score = score + 6; };
    #####:  431:		if (state->hand[player][i] == great_hall) { score = score + 1; };
    #####:  432:		if (state->hand[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  433:	}
        -:  434:
        -:  435:	//score from discard
    #####:  436:	for (i = 0; i < state->discardCount[player]; i++)
        -:  437:	{
    #####:  438:		if (state->discard[player][i] == curse) { score = score - 1; };
    #####:  439:		if (state->discard[player][i] == estate) { score = score + 1; };
    #####:  440:		if (state->discard[player][i] == duchy) { score = score + 3; };
    #####:  441:		if (state->discard[player][i] == province) { score = score + 6; };
    #####:  442:		if (state->discard[player][i] == great_hall) { score = score + 1; };
    #####:  443:		if (state->discard[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  444:	}
        -:  445:
        -:  446:	//score from deck
    #####:  447:	for (i = 0; i < state->discardCount[player]; i++)
        -:  448:	{
    #####:  449:		if (state->deck[player][i] == curse) { score = score - 1; };
    #####:  450:		if (state->deck[player][i] == estate) { score = score + 1; };
    #####:  451:		if (state->deck[player][i] == duchy) { score = score + 3; };
    #####:  452:		if (state->deck[player][i] == province) { score = score + 6; };
    #####:  453:		if (state->deck[player][i] == great_hall) { score = score + 1; };
    #####:  454:		if (state->deck[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  455:	}
        -:  456:
    #####:  457:	return score;
        -:  458:}
        -:  459:
    #####:  460:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  461:	int i;
        -:  462:	int j;
        -:  463:	int highScore;
        -:  464:	int currentPlayer;
        -:  465:
        -:  466:	//get score for each player
    #####:  467:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  468:	{
        -:  469:		//set unused player scores to -9999
    #####:  470:		if (i >= state->numPlayers)
        -:  471:		{
    #####:  472:			players[i] = -9999;
        -:  473:		}
        -:  474:		else
        -:  475:		{
    #####:  476:			players[i] = scoreFor(i, state);
        -:  477:		}
        -:  478:	}
        -:  479:
        -:  480:	//find highest score
    #####:  481:	j = 0;
    #####:  482:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  483:	{
    #####:  484:		if (players[i] > players[j])
        -:  485:		{
    #####:  486:			j = i;
        -:  487:		}
        -:  488:	}
    #####:  489:	highScore = players[j];
        -:  490:
        -:  491:	//add 1 to players who had less turns
    #####:  492:	currentPlayer = whoseTurn(state);
    #####:  493:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  494:	{
    #####:  495:		if (players[i] == highScore && i > currentPlayer)
        -:  496:		{
    #####:  497:			players[i]++;
        -:  498:		}
        -:  499:	}
        -:  500:
        -:  501:	//find new highest score
    #####:  502:	j = 0;
    #####:  503:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  504:	{
    #####:  505:		if (players[i] > players[j])
        -:  506:		{
    #####:  507:			j = i;
        -:  508:		}
        -:  509:	}
    #####:  510:	highScore = players[j];
        -:  511:
        -:  512:	//set winners in array to 1 and rest to 0
    #####:  513:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  514:	{
    #####:  515:		if (players[i] == highScore)
        -:  516:		{
    #####:  517:			players[i] = 1;
        -:  518:		}
        -:  519:		else
        -:  520:		{
    #####:  521:			players[i] = 0;
        -:  522:		}
        -:  523:	}
        -:  524:
    #####:  525:	return 0;
        -:  526:}
        -:  527:
     1388:  528:int drawCard(int player, struct gameState *state)
        -:  529:{
        -:  530:	int count;
        -:  531:	int deckCounter;
     1388:  532:	if (state->deckCount[player] <= 0){//Deck is empty
        -:  533:
        -:  534:		//Step 1 Shuffle the discard pile back into a deck
        -:  535:		int i;
        -:  536:		//Move discard to deck
     1480:  537:		for (i = 0; i < state->discardCount[player]; i++){
     1405:  538:			state->deck[player][i] = state->discard[player][i];
     1405:  539:			state->discard[player][i] = -1;
        -:  540:		}
        -:  541:
       75:  542:		state->deckCount[player] = state->discardCount[player];
       75:  543:		state->discardCount[player] = 0;//Reset discard
        -:  544:
        -:  545:		//Shufffle the deck
       75:  546:		shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  547:
        -:  548:		if (DEBUG){//Debug statements
        -:  549:			printf("Deck count now: %d\n", state->deckCount[player]);
        -:  550:		}
        -:  551:
       75:  552:		state->discardCount[player] = 0;
        -:  553:
        -:  554:		//Step 2 Draw Card
       75:  555:		count = state->handCount[player];//Get current player's hand count
        -:  556:
        -:  557:		if (DEBUG){//Debug statements
        -:  558:			printf("Current hand count: %d\n", count);
        -:  559:		}
        -:  560:
       75:  561:		deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  562:
       75:  563:		if (deckCounter == 0)
    #####:  564:			return -1;
        -:  565:
       75:  566:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
       75:  567:		state->deckCount[player]--;
       75:  568:		state->handCount[player]++;//Increment hand count
        -:  569:	}
        -:  570:
        -:  571:	else{
     1313:  572:		int count = state->handCount[player];//Get current hand count for player
        -:  573:		int deckCounter;
        -:  574:		if (DEBUG){//Debug statements
        -:  575:			printf("Current hand count: %d\n", count);
        -:  576:		}
        -:  577:
     1313:  578:		deckCounter = state->deckCount[player];//Create holder for the deck count
     1313:  579:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
     1313:  580:		state->deckCount[player]--;
     1313:  581:		state->handCount[player]++;//Increment hand count
        -:  582:	}
        -:  583:
     1388:  584:	return 0;
        -:  585:}
        -:  586:
     1012:  587:int getCost(int cardNumber)
        -:  588:{
     1012:  589:	switch (cardNumber)
        -:  590:	{
        -:  591:	case curse:
       84:  592:		return 0;
        -:  593:	case estate:
       39:  594:		return 2;
        -:  595:	case duchy:
       57:  596:		return 5;
        -:  597:	case province:
       58:  598:		return 8;
        -:  599:	case copper:
      116:  600:		return 0;
        -:  601:	case silver:
       77:  602:		return 3;
        -:  603:	case gold:
       39:  604:		return 6;
        -:  605:	case adventurer:
       46:  606:		return 6;
        -:  607:	case council_room:
       22:  608:		return 5;
        -:  609:	case feast:
    #####:  610:		return 4;
        -:  611:	case gardens:
    #####:  612:		return 4;
        -:  613:	case mine:
       58:  614:		return 5;
        -:  615:	case remodel:
       35:  616:		return 4;
        -:  617:	case smithy:
       17:  618:		return 4;
        -:  619:	case village:
       21:  620:		return 3;
        -:  621:	case baron:
       71:  622:		return 4;
        -:  623:	case great_hall:
       21:  624:		return 3;
        -:  625:	case minion:
       36:  626:		return 5;
        -:  627:	case steward:
       30:  628:		return 3;
        -:  629:	case tribute:
    #####:  630:		return 5;
        -:  631:	case ambassador:
       21:  632:		return 3;
        -:  633:	case cutpurse:
       30:  634:		return 4;
        -:  635:	case embargo:
    #####:  636:		return 2;
        -:  637:	case outpost:
       36:  638:		return 5;
        -:  639:	case salvager:
       43:  640:		return 4;
        -:  641:	case sea_hag:
       18:  642:		return 4;
        -:  643:	case treasure_map:
       36:  644:		return 4;
        -:  645:	}
        -:  646:
        1:  647:	return -1;
        -:  648:}
        -:  649:
    #####:  650:void playAdventurer(struct gameState *state, int currentPlayer)
        -:  651:// Reveal cards from deck until 2 Treasure cards are found.  Put those Treasure cards in the hand and discard the rest.
        -:  652:{
    #####:  653:	int drawntreasure = 0;
        -:  654:	int temphand[MAX_HAND];
        -:  655:	int cardDrawn;
    #####:  656:	int z = 0; // this is the counter for the temp hand
        -:  657:
    #####:  658:	while (drawntreasure < 2){
    #####:  659:		if (state->deckCount[currentPlayer] < 1){//if the deck is empty we need to shuffle discard and add to deck
    #####:  660:			shuffle(currentPlayer, state);
        -:  661:		}
    #####:  662:		drawCard(currentPlayer, state);
    #####:  663:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer] - 1];//top card of hand is most recently drawn card.
    #####:  664:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
    #####:  665:			drawntreasure++;
        -:  666:		else{
    #####:  667:			temphand[z] = cardDrawn;
    #####:  668:			state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####:  669:			z++;
        -:  670:		}
        -:  671:	}
    #####:  672:	while (z - 1 >= 0){
    #####:  673:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; // discard all cards in play that have been drawn
    #####:  674:		z = z - 1;
        -:  675:	}
    #####:  676:}
        -:  677:
        4:  678:int playRemodel(struct gameState *state, int currentPlayer, int choice1, int choice2, int handPos)
        -:  679://Trash a card in the hand, and gain a card costing up to $2 more than the trashed card
        -:  680:{
        -:  681:	int i;
        4:  682:	int j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  683:
        4:  684:	if ((getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2))
        -:  685:	{
        1:  686:		return -1;
        -:  687:	}
        -:  688:
        3:  689:	gainCard(choice2, state, 0, currentPlayer);
        -:  690:
        -:  691:	//discard card from hand
        3:  692:	discardCard(handPos, currentPlayer, state, 0);
        -:  693:
        -:  694:	//discard trashed card
        9:  695:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  696:	{
        8:  697:		if (state->hand[currentPlayer][i] == j)
        -:  698:		{
        2:  699:			discardCard(i, currentPlayer, state, 0);
        2:  700:			break;
        -:  701:		}
        -:  702:	}
        -:  703:
        3:  704:	return 0;
        -:  705:}
        -:  706:
        1:  707:void playSmithy(struct gameState *state, int currentPlayer, int handPos)
        -:  708:// Draw 3 cards
        -:  709:{
        -:  710:	int i;
        4:  711:	for (i = 0; i < 3; i++)
        -:  712:	{
        3:  713:		drawCard(currentPlayer, state);
        -:  714:	}
        -:  715:
        -:  716:	//discard card from hand
        1:  717:	discardCard(handPos, currentPlayer, state, 0);
        1:  718:}
        -:  719:
       23:  720:void playBaron(struct gameState *state, int currentPlayer, int choice1, int handPos)
        -:  721://Add a buy.  OPTION:  Discard an Estate card and gain $4.  Otherwise, gain an Estate card.
        -:  722:{
       23:  723:	state->numBuys++;//Increase buys by 1!
       23:  724:	if (choice1 > 0){//Boolean true or going to discard an estate
       23:  725:		int p = 0;//Iterator for hand!
       23:  726:		int card_not_discarded = 1;//Flag for discard set!
      161:  727:		while (card_not_discarded){
      115:  728:			if (state->hand[currentPlayer][p] == estate){ //Found an estate card!
       13:  729:				state->coins += 4;//Add 4 coins to the amount of coins
       13:  730:				state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
       13:  731:				state->discardCount[currentPlayer]++;
       46:  732:				for (; p < state->handCount[currentPlayer]; p++){
       33:  733:					state->hand[currentPlayer][p] = state->hand[currentPlayer][p + 1];
        -:  734:				}
       13:  735:				state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
       13:  736:				state->handCount[currentPlayer]--;
       13:  737:				card_not_discarded = 0;//Exit the loop
        -:  738:			}
      102:  739:			else if (p > state->handCount[currentPlayer]){
        -:  740:				if (DEBUG) {
        -:  741:					printf("No estate cards in your hand, invalid choice\n");
        -:  742:					printf("Must gain an estate if there are any\n");
        -:  743:				}
       10:  744:				if (supplyCount(estate, state) > 0){
        5:  745:					gainCard(estate, state, 1, currentPlayer);
        5:  746:					state->supplyCount[estate]--;//Decrement estates
        5:  747:					if (supplyCount(estate, state) == 0){
    #####:  748:						isGameOver(state);
        -:  749:					}
        -:  750:				}
       10:  751:				card_not_discarded = 0;//Exit the loop
        -:  752:			}
        -:  753:
        -:  754:			else{
       92:  755:				p++;//Next card
        -:  756:			}
        -:  757:		}
        -:  758:	}
        -:  759:
        -:  760:	else{
    #####:  761:		if (supplyCount(estate, state) > 0){
    #####:  762:			gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  763:			state->supplyCount[estate]--;//Decrement Estates
    #####:  764:			if (supplyCount(estate, state) == 0){
    #####:  765:				isGameOver(state);
        -:  766:			}
        -:  767:		}
        -:  768:	}
       23:  769:}
        -:  770:
        3:  771:int playTreasureMap(struct gameState *state, int currentPlayer, int handPos)
        -:  772://Trashing two treasure map cards from the hand = four gold on top of the deck.
        -:  773:{
        -:  774:	int i;
        -:  775:	int index;
        -:  776:
        -:  777:	//search hand for another treasure_map
       18:  778:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  779:	{
       15:  780:		if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -:  781:		{
    #####:  782:			index = i;
    #####:  783:			break;
        -:  784:		}
        -:  785:	}
        3:  786:	if (index > -1)
        -:  787:	{
        -:  788:		//trash both treasure cards
        3:  789:		discardCard(handPos, currentPlayer, state, 1);
        3:  790:		discardCard(index, currentPlayer, state, 1);
        -:  791:
        -:  792:		//gain 4 Gold cards
       15:  793:		for (i = 0; i < 4; i++)
        -:  794:		{
       12:  795:			gainCard(gold, state, 1, currentPlayer);
        -:  796:		}
        -:  797:
        -:  798:		//return success
        3:  799:		return 1;
        -:  800:	}
        -:  801:
        -:  802:	//no second treasure_map found in hand
    #####:  803:	return -1;
        -:  804:}
        -:  805:
       72:  806:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  807:{
        -:  808:	int i;
        -:  809:	int j;
        -:  810:	int k;
        -:  811:	//int x;  //Unused after while loop removed from feast.
       72:  812:	int currentPlayer = whoseTurn(state);
       72:  813:	int nextPlayer = currentPlayer + 1;
        -:  814:	int temphand[MAX_HAND];
        -:  815:
       72:  816:	int tributeRevealedCards[2] = { -1, -1 };
        -:  817:
       72:  818:	if (nextPlayer > (state->numPlayers - 1)){
       20:  819:		nextPlayer = 0;
        -:  820:	}
        -:  821:
        -:  822:	//uses switch to select card and perform actions
       72:  823:	switch (card)
        -:  824:	{
        -:  825:	case adventurer:
        -:  826:
    #####:  827:		playAdventurer(state, currentPlayer);
    #####:  828:		return 0;
        -:  829:
        -:  830:	case council_room:
        -:  831:		//+4 Cards
    #####:  832:		for (i = 0; i < 4; i++)
        -:  833:		{
    #####:  834:			drawCard(currentPlayer, state);
        -:  835:		}
        -:  836:
        -:  837:		//+1 Buy
    #####:  838:		state->numBuys++;
        -:  839:
        -:  840:		//Each other player draws a card
    #####:  841:		for (i = 0; i < state->numPlayers; i++)
        -:  842:		{
    #####:  843:			if (i != currentPlayer)
        -:  844:			{
    #####:  845:				drawCard(i, state);
        -:  846:			}
        -:  847:		}
        -:  848:
        -:  849:		//put played card in played card pile
    #####:  850:		discardCard(handPos, currentPlayer, state, 0);
        -:  851:
    #####:  852:		return 0;
        -:  853:
        -:  854:	case feast:
        -:  855:		//gain card with cost up to 5
        -:  856:		//Backup hand
    #####:  857:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  858:			temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  859:			state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  860:		}
        -:  861:		//Backup hand
        -:  862:
        -:  863:		//Update Coins for Buy
    #####:  864:		updateCoins(currentPlayer, state, 5);
        -:  865://		x = 1;//Condition to loop on
        -:  866://		while (x == 1) {//Buy one card
    #####:  867:			if (supplyCount(choice1, state) <= 0){
        -:  868:				if (DEBUG)
        -:  869:					printf("None of that card left, sorry!\n");
        -:  870:
        -:  871:				if (DEBUG){
        -:  872:					printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  873:				}
        -:  874:			}
    #####:  875:			else if (state->coins < getCost(choice1)){
    #####:  876:				printf("That card is too expensive!\n");
        -:  877:
        -:  878:				if (DEBUG){
        -:  879:					printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  880:				}
        -:  881:			}
        -:  882:			else{
        -:  883:
        -:  884:				if (DEBUG){
        -:  885:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  886:				}
        -:  887:
    #####:  888:				gainCard(choice1, state, 0, currentPlayer);//Gain the card
        -:  889://				x = 0;//No more buying cards
        -:  890:
        -:  891:				if (DEBUG){
        -:  892:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  893:				}
        -:  894:
        -:  895:			}
        -:  896://		}
        -:  897:
        -:  898:		//Reset Hand
    #####:  899:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  900:			state->hand[currentPlayer][i] = temphand[i];
    #####:  901:			temphand[i] = -1;
        -:  902:		}
        -:  903:		//Reset Hand
        -:  904:
    #####:  905:		return 0;
        -:  906:
        -:  907:	case gardens:
    #####:  908:		return -1;
        -:  909:
        -:  910:	case mine:
        3:  911:		j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  912:
        3:  913:		if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  914:		{
        2:  915:			return -1;
        -:  916:		}
        -:  917:
        1:  918:		if (choice2 > treasure_map || choice2 < curse)
        -:  919:		{
    #####:  920:			return -1;
        -:  921:		}
        -:  922:
        1:  923:		if ((getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2))
        -:  924:		{
        1:  925:			return -1;
        -:  926:		}
        -:  927:
    #####:  928:		gainCard(choice2, state, 2, currentPlayer);
        -:  929:
        -:  930:		//discard card from hand
    #####:  931:		discardCard(handPos, currentPlayer, state, 0);
        -:  932:
        -:  933:		//discard trashed card
    #####:  934:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  935:		{
    #####:  936:			if (state->hand[currentPlayer][i] == j)
        -:  937:			{
    #####:  938:				discardCard(i, currentPlayer, state, 0);
    #####:  939:				break;
        -:  940:			}
        -:  941:		}
        -:  942:
    #####:  943:		return 0;
        -:  944:
        -:  945:	case remodel:
        -:  946:
        4:  947:		return playRemodel(state, currentPlayer, choice1, choice2, handPos);
        -:  948:
        -:  949:	case smithy:
        -:  950:
        1:  951:		playSmithy(state, currentPlayer, handPos);
        1:  952:		return 0;
        -:  953:
        -:  954:	case village:
        -:  955:		//+1 Card
        9:  956:		drawCard(currentPlayer, state);
        -:  957:
        -:  958:		//+2 Actions
        9:  959:		state->numActions = state->numActions + 2;
        -:  960:
        -:  961:		//discard played card from hand
        9:  962:		discardCard(handPos, currentPlayer, state, 0);
        9:  963:		return 0;
        -:  964:
        -:  965:	case baron:
        -:  966:
       23:  967:		playBaron(state, currentPlayer, choice1, handPos);
       23:  968:		return 0;
        -:  969:
        -:  970:	case great_hall:
        -:  971:		//+1 Card
        1:  972:		drawCard(currentPlayer, state);
        -:  973:
        -:  974:		//+1 Actions
        1:  975:		state->numActions++;
        -:  976:
        -:  977:		//discard card from hand
        1:  978:		discardCard(handPos, currentPlayer, state, 0);
        1:  979:		return 0;
        -:  980:
        -:  981:	case minion:
        -:  982:		//+1 action
        1:  983:		state->numActions++;
        -:  984:
        -:  985:		//discard card from hand
        1:  986:		discardCard(handPos, currentPlayer, state, 0);
        -:  987:
        1:  988:		if (choice1)		//+2 coins
        -:  989:		{
        1:  990:			state->coins = state->coins + 2;
        -:  991:		}
        -:  992:
    #####:  993:		else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  994:		{
        -:  995:			//discard hand
    #####:  996:			while (numHandCards(state) > 0)
        -:  997:			{
    #####:  998:				discardCard(handPos, currentPlayer, state, 0);
        -:  999:			}
        -: 1000:
        -: 1001:			//draw 4
    #####: 1002:			for (i = 0; i < 4; i++)
        -: 1003:			{
    #####: 1004:				drawCard(currentPlayer, state);
        -: 1005:			}
        -: 1006:
        -: 1007:			//other players discard hand and redraw if hand size > 4
    #####: 1008:			for (i = 0; i < state->numPlayers; i++)
        -: 1009:			{
    #####: 1010:				if (i != currentPlayer)
        -: 1011:				{
    #####: 1012:					if (state->handCount[i] > 4)
        -: 1013:					{
        -: 1014:						//discard hand
    #####: 1015:						while (state->handCount[i] > 0)
        -: 1016:						{
    #####: 1017:							discardCard(handPos, i, state, 0);
        -: 1018:						}
        -: 1019:
        -: 1020:						//draw 4
    #####: 1021:						for (j = 0; j < 4; j++)
        -: 1022:						{
    #####: 1023:							drawCard(i, state);
        -: 1024:						}
        -: 1025:					}
        -: 1026:				}
        -: 1027:			}
        -: 1028:
        -: 1029:		}
        1: 1030:		return 0;
        -: 1031:
        -: 1032:	case steward:
        4: 1033:		if (choice1 == 1)
        -: 1034:		{
        -: 1035:			//+2 cards
    #####: 1036:			drawCard(currentPlayer, state);
    #####: 1037:			drawCard(currentPlayer, state);
        -: 1038:		}
        4: 1039:		else if (choice1 == 2)
        -: 1040:		{
        -: 1041:			//+2 coins
    #####: 1042:			state->coins = state->coins + 2;
        -: 1043:		}
        -: 1044:		else
        -: 1045:		{
        -: 1046:			//trash 2 cards in hand
        4: 1047:			discardCard(choice2, currentPlayer, state, 1);
        4: 1048:			discardCard(choice3, currentPlayer, state, 1);
        -: 1049:		}
        -: 1050:
        -: 1051:		//discard card from hand
        4: 1052:		discardCard(handPos, currentPlayer, state, 0);
        4: 1053:		return 0;
        -: 1054:
        -: 1055:	case tribute:
    #####: 1056:		if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####: 1057:			if (state->deckCount[nextPlayer] > 0){
    #####: 1058:				tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1059:				state->deckCount[nextPlayer]--;
        -: 1060:			}
    #####: 1061:			else if (state->discardCount[nextPlayer] > 0){
    #####: 1062:				tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer] - 1];
    #####: 1063:				state->discardCount[nextPlayer]--;
        -: 1064:			}
        -: 1065:			else{
        -: 1066:				//No Card to Reveal
        -: 1067:				if (DEBUG){
        -: 1068:					printf("No cards to reveal\n");
        -: 1069:				}
        -: 1070:			}
        -: 1071:		}
        -: 1072:
        -: 1073:		else{
    #####: 1074:			if (state->deckCount[nextPlayer] == 0){
    #####: 1075:				for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####: 1076:					state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1077:					state->deckCount[nextPlayer]++;
    #####: 1078:					state->discard[nextPlayer][i] = -1;
    #####: 1079:					state->discardCount[nextPlayer]--;
        -: 1080:				}
        -: 1081:
    #####: 1082:				shuffle(nextPlayer, state);//Shuffle the deck
        -: 1083:			}
    #####: 1084:			tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1085:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1086:			state->deckCount[nextPlayer]--;
    #####: 1087:			tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1088:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1089:			state->deckCount[nextPlayer]--;
        -: 1090:		}
        -: 1091:
    #####: 1092:		if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
    #####: 1093:			state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1094:			state->playedCardCount++;
    #####: 1095:			tributeRevealedCards[1] = -1;
        -: 1096:		}
        -: 1097:
    #####: 1098:		for (i = 0; i <= 2; i++){
    #####: 1099:			if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
    #####: 1100:				state->coins += 2;
        -: 1101:			}
        -: 1102:
    #####: 1103:			else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
    #####: 1104:				drawCard(currentPlayer, state);
    #####: 1105:				drawCard(currentPlayer, state);
        -: 1106:			}
        -: 1107:			else{//Action Card
    #####: 1108:				state->numActions = state->numActions + 2;
        -: 1109:			}
        -: 1110:		}
        -: 1111:
    #####: 1112:		return 0;
        -: 1113:
        -: 1114:	case ambassador:
        9: 1115:		j = 0;		//used to check if player has enough cards to discard
        -: 1116:
        9: 1117:		if (choice2 > 2 || choice2 < 0)
        -: 1118:		{
        8: 1119:			return -1;
        -: 1120:		}
        -: 1121:
        1: 1122:		if (choice1 == handPos)
        -: 1123:		{
    #####: 1124:			return -1;
        -: 1125:		}
        -: 1126:
        6: 1127:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1128:		{
        5: 1129:			if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1130:			{
        1: 1131:				j++;
        -: 1132:			}
        -: 1133:		}
        1: 1134:		if (j < choice2)
        -: 1135:		{
    #####: 1136:			return -1;
        -: 1137:		}
        -: 1138:
        -: 1139:		if (DEBUG)
        -: 1140:			printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1141:
        -: 1142:		//increase supply count for choosen card by amount being discarded
        1: 1143:		state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1144:
        -: 1145:		//each other player gains a copy of revealed card
        4: 1146:		for (i = 0; i < state->numPlayers; i++)
        -: 1147:		{
        3: 1148:			if (i != currentPlayer)
        -: 1149:			{
        2: 1150:				gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1151:			}
        -: 1152:		}
        -: 1153:
        -: 1154:		//discard played card from hand
        1: 1155:		discardCard(handPos, currentPlayer, state, 0);
        -: 1156:
        -: 1157:		//trash copies of cards returned to supply
        2: 1158:		for (j = 0; j < choice2; j++)
        -: 1159:		{
        3: 1160:			for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1161:			{
        3: 1162:				if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1163:				{
        1: 1164:					discardCard(i, currentPlayer, state, 1);
        1: 1165:					break;
        -: 1166:				}
        -: 1167:			}
        -: 1168:		}
        -: 1169:
        1: 1170:		return 0;
        -: 1171:
        -: 1172:	case cutpurse:
        -: 1173:
        4: 1174:		updateCoins(currentPlayer, state, 2);
       16: 1175:		for (i = 0; i < state->numPlayers; i++)
        -: 1176:		{
       12: 1177:			if (i != currentPlayer)
        -: 1178:			{
        8: 1179:				for (j = 0; j < state->handCount[i]; j++)
        -: 1180:				{
    #####: 1181:					if (state->hand[i][j] == copper)
        -: 1182:					{
    #####: 1183:						discardCard(j, i, state, 0);
    #####: 1184:						break;
        -: 1185:					}
    #####: 1186:					if (j == state->handCount[i])
        -: 1187:					{
    #####: 1188:						for (k = 0; k < state->handCount[i]; k++)
        -: 1189:						{
        -: 1190:							if (DEBUG)
        -: 1191:								printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1192:						}
    #####: 1193:						break;
        -: 1194:					}
        -: 1195:				}
        -: 1196:
        -: 1197:			}
        -: 1198:
        -: 1199:		}
        -: 1200:
        -: 1201:		//discard played card from hand
        4: 1202:		discardCard(handPos, currentPlayer, state, 0);
        -: 1203:
        4: 1204:		return 0;
        -: 1205:
        -: 1206:
        -: 1207:	case embargo:
        -: 1208:		//+2 Coins
    #####: 1209:		state->coins = state->coins + 2;
        -: 1210:
        -: 1211:		//see if selected pile is in play
    #####: 1212:		if (state->supplyCount[choice1] == -1)
        -: 1213:		{
    #####: 1214:			return -1;
        -: 1215:		}
        -: 1216:
        -: 1217:		//add embargo token to selected supply pile
    #####: 1218:		state->embargoTokens[choice1]++;
        -: 1219:
        -: 1220:		//trash card
    #####: 1221:		discardCard(handPos, currentPlayer, state, 1);
    #####: 1222:		return 0;
        -: 1223:
        -: 1224:	case outpost:
        -: 1225:		//set outpost flag
    #####: 1226:		state->outpostPlayed++;
        -: 1227:
        -: 1228:		//discard card
    #####: 1229:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1230:		return 0;
        -: 1231:
        -: 1232:	case salvager:
        -: 1233:		//+1 buy
        6: 1234:		state->numBuys++;
        -: 1235:
        6: 1236:		if (choice1)
        -: 1237:		{
        -: 1238:			//gain coins equal to trashed card
        6: 1239:			state->coins = state->coins + getCost(handCard(choice1, state));
        -: 1240:			//trash card
        6: 1241:			discardCard(choice1, currentPlayer, state, 1);
        -: 1242:		}
        -: 1243:
        -: 1244:		//discard card
        6: 1245:		discardCard(handPos, currentPlayer, state, 0);
        6: 1246:		return 0;
        -: 1247:
        -: 1248:	case sea_hag:
       16: 1249:		for (i = 0; i < state->numPlayers; i++){
       12: 1250:			if (i != currentPlayer){
        8: 1251:				state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
        8: 1252:				state->discardCount[i]++;
        8: 1253:				state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1254:			}
        -: 1255:		}
        4: 1256:		return 0;
        -: 1257:
        -: 1258:	case treasure_map:
        -: 1259:
        3: 1260:		return playTreasureMap(state, currentPlayer, handPos);
        -: 1261:	}
    #####: 1262:	return -1;
        -: 1263:}
        -: 1264:
       53: 1265:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1266:{
        -: 1267:
        -: 1268:	//if card is not trashed, added to Played pile 
       53: 1269:	if (trashFlag < 1)
        -: 1270:	{
        -: 1271:		//add card to played pile
       32: 1272:		state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
       32: 1273:		state->playedCardCount++;
        -: 1274:	}
        -: 1275:
        -: 1276:	//set played card to -1
       53: 1277:	state->hand[currentPlayer][handPos] = -1;
        -: 1278:
        -: 1279:	//remove card from player's hand
       53: 1280:	if (handPos == (state->handCount[currentPlayer] - 1)) 	//last card in hand array is played
        -: 1281:	{
        -: 1282:		//reduce number of cards in hand
        7: 1283:		state->handCount[currentPlayer]--;
        -: 1284:	}
       46: 1285:	else if (state->handCount[currentPlayer] == 1) //only one card in hand
        -: 1286:	{
        -: 1287:		//reduce number of cards in hand
    #####: 1288:		state->handCount[currentPlayer]--;
        -: 1289:	}
        -: 1290:	else
        -: 1291:	{
        -: 1292:		//replace discarded card with last card in hand
       46: 1293:		state->hand[currentPlayer][handPos] = state->hand[currentPlayer][(state->handCount[currentPlayer] - 1)];
        -: 1294:		//set last card to -1
       46: 1295:		state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1296:		//reduce number of cards in hand
       46: 1297:		state->handCount[currentPlayer]--;
        -: 1298:	}
        -: 1299:
       53: 1300:	return 0;
        -: 1301:}
        -: 1302:
      241: 1303:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1304:{
        -: 1305:	//Note: supplyPos is enum of choosen card
        -: 1306:
        -: 1307:	//check if supply pile is empty (0) or card is not used in game (-1)
      241: 1308:	if (supplyCount(supplyPos, state) < 1)
        -: 1309:	{
        2: 1310:		return -1;
        -: 1311:	}
        -: 1312:
        -: 1313:	//added card for [whoseTurn] current player:
        -: 1314:	// toFlag = 0 : add to discard
        -: 1315:	// toFlag = 1 : add to deck
        -: 1316:	// toFlag = 2 : add to hand
        -: 1317:
      239: 1318:	if (toFlag == 1)
        -: 1319:	{
       17: 1320:		state->deck[player][state->deckCount[player]] = supplyPos;
       17: 1321:		state->deckCount[player]++;
        -: 1322:	}
      222: 1323:	else if (toFlag == 2)
        -: 1324:	{
    #####: 1325:		state->hand[player][state->handCount[player]] = supplyPos;
    #####: 1326:		state->handCount[player]++;
        -: 1327:	}
        -: 1328:	else
        -: 1329:	{
      222: 1330:		state->discard[player][state->discardCount[player]] = supplyPos;
      222: 1331:		state->discardCount[player]++;
        -: 1332:	}
        -: 1333:
        -: 1334:	//decrease number in supply pile
      239: 1335:	state->supplyCount[supplyPos]--;
        -: 1336:
      239: 1337:	return 0;
        -: 1338:}
        -: 1339:
      339: 1340:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1341:{
        -: 1342:	int i;
        -: 1343:
        -: 1344:	//reset coin count
      339: 1345:	state->coins = 0;
        -: 1346:
        -: 1347:	//add coins for each Treasure card in player's hand
     1981: 1348:	for (i = 0; i < state->handCount[player]; i++)
        -: 1349:	{
     1642: 1350:		if (state->hand[player][i] == copper)
        -: 1351:		{
      712: 1352:			state->coins += 1;
        -: 1353:		}
      930: 1354:		else if (state->hand[player][i] == silver)
        -: 1355:		{
      105: 1356:			state->coins += 2;
        -: 1357:		}
      825: 1358:		else if (state->hand[player][i] == gold)
        -: 1359:		{
       43: 1360:			state->coins += 3;
        -: 1361:		}
        -: 1362:	}
        -: 1363:
        -: 1364:	//add bonus
      339: 1365:	state->coins += bonus;
        -: 1366:
      339: 1367:	return 0;
        -: 1368:}
        -: 1369:
        -: 1370:
        -: 1371://end of dominion.c
File 'dominion.c'
Lines executed:59.61% of 557
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
     2741:    8:int compare(const void* a, const void* b) {
     2741:    9:	if (*(int*)a > *(int*)b)
      932:   10:		return 1;
     1809:   11:	if (*(int*)a < *(int*)b)
      796:   12:		return -1;
     1013:   13:	return 0;
        -:   14:}
        -:   15:
        4:   16:struct gameState* newGame() {
        4:   17:	struct gameState* g = malloc(sizeof(struct gameState));
        4:   18:	return g;
        -:   19:}
        -:   20:
       38:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:	int k8, int k9, int k10) {
       38:   23:	int* k = malloc(10 * sizeof(int));
       38:   24:	k[0] = k1;
       38:   25:	k[1] = k2;
       38:   26:	k[2] = k3;
       38:   27:	k[3] = k4;
       38:   28:	k[4] = k5;
       38:   29:	k[5] = k6;
       38:   30:	k[6] = k7;
       38:   31:	k[7] = k8;
       38:   32:	k[8] = k9;
       38:   33:	k[9] = k10;
       38:   34:	return k;
        -:   35:}
        -:   36:
       38:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		struct gameState *state) {
        -:   39:
        -:   40:	int i;
        -:   41:	int j;
        -:   42:	int it;
        -:   43:	//set up random number generator
       38:   44:	SelectStream(1);
       38:   45:	PutSeed((long)randomSeed);
        -:   46:
        -:   47:	//check number of players
       38:   48:	if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:	{
    #####:   50:		return -1;
        -:   51:	}
        -:   52:
        -:   53:	//set number of players
       38:   54:	state->numPlayers = numPlayers;
        -:   55:
        -:   56:	//check selected kingdom cards are different
      105:   57:	for (i = 0; i < 10; i++)
        -:   58:	{
      978:   59:		for (j = 0; j < 10; j++)
        -:   60:		{
      911:   61:			if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:			{
       36:   63:				return -1;
        -:   64:			}
        -:   65:		}
        -:   66:	}
        -:   67:
        -:   68:
        -:   69:	//initialize supply
        -:   70:	///////////////////////////////
        -:   71:
        -:   72:	//set number of Curse cards
        2:   73:	if (numPlayers == 2)
        -:   74:	{
        1:   75:		state->supplyCount[curse] = 10;
        -:   76:	}
        1:   77:	else if (numPlayers == 3)
        -:   78:	{
    #####:   79:		state->supplyCount[curse] = 20;
        -:   80:	}
        -:   81:	else
        -:   82:	{
        1:   83:		state->supplyCount[curse] = 30;
        -:   84:	}
        -:   85:
        -:   86:	//set number of Victory cards
        2:   87:	if (numPlayers == 2)
        -:   88:	{
        1:   89:		state->supplyCount[estate] = 8;
        1:   90:		state->supplyCount[duchy] = 8;
        1:   91:		state->supplyCount[province] = 8;
        -:   92:	}
        -:   93:	else
        -:   94:	{
        1:   95:		state->supplyCount[estate] = 12;
        1:   96:		state->supplyCount[duchy] = 12;
        1:   97:		state->supplyCount[province] = 12;
        -:   98:	}
        -:   99:
        -:  100:	//set number of Treasure cards
        2:  101:	state->supplyCount[copper] = 60 - (7 * numPlayers);
        2:  102:	state->supplyCount[silver] = 40;
        2:  103:	state->supplyCount[gold] = 30;
        -:  104:
        -:  105:	//set number of Kingdom cards
       42:  106:	for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:	{
      330:  108:		for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:		{
      310:  110:			if (kingdomCards[j] == i)
        -:  111:			{
        -:  112:				//check if card is a 'Victory' Kingdom card
       20:  113:				if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:				{
        2:  115:					if (numPlayers == 2){
    #####:  116:						state->supplyCount[i] = 8;
        -:  117:					}
        1:  118:					else{ state->supplyCount[i] = 12; }
        -:  119:				}
        -:  120:				else
        -:  121:				{
       19:  122:					state->supplyCount[i] = 10;
        -:  123:				}
       20:  124:				break;
        -:  125:			}
        -:  126:			else    //card is not in the set choosen for the game
        -:  127:			{
      290:  128:				state->supplyCount[i] = -1;
        -:  129:			}
        -:  130:		}
        -:  131:
        -:  132:	}
        -:  133:
        -:  134:	////////////////////////
        -:  135:	//supply intilization complete
        -:  136:
        -:  137:	//set player decks
        8:  138:	for (i = 0; i < numPlayers; i++)
        -:  139:	{
        6:  140:		state->deckCount[i] = 0;
       24:  141:		for (j = 0; j < 3; j++)
        -:  142:		{
       18:  143:			state->deck[i][j] = estate;
       18:  144:			state->deckCount[i]++;
        -:  145:		}
       48:  146:		for (j = 3; j < 10; j++)
        -:  147:		{
       42:  148:			state->deck[i][j] = copper;
       42:  149:			state->deckCount[i]++;
        -:  150:		}
        -:  151:	}
        -:  152:
        -:  153:	//shuffle player decks
        8:  154:	for (i = 0; i < numPlayers; i++)
        -:  155:	{
        6:  156:		if (shuffle(i, state) < 0)
        -:  157:		{
    #####:  158:			return -1;
        -:  159:		}
        -:  160:	}
        -:  161:
        -:  162:	//draw player hands
        8:  163:	for (i = 0; i < numPlayers; i++)
        -:  164:	{
        -:  165:		//initialize hand size to zero
        6:  166:		state->handCount[i] = 0;
        6:  167:		state->discardCount[i] = 0;
        -:  168:		//draw 5 cards
        -:  169:		// for (j = 0; j < 5; j++)
        -:  170:		//	{
        -:  171:		//	  drawCard(i, state);
        -:  172:		//	}
        -:  173:	}
        -:  174:
        -:  175:	//set embargo tokens to 0 for all supply piles
       56:  176:	for (i = 0; i <= treasure_map; i++)
        -:  177:	{
       54:  178:		state->embargoTokens[i] = 0;
        -:  179:	}
        -:  180:
        -:  181:	//initialize first player's turn
        2:  182:	state->outpostPlayed = 0;
        2:  183:	state->phase = 0;
        2:  184:	state->numActions = 1;
        2:  185:	state->numBuys = 1;
        2:  186:	state->playedCardCount = 0;
        2:  187:	state->whoseTurn = 0;
        2:  188:	state->handCount[state->whoseTurn] = 0;
        -:  189:	//int it; move to top
        -:  190:
        -:  191:	//Moved draw cards to here, only drawing at the start of a turn
       12:  192:	for (it = 0; it < 5; it++){
       10:  193:		drawCard(state->whoseTurn, state);
        -:  194:	}
        -:  195:
        2:  196:	updateCoins(state->whoseTurn, state, 0);
        -:  197:
        2:  198:	return 0;
        -:  199:}
        -:  200:
       90:  201:int shuffle(int player, struct gameState *state) {
        -:  202:
        -:  203:
        -:  204:	int newDeck[MAX_DECK];
       90:  205:	int newDeckPos = 0;
        -:  206:	int card;
        -:  207:	int i;
        -:  208:
       90:  209:	if (state->deckCount[player] < 1)
    #####:  210:		return -1;
       90:  211:	qsort((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
        -:  212:	/* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
     1491:  214:	while (state->deckCount[player] > 0) {
     1311:  215:		card = floor(Random() * state->deckCount[player]);
     1311:  216:		newDeck[newDeckPos] = state->deck[player][card];
     1311:  217:		newDeckPos++;
     6709:  218:		for (i = card; i < state->deckCount[player] - 1; i++) {
     5398:  219:			state->deck[player][i] = state->deck[player][i + 1];
        -:  220:		}
     1311:  221:		state->deckCount[player]--;
        -:  222:	}
     1401:  223:	for (i = 0; i < newDeckPos; i++) {
     1311:  224:		state->deck[player][i] = newDeck[i];
     1311:  225:		state->deckCount[player]++;
        -:  226:	}
        -:  227:
       90:  228:	return 0;
        -:  229:}
        -:  230:
     1227:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state)
        -:  232:{
        -:  233:	int card;
     1227:  234:	int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:	//check if it is the right phase
     1227:  237:	if (state->phase != 0)
        -:  238:	{
      182:  239:		return -1;
        -:  240:	}
        -:  241:
        -:  242:	//check if player has enough actions
     1045:  243:	if (state->numActions < 1)
        -:  244:	{
       39:  245:		return -1;
        -:  246:	}
        -:  247:
        -:  248:	//get card played
     1006:  249:	card = handCard(handPos, state);
        -:  250:
        -:  251:	//check if selected card is an action
     1006:  252:	if (card < adventurer || card > treasure_map)
        -:  253:	{
      951:  254:		return -1;
        -:  255:	}
        -:  256:
        -:  257:	//play card
       55:  258:	if (cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0)
        -:  259:	{
    #####:  260:		return -1;
        -:  261:	}
        -:  262:
        -:  263:	//reduce number of actions
       55:  264:	state->numActions--;
        -:  265:
        -:  266:	//update coins (Treasure cards may be added with card draws)
       55:  267:	updateCoins(state->whoseTurn, state, coin_bonus);
        -:  268:
       55:  269:	return 0;
        -:  270:}
        -:  271:
     1294:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:	int who;
        -:  274:	if (DEBUG){
        -:  275:		printf("Entering buyCard...\n");
        -:  276:	}
        -:  277:
        -:  278:	// I don't know what to do about the phase thing.
        -:  279:
     1294:  280:	who = state->whoseTurn;
        -:  281:
     1294:  282:	if (state->numBuys < 1){
        -:  283:		if (DEBUG)
        -:  284:			printf("You do not have any buys left\n");
      203:  285:		return -1;
        -:  286:	}
     1091:  287:	else if (supplyCount(supplyPos, state) < 1){
        -:  288:		if (DEBUG)
        -:  289:			printf("There are not any of that type of card left\n");
      430:  290:		return -1;
        -:  291:	}
      661:  292:	else if (state->coins < getCost(supplyPos)){
        -:  293:		if (DEBUG)
        -:  294:			printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
      469:  295:		return -1;
        -:  296:	}
        -:  297:	else {
      192:  298:		state->phase = 1;
        -:  299:		//state->supplyCount[supplyPos]--;
      192:  300:		gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  301:
      192:  302:		state->coins = (state->coins) - (getCost(supplyPos));
      192:  303:		state->numBuys--;
        -:  304:		if (DEBUG)
        -:  305:			printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  306:	}
        -:  307:
        -:  308:	//state->discard[who][state->discardCount[who]] = supplyPos;
        -:  309:	//state->discardCount[who]++;
        -:  310:
      192:  311:	return 0;
        -:  312:}
        -:  313:
    #####:  314:int numHandCards(struct gameState *state) {
    #####:  315:	return state->handCount[whoseTurn(state)];
        -:  316:}
        -:  317:
     1006:  318:int handCard(int handPos, struct gameState *state) {
     1006:  319:	int currentPlayer = whoseTurn(state);
     1006:  320:	return state->hand[currentPlayer][handPos];
        -:  321:}
        -:  322:
     1300:  323:int supplyCount(int card, struct gameState *state) {
     1300:  324:	return state->supplyCount[card];
        -:  325:}
        -:  326:
    #####:  327:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  328:	int i;
    #####:  329:	int count = 0;
        -:  330:
    #####:  331:	for (i = 0; i < state->deckCount[player]; i++)
        -:  332:	{
    #####:  333:		if (state->deck[player][i] == card) count++;
        -:  334:	}
        -:  335:
    #####:  336:	for (i = 0; i < state->handCount[player]; i++)
        -:  337:	{
    #####:  338:		if (state->hand[player][i] == card) count++;
        -:  339:	}
        -:  340:
    #####:  341:	for (i = 0; i < state->discardCount[player]; i++)
        -:  342:	{
    #####:  343:		if (state->discard[player][i] == card) count++;
        -:  344:	}
        -:  345:
    #####:  346:	return count;
        -:  347:}
        -:  348:
     1292:  349:int whoseTurn(struct gameState *state) {
     1292:  350:	return state->whoseTurn;
        -:  351:}
        -:  352:
      231:  353:int endTurn(struct gameState *state) {
        -:  354:	int k;
        -:  355:	int i;
      231:  356:	int currentPlayer = whoseTurn(state);
        -:  357:
        -:  358:	//Discard hand
     1343:  359:	for (i = 0; i < state->handCount[currentPlayer]; i++){
     1112:  360:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
     1112:  361:		state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  362:	}
      231:  363:	state->handCount[currentPlayer] = 0;//Reset hand count
        -:  364:
        -:  365:	//Code for determining the player
      231:  366:	if (currentPlayer < (state->numPlayers - 1)){
      149:  367:		state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  368:	}
        -:  369:	else{
       82:  370:		state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  371:	}
        -:  372:
      231:  373:	state->outpostPlayed = 0;
      231:  374:	state->phase = 0;
      231:  375:	state->numActions = 1;
      231:  376:	state->coins = 0;
      231:  377:	state->numBuys = 1;
      231:  378:	state->playedCardCount = 0;
      231:  379:	state->handCount[state->whoseTurn] = 0;
        -:  380:
        -:  381:	//int k; move to top
        -:  382:	//Next player draws hand
     1386:  383:	for (k = 0; k < 5; k++){
     1155:  384:		drawCard(state->whoseTurn, state);//Draw a card
        -:  385:	}
        -:  386:
        -:  387:	//Update money
      231:  388:	updateCoins(state->whoseTurn, state, 0);
        -:  389:
      231:  390:	return 0;
        -:  391:}
        -:  392:
     3769:  393:int isGameOver(struct gameState *state) {
        -:  394:	int i;
        -:  395:	int j;
        -:  396:
        -:  397:	//if stack of Province cards is empty, the game ends
     3769:  398:	if (state->supplyCount[province] == 0)
        -:  399:	{
    #####:  400:		return 1;
        -:  401:	}
        -:  402:
        -:  403:	//if three supply pile are at 0, the game ends
     3769:  404:	j = 0;
    97994:  405:	for (i = 0; i < 25; i++)
        -:  406:	{
    94225:  407:		if (state->supplyCount[i] == 0)
        -:  408:		{
     3296:  409:			j++;
        -:  410:		}
        -:  411:	}
     3769:  412:	if (j >= 3)
        -:  413:	{
        2:  414:		return 1;
        -:  415:	}
        -:  416:
     3767:  417:	return 0;
        -:  418:}
        -:  419:
    #####:  420:int scoreFor(int player, struct gameState *state) {
        -:  421:
        -:  422:	int i;
    #####:  423:	int score = 0;
        -:  424:	//score from hand
    #####:  425:	for (i = 0; i < state->handCount[player]; i++)
        -:  426:	{
    #####:  427:		if (state->hand[player][i] == curse) { score = score - 1; };
    #####:  428:		if (state->hand[player][i] == estate) { score = score + 1; };
    #####:  429:		if (state->hand[player][i] == duchy) { score = score + 3; };
    #####:  430:		if (state->hand[player][i] == province) { score = score + 6; };
    #####:  431:		if (state->hand[player][i] == great_hall) { score = score + 1; };
    #####:  432:		if (state->hand[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  433:	}
        -:  434:
        -:  435:	//score from discard
    #####:  436:	for (i = 0; i < state->discardCount[player]; i++)
        -:  437:	{
    #####:  438:		if (state->discard[player][i] == curse) { score = score - 1; };
    #####:  439:		if (state->discard[player][i] == estate) { score = score + 1; };
    #####:  440:		if (state->discard[player][i] == duchy) { score = score + 3; };
    #####:  441:		if (state->discard[player][i] == province) { score = score + 6; };
    #####:  442:		if (state->discard[player][i] == great_hall) { score = score + 1; };
    #####:  443:		if (state->discard[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  444:	}
        -:  445:
        -:  446:	//score from deck
    #####:  447:	for (i = 0; i < state->discardCount[player]; i++)
        -:  448:	{
    #####:  449:		if (state->deck[player][i] == curse) { score = score - 1; };
    #####:  450:		if (state->deck[player][i] == estate) { score = score + 1; };
    #####:  451:		if (state->deck[player][i] == duchy) { score = score + 3; };
    #####:  452:		if (state->deck[player][i] == province) { score = score + 6; };
    #####:  453:		if (state->deck[player][i] == great_hall) { score = score + 1; };
    #####:  454:		if (state->deck[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  455:	}
        -:  456:
    #####:  457:	return score;
        -:  458:}
        -:  459:
    #####:  460:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  461:	int i;
        -:  462:	int j;
        -:  463:	int highScore;
        -:  464:	int currentPlayer;
        -:  465:
        -:  466:	//get score for each player
    #####:  467:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  468:	{
        -:  469:		//set unused player scores to -9999
    #####:  470:		if (i >= state->numPlayers)
        -:  471:		{
    #####:  472:			players[i] = -9999;
        -:  473:		}
        -:  474:		else
        -:  475:		{
    #####:  476:			players[i] = scoreFor(i, state);
        -:  477:		}
        -:  478:	}
        -:  479:
        -:  480:	//find highest score
    #####:  481:	j = 0;
    #####:  482:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  483:	{
    #####:  484:		if (players[i] > players[j])
        -:  485:		{
    #####:  486:			j = i;
        -:  487:		}
        -:  488:	}
    #####:  489:	highScore = players[j];
        -:  490:
        -:  491:	//add 1 to players who had less turns
    #####:  492:	currentPlayer = whoseTurn(state);
    #####:  493:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  494:	{
    #####:  495:		if (players[i] == highScore && i > currentPlayer)
        -:  496:		{
    #####:  497:			players[i]++;
        -:  498:		}
        -:  499:	}
        -:  500:
        -:  501:	//find new highest score
    #####:  502:	j = 0;
    #####:  503:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  504:	{
    #####:  505:		if (players[i] > players[j])
        -:  506:		{
    #####:  507:			j = i;
        -:  508:		}
        -:  509:	}
    #####:  510:	highScore = players[j];
        -:  511:
        -:  512:	//set winners in array to 1 and rest to 0
    #####:  513:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  514:	{
    #####:  515:		if (players[i] == highScore)
        -:  516:		{
    #####:  517:			players[i] = 1;
        -:  518:		}
        -:  519:		else
        -:  520:		{
    #####:  521:			players[i] = 0;
        -:  522:		}
        -:  523:	}
        -:  524:
    #####:  525:	return 0;
        -:  526:}
        -:  527:
     1217:  528:int drawCard(int player, struct gameState *state)
        -:  529:{
        -:  530:	int count;
        -:  531:	int deckCounter;
     1217:  532:	if (state->deckCount[player] <= 0){//Deck is empty
        -:  533:
        -:  534:		//Step 1 Shuffle the discard pile back into a deck
        -:  535:		int i;
        -:  536:		//Move discard to deck
     1335:  537:		for (i = 0; i < state->discardCount[player]; i++){
     1251:  538:			state->deck[player][i] = state->discard[player][i];
     1251:  539:			state->discard[player][i] = -1;
        -:  540:		}
        -:  541:
       84:  542:		state->deckCount[player] = state->discardCount[player];
       84:  543:		state->discardCount[player] = 0;//Reset discard
        -:  544:
        -:  545:		//Shufffle the deck
       84:  546:		shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  547:
        -:  548:		if (DEBUG){//Debug statements
        -:  549:			printf("Deck count now: %d\n", state->deckCount[player]);
        -:  550:		}
        -:  551:
       84:  552:		state->discardCount[player] = 0;
        -:  553:
        -:  554:		//Step 2 Draw Card
       84:  555:		count = state->handCount[player];//Get current player's hand count
        -:  556:
        -:  557:		if (DEBUG){//Debug statements
        -:  558:			printf("Current hand count: %d\n", count);
        -:  559:		}
        -:  560:
       84:  561:		deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  562:
       84:  563:		if (deckCounter == 0)
    #####:  564:			return -1;
        -:  565:
       84:  566:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
       84:  567:		state->deckCount[player]--;
       84:  568:		state->handCount[player]++;//Increment hand count
        -:  569:	}
        -:  570:
        -:  571:	else{
     1133:  572:		int count = state->handCount[player];//Get current hand count for player
        -:  573:		int deckCounter;
        -:  574:		if (DEBUG){//Debug statements
        -:  575:			printf("Current hand count: %d\n", count);
        -:  576:		}
        -:  577:
     1133:  578:		deckCounter = state->deckCount[player];//Create holder for the deck count
     1133:  579:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
     1133:  580:		state->deckCount[player]--;
     1133:  581:		state->handCount[player]++;//Increment hand count
        -:  582:	}
        -:  583:
     1217:  584:	return 0;
        -:  585:}
        -:  586:
      861:  587:int getCost(int cardNumber)
        -:  588:{
      861:  589:	switch (cardNumber)
        -:  590:	{
        -:  591:	case curse:
       84:  592:		return 0;
        -:  593:	case estate:
       36:  594:		return 2;
        -:  595:	case duchy:
       46:  596:		return 5;
        -:  597:	case province:
       42:  598:		return 8;
        -:  599:	case copper:
       72:  600:		return 0;
        -:  601:	case silver:
       49:  602:		return 3;
        -:  603:	case gold:
       53:  604:		return 6;
        -:  605:	case adventurer:
       36:  606:		return 6;
        -:  607:	case council_room:
       55:  608:		return 5;
        -:  609:	case feast:
    #####:  610:		return 4;
        -:  611:	case gardens:
    #####:  612:		return 4;
        -:  613:	case mine:
       11:  614:		return 5;
        -:  615:	case remodel:
       25:  616:		return 4;
        -:  617:	case smithy:
       18:  618:		return 4;
        -:  619:	case village:
       23:  620:		return 3;
        -:  621:	case baron:
       51:  622:		return 4;
        -:  623:	case great_hall:
       40:  624:		return 3;
        -:  625:	case minion:
       46:  626:		return 5;
        -:  627:	case steward:
       61:  628:		return 3;
        -:  629:	case tribute:
    #####:  630:		return 5;
        -:  631:	case ambassador:
    #####:  632:		return 3;
        -:  633:	case cutpurse:
       30:  634:		return 4;
        -:  635:	case embargo:
    #####:  636:		return 2;
        -:  637:	case outpost:
       44:  638:		return 5;
        -:  639:	case salvager:
    #####:  640:		return 4;
        -:  641:	case sea_hag:
       22:  642:		return 4;
        -:  643:	case treasure_map:
       17:  644:		return 4;
        -:  645:	}
        -:  646:
    #####:  647:	return -1;
        -:  648:}
        -:  649:
    #####:  650:void playAdventurer(struct gameState *state, int currentPlayer)
        -:  651:// Reveal cards from deck until 2 Treasure cards are found.  Put those Treasure cards in the hand and discard the rest.
        -:  652:{
    #####:  653:	int drawntreasure = 0;
        -:  654:	int temphand[MAX_HAND];
        -:  655:	int cardDrawn;
    #####:  656:	int z = 0; // this is the counter for the temp hand
        -:  657:
    #####:  658:	while (drawntreasure < 2){
    #####:  659:		if (state->deckCount[currentPlayer] < 1){//if the deck is empty we need to shuffle discard and add to deck
    #####:  660:			shuffle(currentPlayer, state);
        -:  661:		}
    #####:  662:		drawCard(currentPlayer, state);
    #####:  663:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer] - 1];//top card of hand is most recently drawn card.
    #####:  664:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
    #####:  665:			drawntreasure++;
        -:  666:		else{
    #####:  667:			temphand[z] = cardDrawn;
    #####:  668:			state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####:  669:			z++;
        -:  670:		}
        -:  671:	}
    #####:  672:	while (z - 1 >= 0){
    #####:  673:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; // discard all cards in play that have been drawn
    #####:  674:		z = z - 1;
        -:  675:	}
    #####:  676:}
        -:  677:
        4:  678:int playRemodel(struct gameState *state, int currentPlayer, int choice1, int choice2, int handPos)
        -:  679://Trash a card in the hand, and gain a card costing up to $2 more than the trashed card
        -:  680:{
        -:  681:	int i;
        4:  682:	int j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  683:
        4:  684:	if ((getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2))
        -:  685:	{
    #####:  686:		return -1;
        -:  687:	}
        -:  688:
        4:  689:	gainCard(choice2, state, 0, currentPlayer);
        -:  690:
        -:  691:	//discard card from hand
        4:  692:	discardCard(handPos, currentPlayer, state, 0);
        -:  693:
        -:  694:	//discard trashed card
       13:  695:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  696:	{
       12:  697:		if (state->hand[currentPlayer][i] == j)
        -:  698:		{
        3:  699:			discardCard(i, currentPlayer, state, 0);
        3:  700:			break;
        -:  701:		}
        -:  702:	}
        -:  703:
        4:  704:	return 0;
        -:  705:}
        -:  706:
        1:  707:void playSmithy(struct gameState *state, int currentPlayer, int handPos)
        -:  708:// Draw 3 cards
        -:  709:{
        -:  710:	int i;
        4:  711:	for (i = 0; i < 3; i++)
        -:  712:	{
        3:  713:		drawCard(currentPlayer, state);
        -:  714:	}
        -:  715:
        -:  716:	//discard card from hand
        1:  717:	discardCard(handPos, currentPlayer, state, 0);
        1:  718:}
        -:  719:
        6:  720:void playBaron(struct gameState *state, int currentPlayer, int choice1, int handPos)
        -:  721://Add a buy.  OPTION:  Discard an Estate card and gain $4.  Otherwise, gain an Estate card.
        -:  722:{
        6:  723:	state->numBuys++;//Increase buys by 1!
        6:  724:	if (choice1 > 0){//Boolean true or going to discard an estate
        6:  725:		int p = 0;//Iterator for hand!
        6:  726:		int card_not_discarded = 1;//Flag for discard set!
       40:  727:		while (card_not_discarded){
       28:  728:			if (state->hand[currentPlayer][p] == estate){ //Found an estate card!
        3:  729:				state->coins += 4;//Add 4 coins to the amount of coins
        3:  730:				state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
        3:  731:				state->discardCount[currentPlayer]++;
       14:  732:				for (; p < state->handCount[currentPlayer]; p++){
       11:  733:					state->hand[currentPlayer][p] = state->hand[currentPlayer][p + 1];
        -:  734:				}
        3:  735:				state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
        3:  736:				state->handCount[currentPlayer]--;
        3:  737:				card_not_discarded = 0;//Exit the loop
        -:  738:			}
       25:  739:			else if (p > state->handCount[currentPlayer]){
        -:  740:				if (DEBUG) {
        -:  741:					printf("No estate cards in your hand, invalid choice\n");
        -:  742:					printf("Must gain an estate if there are any\n");
        -:  743:				}
        3:  744:				if (supplyCount(estate, state) > 0){
        1:  745:					gainCard(estate, state, 1, currentPlayer);
        1:  746:					state->supplyCount[estate]--;//Decrement estates
        1:  747:					if (supplyCount(estate, state) == 0){
    #####:  748:						isGameOver(state);
        -:  749:					}
        -:  750:				}
        3:  751:				card_not_discarded = 0;//Exit the loop
        -:  752:			}
        -:  753:
        -:  754:			else{
       22:  755:				p++;//Next card
        -:  756:			}
        -:  757:		}
        -:  758:	}
        -:  759:
        -:  760:	else{
    #####:  761:		if (supplyCount(estate, state) > 0){
    #####:  762:			gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  763:			state->supplyCount[estate]--;//Decrement Estates
    #####:  764:			if (supplyCount(estate, state) == 0){
    #####:  765:				isGameOver(state);
        -:  766:			}
        -:  767:		}
        -:  768:	}
        6:  769:}
        -:  770:
        2:  771:int playTreasureMap(struct gameState *state, int currentPlayer, int handPos)
        -:  772://Trashing two treasure map cards from the hand = four gold on top of the deck.
        -:  773:{
        -:  774:	int i;
        -:  775:	int index;
        -:  776:
        -:  777:	//search hand for another treasure_map
       12:  778:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  779:	{
       10:  780:		if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -:  781:		{
    #####:  782:			index = i;
    #####:  783:			break;
        -:  784:		}
        -:  785:	}
        2:  786:	if (index > -1)
        -:  787:	{
        -:  788:		//trash both treasure cards
        2:  789:		discardCard(handPos, currentPlayer, state, 1);
        2:  790:		discardCard(index, currentPlayer, state, 1);
        -:  791:
        -:  792:		//gain 4 Gold cards
       10:  793:		for (i = 0; i < 4; i++)
        -:  794:		{
        8:  795:			gainCard(gold, state, 1, currentPlayer);
        -:  796:		}
        -:  797:
        -:  798:		//return success
        2:  799:		return 1;
        -:  800:	}
        -:  801:
        -:  802:	//no second treasure_map found in hand
    #####:  803:	return -1;
        -:  804:}
        -:  805:
       55:  806:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  807:{
        -:  808:	int i;
        -:  809:	int j;
        -:  810:	int k;
        -:  811:	//int x;  //Unused after while loop removed from feast.
       55:  812:	int currentPlayer = whoseTurn(state);
       55:  813:	int nextPlayer = currentPlayer + 1;
        -:  814:	int temphand[MAX_HAND];
        -:  815:
       55:  816:	int tributeRevealedCards[2] = { -1, -1 };
        -:  817:
       55:  818:	if (nextPlayer > (state->numPlayers - 1)){
       21:  819:		nextPlayer = 0;
        -:  820:	}
        -:  821:
        -:  822:	//uses switch to select card and perform actions
       55:  823:	switch (card)
        -:  824:	{
        -:  825:	case adventurer:
        -:  826:
    #####:  827:		playAdventurer(state, currentPlayer);
    #####:  828:		return 0;
        -:  829:
        -:  830:	case council_room:
        -:  831:		//+4 Cards
       30:  832:		for (i = 0; i < 4; i++)
        -:  833:		{
       24:  834:			drawCard(currentPlayer, state);
        -:  835:		}
        -:  836:
        -:  837:		//+1 Buy
        6:  838:		state->numBuys++;
        -:  839:
        -:  840:		//Each other player draws a card
       22:  841:		for (i = 0; i < state->numPlayers; i++)
        -:  842:		{
       16:  843:			if (i != currentPlayer)
        -:  844:			{
       10:  845:				drawCard(i, state);
        -:  846:			}
        -:  847:		}
        -:  848:
        -:  849:		//put played card in played card pile
        6:  850:		discardCard(handPos, currentPlayer, state, 0);
        -:  851:
        6:  852:		return 0;
        -:  853:
        -:  854:	case feast:
        -:  855:		//gain card with cost up to 5
        -:  856:		//Backup hand
    #####:  857:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  858:			temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  859:			state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  860:		}
        -:  861:		//Backup hand
        -:  862:
        -:  863:		//Update Coins for Buy
    #####:  864:		updateCoins(currentPlayer, state, 5);
        -:  865://		x = 1;//Condition to loop on
        -:  866://		while (x == 1) {//Buy one card
    #####:  867:			if (supplyCount(choice1, state) <= 0){
        -:  868:				if (DEBUG)
        -:  869:					printf("None of that card left, sorry!\n");
        -:  870:
        -:  871:				if (DEBUG){
        -:  872:					printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  873:				}
        -:  874:			}
    #####:  875:			else if (state->coins < getCost(choice1)){
    #####:  876:				printf("That card is too expensive!\n");
        -:  877:
        -:  878:				if (DEBUG){
        -:  879:					printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  880:				}
        -:  881:			}
        -:  882:			else{
        -:  883:
        -:  884:				if (DEBUG){
        -:  885:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  886:				}
        -:  887:
    #####:  888:				gainCard(choice1, state, 0, currentPlayer);//Gain the card
        -:  889://				x = 0;//No more buying cards
        -:  890:
        -:  891:				if (DEBUG){
        -:  892:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  893:				}
        -:  894:
        -:  895:			}
        -:  896://		}
        -:  897:
        -:  898:		//Reset Hand
    #####:  899:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  900:			state->hand[currentPlayer][i] = temphand[i];
    #####:  901:			temphand[i] = -1;
        -:  902:		}
        -:  903:		//Reset Hand
        -:  904:
    #####:  905:		return 0;
        -:  906:
        -:  907:	case gardens:
    #####:  908:		return -1;
        -:  909:
        -:  910:	case mine:
    #####:  911:		j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  912:
    #####:  913:		if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  914:		{
    #####:  915:			return -1;
        -:  916:		}
        -:  917:
    #####:  918:		if (choice2 > treasure_map || choice2 < curse)
        -:  919:		{
    #####:  920:			return -1;
        -:  921:		}
        -:  922:
    #####:  923:		if ((getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2))
        -:  924:		{
    #####:  925:			return -1;
        -:  926:		}
        -:  927:
    #####:  928:		gainCard(choice2, state, 2, currentPlayer);
        -:  929:
        -:  930:		//discard card from hand
    #####:  931:		discardCard(handPos, currentPlayer, state, 0);
        -:  932:
        -:  933:		//discard trashed card
    #####:  934:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  935:		{
    #####:  936:			if (state->hand[currentPlayer][i] == j)
        -:  937:			{
    #####:  938:				discardCard(i, currentPlayer, state, 0);
    #####:  939:				break;
        -:  940:			}
        -:  941:		}
        -:  942:
    #####:  943:		return 0;
        -:  944:
        -:  945:	case remodel:
        -:  946:
        4:  947:		return playRemodel(state, currentPlayer, choice1, choice2, handPos);
        -:  948:
        -:  949:	case smithy:
        -:  950:
        1:  951:		playSmithy(state, currentPlayer, handPos);
        1:  952:		return 0;
        -:  953:
        -:  954:	case village:
        -:  955:		//+1 Card
        5:  956:		drawCard(currentPlayer, state);
        -:  957:
        -:  958:		//+2 Actions
        5:  959:		state->numActions = state->numActions + 2;
        -:  960:
        -:  961:		//discard played card from hand
        5:  962:		discardCard(handPos, currentPlayer, state, 0);
        5:  963:		return 0;
        -:  964:
        -:  965:	case baron:
        -:  966:
        6:  967:		playBaron(state, currentPlayer, choice1, handPos);
        6:  968:		return 0;
        -:  969:
        -:  970:	case great_hall:
        -:  971:		//+1 Card
       10:  972:		drawCard(currentPlayer, state);
        -:  973:
        -:  974:		//+1 Actions
       10:  975:		state->numActions++;
        -:  976:
        -:  977:		//discard card from hand
       10:  978:		discardCard(handPos, currentPlayer, state, 0);
       10:  979:		return 0;
        -:  980:
        -:  981:	case minion:
        -:  982:		//+1 action
    #####:  983:		state->numActions++;
        -:  984:
        -:  985:		//discard card from hand
    #####:  986:		discardCard(handPos, currentPlayer, state, 0);
        -:  987:
    #####:  988:		if (choice1)		//+2 coins
        -:  989:		{
    #####:  990:			state->coins = state->coins + 2;
        -:  991:		}
        -:  992:
    #####:  993:		else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  994:		{
        -:  995:			//discard hand
    #####:  996:			while (numHandCards(state) > 0)
        -:  997:			{
    #####:  998:				discardCard(handPos, currentPlayer, state, 0);
        -:  999:			}
        -: 1000:
        -: 1001:			//draw 4
    #####: 1002:			for (i = 0; i < 4; i++)
        -: 1003:			{
    #####: 1004:				drawCard(currentPlayer, state);
        -: 1005:			}
        -: 1006:
        -: 1007:			//other players discard hand and redraw if hand size > 4
    #####: 1008:			for (i = 0; i < state->numPlayers; i++)
        -: 1009:			{
    #####: 1010:				if (i != currentPlayer)
        -: 1011:				{
    #####: 1012:					if (state->handCount[i] > 4)
        -: 1013:					{
        -: 1014:						//discard hand
    #####: 1015:						while (state->handCount[i] > 0)
        -: 1016:						{
    #####: 1017:							discardCard(handPos, i, state, 0);
        -: 1018:						}
        -: 1019:
        -: 1020:						//draw 4
    #####: 1021:						for (j = 0; j < 4; j++)
        -: 1022:						{
    #####: 1023:							drawCard(i, state);
        -: 1024:						}
        -: 1025:					}
        -: 1026:				}
        -: 1027:			}
        -: 1028:
        -: 1029:		}
    #####: 1030:		return 0;
        -: 1031:
        -: 1032:	case steward:
       13: 1033:		if (choice1 == 1)
        -: 1034:		{
        -: 1035:			//+2 cards
    #####: 1036:			drawCard(currentPlayer, state);
    #####: 1037:			drawCard(currentPlayer, state);
        -: 1038:		}
       13: 1039:		else if (choice1 == 2)
        -: 1040:		{
        -: 1041:			//+2 coins
    #####: 1042:			state->coins = state->coins + 2;
        -: 1043:		}
        -: 1044:		else
        -: 1045:		{
        -: 1046:			//trash 2 cards in hand
       13: 1047:			discardCard(choice2, currentPlayer, state, 1);
       13: 1048:			discardCard(choice3, currentPlayer, state, 1);
        -: 1049:		}
        -: 1050:
        -: 1051:		//discard card from hand
       13: 1052:		discardCard(handPos, currentPlayer, state, 0);
       13: 1053:		return 0;
        -: 1054:
        -: 1055:	case tribute:
    #####: 1056:		if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####: 1057:			if (state->deckCount[nextPlayer] > 0){
    #####: 1058:				tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1059:				state->deckCount[nextPlayer]--;
        -: 1060:			}
    #####: 1061:			else if (state->discardCount[nextPlayer] > 0){
    #####: 1062:				tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer] - 1];
    #####: 1063:				state->discardCount[nextPlayer]--;
        -: 1064:			}
        -: 1065:			else{
        -: 1066:				//No Card to Reveal
        -: 1067:				if (DEBUG){
        -: 1068:					printf("No cards to reveal\n");
        -: 1069:				}
        -: 1070:			}
        -: 1071:		}
        -: 1072:
        -: 1073:		else{
    #####: 1074:			if (state->deckCount[nextPlayer] == 0){
    #####: 1075:				for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####: 1076:					state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1077:					state->deckCount[nextPlayer]++;
    #####: 1078:					state->discard[nextPlayer][i] = -1;
    #####: 1079:					state->discardCount[nextPlayer]--;
        -: 1080:				}
        -: 1081:
    #####: 1082:				shuffle(nextPlayer, state);//Shuffle the deck
        -: 1083:			}
    #####: 1084:			tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1085:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1086:			state->deckCount[nextPlayer]--;
    #####: 1087:			tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1088:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1089:			state->deckCount[nextPlayer]--;
        -: 1090:		}
        -: 1091:
    #####: 1092:		if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
    #####: 1093:			state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1094:			state->playedCardCount++;
    #####: 1095:			tributeRevealedCards[1] = -1;
        -: 1096:		}
        -: 1097:
    #####: 1098:		for (i = 0; i <= 2; i++){
    #####: 1099:			if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
    #####: 1100:				state->coins += 2;
        -: 1101:			}
        -: 1102:
    #####: 1103:			else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
    #####: 1104:				drawCard(currentPlayer, state);
    #####: 1105:				drawCard(currentPlayer, state);
        -: 1106:			}
        -: 1107:			else{//Action Card
    #####: 1108:				state->numActions = state->numActions + 2;
        -: 1109:			}
        -: 1110:		}
        -: 1111:
    #####: 1112:		return 0;
        -: 1113:
        -: 1114:	case ambassador:
    #####: 1115:		j = 0;		//used to check if player has enough cards to discard
        -: 1116:
    #####: 1117:		if (choice2 > 2 || choice2 < 0)
        -: 1118:		{
    #####: 1119:			return -1;
        -: 1120:		}
        -: 1121:
    #####: 1122:		if (choice1 == handPos)
        -: 1123:		{
    #####: 1124:			return -1;
        -: 1125:		}
        -: 1126:
    #####: 1127:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1128:		{
    #####: 1129:			if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1130:			{
    #####: 1131:				j++;
        -: 1132:			}
        -: 1133:		}
    #####: 1134:		if (j < choice2)
        -: 1135:		{
    #####: 1136:			return -1;
        -: 1137:		}
        -: 1138:
        -: 1139:		if (DEBUG)
        -: 1140:			printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1141:
        -: 1142:		//increase supply count for choosen card by amount being discarded
    #####: 1143:		state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1144:
        -: 1145:		//each other player gains a copy of revealed card
    #####: 1146:		for (i = 0; i < state->numPlayers; i++)
        -: 1147:		{
    #####: 1148:			if (i != currentPlayer)
        -: 1149:			{
    #####: 1150:				gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1151:			}
        -: 1152:		}
        -: 1153:
        -: 1154:		//discard played card from hand
    #####: 1155:		discardCard(handPos, currentPlayer, state, 0);
        -: 1156:
        -: 1157:		//trash copies of cards returned to supply
    #####: 1158:		for (j = 0; j < choice2; j++)
        -: 1159:		{
    #####: 1160:			for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1161:			{
    #####: 1162:				if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1163:				{
    #####: 1164:					discardCard(i, currentPlayer, state, 1);
    #####: 1165:					break;
        -: 1166:				}
        -: 1167:			}
        -: 1168:		}
        -: 1169:
    #####: 1170:		return 0;
        -: 1171:
        -: 1172:	case cutpurse:
        -: 1173:
        4: 1174:		updateCoins(currentPlayer, state, 2);
       20: 1175:		for (i = 0; i < state->numPlayers; i++)
        -: 1176:		{
       16: 1177:			if (i != currentPlayer)
        -: 1178:			{
       12: 1179:				for (j = 0; j < state->handCount[i]; j++)
        -: 1180:				{
    #####: 1181:					if (state->hand[i][j] == copper)
        -: 1182:					{
    #####: 1183:						discardCard(j, i, state, 0);
    #####: 1184:						break;
        -: 1185:					}
    #####: 1186:					if (j == state->handCount[i])
        -: 1187:					{
    #####: 1188:						for (k = 0; k < state->handCount[i]; k++)
        -: 1189:						{
        -: 1190:							if (DEBUG)
        -: 1191:								printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1192:						}
    #####: 1193:						break;
        -: 1194:					}
        -: 1195:				}
        -: 1196:
        -: 1197:			}
        -: 1198:
        -: 1199:		}
        -: 1200:
        -: 1201:		//discard played card from hand
        4: 1202:		discardCard(handPos, currentPlayer, state, 0);
        -: 1203:
        4: 1204:		return 0;
        -: 1205:
        -: 1206:
        -: 1207:	case embargo:
        -: 1208:		//+2 Coins
    #####: 1209:		state->coins = state->coins + 2;
        -: 1210:
        -: 1211:		//see if selected pile is in play
    #####: 1212:		if (state->supplyCount[choice1] == -1)
        -: 1213:		{
    #####: 1214:			return -1;
        -: 1215:		}
        -: 1216:
        -: 1217:		//add embargo token to selected supply pile
    #####: 1218:		state->embargoTokens[choice1]++;
        -: 1219:
        -: 1220:		//trash card
    #####: 1221:		discardCard(handPos, currentPlayer, state, 1);
    #####: 1222:		return 0;
        -: 1223:
        -: 1224:	case outpost:
        -: 1225:		//set outpost flag
        1: 1226:		state->outpostPlayed++;
        -: 1227:
        -: 1228:		//discard card
        1: 1229:		discardCard(handPos, currentPlayer, state, 0);
        1: 1230:		return 0;
        -: 1231:
        -: 1232:	case salvager:
        -: 1233:		//+1 buy
    #####: 1234:		state->numBuys++;
        -: 1235:
    #####: 1236:		if (choice1)
        -: 1237:		{
        -: 1238:			//gain coins equal to trashed card
    #####: 1239:			state->coins = state->coins + getCost(handCard(choice1, state));
        -: 1240:			//trash card
    #####: 1241:			discardCard(choice1, currentPlayer, state, 1);
        -: 1242:		}
        -: 1243:
        -: 1244:		//discard card
    #####: 1245:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1246:		return 0;
        -: 1247:
        -: 1248:	case sea_hag:
       15: 1249:		for (i = 0; i < state->numPlayers; i++){
       12: 1250:			if (i != currentPlayer){
        9: 1251:				state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
        9: 1252:				state->discardCount[i]++;
        9: 1253:				state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1254:			}
        -: 1255:		}
        3: 1256:		return 0;
        -: 1257:
        -: 1258:	case treasure_map:
        -: 1259:
        2: 1260:		return playTreasureMap(state, currentPlayer, handPos);
        -: 1261:	}
    #####: 1262:	return -1;
        -: 1263:}
        -: 1264:
       77: 1265:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1266:{
        -: 1267:
        -: 1268:	//if card is not trashed, added to Played pile 
       77: 1269:	if (trashFlag < 1)
        -: 1270:	{
        -: 1271:		//add card to played pile
       47: 1272:		state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
       47: 1273:		state->playedCardCount++;
        -: 1274:	}
        -: 1275:
        -: 1276:	//set played card to -1
       77: 1277:	state->hand[currentPlayer][handPos] = -1;
        -: 1278:
        -: 1279:	//remove card from player's hand
       77: 1280:	if (handPos == (state->handCount[currentPlayer] - 1)) 	//last card in hand array is played
        -: 1281:	{
        -: 1282:		//reduce number of cards in hand
        9: 1283:		state->handCount[currentPlayer]--;
        -: 1284:	}
       68: 1285:	else if (state->handCount[currentPlayer] == 1) //only one card in hand
        -: 1286:	{
        -: 1287:		//reduce number of cards in hand
    #####: 1288:		state->handCount[currentPlayer]--;
        -: 1289:	}
        -: 1290:	else
        -: 1291:	{
        -: 1292:		//replace discarded card with last card in hand
       68: 1293:		state->hand[currentPlayer][handPos] = state->hand[currentPlayer][(state->handCount[currentPlayer] - 1)];
        -: 1294:		//set last card to -1
       68: 1295:		state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1296:		//reduce number of cards in hand
       68: 1297:		state->handCount[currentPlayer]--;
        -: 1298:	}
        -: 1299:
       77: 1300:	return 0;
        -: 1301:}
        -: 1302:
      205: 1303:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1304:{
        -: 1305:	//Note: supplyPos is enum of choosen card
        -: 1306:
        -: 1307:	//check if supply pile is empty (0) or card is not used in game (-1)
      205: 1308:	if (supplyCount(supplyPos, state) < 1)
        -: 1309:	{
        1: 1310:		return -1;
        -: 1311:	}
        -: 1312:
        -: 1313:	//added card for [whoseTurn] current player:
        -: 1314:	// toFlag = 0 : add to discard
        -: 1315:	// toFlag = 1 : add to deck
        -: 1316:	// toFlag = 2 : add to hand
        -: 1317:
      204: 1318:	if (toFlag == 1)
        -: 1319:	{
        9: 1320:		state->deck[player][state->deckCount[player]] = supplyPos;
        9: 1321:		state->deckCount[player]++;
        -: 1322:	}
      195: 1323:	else if (toFlag == 2)
        -: 1324:	{
    #####: 1325:		state->hand[player][state->handCount[player]] = supplyPos;
    #####: 1326:		state->handCount[player]++;
        -: 1327:	}
        -: 1328:	else
        -: 1329:	{
      195: 1330:		state->discard[player][state->discardCount[player]] = supplyPos;
      195: 1331:		state->discardCount[player]++;
        -: 1332:	}
        -: 1333:
        -: 1334:	//decrease number in supply pile
      204: 1335:	state->supplyCount[supplyPos]--;
        -: 1336:
      204: 1337:	return 0;
        -: 1338:}
        -: 1339:
      292: 1340:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1341:{
        -: 1342:	int i;
        -: 1343:
        -: 1344:	//reset coin count
      292: 1345:	state->coins = 0;
        -: 1346:
        -: 1347:	//add coins for each Treasure card in player's hand
     1709: 1348:	for (i = 0; i < state->handCount[player]; i++)
        -: 1349:	{
     1417: 1350:		if (state->hand[player][i] == copper)
        -: 1351:		{
      618: 1352:			state->coins += 1;
        -: 1353:		}
      799: 1354:		else if (state->hand[player][i] == silver)
        -: 1355:		{
       87: 1356:			state->coins += 2;
        -: 1357:		}
      712: 1358:		else if (state->hand[player][i] == gold)
        -: 1359:		{
       26: 1360:			state->coins += 3;
        -: 1361:		}
        -: 1362:	}
        -: 1363:
        -: 1364:	//add bonus
      292: 1365:	state->coins += bonus;
        -: 1366:
      292: 1367:	return 0;
        -: 1368:}
        -: 1369:
        -: 1370:
        -: 1371://end of dominion.c
File 'dominion.c'
Lines executed:70.20% of 557
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
     4127:    8:int compare(const void* a, const void* b) {
     4127:    9:	if (*(int*)a > *(int*)b)
     1450:   10:		return 1;
     2677:   11:	if (*(int*)a < *(int*)b)
     1309:   12:		return -1;
     1368:   13:	return 0;
        -:   14:}
        -:   15:
        4:   16:struct gameState* newGame() {
        4:   17:	struct gameState* g = malloc(sizeof(struct gameState));
        4:   18:	return g;
        -:   19:}
        -:   20:
        6:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:	int k8, int k9, int k10) {
        6:   23:	int* k = malloc(10 * sizeof(int));
        6:   24:	k[0] = k1;
        6:   25:	k[1] = k2;
        6:   26:	k[2] = k3;
        6:   27:	k[3] = k4;
        6:   28:	k[4] = k5;
        6:   29:	k[5] = k6;
        6:   30:	k[6] = k7;
        6:   31:	k[7] = k8;
        6:   32:	k[8] = k9;
        6:   33:	k[9] = k10;
        6:   34:	return k;
        -:   35:}
        -:   36:
        6:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		struct gameState *state) {
        -:   39:
        -:   40:	int i;
        -:   41:	int j;
        -:   42:	int it;
        -:   43:	//set up random number generator
        6:   44:	SelectStream(1);
        6:   45:	PutSeed((long)randomSeed);
        -:   46:
        -:   47:	//check number of players
        6:   48:	if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:	{
    #####:   50:		return -1;
        -:   51:	}
        -:   52:
        -:   53:	//set number of players
        6:   54:	state->numPlayers = numPlayers;
        -:   55:
        -:   56:	//check selected kingdom cards are different
       29:   57:	for (i = 0; i < 10; i++)
        -:   58:	{
      276:   59:		for (j = 0; j < 10; j++)
        -:   60:		{
      253:   61:			if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:			{
        4:   63:				return -1;
        -:   64:			}
        -:   65:		}
        -:   66:	}
        -:   67:
        -:   68:
        -:   69:	//initialize supply
        -:   70:	///////////////////////////////
        -:   71:
        -:   72:	//set number of Curse cards
        2:   73:	if (numPlayers == 2)
        -:   74:	{
    #####:   75:		state->supplyCount[curse] = 10;
        -:   76:	}
        2:   77:	else if (numPlayers == 3)
        -:   78:	{
        1:   79:		state->supplyCount[curse] = 20;
        -:   80:	}
        -:   81:	else
        -:   82:	{
        1:   83:		state->supplyCount[curse] = 30;
        -:   84:	}
        -:   85:
        -:   86:	//set number of Victory cards
        2:   87:	if (numPlayers == 2)
        -:   88:	{
    #####:   89:		state->supplyCount[estate] = 8;
    #####:   90:		state->supplyCount[duchy] = 8;
    #####:   91:		state->supplyCount[province] = 8;
        -:   92:	}
        -:   93:	else
        -:   94:	{
        2:   95:		state->supplyCount[estate] = 12;
        2:   96:		state->supplyCount[duchy] = 12;
        2:   97:		state->supplyCount[province] = 12;
        -:   98:	}
        -:   99:
        -:  100:	//set number of Treasure cards
        2:  101:	state->supplyCount[copper] = 60 - (7 * numPlayers);
        2:  102:	state->supplyCount[silver] = 40;
        2:  103:	state->supplyCount[gold] = 30;
        -:  104:
        -:  105:	//set number of Kingdom cards
       42:  106:	for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:	{
      330:  108:		for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:		{
      310:  110:			if (kingdomCards[j] == i)
        -:  111:			{
        -:  112:				//check if card is a 'Victory' Kingdom card
       20:  113:				if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:				{
        2:  115:					if (numPlayers == 2){
    #####:  116:						state->supplyCount[i] = 8;
        -:  117:					}
        1:  118:					else{ state->supplyCount[i] = 12; }
        -:  119:				}
        -:  120:				else
        -:  121:				{
       19:  122:					state->supplyCount[i] = 10;
        -:  123:				}
       20:  124:				break;
        -:  125:			}
        -:  126:			else    //card is not in the set choosen for the game
        -:  127:			{
      290:  128:				state->supplyCount[i] = -1;
        -:  129:			}
        -:  130:		}
        -:  131:
        -:  132:	}
        -:  133:
        -:  134:	////////////////////////
        -:  135:	//supply intilization complete
        -:  136:
        -:  137:	//set player decks
        9:  138:	for (i = 0; i < numPlayers; i++)
        -:  139:	{
        7:  140:		state->deckCount[i] = 0;
       28:  141:		for (j = 0; j < 3; j++)
        -:  142:		{
       21:  143:			state->deck[i][j] = estate;
       21:  144:			state->deckCount[i]++;
        -:  145:		}
       56:  146:		for (j = 3; j < 10; j++)
        -:  147:		{
       49:  148:			state->deck[i][j] = copper;
       49:  149:			state->deckCount[i]++;
        -:  150:		}
        -:  151:	}
        -:  152:
        -:  153:	//shuffle player decks
        9:  154:	for (i = 0; i < numPlayers; i++)
        -:  155:	{
        7:  156:		if (shuffle(i, state) < 0)
        -:  157:		{
    #####:  158:			return -1;
        -:  159:		}
        -:  160:	}
        -:  161:
        -:  162:	//draw player hands
        9:  163:	for (i = 0; i < numPlayers; i++)
        -:  164:	{
        -:  165:		//initialize hand size to zero
        7:  166:		state->handCount[i] = 0;
        7:  167:		state->discardCount[i] = 0;
        -:  168:		//draw 5 cards
        -:  169:		// for (j = 0; j < 5; j++)
        -:  170:		//	{
        -:  171:		//	  drawCard(i, state);
        -:  172:		//	}
        -:  173:	}
        -:  174:
        -:  175:	//set embargo tokens to 0 for all supply piles
       56:  176:	for (i = 0; i <= treasure_map; i++)
        -:  177:	{
       54:  178:		state->embargoTokens[i] = 0;
        -:  179:	}
        -:  180:
        -:  181:	//initialize first player's turn
        2:  182:	state->outpostPlayed = 0;
        2:  183:	state->phase = 0;
        2:  184:	state->numActions = 1;
        2:  185:	state->numBuys = 1;
        2:  186:	state->playedCardCount = 0;
        2:  187:	state->whoseTurn = 0;
        2:  188:	state->handCount[state->whoseTurn] = 0;
        -:  189:	//int it; move to top
        -:  190:
        -:  191:	//Moved draw cards to here, only drawing at the start of a turn
       12:  192:	for (it = 0; it < 5; it++){
       10:  193:		drawCard(state->whoseTurn, state);
        -:  194:	}
        -:  195:
        2:  196:	updateCoins(state->whoseTurn, state, 0);
        -:  197:
        2:  198:	return 0;
        -:  199:}
        -:  200:
       89:  201:int shuffle(int player, struct gameState *state) {
        -:  202:
        -:  203:
        -:  204:	int newDeck[MAX_DECK];
       89:  205:	int newDeckPos = 0;
        -:  206:	int card;
        -:  207:	int i;
        -:  208:
       89:  209:	if (state->deckCount[player] < 1)
    #####:  210:		return -1;
       89:  211:	qsort((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
        -:  212:	/* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
     1947:  214:	while (state->deckCount[player] > 0) {
     1769:  215:		card = floor(Random() * state->deckCount[player]);
     1769:  216:		newDeck[newDeckPos] = state->deck[player][card];
     1769:  217:		newDeckPos++;
    12043:  218:		for (i = card; i < state->deckCount[player] - 1; i++) {
    10274:  219:			state->deck[player][i] = state->deck[player][i + 1];
        -:  220:		}
     1769:  221:		state->deckCount[player]--;
        -:  222:	}
     1858:  223:	for (i = 0; i < newDeckPos; i++) {
     1769:  224:		state->deck[player][i] = newDeck[i];
     1769:  225:		state->deckCount[player]++;
        -:  226:	}
        -:  227:
       89:  228:	return 0;
        -:  229:}
        -:  230:
     1558:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state)
        -:  232:{
        -:  233:	int card;
     1558:  234:	int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:	//check if it is the right phase
     1558:  237:	if (state->phase != 0)
        -:  238:	{
      254:  239:		return -1;
        -:  240:	}
        -:  241:
        -:  242:	//check if player has enough actions
     1304:  243:	if (state->numActions < 1)
        -:  244:	{
       43:  245:		return -1;
        -:  246:	}
        -:  247:
        -:  248:	//get card played
     1261:  249:	card = handCard(handPos, state);
        -:  250:
        -:  251:	//check if selected card is an action
     1261:  252:	if (card < adventurer || card > treasure_map)
        -:  253:	{
     1127:  254:		return -1;
        -:  255:	}
        -:  256:
        -:  257:	//play card
      134:  258:	if (cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0)
        -:  259:	{
       72:  260:		return -1;
        -:  261:	}
        -:  262:
        -:  263:	//reduce number of actions
       62:  264:	state->numActions--;
        -:  265:
        -:  266:	//update coins (Treasure cards may be added with card draws)
       62:  267:	updateCoins(state->whoseTurn, state, coin_bonus);
        -:  268:
       62:  269:	return 0;
        -:  270:}
        -:  271:
     1508:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:	int who;
        -:  274:	if (DEBUG){
        -:  275:		printf("Entering buyCard...\n");
        -:  276:	}
        -:  277:
        -:  278:	// I don't know what to do about the phase thing.
        -:  279:
     1508:  280:	who = state->whoseTurn;
        -:  281:
     1508:  282:	if (state->numBuys < 1){
        -:  283:		if (DEBUG)
        -:  284:			printf("You do not have any buys left\n");
      237:  285:		return -1;
        -:  286:	}
     1271:  287:	else if (supplyCount(supplyPos, state) < 1){
        -:  288:		if (DEBUG)
        -:  289:			printf("There are not any of that type of card left\n");
      505:  290:		return -1;
        -:  291:	}
      766:  292:	else if (state->coins < getCost(supplyPos)){
        -:  293:		if (DEBUG)
        -:  294:			printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
      505:  295:		return -1;
        -:  296:	}
        -:  297:	else {
      261:  298:		state->phase = 1;
        -:  299:		//state->supplyCount[supplyPos]--;
      261:  300:		gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  301:
      261:  302:		state->coins = (state->coins) - (getCost(supplyPos));
      261:  303:		state->numBuys--;
        -:  304:		if (DEBUG)
        -:  305:			printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  306:	}
        -:  307:
        -:  308:	//state->discard[who][state->discardCount[who]] = supplyPos;
        -:  309:	//state->discardCount[who]++;
        -:  310:
      261:  311:	return 0;
        -:  312:}
        -:  313:
    #####:  314:int numHandCards(struct gameState *state) {
    #####:  315:	return state->handCount[whoseTurn(state)];
        -:  316:}
        -:  317:
     1263:  318:int handCard(int handPos, struct gameState *state) {
     1263:  319:	int currentPlayer = whoseTurn(state);
     1263:  320:	return state->hand[currentPlayer][handPos];
        -:  321:}
        -:  322:
     1575:  323:int supplyCount(int card, struct gameState *state) {
     1575:  324:	return state->supplyCount[card];
        -:  325:}
        -:  326:
    #####:  327:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  328:	int i;
    #####:  329:	int count = 0;
        -:  330:
    #####:  331:	for (i = 0; i < state->deckCount[player]; i++)
        -:  332:	{
    #####:  333:		if (state->deck[player][i] == card) count++;
        -:  334:	}
        -:  335:
    #####:  336:	for (i = 0; i < state->handCount[player]; i++)
        -:  337:	{
    #####:  338:		if (state->hand[player][i] == card) count++;
        -:  339:	}
        -:  340:
    #####:  341:	for (i = 0; i < state->discardCount[player]; i++)
        -:  342:	{
    #####:  343:		if (state->discard[player][i] == card) count++;
        -:  344:	}
        -:  345:
    #####:  346:	return count;
        -:  347:}
        -:  348:
     1709:  349:int whoseTurn(struct gameState *state) {
     1709:  350:	return state->whoseTurn;
        -:  351:}
        -:  352:
      312:  353:int endTurn(struct gameState *state) {
        -:  354:	int k;
        -:  355:	int i;
      312:  356:	int currentPlayer = whoseTurn(state);
        -:  357:
        -:  358:	//Discard hand
     1859:  359:	for (i = 0; i < state->handCount[currentPlayer]; i++){
     1547:  360:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
     1547:  361:		state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  362:	}
      312:  363:	state->handCount[currentPlayer] = 0;//Reset hand count
        -:  364:
        -:  365:	//Code for determining the player
      312:  366:	if (currentPlayer < (state->numPlayers - 1)){
      222:  367:		state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  368:	}
        -:  369:	else{
       90:  370:		state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  371:	}
        -:  372:
      312:  373:	state->outpostPlayed = 0;
      312:  374:	state->phase = 0;
      312:  375:	state->numActions = 1;
      312:  376:	state->coins = 0;
      312:  377:	state->numBuys = 1;
      312:  378:	state->playedCardCount = 0;
      312:  379:	state->handCount[state->whoseTurn] = 0;
        -:  380:
        -:  381:	//int k; move to top
        -:  382:	//Next player draws hand
     1872:  383:	for (k = 0; k < 5; k++){
     1560:  384:		drawCard(state->whoseTurn, state);//Draw a card
        -:  385:	}
        -:  386:
        -:  387:	//Update money
      312:  388:	updateCoins(state->whoseTurn, state, 0);
        -:  389:
      312:  390:	return 0;
        -:  391:}
        -:  392:
     4607:  393:int isGameOver(struct gameState *state) {
        -:  394:	int i;
        -:  395:	int j;
        -:  396:
        -:  397:	//if stack of Province cards is empty, the game ends
     4607:  398:	if (state->supplyCount[province] == 0)
        -:  399:	{
    #####:  400:		return 1;
        -:  401:	}
        -:  402:
        -:  403:	//if three supply pile are at 0, the game ends
     4607:  404:	j = 0;
   119782:  405:	for (i = 0; i < 25; i++)
        -:  406:	{
   115175:  407:		if (state->supplyCount[i] == 0)
        -:  408:		{
     3259:  409:			j++;
        -:  410:		}
        -:  411:	}
     4607:  412:	if (j >= 3)
        -:  413:	{
        2:  414:		return 1;
        -:  415:	}
        -:  416:
     4605:  417:	return 0;
        -:  418:}
        -:  419:
    #####:  420:int scoreFor(int player, struct gameState *state) {
        -:  421:
        -:  422:	int i;
    #####:  423:	int score = 0;
        -:  424:	//score from hand
    #####:  425:	for (i = 0; i < state->handCount[player]; i++)
        -:  426:	{
    #####:  427:		if (state->hand[player][i] == curse) { score = score - 1; };
    #####:  428:		if (state->hand[player][i] == estate) { score = score + 1; };
    #####:  429:		if (state->hand[player][i] == duchy) { score = score + 3; };
    #####:  430:		if (state->hand[player][i] == province) { score = score + 6; };
    #####:  431:		if (state->hand[player][i] == great_hall) { score = score + 1; };
    #####:  432:		if (state->hand[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  433:	}
        -:  434:
        -:  435:	//score from discard
    #####:  436:	for (i = 0; i < state->discardCount[player]; i++)
        -:  437:	{
    #####:  438:		if (state->discard[player][i] == curse) { score = score - 1; };
    #####:  439:		if (state->discard[player][i] == estate) { score = score + 1; };
    #####:  440:		if (state->discard[player][i] == duchy) { score = score + 3; };
    #####:  441:		if (state->discard[player][i] == province) { score = score + 6; };
    #####:  442:		if (state->discard[player][i] == great_hall) { score = score + 1; };
    #####:  443:		if (state->discard[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  444:	}
        -:  445:
        -:  446:	//score from deck
    #####:  447:	for (i = 0; i < state->discardCount[player]; i++)
        -:  448:	{
    #####:  449:		if (state->deck[player][i] == curse) { score = score - 1; };
    #####:  450:		if (state->deck[player][i] == estate) { score = score + 1; };
    #####:  451:		if (state->deck[player][i] == duchy) { score = score + 3; };
    #####:  452:		if (state->deck[player][i] == province) { score = score + 6; };
    #####:  453:		if (state->deck[player][i] == great_hall) { score = score + 1; };
    #####:  454:		if (state->deck[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  455:	}
        -:  456:
    #####:  457:	return score;
        -:  458:}
        -:  459:
    #####:  460:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  461:	int i;
        -:  462:	int j;
        -:  463:	int highScore;
        -:  464:	int currentPlayer;
        -:  465:
        -:  466:	//get score for each player
    #####:  467:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  468:	{
        -:  469:		//set unused player scores to -9999
    #####:  470:		if (i >= state->numPlayers)
        -:  471:		{
    #####:  472:			players[i] = -9999;
        -:  473:		}
        -:  474:		else
        -:  475:		{
    #####:  476:			players[i] = scoreFor(i, state);
        -:  477:		}
        -:  478:	}
        -:  479:
        -:  480:	//find highest score
    #####:  481:	j = 0;
    #####:  482:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  483:	{
    #####:  484:		if (players[i] > players[j])
        -:  485:		{
    #####:  486:			j = i;
        -:  487:		}
        -:  488:	}
    #####:  489:	highScore = players[j];
        -:  490:
        -:  491:	//add 1 to players who had less turns
    #####:  492:	currentPlayer = whoseTurn(state);
    #####:  493:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  494:	{
    #####:  495:		if (players[i] == highScore && i > currentPlayer)
        -:  496:		{
    #####:  497:			players[i]++;
        -:  498:		}
        -:  499:	}
        -:  500:
        -:  501:	//find new highest score
    #####:  502:	j = 0;
    #####:  503:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  504:	{
    #####:  505:		if (players[i] > players[j])
        -:  506:		{
    #####:  507:			j = i;
        -:  508:		}
        -:  509:	}
    #####:  510:	highScore = players[j];
        -:  511:
        -:  512:	//set winners in array to 1 and rest to 0
    #####:  513:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  514:	{
    #####:  515:		if (players[i] == highScore)
        -:  516:		{
    #####:  517:			players[i] = 1;
        -:  518:		}
        -:  519:		else
        -:  520:		{
    #####:  521:			players[i] = 0;
        -:  522:		}
        -:  523:	}
        -:  524:
    #####:  525:	return 0;
        -:  526:}
        -:  527:
     1623:  528:int drawCard(int player, struct gameState *state)
        -:  529:{
        -:  530:	int count;
        -:  531:	int deckCounter;
     1623:  532:	if (state->deckCount[player] <= 0){//Deck is empty
        -:  533:
        -:  534:		//Step 1 Shuffle the discard pile back into a deck
        -:  535:		int i;
        -:  536:		//Move discard to deck
     1765:  537:		for (i = 0; i < state->discardCount[player]; i++){
     1684:  538:			state->deck[player][i] = state->discard[player][i];
     1684:  539:			state->discard[player][i] = -1;
        -:  540:		}
        -:  541:
       81:  542:		state->deckCount[player] = state->discardCount[player];
       81:  543:		state->discardCount[player] = 0;//Reset discard
        -:  544:
        -:  545:		//Shufffle the deck
       81:  546:		shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  547:
        -:  548:		if (DEBUG){//Debug statements
        -:  549:			printf("Deck count now: %d\n", state->deckCount[player]);
        -:  550:		}
        -:  551:
       81:  552:		state->discardCount[player] = 0;
        -:  553:
        -:  554:		//Step 2 Draw Card
       81:  555:		count = state->handCount[player];//Get current player's hand count
        -:  556:
        -:  557:		if (DEBUG){//Debug statements
        -:  558:			printf("Current hand count: %d\n", count);
        -:  559:		}
        -:  560:
       81:  561:		deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  562:
       81:  563:		if (deckCounter == 0)
    #####:  564:			return -1;
        -:  565:
       81:  566:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
       81:  567:		state->deckCount[player]--;
       81:  568:		state->handCount[player]++;//Increment hand count
        -:  569:	}
        -:  570:
        -:  571:	else{
     1542:  572:		int count = state->handCount[player];//Get current hand count for player
        -:  573:		int deckCounter;
        -:  574:		if (DEBUG){//Debug statements
        -:  575:			printf("Current hand count: %d\n", count);
        -:  576:		}
        -:  577:
     1542:  578:		deckCounter = state->deckCount[player];//Create holder for the deck count
     1542:  579:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
     1542:  580:		state->deckCount[player]--;
     1542:  581:		state->handCount[player]++;//Increment hand count
        -:  582:	}
        -:  583:
     1623:  584:	return 0;
        -:  585:}
        -:  586:
     1036:  587:int getCost(int cardNumber)
        -:  588:{
     1036:  589:	switch (cardNumber)
        -:  590:	{
        -:  591:	case curse:
       99:  592:		return 0;
        -:  593:	case estate:
       37:  594:		return 2;
        -:  595:	case duchy:
       50:  596:		return 5;
        -:  597:	case province:
       58:  598:		return 8;
        -:  599:	case copper:
       94:  600:		return 0;
        -:  601:	case silver:
       80:  602:		return 3;
        -:  603:	case gold:
       47:  604:		return 6;
        -:  605:	case adventurer:
        1:  606:		return 6;
        -:  607:	case council_room:
       59:  608:		return 5;
        -:  609:	case feast:
       33:  610:		return 4;
        -:  611:	case gardens:
    #####:  612:		return 4;
        -:  613:	case mine:
       22:  614:		return 5;
        -:  615:	case remodel:
       36:  616:		return 4;
        -:  617:	case smithy:
       59:  618:		return 4;
        -:  619:	case village:
       26:  620:		return 3;
        -:  621:	case baron:
       55:  622:		return 4;
        -:  623:	case great_hall:
       38:  624:		return 3;
        -:  625:	case minion:
    #####:  626:		return 5;
        -:  627:	case steward:
    #####:  628:		return 3;
        -:  629:	case tribute:
       53:  630:		return 5;
        -:  631:	case ambassador:
       63:  632:		return 3;
        -:  633:	case cutpurse:
       28:  634:		return 4;
        -:  635:	case embargo:
    #####:  636:		return 2;
        -:  637:	case outpost:
       17:  638:		return 5;
        -:  639:	case salvager:
       24:  640:		return 4;
        -:  641:	case sea_hag:
       28:  642:		return 4;
        -:  643:	case treasure_map:
       29:  644:		return 4;
        -:  645:	}
        -:  646:
    #####:  647:	return -1;
        -:  648:}
        -:  649:
    #####:  650:void playAdventurer(struct gameState *state, int currentPlayer)
        -:  651:// Reveal cards from deck until 2 Treasure cards are found.  Put those Treasure cards in the hand and discard the rest.
        -:  652:{
    #####:  653:	int drawntreasure = 0;
        -:  654:	int temphand[MAX_HAND];
        -:  655:	int cardDrawn;
    #####:  656:	int z = 0; // this is the counter for the temp hand
        -:  657:
    #####:  658:	while (drawntreasure < 2){
    #####:  659:		if (state->deckCount[currentPlayer] < 1){//if the deck is empty we need to shuffle discard and add to deck
    #####:  660:			shuffle(currentPlayer, state);
        -:  661:		}
    #####:  662:		drawCard(currentPlayer, state);
    #####:  663:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer] - 1];//top card of hand is most recently drawn card.
    #####:  664:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
    #####:  665:			drawntreasure++;
        -:  666:		else{
    #####:  667:			temphand[z] = cardDrawn;
    #####:  668:			state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####:  669:			z++;
        -:  670:		}
        -:  671:	}
    #####:  672:	while (z - 1 >= 0){
    #####:  673:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; // discard all cards in play that have been drawn
    #####:  674:		z = z - 1;
        -:  675:	}
    #####:  676:}
        -:  677:
        3:  678:int playRemodel(struct gameState *state, int currentPlayer, int choice1, int choice2, int handPos)
        -:  679://Trash a card in the hand, and gain a card costing up to $2 more than the trashed card
        -:  680:{
        -:  681:	int i;
        3:  682:	int j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  683:
        3:  684:	if ((getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2))
        -:  685:	{
    #####:  686:		return -1;
        -:  687:	}
        -:  688:
        3:  689:	gainCard(choice2, state, 0, currentPlayer);
        -:  690:
        -:  691:	//discard card from hand
        3:  692:	discardCard(handPos, currentPlayer, state, 0);
        -:  693:
        -:  694:	//discard trashed card
       10:  695:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  696:	{
        9:  697:		if (state->hand[currentPlayer][i] == j)
        -:  698:		{
        2:  699:			discardCard(i, currentPlayer, state, 0);
        2:  700:			break;
        -:  701:		}
        -:  702:	}
        -:  703:
        3:  704:	return 0;
        -:  705:}
        -:  706:
        4:  707:void playSmithy(struct gameState *state, int currentPlayer, int handPos)
        -:  708:// Draw 3 cards
        -:  709:{
        -:  710:	int i;
       16:  711:	for (i = 0; i < 3; i++)
        -:  712:	{
       12:  713:		drawCard(currentPlayer, state);
        -:  714:	}
        -:  715:
        -:  716:	//discard card from hand
        4:  717:	discardCard(handPos, currentPlayer, state, 0);
        4:  718:}
        -:  719:
       15:  720:void playBaron(struct gameState *state, int currentPlayer, int choice1, int handPos)
        -:  721://Add a buy.  OPTION:  Discard an Estate card and gain $4.  Otherwise, gain an Estate card.
        -:  722:{
       15:  723:	state->numBuys++;//Increase buys by 1!
       15:  724:	if (choice1 > 0){//Boolean true or going to discard an estate
       14:  725:		int p = 0;//Iterator for hand!
       14:  726:		int card_not_discarded = 1;//Flag for discard set!
       92:  727:		while (card_not_discarded){
       64:  728:			if (state->hand[currentPlayer][p] == estate){ //Found an estate card!
        8:  729:				state->coins += 4;//Add 4 coins to the amount of coins
        8:  730:				state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
        8:  731:				state->discardCount[currentPlayer]++;
       34:  732:				for (; p < state->handCount[currentPlayer]; p++){
       26:  733:					state->hand[currentPlayer][p] = state->hand[currentPlayer][p + 1];
        -:  734:				}
        8:  735:				state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
        8:  736:				state->handCount[currentPlayer]--;
        8:  737:				card_not_discarded = 0;//Exit the loop
        -:  738:			}
       56:  739:			else if (p > state->handCount[currentPlayer]){
        -:  740:				if (DEBUG) {
        -:  741:					printf("No estate cards in your hand, invalid choice\n");
        -:  742:					printf("Must gain an estate if there are any\n");
        -:  743:				}
        6:  744:				if (supplyCount(estate, state) > 0){
        3:  745:					gainCard(estate, state, 1, currentPlayer);
        3:  746:					state->supplyCount[estate]--;//Decrement estates
        3:  747:					if (supplyCount(estate, state) == 0){
        1:  748:						isGameOver(state);
        -:  749:					}
        -:  750:				}
        6:  751:				card_not_discarded = 0;//Exit the loop
        -:  752:			}
        -:  753:
        -:  754:			else{
       50:  755:				p++;//Next card
        -:  756:			}
        -:  757:		}
        -:  758:	}
        -:  759:
        -:  760:	else{
        1:  761:		if (supplyCount(estate, state) > 0){
    #####:  762:			gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  763:			state->supplyCount[estate]--;//Decrement Estates
    #####:  764:			if (supplyCount(estate, state) == 0){
    #####:  765:				isGameOver(state);
        -:  766:			}
        -:  767:		}
        -:  768:	}
       15:  769:}
        -:  770:
        5:  771:int playTreasureMap(struct gameState *state, int currentPlayer, int handPos)
        -:  772://Trashing two treasure map cards from the hand = four gold on top of the deck.
        -:  773:{
        -:  774:	int i;
        -:  775:	int index;
        -:  776:
        -:  777:	//search hand for another treasure_map
       30:  778:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  779:	{
       25:  780:		if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -:  781:		{
    #####:  782:			index = i;
    #####:  783:			break;
        -:  784:		}
        -:  785:	}
        5:  786:	if (index > -1)
        -:  787:	{
        -:  788:		//trash both treasure cards
        5:  789:		discardCard(handPos, currentPlayer, state, 1);
        5:  790:		discardCard(index, currentPlayer, state, 1);
        -:  791:
        -:  792:		//gain 4 Gold cards
       25:  793:		for (i = 0; i < 4; i++)
        -:  794:		{
       20:  795:			gainCard(gold, state, 1, currentPlayer);
        -:  796:		}
        -:  797:
        -:  798:		//return success
        5:  799:		return 1;
        -:  800:	}
        -:  801:
        -:  802:	//no second treasure_map found in hand
    #####:  803:	return -1;
        -:  804:}
        -:  805:
      134:  806:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  807:{
        -:  808:	int i;
        -:  809:	int j;
        -:  810:	int k;
        -:  811:	//int x;  //Unused after while loop removed from feast.
      134:  812:	int currentPlayer = whoseTurn(state);
      134:  813:	int nextPlayer = currentPlayer + 1;
        -:  814:	int temphand[MAX_HAND];
        -:  815:
      134:  816:	int tributeRevealedCards[2] = { -1, -1 };
        -:  817:
      134:  818:	if (nextPlayer > (state->numPlayers - 1)){
       45:  819:		nextPlayer = 0;
        -:  820:	}
        -:  821:
        -:  822:	//uses switch to select card and perform actions
      134:  823:	switch (card)
        -:  824:	{
        -:  825:	case adventurer:
        -:  826:
    #####:  827:		playAdventurer(state, currentPlayer);
    #####:  828:		return 0;
        -:  829:
        -:  830:	case council_room:
        -:  831:		//+4 Cards
       20:  832:		for (i = 0; i < 4; i++)
        -:  833:		{
       16:  834:			drawCard(currentPlayer, state);
        -:  835:		}
        -:  836:
        -:  837:		//+1 Buy
        4:  838:		state->numBuys++;
        -:  839:
        -:  840:		//Each other player draws a card
       17:  841:		for (i = 0; i < state->numPlayers; i++)
        -:  842:		{
       13:  843:			if (i != currentPlayer)
        -:  844:			{
        9:  845:				drawCard(i, state);
        -:  846:			}
        -:  847:		}
        -:  848:
        -:  849:		//put played card in played card pile
        4:  850:		discardCard(handPos, currentPlayer, state, 0);
        -:  851:
        4:  852:		return 0;
        -:  853:
        -:  854:	case feast:
        -:  855:		//gain card with cost up to 5
        -:  856:		//Backup hand
       21:  857:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
       18:  858:			temphand[i] = state->hand[currentPlayer][i];//Backup card
       18:  859:			state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  860:		}
        -:  861:		//Backup hand
        -:  862:
        -:  863:		//Update Coins for Buy
        3:  864:		updateCoins(currentPlayer, state, 5);
        -:  865://		x = 1;//Condition to loop on
        -:  866://		while (x == 1) {//Buy one card
        3:  867:			if (supplyCount(choice1, state) <= 0){
        -:  868:				if (DEBUG)
        -:  869:					printf("None of that card left, sorry!\n");
        -:  870:
        -:  871:				if (DEBUG){
        -:  872:					printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  873:				}
        -:  874:			}
        1:  875:			else if (state->coins < getCost(choice1)){
    #####:  876:				printf("That card is too expensive!\n");
        -:  877:
        -:  878:				if (DEBUG){
        -:  879:					printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  880:				}
        -:  881:			}
        -:  882:			else{
        -:  883:
        -:  884:				if (DEBUG){
        -:  885:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  886:				}
        -:  887:
        1:  888:				gainCard(choice1, state, 0, currentPlayer);//Gain the card
        -:  889://				x = 0;//No more buying cards
        -:  890:
        -:  891:				if (DEBUG){
        -:  892:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  893:				}
        -:  894:
        -:  895:			}
        -:  896://		}
        -:  897:
        -:  898:		//Reset Hand
       21:  899:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
       18:  900:			state->hand[currentPlayer][i] = temphand[i];
       18:  901:			temphand[i] = -1;
        -:  902:		}
        -:  903:		//Reset Hand
        -:  904:
        3:  905:		return 0;
        -:  906:
        -:  907:	case gardens:
    #####:  908:		return -1;
        -:  909:
        -:  910:	case mine:
    #####:  911:		j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  912:
    #####:  913:		if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  914:		{
    #####:  915:			return -1;
        -:  916:		}
        -:  917:
    #####:  918:		if (choice2 > treasure_map || choice2 < curse)
        -:  919:		{
    #####:  920:			return -1;
        -:  921:		}
        -:  922:
    #####:  923:		if ((getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2))
        -:  924:		{
    #####:  925:			return -1;
        -:  926:		}
        -:  927:
    #####:  928:		gainCard(choice2, state, 2, currentPlayer);
        -:  929:
        -:  930:		//discard card from hand
    #####:  931:		discardCard(handPos, currentPlayer, state, 0);
        -:  932:
        -:  933:		//discard trashed card
    #####:  934:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  935:		{
    #####:  936:			if (state->hand[currentPlayer][i] == j)
        -:  937:			{
    #####:  938:				discardCard(i, currentPlayer, state, 0);
    #####:  939:				break;
        -:  940:			}
        -:  941:		}
        -:  942:
    #####:  943:		return 0;
        -:  944:
        -:  945:	case remodel:
        -:  946:
        3:  947:		return playRemodel(state, currentPlayer, choice1, choice2, handPos);
        -:  948:
        -:  949:	case smithy:
        -:  950:
        4:  951:		playSmithy(state, currentPlayer, handPos);
        4:  952:		return 0;
        -:  953:
        -:  954:	case village:
        -:  955:		//+1 Card
        6:  956:		drawCard(currentPlayer, state);
        -:  957:
        -:  958:		//+2 Actions
        6:  959:		state->numActions = state->numActions + 2;
        -:  960:
        -:  961:		//discard played card from hand
        6:  962:		discardCard(handPos, currentPlayer, state, 0);
        6:  963:		return 0;
        -:  964:
        -:  965:	case baron:
        -:  966:
       15:  967:		playBaron(state, currentPlayer, choice1, handPos);
       15:  968:		return 0;
        -:  969:
        -:  970:	case great_hall:
        -:  971:		//+1 Card
        8:  972:		drawCard(currentPlayer, state);
        -:  973:
        -:  974:		//+1 Actions
        8:  975:		state->numActions++;
        -:  976:
        -:  977:		//discard card from hand
        8:  978:		discardCard(handPos, currentPlayer, state, 0);
        8:  979:		return 0;
        -:  980:
        -:  981:	case minion:
        -:  982:		//+1 action
    #####:  983:		state->numActions++;
        -:  984:
        -:  985:		//discard card from hand
    #####:  986:		discardCard(handPos, currentPlayer, state, 0);
        -:  987:
    #####:  988:		if (choice1)		//+2 coins
        -:  989:		{
    #####:  990:			state->coins = state->coins + 2;
        -:  991:		}
        -:  992:
    #####:  993:		else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  994:		{
        -:  995:			//discard hand
    #####:  996:			while (numHandCards(state) > 0)
        -:  997:			{
    #####:  998:				discardCard(handPos, currentPlayer, state, 0);
        -:  999:			}
        -: 1000:
        -: 1001:			//draw 4
    #####: 1002:			for (i = 0; i < 4; i++)
        -: 1003:			{
    #####: 1004:				drawCard(currentPlayer, state);
        -: 1005:			}
        -: 1006:
        -: 1007:			//other players discard hand and redraw if hand size > 4
    #####: 1008:			for (i = 0; i < state->numPlayers; i++)
        -: 1009:			{
    #####: 1010:				if (i != currentPlayer)
        -: 1011:				{
    #####: 1012:					if (state->handCount[i] > 4)
        -: 1013:					{
        -: 1014:						//discard hand
    #####: 1015:						while (state->handCount[i] > 0)
        -: 1016:						{
    #####: 1017:							discardCard(handPos, i, state, 0);
        -: 1018:						}
        -: 1019:
        -: 1020:						//draw 4
    #####: 1021:						for (j = 0; j < 4; j++)
        -: 1022:						{
    #####: 1023:							drawCard(i, state);
        -: 1024:						}
        -: 1025:					}
        -: 1026:				}
        -: 1027:			}
        -: 1028:
        -: 1029:		}
    #####: 1030:		return 0;
        -: 1031:
        -: 1032:	case steward:
    #####: 1033:		if (choice1 == 1)
        -: 1034:		{
        -: 1035:			//+2 cards
    #####: 1036:			drawCard(currentPlayer, state);
    #####: 1037:			drawCard(currentPlayer, state);
        -: 1038:		}
    #####: 1039:		else if (choice1 == 2)
        -: 1040:		{
        -: 1041:			//+2 coins
    #####: 1042:			state->coins = state->coins + 2;
        -: 1043:		}
        -: 1044:		else
        -: 1045:		{
        -: 1046:			//trash 2 cards in hand
    #####: 1047:			discardCard(choice2, currentPlayer, state, 1);
    #####: 1048:			discardCard(choice3, currentPlayer, state, 1);
        -: 1049:		}
        -: 1050:
        -: 1051:		//discard card from hand
    #####: 1052:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1053:		return 0;
        -: 1054:
        -: 1055:	case tribute:
        4: 1056:		if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####: 1057:			if (state->deckCount[nextPlayer] > 0){
    #####: 1058:				tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1059:				state->deckCount[nextPlayer]--;
        -: 1060:			}
    #####: 1061:			else if (state->discardCount[nextPlayer] > 0){
    #####: 1062:				tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer] - 1];
    #####: 1063:				state->discardCount[nextPlayer]--;
        -: 1064:			}
        -: 1065:			else{
        -: 1066:				//No Card to Reveal
        -: 1067:				if (DEBUG){
        -: 1068:					printf("No cards to reveal\n");
        -: 1069:				}
        -: 1070:			}
        -: 1071:		}
        -: 1072:
        -: 1073:		else{
        4: 1074:			if (state->deckCount[nextPlayer] == 0){
       16: 1075:				for (i = 0; i < state->discardCount[nextPlayer]; i++){
       15: 1076:					state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
       15: 1077:					state->deckCount[nextPlayer]++;
       15: 1078:					state->discard[nextPlayer][i] = -1;
       15: 1079:					state->discardCount[nextPlayer]--;
        -: 1080:				}
        -: 1081:
        1: 1082:				shuffle(nextPlayer, state);//Shuffle the deck
        -: 1083:			}
        4: 1084:			tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
        4: 1085:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
        4: 1086:			state->deckCount[nextPlayer]--;
        4: 1087:			tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
        4: 1088:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
        4: 1089:			state->deckCount[nextPlayer]--;
        -: 1090:		}
        -: 1091:
        4: 1092:		if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
        1: 1093:			state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
        1: 1094:			state->playedCardCount++;
        1: 1095:			tributeRevealedCards[1] = -1;
        -: 1096:		}
        -: 1097:
       16: 1098:		for (i = 0; i <= 2; i++){
       12: 1099:			if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
        7: 1100:				state->coins += 2;
        -: 1101:			}
        -: 1102:
        5: 1103:			else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
        1: 1104:				drawCard(currentPlayer, state);
        1: 1105:				drawCard(currentPlayer, state);
        -: 1106:			}
        -: 1107:			else{//Action Card
        4: 1108:				state->numActions = state->numActions + 2;
        -: 1109:			}
        -: 1110:		}
        -: 1111:
        4: 1112:		return 0;
        -: 1113:
        -: 1114:	case ambassador:
       73: 1115:		j = 0;		//used to check if player has enough cards to discard
        -: 1116:
       73: 1117:		if (choice2 > 2 || choice2 < 0)
        -: 1118:		{
       70: 1119:			return -1;
        -: 1120:		}
        -: 1121:
        3: 1122:		if (choice1 == handPos)
        -: 1123:		{
    #####: 1124:			return -1;
        -: 1125:		}
        -: 1126:
       18: 1127:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1128:		{
       15: 1129:			if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1130:			{
        2: 1131:				j++;
        -: 1132:			}
        -: 1133:		}
        3: 1134:		if (j < choice2)
        -: 1135:		{
        2: 1136:			return -1;
        -: 1137:		}
        -: 1138:
        -: 1139:		if (DEBUG)
        -: 1140:			printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1141:
        -: 1142:		//increase supply count for choosen card by amount being discarded
        1: 1143:		state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1144:
        -: 1145:		//each other player gains a copy of revealed card
        5: 1146:		for (i = 0; i < state->numPlayers; i++)
        -: 1147:		{
        4: 1148:			if (i != currentPlayer)
        -: 1149:			{
        3: 1150:				gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1151:			}
        -: 1152:		}
        -: 1153:
        -: 1154:		//discard played card from hand
        1: 1155:		discardCard(handPos, currentPlayer, state, 0);
        -: 1156:
        -: 1157:		//trash copies of cards returned to supply
        2: 1158:		for (j = 0; j < choice2; j++)
        -: 1159:		{
        2: 1160:			for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1161:			{
        2: 1162:				if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1163:				{
        1: 1164:					discardCard(i, currentPlayer, state, 1);
        1: 1165:					break;
        -: 1166:				}
        -: 1167:			}
        -: 1168:		}
        -: 1169:
        1: 1170:		return 0;
        -: 1171:
        -: 1172:	case cutpurse:
        -: 1173:
        4: 1174:		updateCoins(currentPlayer, state, 2);
       20: 1175:		for (i = 0; i < state->numPlayers; i++)
        -: 1176:		{
       16: 1177:			if (i != currentPlayer)
        -: 1178:			{
       12: 1179:				for (j = 0; j < state->handCount[i]; j++)
        -: 1180:				{
    #####: 1181:					if (state->hand[i][j] == copper)
        -: 1182:					{
    #####: 1183:						discardCard(j, i, state, 0);
    #####: 1184:						break;
        -: 1185:					}
    #####: 1186:					if (j == state->handCount[i])
        -: 1187:					{
    #####: 1188:						for (k = 0; k < state->handCount[i]; k++)
        -: 1189:						{
        -: 1190:							if (DEBUG)
        -: 1191:								printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1192:						}
    #####: 1193:						break;
        -: 1194:					}
        -: 1195:				}
        -: 1196:
        -: 1197:			}
        -: 1198:
        -: 1199:		}
        -: 1200:
        -: 1201:		//discard played card from hand
        4: 1202:		discardCard(handPos, currentPlayer, state, 0);
        -: 1203:
        4: 1204:		return 0;
        -: 1205:
        -: 1206:
        -: 1207:	case embargo:
        -: 1208:		//+2 Coins
    #####: 1209:		state->coins = state->coins + 2;
        -: 1210:
        -: 1211:		//see if selected pile is in play
    #####: 1212:		if (state->supplyCount[choice1] == -1)
        -: 1213:		{
    #####: 1214:			return -1;
        -: 1215:		}
        -: 1216:
        -: 1217:		//add embargo token to selected supply pile
    #####: 1218:		state->embargoTokens[choice1]++;
        -: 1219:
        -: 1220:		//trash card
    #####: 1221:		discardCard(handPos, currentPlayer, state, 1);
    #####: 1222:		return 0;
        -: 1223:
        -: 1224:	case outpost:
        -: 1225:		//set outpost flag
        2: 1226:		state->outpostPlayed++;
        -: 1227:
        -: 1228:		//discard card
        2: 1229:		discardCard(handPos, currentPlayer, state, 0);
        2: 1230:		return 0;
        -: 1231:
        -: 1232:	case salvager:
        -: 1233:		//+1 buy
        2: 1234:		state->numBuys++;
        -: 1235:
        2: 1236:		if (choice1)
        -: 1237:		{
        -: 1238:			//gain coins equal to trashed card
        2: 1239:			state->coins = state->coins + getCost(handCard(choice1, state));
        -: 1240:			//trash card
        2: 1241:			discardCard(choice1, currentPlayer, state, 1);
        -: 1242:		}
        -: 1243:
        -: 1244:		//discard card
        2: 1245:		discardCard(handPos, currentPlayer, state, 0);
        2: 1246:		return 0;
        -: 1247:
        -: 1248:	case sea_hag:
        4: 1249:		for (i = 0; i < state->numPlayers; i++){
        3: 1250:			if (i != currentPlayer){
        2: 1251:				state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
        2: 1252:				state->discardCount[i]++;
        2: 1253:				state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1254:			}
        -: 1255:		}
        1: 1256:		return 0;
        -: 1257:
        -: 1258:	case treasure_map:
        -: 1259:
        5: 1260:		return playTreasureMap(state, currentPlayer, handPos);
        -: 1261:	}
    #####: 1262:	return -1;
        -: 1263:}
        -: 1264:
       49: 1265:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1266:{
        -: 1267:
        -: 1268:	//if card is not trashed, added to Played pile 
       49: 1269:	if (trashFlag < 1)
        -: 1270:	{
        -: 1271:		//add card to played pile
       36: 1272:		state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
       36: 1273:		state->playedCardCount++;
        -: 1274:	}
        -: 1275:
        -: 1276:	//set played card to -1
       49: 1277:	state->hand[currentPlayer][handPos] = -1;
        -: 1278:
        -: 1279:	//remove card from player's hand
       49: 1280:	if (handPos == (state->handCount[currentPlayer] - 1)) 	//last card in hand array is played
        -: 1281:	{
        -: 1282:		//reduce number of cards in hand
        3: 1283:		state->handCount[currentPlayer]--;
        -: 1284:	}
       46: 1285:	else if (state->handCount[currentPlayer] == 1) //only one card in hand
        -: 1286:	{
        -: 1287:		//reduce number of cards in hand
    #####: 1288:		state->handCount[currentPlayer]--;
        -: 1289:	}
        -: 1290:	else
        -: 1291:	{
        -: 1292:		//replace discarded card with last card in hand
       46: 1293:		state->hand[currentPlayer][handPos] = state->hand[currentPlayer][(state->handCount[currentPlayer] - 1)];
        -: 1294:		//set last card to -1
       46: 1295:		state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1296:		//reduce number of cards in hand
       46: 1297:		state->handCount[currentPlayer]--;
        -: 1298:	}
        -: 1299:
       49: 1300:	return 0;
        -: 1301:}
        -: 1302:
      291: 1303:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1304:{
        -: 1305:	//Note: supplyPos is enum of choosen card
        -: 1306:
        -: 1307:	//check if supply pile is empty (0) or card is not used in game (-1)
      291: 1308:	if (supplyCount(supplyPos, state) < 1)
        -: 1309:	{
        1: 1310:		return -1;
        -: 1311:	}
        -: 1312:
        -: 1313:	//added card for [whoseTurn] current player:
        -: 1314:	// toFlag = 0 : add to discard
        -: 1315:	// toFlag = 1 : add to deck
        -: 1316:	// toFlag = 2 : add to hand
        -: 1317:
      290: 1318:	if (toFlag == 1)
        -: 1319:	{
       23: 1320:		state->deck[player][state->deckCount[player]] = supplyPos;
       23: 1321:		state->deckCount[player]++;
        -: 1322:	}
      267: 1323:	else if (toFlag == 2)
        -: 1324:	{
    #####: 1325:		state->hand[player][state->handCount[player]] = supplyPos;
    #####: 1326:		state->handCount[player]++;
        -: 1327:	}
        -: 1328:	else
        -: 1329:	{
      267: 1330:		state->discard[player][state->discardCount[player]] = supplyPos;
      267: 1331:		state->discardCount[player]++;
        -: 1332:	}
        -: 1333:
        -: 1334:	//decrease number in supply pile
      290: 1335:	state->supplyCount[supplyPos]--;
        -: 1336:
      290: 1337:	return 0;
        -: 1338:}
        -: 1339:
      383: 1340:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1341:{
        -: 1342:	int i;
        -: 1343:
        -: 1344:	//reset coin count
      383: 1345:	state->coins = 0;
        -: 1346:
        -: 1347:	//add coins for each Treasure card in player's hand
     2285: 1348:	for (i = 0; i < state->handCount[player]; i++)
        -: 1349:	{
     1902: 1350:		if (state->hand[player][i] == copper)
        -: 1351:		{
      738: 1352:			state->coins += 1;
        -: 1353:		}
     1164: 1354:		else if (state->hand[player][i] == silver)
        -: 1355:		{
      202: 1356:			state->coins += 2;
        -: 1357:		}
      962: 1358:		else if (state->hand[player][i] == gold)
        -: 1359:		{
       64: 1360:			state->coins += 3;
        -: 1361:		}
        -: 1362:	}
        -: 1363:
        -: 1364:	//add bonus
      383: 1365:	state->coins += bonus;
        -: 1366:
      383: 1367:	return 0;
        -: 1368:}
        -: 1369:
        -: 1370:
        -: 1371://end of dominion.c
File 'dominion.c'
Lines executed:66.43% of 557
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
     2782:    8:int compare(const void* a, const void* b) {
     2782:    9:	if (*(int*)a > *(int*)b)
     1008:   10:		return 1;
     1774:   11:	if (*(int*)a < *(int*)b)
      777:   12:		return -1;
      997:   13:	return 0;
        -:   14:}
        -:   15:
        4:   16:struct gameState* newGame() {
        4:   17:	struct gameState* g = malloc(sizeof(struct gameState));
        4:   18:	return g;
        -:   19:}
        -:   20:
       44:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:	int k8, int k9, int k10) {
       44:   23:	int* k = malloc(10 * sizeof(int));
       44:   24:	k[0] = k1;
       44:   25:	k[1] = k2;
       44:   26:	k[2] = k3;
       44:   27:	k[3] = k4;
       44:   28:	k[4] = k5;
       44:   29:	k[5] = k6;
       44:   30:	k[6] = k7;
       44:   31:	k[7] = k8;
       44:   32:	k[8] = k9;
       44:   33:	k[9] = k10;
       44:   34:	return k;
        -:   35:}
        -:   36:
       44:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		struct gameState *state) {
        -:   39:
        -:   40:	int i;
        -:   41:	int j;
        -:   42:	int it;
        -:   43:	//set up random number generator
       44:   44:	SelectStream(1);
       44:   45:	PutSeed((long)randomSeed);
        -:   46:
        -:   47:	//check number of players
       44:   48:	if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:	{
    #####:   50:		return -1;
        -:   51:	}
        -:   52:
        -:   53:	//set number of players
       44:   54:	state->numPlayers = numPlayers;
        -:   55:
        -:   56:	//check selected kingdom cards are different
      142:   57:	for (i = 0; i < 10; i++)
        -:   58:	{
     1365:   59:		for (j = 0; j < 10; j++)
        -:   60:		{
     1267:   61:			if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:			{
       42:   63:				return -1;
        -:   64:			}
        -:   65:		}
        -:   66:	}
        -:   67:
        -:   68:
        -:   69:	//initialize supply
        -:   70:	///////////////////////////////
        -:   71:
        -:   72:	//set number of Curse cards
        2:   73:	if (numPlayers == 2)
        -:   74:	{
    #####:   75:		state->supplyCount[curse] = 10;
        -:   76:	}
        2:   77:	else if (numPlayers == 3)
        -:   78:	{
        2:   79:		state->supplyCount[curse] = 20;
        -:   80:	}
        -:   81:	else
        -:   82:	{
    #####:   83:		state->supplyCount[curse] = 30;
        -:   84:	}
        -:   85:
        -:   86:	//set number of Victory cards
        2:   87:	if (numPlayers == 2)
        -:   88:	{
    #####:   89:		state->supplyCount[estate] = 8;
    #####:   90:		state->supplyCount[duchy] = 8;
    #####:   91:		state->supplyCount[province] = 8;
        -:   92:	}
        -:   93:	else
        -:   94:	{
        2:   95:		state->supplyCount[estate] = 12;
        2:   96:		state->supplyCount[duchy] = 12;
        2:   97:		state->supplyCount[province] = 12;
        -:   98:	}
        -:   99:
        -:  100:	//set number of Treasure cards
        2:  101:	state->supplyCount[copper] = 60 - (7 * numPlayers);
        2:  102:	state->supplyCount[silver] = 40;
        2:  103:	state->supplyCount[gold] = 30;
        -:  104:
        -:  105:	//set number of Kingdom cards
       42:  106:	for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:	{
      330:  108:		for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:		{
      310:  110:			if (kingdomCards[j] == i)
        -:  111:			{
        -:  112:				//check if card is a 'Victory' Kingdom card
       20:  113:				if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:				{
        4:  115:					if (numPlayers == 2){
    #####:  116:						state->supplyCount[i] = 8;
        -:  117:					}
        2:  118:					else{ state->supplyCount[i] = 12; }
        -:  119:				}
        -:  120:				else
        -:  121:				{
       18:  122:					state->supplyCount[i] = 10;
        -:  123:				}
       20:  124:				break;
        -:  125:			}
        -:  126:			else    //card is not in the set choosen for the game
        -:  127:			{
      290:  128:				state->supplyCount[i] = -1;
        -:  129:			}
        -:  130:		}
        -:  131:
        -:  132:	}
        -:  133:
        -:  134:	////////////////////////
        -:  135:	//supply intilization complete
        -:  136:
        -:  137:	//set player decks
        8:  138:	for (i = 0; i < numPlayers; i++)
        -:  139:	{
        6:  140:		state->deckCount[i] = 0;
       24:  141:		for (j = 0; j < 3; j++)
        -:  142:		{
       18:  143:			state->deck[i][j] = estate;
       18:  144:			state->deckCount[i]++;
        -:  145:		}
       48:  146:		for (j = 3; j < 10; j++)
        -:  147:		{
       42:  148:			state->deck[i][j] = copper;
       42:  149:			state->deckCount[i]++;
        -:  150:		}
        -:  151:	}
        -:  152:
        -:  153:	//shuffle player decks
        8:  154:	for (i = 0; i < numPlayers; i++)
        -:  155:	{
        6:  156:		if (shuffle(i, state) < 0)
        -:  157:		{
    #####:  158:			return -1;
        -:  159:		}
        -:  160:	}
        -:  161:
        -:  162:	//draw player hands
        8:  163:	for (i = 0; i < numPlayers; i++)
        -:  164:	{
        -:  165:		//initialize hand size to zero
        6:  166:		state->handCount[i] = 0;
        6:  167:		state->discardCount[i] = 0;
        -:  168:		//draw 5 cards
        -:  169:		// for (j = 0; j < 5; j++)
        -:  170:		//	{
        -:  171:		//	  drawCard(i, state);
        -:  172:		//	}
        -:  173:	}
        -:  174:
        -:  175:	//set embargo tokens to 0 for all supply piles
       56:  176:	for (i = 0; i <= treasure_map; i++)
        -:  177:	{
       54:  178:		state->embargoTokens[i] = 0;
        -:  179:	}
        -:  180:
        -:  181:	//initialize first player's turn
        2:  182:	state->outpostPlayed = 0;
        2:  183:	state->phase = 0;
        2:  184:	state->numActions = 1;
        2:  185:	state->numBuys = 1;
        2:  186:	state->playedCardCount = 0;
        2:  187:	state->whoseTurn = 0;
        2:  188:	state->handCount[state->whoseTurn] = 0;
        -:  189:	//int it; move to top
        -:  190:
        -:  191:	//Moved draw cards to here, only drawing at the start of a turn
       12:  192:	for (it = 0; it < 5; it++){
       10:  193:		drawCard(state->whoseTurn, state);
        -:  194:	}
        -:  195:
        2:  196:	updateCoins(state->whoseTurn, state, 0);
        -:  197:
        2:  198:	return 0;
        -:  199:}
        -:  200:
       73:  201:int shuffle(int player, struct gameState *state) {
        -:  202:
        -:  203:
        -:  204:	int newDeck[MAX_DECK];
       73:  205:	int newDeckPos = 0;
        -:  206:	int card;
        -:  207:	int i;
        -:  208:
       73:  209:	if (state->deckCount[player] < 1)
    #####:  210:		return -1;
       73:  211:	qsort((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
        -:  212:	/* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
     1410:  214:	while (state->deckCount[player] > 0) {
     1264:  215:		card = floor(Random() * state->deckCount[player]);
     1264:  216:		newDeck[newDeckPos] = state->deck[player][card];
     1264:  217:		newDeckPos++;
     7538:  218:		for (i = card; i < state->deckCount[player] - 1; i++) {
     6274:  219:			state->deck[player][i] = state->deck[player][i + 1];
        -:  220:		}
     1264:  221:		state->deckCount[player]--;
        -:  222:	}
     1337:  223:	for (i = 0; i < newDeckPos; i++) {
     1264:  224:		state->deck[player][i] = newDeck[i];
     1264:  225:		state->deckCount[player]++;
        -:  226:	}
        -:  227:
       73:  228:	return 0;
        -:  229:}
        -:  230:
     1305:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state)
        -:  232:{
        -:  233:	int card;
     1305:  234:	int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:	//check if it is the right phase
     1305:  237:	if (state->phase != 0)
        -:  238:	{
      181:  239:		return -1;
        -:  240:	}
        -:  241:
        -:  242:	//check if player has enough actions
     1124:  243:	if (state->numActions < 1)
        -:  244:	{
       41:  245:		return -1;
        -:  246:	}
        -:  247:
        -:  248:	//get card played
     1083:  249:	card = handCard(handPos, state);
        -:  250:
        -:  251:	//check if selected card is an action
     1083:  252:	if (card < adventurer || card > treasure_map)
        -:  253:	{
      969:  254:		return -1;
        -:  255:	}
        -:  256:
        -:  257:	//play card
      114:  258:	if (cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0)
        -:  259:	{
       69:  260:		return -1;
        -:  261:	}
        -:  262:
        -:  263:	//reduce number of actions
       45:  264:	state->numActions--;
        -:  265:
        -:  266:	//update coins (Treasure cards may be added with card draws)
       45:  267:	updateCoins(state->whoseTurn, state, coin_bonus);
        -:  268:
       45:  269:	return 0;
        -:  270:}
        -:  271:
     1269:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:	int who;
        -:  274:	if (DEBUG){
        -:  275:		printf("Entering buyCard...\n");
        -:  276:	}
        -:  277:
        -:  278:	// I don't know what to do about the phase thing.
        -:  279:
     1269:  280:	who = state->whoseTurn;
        -:  281:
     1269:  282:	if (state->numBuys < 1){
        -:  283:		if (DEBUG)
        -:  284:			printf("You do not have any buys left\n");
      189:  285:		return -1;
        -:  286:	}
     1080:  287:	else if (supplyCount(supplyPos, state) < 1){
        -:  288:		if (DEBUG)
        -:  289:			printf("There are not any of that type of card left\n");
      423:  290:		return -1;
        -:  291:	}
      657:  292:	else if (state->coins < getCost(supplyPos)){
        -:  293:		if (DEBUG)
        -:  294:			printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
      460:  295:		return -1;
        -:  296:	}
        -:  297:	else {
      197:  298:		state->phase = 1;
        -:  299:		//state->supplyCount[supplyPos]--;
      197:  300:		gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  301:
      197:  302:		state->coins = (state->coins) - (getCost(supplyPos));
      197:  303:		state->numBuys--;
        -:  304:		if (DEBUG)
        -:  305:			printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  306:	}
        -:  307:
        -:  308:	//state->discard[who][state->discardCount[who]] = supplyPos;
        -:  309:	//state->discardCount[who]++;
        -:  310:
      197:  311:	return 0;
        -:  312:}
        -:  313:
    #####:  314:int numHandCards(struct gameState *state) {
    #####:  315:	return state->handCount[whoseTurn(state)];
        -:  316:}
        -:  317:
     1083:  318:int handCard(int handPos, struct gameState *state) {
     1083:  319:	int currentPlayer = whoseTurn(state);
     1083:  320:	return state->hand[currentPlayer][handPos];
        -:  321:}
        -:  322:
     1298:  323:int supplyCount(int card, struct gameState *state) {
     1298:  324:	return state->supplyCount[card];
        -:  325:}
        -:  326:
    #####:  327:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  328:	int i;
    #####:  329:	int count = 0;
        -:  330:
    #####:  331:	for (i = 0; i < state->deckCount[player]; i++)
        -:  332:	{
    #####:  333:		if (state->deck[player][i] == card) count++;
        -:  334:	}
        -:  335:
    #####:  336:	for (i = 0; i < state->handCount[player]; i++)
        -:  337:	{
    #####:  338:		if (state->hand[player][i] == card) count++;
        -:  339:	}
        -:  340:
    #####:  341:	for (i = 0; i < state->discardCount[player]; i++)
        -:  342:	{
    #####:  343:		if (state->discard[player][i] == card) count++;
        -:  344:	}
        -:  345:
    #####:  346:	return count;
        -:  347:}
        -:  348:
     1427:  349:int whoseTurn(struct gameState *state) {
     1427:  350:	return state->whoseTurn;
        -:  351:}
        -:  352:
      230:  353:int endTurn(struct gameState *state) {
        -:  354:	int k;
        -:  355:	int i;
      230:  356:	int currentPlayer = whoseTurn(state);
        -:  357:
        -:  358:	//Discard hand
     1361:  359:	for (i = 0; i < state->handCount[currentPlayer]; i++){
     1131:  360:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
     1131:  361:		state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  362:	}
      230:  363:	state->handCount[currentPlayer] = 0;//Reset hand count
        -:  364:
        -:  365:	//Code for determining the player
      230:  366:	if (currentPlayer < (state->numPlayers - 1)){
      146:  367:		state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  368:	}
        -:  369:	else{
       84:  370:		state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  371:	}
        -:  372:
      230:  373:	state->outpostPlayed = 0;
      230:  374:	state->phase = 0;
      230:  375:	state->numActions = 1;
      230:  376:	state->coins = 0;
      230:  377:	state->numBuys = 1;
      230:  378:	state->playedCardCount = 0;
      230:  379:	state->handCount[state->whoseTurn] = 0;
        -:  380:
        -:  381:	//int k; move to top
        -:  382:	//Next player draws hand
     1380:  383:	for (k = 0; k < 5; k++){
     1150:  384:		drawCard(state->whoseTurn, state);//Draw a card
        -:  385:	}
        -:  386:
        -:  387:	//Update money
      230:  388:	updateCoins(state->whoseTurn, state, 0);
        -:  389:
      230:  390:	return 0;
        -:  391:}
        -:  392:
     3818:  393:int isGameOver(struct gameState *state) {
        -:  394:	int i;
        -:  395:	int j;
        -:  396:
        -:  397:	//if stack of Province cards is empty, the game ends
     3818:  398:	if (state->supplyCount[province] == 0)
        -:  399:	{
    #####:  400:		return 1;
        -:  401:	}
        -:  402:
        -:  403:	//if three supply pile are at 0, the game ends
     3818:  404:	j = 0;
    99268:  405:	for (i = 0; i < 25; i++)
        -:  406:	{
    95450:  407:		if (state->supplyCount[i] == 0)
        -:  408:		{
     3121:  409:			j++;
        -:  410:		}
        -:  411:	}
     3818:  412:	if (j >= 3)
        -:  413:	{
        2:  414:		return 1;
        -:  415:	}
        -:  416:
     3816:  417:	return 0;
        -:  418:}
        -:  419:
    #####:  420:int scoreFor(int player, struct gameState *state) {
        -:  421:
        -:  422:	int i;
    #####:  423:	int score = 0;
        -:  424:	//score from hand
    #####:  425:	for (i = 0; i < state->handCount[player]; i++)
        -:  426:	{
    #####:  427:		if (state->hand[player][i] == curse) { score = score - 1; };
    #####:  428:		if (state->hand[player][i] == estate) { score = score + 1; };
    #####:  429:		if (state->hand[player][i] == duchy) { score = score + 3; };
    #####:  430:		if (state->hand[player][i] == province) { score = score + 6; };
    #####:  431:		if (state->hand[player][i] == great_hall) { score = score + 1; };
    #####:  432:		if (state->hand[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  433:	}
        -:  434:
        -:  435:	//score from discard
    #####:  436:	for (i = 0; i < state->discardCount[player]; i++)
        -:  437:	{
    #####:  438:		if (state->discard[player][i] == curse) { score = score - 1; };
    #####:  439:		if (state->discard[player][i] == estate) { score = score + 1; };
    #####:  440:		if (state->discard[player][i] == duchy) { score = score + 3; };
    #####:  441:		if (state->discard[player][i] == province) { score = score + 6; };
    #####:  442:		if (state->discard[player][i] == great_hall) { score = score + 1; };
    #####:  443:		if (state->discard[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  444:	}
        -:  445:
        -:  446:	//score from deck
    #####:  447:	for (i = 0; i < state->discardCount[player]; i++)
        -:  448:	{
    #####:  449:		if (state->deck[player][i] == curse) { score = score - 1; };
    #####:  450:		if (state->deck[player][i] == estate) { score = score + 1; };
    #####:  451:		if (state->deck[player][i] == duchy) { score = score + 3; };
    #####:  452:		if (state->deck[player][i] == province) { score = score + 6; };
    #####:  453:		if (state->deck[player][i] == great_hall) { score = score + 1; };
    #####:  454:		if (state->deck[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  455:	}
        -:  456:
    #####:  457:	return score;
        -:  458:}
        -:  459:
    #####:  460:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  461:	int i;
        -:  462:	int j;
        -:  463:	int highScore;
        -:  464:	int currentPlayer;
        -:  465:
        -:  466:	//get score for each player
    #####:  467:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  468:	{
        -:  469:		//set unused player scores to -9999
    #####:  470:		if (i >= state->numPlayers)
        -:  471:		{
    #####:  472:			players[i] = -9999;
        -:  473:		}
        -:  474:		else
        -:  475:		{
    #####:  476:			players[i] = scoreFor(i, state);
        -:  477:		}
        -:  478:	}
        -:  479:
        -:  480:	//find highest score
    #####:  481:	j = 0;
    #####:  482:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  483:	{
    #####:  484:		if (players[i] > players[j])
        -:  485:		{
    #####:  486:			j = i;
        -:  487:		}
        -:  488:	}
    #####:  489:	highScore = players[j];
        -:  490:
        -:  491:	//add 1 to players who had less turns
    #####:  492:	currentPlayer = whoseTurn(state);
    #####:  493:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  494:	{
    #####:  495:		if (players[i] == highScore && i > currentPlayer)
        -:  496:		{
    #####:  497:			players[i]++;
        -:  498:		}
        -:  499:	}
        -:  500:
        -:  501:	//find new highest score
    #####:  502:	j = 0;
    #####:  503:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  504:	{
    #####:  505:		if (players[i] > players[j])
        -:  506:		{
    #####:  507:			j = i;
        -:  508:		}
        -:  509:	}
    #####:  510:	highScore = players[j];
        -:  511:
        -:  512:	//set winners in array to 1 and rest to 0
    #####:  513:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  514:	{
    #####:  515:		if (players[i] == highScore)
        -:  516:		{
    #####:  517:			players[i] = 1;
        -:  518:		}
        -:  519:		else
        -:  520:		{
    #####:  521:			players[i] = 0;
        -:  522:		}
        -:  523:	}
        -:  524:
    #####:  525:	return 0;
        -:  526:}
        -:  527:
     1199:  528:int drawCard(int player, struct gameState *state)
        -:  529:{
        -:  530:	int count;
        -:  531:	int deckCounter;
     1199:  532:	if (state->deckCount[player] <= 0){//Deck is empty
        -:  533:
        -:  534:		//Step 1 Shuffle the discard pile back into a deck
        -:  535:		int i;
        -:  536:		//Move discard to deck
     1271:  537:		for (i = 0; i < state->discardCount[player]; i++){
     1204:  538:			state->deck[player][i] = state->discard[player][i];
     1204:  539:			state->discard[player][i] = -1;
        -:  540:		}
        -:  541:
       67:  542:		state->deckCount[player] = state->discardCount[player];
       67:  543:		state->discardCount[player] = 0;//Reset discard
        -:  544:
        -:  545:		//Shufffle the deck
       67:  546:		shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  547:
        -:  548:		if (DEBUG){//Debug statements
        -:  549:			printf("Deck count now: %d\n", state->deckCount[player]);
        -:  550:		}
        -:  551:
       67:  552:		state->discardCount[player] = 0;
        -:  553:
        -:  554:		//Step 2 Draw Card
       67:  555:		count = state->handCount[player];//Get current player's hand count
        -:  556:
        -:  557:		if (DEBUG){//Debug statements
        -:  558:			printf("Current hand count: %d\n", count);
        -:  559:		}
        -:  560:
       67:  561:		deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  562:
       67:  563:		if (deckCounter == 0)
    #####:  564:			return -1;
        -:  565:
       67:  566:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
       67:  567:		state->deckCount[player]--;
       67:  568:		state->handCount[player]++;//Increment hand count
        -:  569:	}
        -:  570:
        -:  571:	else{
     1132:  572:		int count = state->handCount[player];//Get current hand count for player
        -:  573:		int deckCounter;
        -:  574:		if (DEBUG){//Debug statements
        -:  575:			printf("Current hand count: %d\n", count);
        -:  576:		}
        -:  577:
     1132:  578:		deckCounter = state->deckCount[player];//Create holder for the deck count
     1132:  579:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
     1132:  580:		state->deckCount[player]--;
     1132:  581:		state->handCount[player]++;//Increment hand count
        -:  582:	}
        -:  583:
     1199:  584:	return 0;
        -:  585:}
        -:  586:
      860:  587:int getCost(int cardNumber)
        -:  588:{
      860:  589:	switch (cardNumber)
        -:  590:	{
        -:  591:	case curse:
       81:  592:		return 0;
        -:  593:	case estate:
       48:  594:		return 2;
        -:  595:	case duchy:
       40:  596:		return 5;
        -:  597:	case province:
       38:  598:		return 8;
        -:  599:	case copper:
       96:  600:		return 0;
        -:  601:	case silver:
       52:  602:		return 3;
        -:  603:	case gold:
       39:  604:		return 6;
        -:  605:	case adventurer:
       16:  606:		return 6;
        -:  607:	case council_room:
       43:  608:		return 5;
        -:  609:	case feast:
    #####:  610:		return 4;
        -:  611:	case gardens:
       47:  612:		return 4;
        -:  613:	case mine:
       52:  614:		return 5;
        -:  615:	case remodel:
       24:  616:		return 4;
        -:  617:	case smithy:
       54:  618:		return 4;
        -:  619:	case village:
    #####:  620:		return 3;
        -:  621:	case baron:
       19:  622:		return 4;
        -:  623:	case great_hall:
    #####:  624:		return 3;
        -:  625:	case minion:
       29:  626:		return 5;
        -:  627:	case steward:
       30:  628:		return 3;
        -:  629:	case tribute:
       23:  630:		return 5;
        -:  631:	case ambassador:
       27:  632:		return 3;
        -:  633:	case cutpurse:
       29:  634:		return 4;
        -:  635:	case embargo:
       21:  636:		return 2;
        -:  637:	case outpost:
       24:  638:		return 5;
        -:  639:	case salvager:
       14:  640:		return 4;
        -:  641:	case sea_hag:
    #####:  642:		return 4;
        -:  643:	case treasure_map:
       14:  644:		return 4;
        -:  645:	}
        -:  646:
    #####:  647:	return -1;
        -:  648:}
        -:  649:
    #####:  650:void playAdventurer(struct gameState *state, int currentPlayer)
        -:  651:// Reveal cards from deck until 2 Treasure cards are found.  Put those Treasure cards in the hand and discard the rest.
        -:  652:{
    #####:  653:	int drawntreasure = 0;
        -:  654:	int temphand[MAX_HAND];
        -:  655:	int cardDrawn;
    #####:  656:	int z = 0; // this is the counter for the temp hand
        -:  657:
    #####:  658:	while (drawntreasure < 2){
    #####:  659:		if (state->deckCount[currentPlayer] < 1){//if the deck is empty we need to shuffle discard and add to deck
    #####:  660:			shuffle(currentPlayer, state);
        -:  661:		}
    #####:  662:		drawCard(currentPlayer, state);
    #####:  663:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer] - 1];//top card of hand is most recently drawn card.
    #####:  664:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
    #####:  665:			drawntreasure++;
        -:  666:		else{
    #####:  667:			temphand[z] = cardDrawn;
    #####:  668:			state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####:  669:			z++;
        -:  670:		}
        -:  671:	}
    #####:  672:	while (z - 1 >= 0){
    #####:  673:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; // discard all cards in play that have been drawn
    #####:  674:		z = z - 1;
        -:  675:	}
    #####:  676:}
        -:  677:
        3:  678:int playRemodel(struct gameState *state, int currentPlayer, int choice1, int choice2, int handPos)
        -:  679://Trash a card in the hand, and gain a card costing up to $2 more than the trashed card
        -:  680:{
        -:  681:	int i;
        3:  682:	int j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  683:
        3:  684:	if ((getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2))
        -:  685:	{
    #####:  686:		return -1;
        -:  687:	}
        -:  688:
        3:  689:	gainCard(choice2, state, 0, currentPlayer);
        -:  690:
        -:  691:	//discard card from hand
        3:  692:	discardCard(handPos, currentPlayer, state, 0);
        -:  693:
        -:  694:	//discard trashed card
        6:  695:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  696:	{
        6:  697:		if (state->hand[currentPlayer][i] == j)
        -:  698:		{
        3:  699:			discardCard(i, currentPlayer, state, 0);
        3:  700:			break;
        -:  701:		}
        -:  702:	}
        -:  703:
        3:  704:	return 0;
        -:  705:}
        -:  706:
       11:  707:void playSmithy(struct gameState *state, int currentPlayer, int handPos)
        -:  708:// Draw 3 cards
        -:  709:{
        -:  710:	int i;
       44:  711:	for (i = 0; i < 3; i++)
        -:  712:	{
       33:  713:		drawCard(currentPlayer, state);
        -:  714:	}
        -:  715:
        -:  716:	//discard card from hand
       11:  717:	discardCard(handPos, currentPlayer, state, 0);
       11:  718:}
        -:  719:
        5:  720:void playBaron(struct gameState *state, int currentPlayer, int choice1, int handPos)
        -:  721://Add a buy.  OPTION:  Discard an Estate card and gain $4.  Otherwise, gain an Estate card.
        -:  722:{
        5:  723:	state->numBuys++;//Increase buys by 1!
        5:  724:	if (choice1 > 0){//Boolean true or going to discard an estate
        4:  725:		int p = 0;//Iterator for hand!
        4:  726:		int card_not_discarded = 1;//Flag for discard set!
       24:  727:		while (card_not_discarded){
       16:  728:			if (state->hand[currentPlayer][p] == estate){ //Found an estate card!
        2:  729:				state->coins += 4;//Add 4 coins to the amount of coins
        2:  730:				state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
        2:  731:				state->discardCount[currentPlayer]++;
       12:  732:				for (; p < state->handCount[currentPlayer]; p++){
       10:  733:					state->hand[currentPlayer][p] = state->hand[currentPlayer][p + 1];
        -:  734:				}
        2:  735:				state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
        2:  736:				state->handCount[currentPlayer]--;
        2:  737:				card_not_discarded = 0;//Exit the loop
        -:  738:			}
       14:  739:			else if (p > state->handCount[currentPlayer]){
        -:  740:				if (DEBUG) {
        -:  741:					printf("No estate cards in your hand, invalid choice\n");
        -:  742:					printf("Must gain an estate if there are any\n");
        -:  743:				}
        2:  744:				if (supplyCount(estate, state) > 0){
        1:  745:					gainCard(estate, state, 1, currentPlayer);
        1:  746:					state->supplyCount[estate]--;//Decrement estates
        1:  747:					if (supplyCount(estate, state) == 0){
    #####:  748:						isGameOver(state);
        -:  749:					}
        -:  750:				}
        2:  751:				card_not_discarded = 0;//Exit the loop
        -:  752:			}
        -:  753:
        -:  754:			else{
       12:  755:				p++;//Next card
        -:  756:			}
        -:  757:		}
        -:  758:	}
        -:  759:
        -:  760:	else{
        1:  761:		if (supplyCount(estate, state) > 0){
        1:  762:			gainCard(estate, state, 0, currentPlayer);//Gain an estate
        1:  763:			state->supplyCount[estate]--;//Decrement Estates
        1:  764:			if (supplyCount(estate, state) == 0){
    #####:  765:				isGameOver(state);
        -:  766:			}
        -:  767:		}
        -:  768:	}
        5:  769:}
        -:  770:
        2:  771:int playTreasureMap(struct gameState *state, int currentPlayer, int handPos)
        -:  772://Trashing two treasure map cards from the hand = four gold on top of the deck.
        -:  773:{
        -:  774:	int i;
        -:  775:	int index;
        -:  776:
        -:  777:	//search hand for another treasure_map
       12:  778:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  779:	{
       10:  780:		if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -:  781:		{
    #####:  782:			index = i;
    #####:  783:			break;
        -:  784:		}
        -:  785:	}
        2:  786:	if (index > -1)
        -:  787:	{
        -:  788:		//trash both treasure cards
        2:  789:		discardCard(handPos, currentPlayer, state, 1);
        2:  790:		discardCard(index, currentPlayer, state, 1);
        -:  791:
        -:  792:		//gain 4 Gold cards
       10:  793:		for (i = 0; i < 4; i++)
        -:  794:		{
        8:  795:			gainCard(gold, state, 1, currentPlayer);
        -:  796:		}
        -:  797:
        -:  798:		//return success
        2:  799:		return 1;
        -:  800:	}
        -:  801:
        -:  802:	//no second treasure_map found in hand
    #####:  803:	return -1;
        -:  804:}
        -:  805:
      114:  806:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  807:{
        -:  808:	int i;
        -:  809:	int j;
        -:  810:	int k;
        -:  811:	//int x;  //Unused after while loop removed from feast.
      114:  812:	int currentPlayer = whoseTurn(state);
      114:  813:	int nextPlayer = currentPlayer + 1;
        -:  814:	int temphand[MAX_HAND];
        -:  815:
      114:  816:	int tributeRevealedCards[2] = { -1, -1 };
        -:  817:
      114:  818:	if (nextPlayer > (state->numPlayers - 1)){
       38:  819:		nextPlayer = 0;
        -:  820:	}
        -:  821:
        -:  822:	//uses switch to select card and perform actions
      114:  823:	switch (card)
        -:  824:	{
        -:  825:	case adventurer:
        -:  826:
    #####:  827:		playAdventurer(state, currentPlayer);
    #####:  828:		return 0;
        -:  829:
        -:  830:	case council_room:
        -:  831:		//+4 Cards
        5:  832:		for (i = 0; i < 4; i++)
        -:  833:		{
        4:  834:			drawCard(currentPlayer, state);
        -:  835:		}
        -:  836:
        -:  837:		//+1 Buy
        1:  838:		state->numBuys++;
        -:  839:
        -:  840:		//Each other player draws a card
        4:  841:		for (i = 0; i < state->numPlayers; i++)
        -:  842:		{
        3:  843:			if (i != currentPlayer)
        -:  844:			{
        2:  845:				drawCard(i, state);
        -:  846:			}
        -:  847:		}
        -:  848:
        -:  849:		//put played card in played card pile
        1:  850:		discardCard(handPos, currentPlayer, state, 0);
        -:  851:
        1:  852:		return 0;
        -:  853:
        -:  854:	case feast:
        -:  855:		//gain card with cost up to 5
        -:  856:		//Backup hand
    #####:  857:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  858:			temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  859:			state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  860:		}
        -:  861:		//Backup hand
        -:  862:
        -:  863:		//Update Coins for Buy
    #####:  864:		updateCoins(currentPlayer, state, 5);
        -:  865://		x = 1;//Condition to loop on
        -:  866://		while (x == 1) {//Buy one card
    #####:  867:			if (supplyCount(choice1, state) <= 0){
        -:  868:				if (DEBUG)
        -:  869:					printf("None of that card left, sorry!\n");
        -:  870:
        -:  871:				if (DEBUG){
        -:  872:					printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  873:				}
        -:  874:			}
    #####:  875:			else if (state->coins < getCost(choice1)){
    #####:  876:				printf("That card is too expensive!\n");
        -:  877:
        -:  878:				if (DEBUG){
        -:  879:					printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  880:				}
        -:  881:			}
        -:  882:			else{
        -:  883:
        -:  884:				if (DEBUG){
        -:  885:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  886:				}
        -:  887:
    #####:  888:				gainCard(choice1, state, 0, currentPlayer);//Gain the card
        -:  889://				x = 0;//No more buying cards
        -:  890:
        -:  891:				if (DEBUG){
        -:  892:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  893:				}
        -:  894:
        -:  895:			}
        -:  896://		}
        -:  897:
        -:  898:		//Reset Hand
    #####:  899:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  900:			state->hand[currentPlayer][i] = temphand[i];
    #####:  901:			temphand[i] = -1;
        -:  902:		}
        -:  903:		//Reset Hand
        -:  904:
    #####:  905:		return 0;
        -:  906:
        -:  907:	case gardens:
       24:  908:		return -1;
        -:  909:
        -:  910:	case mine:
       17:  911:		j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  912:
       17:  913:		if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  914:		{
       17:  915:			return -1;
        -:  916:		}
        -:  917:
    #####:  918:		if (choice2 > treasure_map || choice2 < curse)
        -:  919:		{
    #####:  920:			return -1;
        -:  921:		}
        -:  922:
    #####:  923:		if ((getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2))
        -:  924:		{
    #####:  925:			return -1;
        -:  926:		}
        -:  927:
    #####:  928:		gainCard(choice2, state, 2, currentPlayer);
        -:  929:
        -:  930:		//discard card from hand
    #####:  931:		discardCard(handPos, currentPlayer, state, 0);
        -:  932:
        -:  933:		//discard trashed card
    #####:  934:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  935:		{
    #####:  936:			if (state->hand[currentPlayer][i] == j)
        -:  937:			{
    #####:  938:				discardCard(i, currentPlayer, state, 0);
    #####:  939:				break;
        -:  940:			}
        -:  941:		}
        -:  942:
    #####:  943:		return 0;
        -:  944:
        -:  945:	case remodel:
        -:  946:
        3:  947:		return playRemodel(state, currentPlayer, choice1, choice2, handPos);
        -:  948:
        -:  949:	case smithy:
        -:  950:
       11:  951:		playSmithy(state, currentPlayer, handPos);
       11:  952:		return 0;
        -:  953:
        -:  954:	case village:
        -:  955:		//+1 Card
    #####:  956:		drawCard(currentPlayer, state);
        -:  957:
        -:  958:		//+2 Actions
    #####:  959:		state->numActions = state->numActions + 2;
        -:  960:
        -:  961:		//discard played card from hand
    #####:  962:		discardCard(handPos, currentPlayer, state, 0);
    #####:  963:		return 0;
        -:  964:
        -:  965:	case baron:
        -:  966:
        5:  967:		playBaron(state, currentPlayer, choice1, handPos);
        5:  968:		return 0;
        -:  969:
        -:  970:	case great_hall:
        -:  971:		//+1 Card
    #####:  972:		drawCard(currentPlayer, state);
        -:  973:
        -:  974:		//+1 Actions
    #####:  975:		state->numActions++;
        -:  976:
        -:  977:		//discard card from hand
    #####:  978:		discardCard(handPos, currentPlayer, state, 0);
    #####:  979:		return 0;
        -:  980:
        -:  981:	case minion:
        -:  982:		//+1 action
    #####:  983:		state->numActions++;
        -:  984:
        -:  985:		//discard card from hand
    #####:  986:		discardCard(handPos, currentPlayer, state, 0);
        -:  987:
    #####:  988:		if (choice1)		//+2 coins
        -:  989:		{
    #####:  990:			state->coins = state->coins + 2;
        -:  991:		}
        -:  992:
    #####:  993:		else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  994:		{
        -:  995:			//discard hand
    #####:  996:			while (numHandCards(state) > 0)
        -:  997:			{
    #####:  998:				discardCard(handPos, currentPlayer, state, 0);
        -:  999:			}
        -: 1000:
        -: 1001:			//draw 4
    #####: 1002:			for (i = 0; i < 4; i++)
        -: 1003:			{
    #####: 1004:				drawCard(currentPlayer, state);
        -: 1005:			}
        -: 1006:
        -: 1007:			//other players discard hand and redraw if hand size > 4
    #####: 1008:			for (i = 0; i < state->numPlayers; i++)
        -: 1009:			{
    #####: 1010:				if (i != currentPlayer)
        -: 1011:				{
    #####: 1012:					if (state->handCount[i] > 4)
        -: 1013:					{
        -: 1014:						//discard hand
    #####: 1015:						while (state->handCount[i] > 0)
        -: 1016:						{
    #####: 1017:							discardCard(handPos, i, state, 0);
        -: 1018:						}
        -: 1019:
        -: 1020:						//draw 4
    #####: 1021:						for (j = 0; j < 4; j++)
        -: 1022:						{
    #####: 1023:							drawCard(i, state);
        -: 1024:						}
        -: 1025:					}
        -: 1026:				}
        -: 1027:			}
        -: 1028:
        -: 1029:		}
    #####: 1030:		return 0;
        -: 1031:
        -: 1032:	case steward:
        6: 1033:		if (choice1 == 1)
        -: 1034:		{
        -: 1035:			//+2 cards
    #####: 1036:			drawCard(currentPlayer, state);
    #####: 1037:			drawCard(currentPlayer, state);
        -: 1038:		}
        6: 1039:		else if (choice1 == 2)
        -: 1040:		{
        -: 1041:			//+2 coins
        1: 1042:			state->coins = state->coins + 2;
        -: 1043:		}
        -: 1044:		else
        -: 1045:		{
        -: 1046:			//trash 2 cards in hand
        5: 1047:			discardCard(choice2, currentPlayer, state, 1);
        5: 1048:			discardCard(choice3, currentPlayer, state, 1);
        -: 1049:		}
        -: 1050:
        -: 1051:		//discard card from hand
        6: 1052:		discardCard(handPos, currentPlayer, state, 0);
        6: 1053:		return 0;
        -: 1054:
        -: 1055:	case tribute:
        2: 1056:		if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####: 1057:			if (state->deckCount[nextPlayer] > 0){
    #####: 1058:				tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1059:				state->deckCount[nextPlayer]--;
        -: 1060:			}
    #####: 1061:			else if (state->discardCount[nextPlayer] > 0){
    #####: 1062:				tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer] - 1];
    #####: 1063:				state->discardCount[nextPlayer]--;
        -: 1064:			}
        -: 1065:			else{
        -: 1066:				//No Card to Reveal
        -: 1067:				if (DEBUG){
        -: 1068:					printf("No cards to reveal\n");
        -: 1069:				}
        -: 1070:			}
        -: 1071:		}
        -: 1072:
        -: 1073:		else{
        2: 1074:			if (state->deckCount[nextPlayer] == 0){
    #####: 1075:				for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####: 1076:					state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1077:					state->deckCount[nextPlayer]++;
    #####: 1078:					state->discard[nextPlayer][i] = -1;
    #####: 1079:					state->discardCount[nextPlayer]--;
        -: 1080:				}
        -: 1081:
    #####: 1082:				shuffle(nextPlayer, state);//Shuffle the deck
        -: 1083:			}
        2: 1084:			tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
        2: 1085:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
        2: 1086:			state->deckCount[nextPlayer]--;
        2: 1087:			tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
        2: 1088:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
        2: 1089:			state->deckCount[nextPlayer]--;
        -: 1090:		}
        -: 1091:
        2: 1092:		if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
        1: 1093:			state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
        1: 1094:			state->playedCardCount++;
        1: 1095:			tributeRevealedCards[1] = -1;
        -: 1096:		}
        -: 1097:
        8: 1098:		for (i = 0; i <= 2; i++){
        6: 1099:			if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
        2: 1100:				state->coins += 2;
        -: 1101:			}
        -: 1102:
        4: 1103:			else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
    #####: 1104:				drawCard(currentPlayer, state);
    #####: 1105:				drawCard(currentPlayer, state);
        -: 1106:			}
        -: 1107:			else{//Action Card
        4: 1108:				state->numActions = state->numActions + 2;
        -: 1109:			}
        -: 1110:		}
        -: 1111:
        2: 1112:		return 0;
        -: 1113:
        -: 1114:	case ambassador:
       21: 1115:		j = 0;		//used to check if player has enough cards to discard
        -: 1116:
       21: 1117:		if (choice2 > 2 || choice2 < 0)
        -: 1118:		{
       18: 1119:			return -1;
        -: 1120:		}
        -: 1121:
        3: 1122:		if (choice1 == handPos)
        -: 1123:		{
    #####: 1124:			return -1;
        -: 1125:		}
        -: 1126:
       18: 1127:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1128:		{
       15: 1129:			if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1130:			{
        1: 1131:				j++;
        -: 1132:			}
        -: 1133:		}
        3: 1134:		if (j < choice2)
        -: 1135:		{
        1: 1136:			return -1;
        -: 1137:		}
        -: 1138:
        -: 1139:		if (DEBUG)
        -: 1140:			printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1141:
        -: 1142:		//increase supply count for choosen card by amount being discarded
        2: 1143:		state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1144:
        -: 1145:		//each other player gains a copy of revealed card
        7: 1146:		for (i = 0; i < state->numPlayers; i++)
        -: 1147:		{
        5: 1148:			if (i != currentPlayer)
        -: 1149:			{
        3: 1150:				gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1151:			}
        -: 1152:		}
        -: 1153:
        -: 1154:		//discard played card from hand
        2: 1155:		discardCard(handPos, currentPlayer, state, 0);
        -: 1156:
        -: 1157:		//trash copies of cards returned to supply
        3: 1158:		for (j = 0; j < choice2; j++)
        -: 1159:		{
        1: 1160:			for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1161:			{
        1: 1162:				if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1163:				{
        1: 1164:					discardCard(i, currentPlayer, state, 1);
        1: 1165:					break;
        -: 1166:				}
        -: 1167:			}
        -: 1168:		}
        -: 1169:
        2: 1170:		return 0;
        -: 1171:
        -: 1172:	case cutpurse:
        -: 1173:
        1: 1174:		updateCoins(currentPlayer, state, 2);
        4: 1175:		for (i = 0; i < state->numPlayers; i++)
        -: 1176:		{
        3: 1177:			if (i != currentPlayer)
        -: 1178:			{
        2: 1179:				for (j = 0; j < state->handCount[i]; j++)
        -: 1180:				{
    #####: 1181:					if (state->hand[i][j] == copper)
        -: 1182:					{
    #####: 1183:						discardCard(j, i, state, 0);
    #####: 1184:						break;
        -: 1185:					}
    #####: 1186:					if (j == state->handCount[i])
        -: 1187:					{
    #####: 1188:						for (k = 0; k < state->handCount[i]; k++)
        -: 1189:						{
        -: 1190:							if (DEBUG)
        -: 1191:								printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1192:						}
    #####: 1193:						break;
        -: 1194:					}
        -: 1195:				}
        -: 1196:
        -: 1197:			}
        -: 1198:
        -: 1199:		}
        -: 1200:
        -: 1201:		//discard played card from hand
        1: 1202:		discardCard(handPos, currentPlayer, state, 0);
        -: 1203:
        1: 1204:		return 0;
        -: 1205:
        -: 1206:
        -: 1207:	case embargo:
        -: 1208:		//+2 Coins
       18: 1209:		state->coins = state->coins + 2;
        -: 1210:
        -: 1211:		//see if selected pile is in play
       18: 1212:		if (state->supplyCount[choice1] == -1)
        -: 1213:		{
        9: 1214:			return -1;
        -: 1215:		}
        -: 1216:
        -: 1217:		//add embargo token to selected supply pile
        9: 1218:		state->embargoTokens[choice1]++;
        -: 1219:
        -: 1220:		//trash card
        9: 1221:		discardCard(handPos, currentPlayer, state, 1);
        9: 1222:		return 0;
        -: 1223:
        -: 1224:	case outpost:
        -: 1225:		//set outpost flag
        3: 1226:		state->outpostPlayed++;
        -: 1227:
        -: 1228:		//discard card
        3: 1229:		discardCard(handPos, currentPlayer, state, 0);
        3: 1230:		return 0;
        -: 1231:
        -: 1232:	case salvager:
        -: 1233:		//+1 buy
    #####: 1234:		state->numBuys++;
        -: 1235:
    #####: 1236:		if (choice1)
        -: 1237:		{
        -: 1238:			//gain coins equal to trashed card
    #####: 1239:			state->coins = state->coins + getCost(handCard(choice1, state));
        -: 1240:			//trash card
    #####: 1241:			discardCard(choice1, currentPlayer, state, 1);
        -: 1242:		}
        -: 1243:
        -: 1244:		//discard card
    #####: 1245:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1246:		return 0;
        -: 1247:
        -: 1248:	case sea_hag:
    #####: 1249:		for (i = 0; i < state->numPlayers; i++){
    #####: 1250:			if (i != currentPlayer){
    #####: 1251:				state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1252:				state->discardCount[i]++;
    #####: 1253:				state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1254:			}
        -: 1255:		}
    #####: 1256:		return 0;
        -: 1257:
        -: 1258:	case treasure_map:
        -: 1259:
        2: 1260:		return playTreasureMap(state, currentPlayer, handPos);
        -: 1261:	}
    #####: 1262:	return -1;
        -: 1263:}
        -: 1264:
       54: 1265:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1266:{
        -: 1267:
        -: 1268:	//if card is not trashed, added to Played pile 
       54: 1269:	if (trashFlag < 1)
        -: 1270:	{
        -: 1271:		//add card to played pile
       30: 1272:		state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
       30: 1273:		state->playedCardCount++;
        -: 1274:	}
        -: 1275:
        -: 1276:	//set played card to -1
       54: 1277:	state->hand[currentPlayer][handPos] = -1;
        -: 1278:
        -: 1279:	//remove card from player's hand
       54: 1280:	if (handPos == (state->handCount[currentPlayer] - 1)) 	//last card in hand array is played
        -: 1281:	{
        -: 1282:		//reduce number of cards in hand
        2: 1283:		state->handCount[currentPlayer]--;
        -: 1284:	}
       52: 1285:	else if (state->handCount[currentPlayer] == 1) //only one card in hand
        -: 1286:	{
        -: 1287:		//reduce number of cards in hand
    #####: 1288:		state->handCount[currentPlayer]--;
        -: 1289:	}
        -: 1290:	else
        -: 1291:	{
        -: 1292:		//replace discarded card with last card in hand
       52: 1293:		state->hand[currentPlayer][handPos] = state->hand[currentPlayer][(state->handCount[currentPlayer] - 1)];
        -: 1294:		//set last card to -1
       52: 1295:		state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1296:		//reduce number of cards in hand
       52: 1297:		state->handCount[currentPlayer]--;
        -: 1298:	}
        -: 1299:
       54: 1300:	return 0;
        -: 1301:}
        -: 1302:
      213: 1303:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1304:{
        -: 1305:	//Note: supplyPos is enum of choosen card
        -: 1306:
        -: 1307:	//check if supply pile is empty (0) or card is not used in game (-1)
      213: 1308:	if (supplyCount(supplyPos, state) < 1)
        -: 1309:	{
        2: 1310:		return -1;
        -: 1311:	}
        -: 1312:
        -: 1313:	//added card for [whoseTurn] current player:
        -: 1314:	// toFlag = 0 : add to discard
        -: 1315:	// toFlag = 1 : add to deck
        -: 1316:	// toFlag = 2 : add to hand
        -: 1317:
      211: 1318:	if (toFlag == 1)
        -: 1319:	{
        9: 1320:		state->deck[player][state->deckCount[player]] = supplyPos;
        9: 1321:		state->deckCount[player]++;
        -: 1322:	}
      202: 1323:	else if (toFlag == 2)
        -: 1324:	{
    #####: 1325:		state->hand[player][state->handCount[player]] = supplyPos;
    #####: 1326:		state->handCount[player]++;
        -: 1327:	}
        -: 1328:	else
        -: 1329:	{
      202: 1330:		state->discard[player][state->discardCount[player]] = supplyPos;
      202: 1331:		state->discardCount[player]++;
        -: 1332:	}
        -: 1333:
        -: 1334:	//decrease number in supply pile
      211: 1335:	state->supplyCount[supplyPos]--;
        -: 1336:
      211: 1337:	return 0;
        -: 1338:}
        -: 1339:
      278: 1340:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1341:{
        -: 1342:	int i;
        -: 1343:
        -: 1344:	//reset coin count
      278: 1345:	state->coins = 0;
        -: 1346:
        -: 1347:	//add coins for each Treasure card in player's hand
     1649: 1348:	for (i = 0; i < state->handCount[player]; i++)
        -: 1349:	{
     1371: 1350:		if (state->hand[player][i] == copper)
        -: 1351:		{
      589: 1352:			state->coins += 1;
        -: 1353:		}
      782: 1354:		else if (state->hand[player][i] == silver)
        -: 1355:		{
       60: 1356:			state->coins += 2;
        -: 1357:		}
      722: 1358:		else if (state->hand[player][i] == gold)
        -: 1359:		{
       48: 1360:			state->coins += 3;
        -: 1361:		}
        -: 1362:	}
        -: 1363:
        -: 1364:	//add bonus
      278: 1365:	state->coins += bonus;
        -: 1366:
      278: 1367:	return 0;
        -: 1368:}
        -: 1369:
        -: 1370:
        -: 1371://end of dominion.c
File 'dominion.c'
Lines executed:65.53% of 557
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
     3602:    8:int compare(const void* a, const void* b) {
     3602:    9:	if (*(int*)a > *(int*)b)
     1226:   10:		return 1;
     2376:   11:	if (*(int*)a < *(int*)b)
     1118:   12:		return -1;
     1258:   13:	return 0;
        -:   14:}
        -:   15:
        4:   16:struct gameState* newGame() {
        4:   17:	struct gameState* g = malloc(sizeof(struct gameState));
        4:   18:	return g;
        -:   19:}
        -:   20:
       13:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:	int k8, int k9, int k10) {
       13:   23:	int* k = malloc(10 * sizeof(int));
       13:   24:	k[0] = k1;
       13:   25:	k[1] = k2;
       13:   26:	k[2] = k3;
       13:   27:	k[3] = k4;
       13:   28:	k[4] = k5;
       13:   29:	k[5] = k6;
       13:   30:	k[6] = k7;
       13:   31:	k[7] = k8;
       13:   32:	k[8] = k9;
       13:   33:	k[9] = k10;
       13:   34:	return k;
        -:   35:}
        -:   36:
       13:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		struct gameState *state) {
        -:   39:
        -:   40:	int i;
        -:   41:	int j;
        -:   42:	int it;
        -:   43:	//set up random number generator
       13:   44:	SelectStream(1);
       13:   45:	PutSeed((long)randomSeed);
        -:   46:
        -:   47:	//check number of players
       13:   48:	if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:	{
    #####:   50:		return -1;
        -:   51:	}
        -:   52:
        -:   53:	//set number of players
       13:   54:	state->numPlayers = numPlayers;
        -:   55:
        -:   56:	//check selected kingdom cards are different
       42:   57:	for (i = 0; i < 10; i++)
        -:   58:	{
      374:   59:		for (j = 0; j < 10; j++)
        -:   60:		{
      345:   61:			if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:			{
       11:   63:				return -1;
        -:   64:			}
        -:   65:		}
        -:   66:	}
        -:   67:
        -:   68:
        -:   69:	//initialize supply
        -:   70:	///////////////////////////////
        -:   71:
        -:   72:	//set number of Curse cards
        2:   73:	if (numPlayers == 2)
        -:   74:	{
        1:   75:		state->supplyCount[curse] = 10;
        -:   76:	}
        1:   77:	else if (numPlayers == 3)
        -:   78:	{
    #####:   79:		state->supplyCount[curse] = 20;
        -:   80:	}
        -:   81:	else
        -:   82:	{
        1:   83:		state->supplyCount[curse] = 30;
        -:   84:	}
        -:   85:
        -:   86:	//set number of Victory cards
        2:   87:	if (numPlayers == 2)
        -:   88:	{
        1:   89:		state->supplyCount[estate] = 8;
        1:   90:		state->supplyCount[duchy] = 8;
        1:   91:		state->supplyCount[province] = 8;
        -:   92:	}
        -:   93:	else
        -:   94:	{
        1:   95:		state->supplyCount[estate] = 12;
        1:   96:		state->supplyCount[duchy] = 12;
        1:   97:		state->supplyCount[province] = 12;
        -:   98:	}
        -:   99:
        -:  100:	//set number of Treasure cards
        2:  101:	state->supplyCount[copper] = 60 - (7 * numPlayers);
        2:  102:	state->supplyCount[silver] = 40;
        2:  103:	state->supplyCount[gold] = 30;
        -:  104:
        -:  105:	//set number of Kingdom cards
       42:  106:	for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:	{
      330:  108:		for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:		{
      310:  110:			if (kingdomCards[j] == i)
        -:  111:			{
        -:  112:				//check if card is a 'Victory' Kingdom card
       20:  113:				if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:				{
        4:  115:					if (numPlayers == 2){
        1:  116:						state->supplyCount[i] = 8;
        -:  117:					}
        1:  118:					else{ state->supplyCount[i] = 12; }
        -:  119:				}
        -:  120:				else
        -:  121:				{
       18:  122:					state->supplyCount[i] = 10;
        -:  123:				}
       20:  124:				break;
        -:  125:			}
        -:  126:			else    //card is not in the set choosen for the game
        -:  127:			{
      290:  128:				state->supplyCount[i] = -1;
        -:  129:			}
        -:  130:		}
        -:  131:
        -:  132:	}
        -:  133:
        -:  134:	////////////////////////
        -:  135:	//supply intilization complete
        -:  136:
        -:  137:	//set player decks
        8:  138:	for (i = 0; i < numPlayers; i++)
        -:  139:	{
        6:  140:		state->deckCount[i] = 0;
       24:  141:		for (j = 0; j < 3; j++)
        -:  142:		{
       18:  143:			state->deck[i][j] = estate;
       18:  144:			state->deckCount[i]++;
        -:  145:		}
       48:  146:		for (j = 3; j < 10; j++)
        -:  147:		{
       42:  148:			state->deck[i][j] = copper;
       42:  149:			state->deckCount[i]++;
        -:  150:		}
        -:  151:	}
        -:  152:
        -:  153:	//shuffle player decks
        8:  154:	for (i = 0; i < numPlayers; i++)
        -:  155:	{
        6:  156:		if (shuffle(i, state) < 0)
        -:  157:		{
    #####:  158:			return -1;
        -:  159:		}
        -:  160:	}
        -:  161:
        -:  162:	//draw player hands
        8:  163:	for (i = 0; i < numPlayers; i++)
        -:  164:	{
        -:  165:		//initialize hand size to zero
        6:  166:		state->handCount[i] = 0;
        6:  167:		state->discardCount[i] = 0;
        -:  168:		//draw 5 cards
        -:  169:		// for (j = 0; j < 5; j++)
        -:  170:		//	{
        -:  171:		//	  drawCard(i, state);
        -:  172:		//	}
        -:  173:	}
        -:  174:
        -:  175:	//set embargo tokens to 0 for all supply piles
       56:  176:	for (i = 0; i <= treasure_map; i++)
        -:  177:	{
       54:  178:		state->embargoTokens[i] = 0;
        -:  179:	}
        -:  180:
        -:  181:	//initialize first player's turn
        2:  182:	state->outpostPlayed = 0;
        2:  183:	state->phase = 0;
        2:  184:	state->numActions = 1;
        2:  185:	state->numBuys = 1;
        2:  186:	state->playedCardCount = 0;
        2:  187:	state->whoseTurn = 0;
        2:  188:	state->handCount[state->whoseTurn] = 0;
        -:  189:	//int it; move to top
        -:  190:
        -:  191:	//Moved draw cards to here, only drawing at the start of a turn
       12:  192:	for (it = 0; it < 5; it++){
       10:  193:		drawCard(state->whoseTurn, state);
        -:  194:	}
        -:  195:
        2:  196:	updateCoins(state->whoseTurn, state, 0);
        -:  197:
        2:  198:	return 0;
        -:  199:}
        -:  200:
       73:  201:int shuffle(int player, struct gameState *state) {
        -:  202:
        -:  203:
        -:  204:	int newDeck[MAX_DECK];
       73:  205:	int newDeckPos = 0;
        -:  206:	int card;
        -:  207:	int i;
        -:  208:
       73:  209:	if (state->deckCount[player] < 1)
    #####:  210:		return -1;
       73:  211:	qsort((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
        -:  212:	/* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
     1690:  214:	while (state->deckCount[player] > 0) {
     1544:  215:		card = floor(Random() * state->deckCount[player]);
     1544:  216:		newDeck[newDeckPos] = state->deck[player][card];
     1544:  217:		newDeckPos++;
    11827:  218:		for (i = card; i < state->deckCount[player] - 1; i++) {
    10283:  219:			state->deck[player][i] = state->deck[player][i + 1];
        -:  220:		}
     1544:  221:		state->deckCount[player]--;
        -:  222:	}
     1617:  223:	for (i = 0; i < newDeckPos; i++) {
     1544:  224:		state->deck[player][i] = newDeck[i];
     1544:  225:		state->deckCount[player]++;
        -:  226:	}
        -:  227:
       73:  228:	return 0;
        -:  229:}
        -:  230:
     2230:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state)
        -:  232:{
        -:  233:	int card;
     2230:  234:	int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:	//check if it is the right phase
     2230:  237:	if (state->phase != 0)
        -:  238:	{
      217:  239:		return -1;
        -:  240:	}
        -:  241:
        -:  242:	//check if player has enough actions
     2013:  243:	if (state->numActions < 1)
        -:  244:	{
       26:  245:		return -1;
        -:  246:	}
        -:  247:
        -:  248:	//get card played
     1987:  249:	card = handCard(handPos, state);
        -:  250:
        -:  251:	//check if selected card is an action
     1987:  252:	if (card < adventurer || card > treasure_map)
        -:  253:	{
     1842:  254:		return -1;
        -:  255:	}
        -:  256:
        -:  257:	//play card
      145:  258:	if (cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0)
        -:  259:	{
       92:  260:		return -1;
        -:  261:	}
        -:  262:
        -:  263:	//reduce number of actions
       53:  264:	state->numActions--;
        -:  265:
        -:  266:	//update coins (Treasure cards may be added with card draws)
       53:  267:	updateCoins(state->whoseTurn, state, coin_bonus);
        -:  268:
       53:  269:	return 0;
        -:  270:}
        -:  271:
     2178:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:	int who;
        -:  274:	if (DEBUG){
        -:  275:		printf("Entering buyCard...\n");
        -:  276:	}
        -:  277:
        -:  278:	// I don't know what to do about the phase thing.
        -:  279:
     2178:  280:	who = state->whoseTurn;
        -:  281:
     2178:  282:	if (state->numBuys < 1){
        -:  283:		if (DEBUG)
        -:  284:			printf("You do not have any buys left\n");
      216:  285:		return -1;
        -:  286:	}
     1962:  287:	else if (supplyCount(supplyPos, state) < 1){
        -:  288:		if (DEBUG)
        -:  289:			printf("There are not any of that type of card left\n");
      831:  290:		return -1;
        -:  291:	}
     1131:  292:	else if (state->coins < getCost(supplyPos)){
        -:  293:		if (DEBUG)
        -:  294:			printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
      899:  295:		return -1;
        -:  296:	}
        -:  297:	else {
      232:  298:		state->phase = 1;
        -:  299:		//state->supplyCount[supplyPos]--;
      232:  300:		gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  301:
      232:  302:		state->coins = (state->coins) - (getCost(supplyPos));
      232:  303:		state->numBuys--;
        -:  304:		if (DEBUG)
        -:  305:			printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  306:	}
        -:  307:
        -:  308:	//state->discard[who][state->discardCount[who]] = supplyPos;
        -:  309:	//state->discardCount[who]++;
        -:  310:
      232:  311:	return 0;
        -:  312:}
        -:  313:
    #####:  314:int numHandCards(struct gameState *state) {
    #####:  315:	return state->handCount[whoseTurn(state)];
        -:  316:}
        -:  317:
     1993:  318:int handCard(int handPos, struct gameState *state) {
     1993:  319:	int currentPlayer = whoseTurn(state);
     1993:  320:	return state->hand[currentPlayer][handPos];
        -:  321:}
        -:  322:
     2233:  323:int supplyCount(int card, struct gameState *state) {
     2233:  324:	return state->supplyCount[card];
        -:  325:}
        -:  326:
    #####:  327:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  328:	int i;
    #####:  329:	int count = 0;
        -:  330:
    #####:  331:	for (i = 0; i < state->deckCount[player]; i++)
        -:  332:	{
    #####:  333:		if (state->deck[player][i] == card) count++;
        -:  334:	}
        -:  335:
    #####:  336:	for (i = 0; i < state->handCount[player]; i++)
        -:  337:	{
    #####:  338:		if (state->hand[player][i] == card) count++;
        -:  339:	}
        -:  340:
    #####:  341:	for (i = 0; i < state->discardCount[player]; i++)
        -:  342:	{
    #####:  343:		if (state->discard[player][i] == card) count++;
        -:  344:	}
        -:  345:
    #####:  346:	return count;
        -:  347:}
        -:  348:
     2414:  349:int whoseTurn(struct gameState *state) {
     2414:  350:	return state->whoseTurn;
        -:  351:}
        -:  352:
      276:  353:int endTurn(struct gameState *state) {
        -:  354:	int k;
        -:  355:	int i;
      276:  356:	int currentPlayer = whoseTurn(state);
        -:  357:
        -:  358:	//Discard hand
     1621:  359:	for (i = 0; i < state->handCount[currentPlayer]; i++){
     1345:  360:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
     1345:  361:		state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  362:	}
      276:  363:	state->handCount[currentPlayer] = 0;//Reset hand count
        -:  364:
        -:  365:	//Code for determining the player
      276:  366:	if (currentPlayer < (state->numPlayers - 1)){
      171:  367:		state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  368:	}
        -:  369:	else{
      105:  370:		state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  371:	}
        -:  372:
      276:  373:	state->outpostPlayed = 0;
      276:  374:	state->phase = 0;
      276:  375:	state->numActions = 1;
      276:  376:	state->coins = 0;
      276:  377:	state->numBuys = 1;
      276:  378:	state->playedCardCount = 0;
      276:  379:	state->handCount[state->whoseTurn] = 0;
        -:  380:
        -:  381:	//int k; move to top
        -:  382:	//Next player draws hand
     1656:  383:	for (k = 0; k < 5; k++){
     1380:  384:		drawCard(state->whoseTurn, state);//Draw a card
        -:  385:	}
        -:  386:
        -:  387:	//Update money
      276:  388:	updateCoins(state->whoseTurn, state, 0);
        -:  389:
      276:  390:	return 0;
        -:  391:}
        -:  392:
     6693:  393:int isGameOver(struct gameState *state) {
        -:  394:	int i;
        -:  395:	int j;
        -:  396:
        -:  397:	//if stack of Province cards is empty, the game ends
     6693:  398:	if (state->supplyCount[province] == 0)
        -:  399:	{
    #####:  400:		return 1;
        -:  401:	}
        -:  402:
        -:  403:	//if three supply pile are at 0, the game ends
     6693:  404:	j = 0;
   174018:  405:	for (i = 0; i < 25; i++)
        -:  406:	{
   167325:  407:		if (state->supplyCount[i] == 0)
        -:  408:		{
     7495:  409:			j++;
        -:  410:		}
        -:  411:	}
     6693:  412:	if (j >= 3)
        -:  413:	{
        2:  414:		return 1;
        -:  415:	}
        -:  416:
     6691:  417:	return 0;
        -:  418:}
        -:  419:
    #####:  420:int scoreFor(int player, struct gameState *state) {
        -:  421:
        -:  422:	int i;
    #####:  423:	int score = 0;
        -:  424:	//score from hand
    #####:  425:	for (i = 0; i < state->handCount[player]; i++)
        -:  426:	{
    #####:  427:		if (state->hand[player][i] == curse) { score = score - 1; };
    #####:  428:		if (state->hand[player][i] == estate) { score = score + 1; };
    #####:  429:		if (state->hand[player][i] == duchy) { score = score + 3; };
    #####:  430:		if (state->hand[player][i] == province) { score = score + 6; };
    #####:  431:		if (state->hand[player][i] == great_hall) { score = score + 1; };
    #####:  432:		if (state->hand[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  433:	}
        -:  434:
        -:  435:	//score from discard
    #####:  436:	for (i = 0; i < state->discardCount[player]; i++)
        -:  437:	{
    #####:  438:		if (state->discard[player][i] == curse) { score = score - 1; };
    #####:  439:		if (state->discard[player][i] == estate) { score = score + 1; };
    #####:  440:		if (state->discard[player][i] == duchy) { score = score + 3; };
    #####:  441:		if (state->discard[player][i] == province) { score = score + 6; };
    #####:  442:		if (state->discard[player][i] == great_hall) { score = score + 1; };
    #####:  443:		if (state->discard[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  444:	}
        -:  445:
        -:  446:	//score from deck
    #####:  447:	for (i = 0; i < state->discardCount[player]; i++)
        -:  448:	{
    #####:  449:		if (state->deck[player][i] == curse) { score = score - 1; };
    #####:  450:		if (state->deck[player][i] == estate) { score = score + 1; };
    #####:  451:		if (state->deck[player][i] == duchy) { score = score + 3; };
    #####:  452:		if (state->deck[player][i] == province) { score = score + 6; };
    #####:  453:		if (state->deck[player][i] == great_hall) { score = score + 1; };
    #####:  454:		if (state->deck[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  455:	}
        -:  456:
    #####:  457:	return score;
        -:  458:}
        -:  459:
    #####:  460:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  461:	int i;
        -:  462:	int j;
        -:  463:	int highScore;
        -:  464:	int currentPlayer;
        -:  465:
        -:  466:	//get score for each player
    #####:  467:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  468:	{
        -:  469:		//set unused player scores to -9999
    #####:  470:		if (i >= state->numPlayers)
        -:  471:		{
    #####:  472:			players[i] = -9999;
        -:  473:		}
        -:  474:		else
        -:  475:		{
    #####:  476:			players[i] = scoreFor(i, state);
        -:  477:		}
        -:  478:	}
        -:  479:
        -:  480:	//find highest score
    #####:  481:	j = 0;
    #####:  482:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  483:	{
    #####:  484:		if (players[i] > players[j])
        -:  485:		{
    #####:  486:			j = i;
        -:  487:		}
        -:  488:	}
    #####:  489:	highScore = players[j];
        -:  490:
        -:  491:	//add 1 to players who had less turns
    #####:  492:	currentPlayer = whoseTurn(state);
    #####:  493:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  494:	{
    #####:  495:		if (players[i] == highScore && i > currentPlayer)
        -:  496:		{
    #####:  497:			players[i]++;
        -:  498:		}
        -:  499:	}
        -:  500:
        -:  501:	//find new highest score
    #####:  502:	j = 0;
    #####:  503:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  504:	{
    #####:  505:		if (players[i] > players[j])
        -:  506:		{
    #####:  507:			j = i;
        -:  508:		}
        -:  509:	}
    #####:  510:	highScore = players[j];
        -:  511:
        -:  512:	//set winners in array to 1 and rest to 0
    #####:  513:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  514:	{
    #####:  515:		if (players[i] == highScore)
        -:  516:		{
    #####:  517:			players[i] = 1;
        -:  518:		}
        -:  519:		else
        -:  520:		{
    #####:  521:			players[i] = 0;
        -:  522:		}
        -:  523:	}
        -:  524:
    #####:  525:	return 0;
        -:  526:}
        -:  527:
     1399:  528:int drawCard(int player, struct gameState *state)
        -:  529:{
        -:  530:	int count;
        -:  531:	int deckCounter;
     1399:  532:	if (state->deckCount[player] <= 0){//Deck is empty
        -:  533:
        -:  534:		//Step 1 Shuffle the discard pile back into a deck
        -:  535:		int i;
        -:  536:		//Move discard to deck
     1551:  537:		for (i = 0; i < state->discardCount[player]; i++){
     1484:  538:			state->deck[player][i] = state->discard[player][i];
     1484:  539:			state->discard[player][i] = -1;
        -:  540:		}
        -:  541:
       67:  542:		state->deckCount[player] = state->discardCount[player];
       67:  543:		state->discardCount[player] = 0;//Reset discard
        -:  544:
        -:  545:		//Shufffle the deck
       67:  546:		shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  547:
        -:  548:		if (DEBUG){//Debug statements
        -:  549:			printf("Deck count now: %d\n", state->deckCount[player]);
        -:  550:		}
        -:  551:
       67:  552:		state->discardCount[player] = 0;
        -:  553:
        -:  554:		//Step 2 Draw Card
       67:  555:		count = state->handCount[player];//Get current player's hand count
        -:  556:
        -:  557:		if (DEBUG){//Debug statements
        -:  558:			printf("Current hand count: %d\n", count);
        -:  559:		}
        -:  560:
       67:  561:		deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  562:
       67:  563:		if (deckCounter == 0)
    #####:  564:			return -1;
        -:  565:
       67:  566:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
       67:  567:		state->deckCount[player]--;
       67:  568:		state->handCount[player]++;//Increment hand count
        -:  569:	}
        -:  570:
        -:  571:	else{
     1332:  572:		int count = state->handCount[player];//Get current hand count for player
        -:  573:		int deckCounter;
        -:  574:		if (DEBUG){//Debug statements
        -:  575:			printf("Current hand count: %d\n", count);
        -:  576:		}
        -:  577:
     1332:  578:		deckCounter = state->deckCount[player];//Create holder for the deck count
     1332:  579:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
     1332:  580:		state->deckCount[player]--;
     1332:  581:		state->handCount[player]++;//Increment hand count
        -:  582:	}
        -:  583:
     1399:  584:	return 0;
        -:  585:}
        -:  586:
     1372:  587:int getCost(int cardNumber)
        -:  588:{
     1372:  589:	switch (cardNumber)
        -:  590:	{
        -:  591:	case curse:
       73:  592:		return 0;
        -:  593:	case estate:
       44:  594:		return 2;
        -:  595:	case duchy:
       75:  596:		return 5;
        -:  597:	case province:
       86:  598:		return 8;
        -:  599:	case copper:
      136:  600:		return 0;
        -:  601:	case silver:
       93:  602:		return 3;
        -:  603:	case gold:
       89:  604:		return 6;
        -:  605:	case adventurer:
       36:  606:		return 6;
        -:  607:	case council_room:
       22:  608:		return 5;
        -:  609:	case feast:
       41:  610:		return 4;
        -:  611:	case gardens:
       86:  612:		return 4;
        -:  613:	case mine:
       35:  614:		return 5;
        -:  615:	case remodel:
       45:  616:		return 4;
        -:  617:	case smithy:
       63:  618:		return 4;
        -:  619:	case village:
    #####:  620:		return 3;
        -:  621:	case baron:
       88:  622:		return 4;
        -:  623:	case great_hall:
    #####:  624:		return 3;
        -:  625:	case minion:
       22:  626:		return 5;
        -:  627:	case steward:
    #####:  628:		return 3;
        -:  629:	case tribute:
       33:  630:		return 5;
        -:  631:	case ambassador:
       36:  632:		return 3;
        -:  633:	case cutpurse:
       30:  634:		return 4;
        -:  635:	case embargo:
    #####:  636:		return 2;
        -:  637:	case outpost:
    #####:  638:		return 5;
        -:  639:	case salvager:
       81:  640:		return 4;
        -:  641:	case sea_hag:
       80:  642:		return 4;
        -:  643:	case treasure_map:
       78:  644:		return 4;
        -:  645:	}
        -:  646:
    #####:  647:	return -1;
        -:  648:}
        -:  649:
    #####:  650:void playAdventurer(struct gameState *state, int currentPlayer)
        -:  651:// Reveal cards from deck until 2 Treasure cards are found.  Put those Treasure cards in the hand and discard the rest.
        -:  652:{
    #####:  653:	int drawntreasure = 0;
        -:  654:	int temphand[MAX_HAND];
        -:  655:	int cardDrawn;
    #####:  656:	int z = 0; // this is the counter for the temp hand
        -:  657:
    #####:  658:	while (drawntreasure < 2){
    #####:  659:		if (state->deckCount[currentPlayer] < 1){//if the deck is empty we need to shuffle discard and add to deck
    #####:  660:			shuffle(currentPlayer, state);
        -:  661:		}
    #####:  662:		drawCard(currentPlayer, state);
    #####:  663:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer] - 1];//top card of hand is most recently drawn card.
    #####:  664:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
    #####:  665:			drawntreasure++;
        -:  666:		else{
    #####:  667:			temphand[z] = cardDrawn;
    #####:  668:			state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####:  669:			z++;
        -:  670:		}
        -:  671:	}
    #####:  672:	while (z - 1 >= 0){
    #####:  673:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; // discard all cards in play that have been drawn
    #####:  674:		z = z - 1;
        -:  675:	}
    #####:  676:}
        -:  677:
        1:  678:int playRemodel(struct gameState *state, int currentPlayer, int choice1, int choice2, int handPos)
        -:  679://Trash a card in the hand, and gain a card costing up to $2 more than the trashed card
        -:  680:{
        -:  681:	int i;
        1:  682:	int j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  683:
        1:  684:	if ((getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2))
        -:  685:	{
    #####:  686:		return -1;
        -:  687:	}
        -:  688:
        1:  689:	gainCard(choice2, state, 0, currentPlayer);
        -:  690:
        -:  691:	//discard card from hand
        1:  692:	discardCard(handPos, currentPlayer, state, 0);
        -:  693:
        -:  694:	//discard trashed card
        5:  695:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  696:	{
        4:  697:		if (state->hand[currentPlayer][i] == j)
        -:  698:		{
    #####:  699:			discardCard(i, currentPlayer, state, 0);
    #####:  700:			break;
        -:  701:		}
        -:  702:	}
        -:  703:
        1:  704:	return 0;
        -:  705:}
        -:  706:
        3:  707:void playSmithy(struct gameState *state, int currentPlayer, int handPos)
        -:  708:// Draw 3 cards
        -:  709:{
        -:  710:	int i;
       12:  711:	for (i = 0; i < 3; i++)
        -:  712:	{
        9:  713:		drawCard(currentPlayer, state);
        -:  714:	}
        -:  715:
        -:  716:	//discard card from hand
        3:  717:	discardCard(handPos, currentPlayer, state, 0);
        3:  718:}
        -:  719:
       20:  720:void playBaron(struct gameState *state, int currentPlayer, int choice1, int handPos)
        -:  721://Add a buy.  OPTION:  Discard an Estate card and gain $4.  Otherwise, gain an Estate card.
        -:  722:{
       20:  723:	state->numBuys++;//Increase buys by 1!
       20:  724:	if (choice1 > 0){//Boolean true or going to discard an estate
       19:  725:		int p = 0;//Iterator for hand!
       19:  726:		int card_not_discarded = 1;//Flag for discard set!
      106:  727:		while (card_not_discarded){
       68:  728:			if (state->hand[currentPlayer][p] == estate){ //Found an estate card!
       14:  729:				state->coins += 4;//Add 4 coins to the amount of coins
       14:  730:				state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
       14:  731:				state->discardCount[currentPlayer]++;
       65:  732:				for (; p < state->handCount[currentPlayer]; p++){
       51:  733:					state->hand[currentPlayer][p] = state->hand[currentPlayer][p + 1];
        -:  734:				}
       14:  735:				state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
       14:  736:				state->handCount[currentPlayer]--;
       14:  737:				card_not_discarded = 0;//Exit the loop
        -:  738:			}
       54:  739:			else if (p > state->handCount[currentPlayer]){
        -:  740:				if (DEBUG) {
        -:  741:					printf("No estate cards in your hand, invalid choice\n");
        -:  742:					printf("Must gain an estate if there are any\n");
        -:  743:				}
        5:  744:				if (supplyCount(estate, state) > 0){
    #####:  745:					gainCard(estate, state, 1, currentPlayer);
    #####:  746:					state->supplyCount[estate]--;//Decrement estates
    #####:  747:					if (supplyCount(estate, state) == 0){
    #####:  748:						isGameOver(state);
        -:  749:					}
        -:  750:				}
        5:  751:				card_not_discarded = 0;//Exit the loop
        -:  752:			}
        -:  753:
        -:  754:			else{
       49:  755:				p++;//Next card
        -:  756:			}
        -:  757:		}
        -:  758:	}
        -:  759:
        -:  760:	else{
        1:  761:		if (supplyCount(estate, state) > 0){
        1:  762:			gainCard(estate, state, 0, currentPlayer);//Gain an estate
        1:  763:			state->supplyCount[estate]--;//Decrement Estates
        1:  764:			if (supplyCount(estate, state) == 0){
    #####:  765:				isGameOver(state);
        -:  766:			}
        -:  767:		}
        -:  768:	}
       20:  769:}
        -:  770:
        5:  771:int playTreasureMap(struct gameState *state, int currentPlayer, int handPos)
        -:  772://Trashing two treasure map cards from the hand = four gold on top of the deck.
        -:  773:{
        -:  774:	int i;
        -:  775:	int index;
        -:  776:
        -:  777:	//search hand for another treasure_map
       30:  778:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  779:	{
       25:  780:		if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -:  781:		{
    #####:  782:			index = i;
    #####:  783:			break;
        -:  784:		}
        -:  785:	}
        5:  786:	if (index > -1)
        -:  787:	{
        -:  788:		//trash both treasure cards
        5:  789:		discardCard(handPos, currentPlayer, state, 1);
        5:  790:		discardCard(index, currentPlayer, state, 1);
        -:  791:
        -:  792:		//gain 4 Gold cards
       25:  793:		for (i = 0; i < 4; i++)
        -:  794:		{
       20:  795:			gainCard(gold, state, 1, currentPlayer);
        -:  796:		}
        -:  797:
        -:  798:		//return success
        5:  799:		return 1;
        -:  800:	}
        -:  801:
        -:  802:	//no second treasure_map found in hand
    #####:  803:	return -1;
        -:  804:}
        -:  805:
      145:  806:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  807:{
        -:  808:	int i;
        -:  809:	int j;
        -:  810:	int k;
        -:  811:	//int x;  //Unused after while loop removed from feast.
      145:  812:	int currentPlayer = whoseTurn(state);
      145:  813:	int nextPlayer = currentPlayer + 1;
        -:  814:	int temphand[MAX_HAND];
        -:  815:
      145:  816:	int tributeRevealedCards[2] = { -1, -1 };
        -:  817:
      145:  818:	if (nextPlayer > (state->numPlayers - 1)){
       65:  819:		nextPlayer = 0;
        -:  820:	}
        -:  821:
        -:  822:	//uses switch to select card and perform actions
      145:  823:	switch (card)
        -:  824:	{
        -:  825:	case adventurer:
        -:  826:
    #####:  827:		playAdventurer(state, currentPlayer);
    #####:  828:		return 0;
        -:  829:
        -:  830:	case council_room:
        -:  831:		//+4 Cards
    #####:  832:		for (i = 0; i < 4; i++)
        -:  833:		{
    #####:  834:			drawCard(currentPlayer, state);
        -:  835:		}
        -:  836:
        -:  837:		//+1 Buy
    #####:  838:		state->numBuys++;
        -:  839:
        -:  840:		//Each other player draws a card
    #####:  841:		for (i = 0; i < state->numPlayers; i++)
        -:  842:		{
    #####:  843:			if (i != currentPlayer)
        -:  844:			{
    #####:  845:				drawCard(i, state);
        -:  846:			}
        -:  847:		}
        -:  848:
        -:  849:		//put played card in played card pile
    #####:  850:		discardCard(handPos, currentPlayer, state, 0);
        -:  851:
    #####:  852:		return 0;
        -:  853:
        -:  854:	case feast:
        -:  855:		//gain card with cost up to 5
        -:  856:		//Backup hand
       21:  857:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
       18:  858:			temphand[i] = state->hand[currentPlayer][i];//Backup card
       18:  859:			state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  860:		}
        -:  861:		//Backup hand
        -:  862:
        -:  863:		//Update Coins for Buy
        3:  864:		updateCoins(currentPlayer, state, 5);
        -:  865://		x = 1;//Condition to loop on
        -:  866://		while (x == 1) {//Buy one card
        3:  867:			if (supplyCount(choice1, state) <= 0){
        -:  868:				if (DEBUG)
        -:  869:					printf("None of that card left, sorry!\n");
        -:  870:
        -:  871:				if (DEBUG){
        -:  872:					printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  873:				}
        -:  874:			}
        1:  875:			else if (state->coins < getCost(choice1)){
    #####:  876:				printf("That card is too expensive!\n");
        -:  877:
        -:  878:				if (DEBUG){
        -:  879:					printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  880:				}
        -:  881:			}
        -:  882:			else{
        -:  883:
        -:  884:				if (DEBUG){
        -:  885:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  886:				}
        -:  887:
        1:  888:				gainCard(choice1, state, 0, currentPlayer);//Gain the card
        -:  889://				x = 0;//No more buying cards
        -:  890:
        -:  891:				if (DEBUG){
        -:  892:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  893:				}
        -:  894:
        -:  895:			}
        -:  896://		}
        -:  897:
        -:  898:		//Reset Hand
       21:  899:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
       18:  900:			state->hand[currentPlayer][i] = temphand[i];
       18:  901:			temphand[i] = -1;
        -:  902:		}
        -:  903:		//Reset Hand
        -:  904:
        3:  905:		return 0;
        -:  906:
        -:  907:	case gardens:
       55:  908:		return -1;
        -:  909:
        -:  910:	case mine:
    #####:  911:		j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  912:
    #####:  913:		if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  914:		{
    #####:  915:			return -1;
        -:  916:		}
        -:  917:
    #####:  918:		if (choice2 > treasure_map || choice2 < curse)
        -:  919:		{
    #####:  920:			return -1;
        -:  921:		}
        -:  922:
    #####:  923:		if ((getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2))
        -:  924:		{
    #####:  925:			return -1;
        -:  926:		}
        -:  927:
    #####:  928:		gainCard(choice2, state, 2, currentPlayer);
        -:  929:
        -:  930:		//discard card from hand
    #####:  931:		discardCard(handPos, currentPlayer, state, 0);
        -:  932:
        -:  933:		//discard trashed card
    #####:  934:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  935:		{
    #####:  936:			if (state->hand[currentPlayer][i] == j)
        -:  937:			{
    #####:  938:				discardCard(i, currentPlayer, state, 0);
    #####:  939:				break;
        -:  940:			}
        -:  941:		}
        -:  942:
    #####:  943:		return 0;
        -:  944:
        -:  945:	case remodel:
        -:  946:
        1:  947:		return playRemodel(state, currentPlayer, choice1, choice2, handPos);
        -:  948:
        -:  949:	case smithy:
        -:  950:
        3:  951:		playSmithy(state, currentPlayer, handPos);
        3:  952:		return 0;
        -:  953:
        -:  954:	case village:
        -:  955:		//+1 Card
    #####:  956:		drawCard(currentPlayer, state);
        -:  957:
        -:  958:		//+2 Actions
    #####:  959:		state->numActions = state->numActions + 2;
        -:  960:
        -:  961:		//discard played card from hand
    #####:  962:		discardCard(handPos, currentPlayer, state, 0);
    #####:  963:		return 0;
        -:  964:
        -:  965:	case baron:
        -:  966:
       20:  967:		playBaron(state, currentPlayer, choice1, handPos);
       20:  968:		return 0;
        -:  969:
        -:  970:	case great_hall:
        -:  971:		//+1 Card
    #####:  972:		drawCard(currentPlayer, state);
        -:  973:
        -:  974:		//+1 Actions
    #####:  975:		state->numActions++;
        -:  976:
        -:  977:		//discard card from hand
    #####:  978:		discardCard(handPos, currentPlayer, state, 0);
    #####:  979:		return 0;
        -:  980:
        -:  981:	case minion:
        -:  982:		//+1 action
        1:  983:		state->numActions++;
        -:  984:
        -:  985:		//discard card from hand
        1:  986:		discardCard(handPos, currentPlayer, state, 0);
        -:  987:
        1:  988:		if (choice1)		//+2 coins
        -:  989:		{
        1:  990:			state->coins = state->coins + 2;
        -:  991:		}
        -:  992:
    #####:  993:		else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  994:		{
        -:  995:			//discard hand
    #####:  996:			while (numHandCards(state) > 0)
        -:  997:			{
    #####:  998:				discardCard(handPos, currentPlayer, state, 0);
        -:  999:			}
        -: 1000:
        -: 1001:			//draw 4
    #####: 1002:			for (i = 0; i < 4; i++)
        -: 1003:			{
    #####: 1004:				drawCard(currentPlayer, state);
        -: 1005:			}
        -: 1006:
        -: 1007:			//other players discard hand and redraw if hand size > 4
    #####: 1008:			for (i = 0; i < state->numPlayers; i++)
        -: 1009:			{
    #####: 1010:				if (i != currentPlayer)
        -: 1011:				{
    #####: 1012:					if (state->handCount[i] > 4)
        -: 1013:					{
        -: 1014:						//discard hand
    #####: 1015:						while (state->handCount[i] > 0)
        -: 1016:						{
    #####: 1017:							discardCard(handPos, i, state, 0);
        -: 1018:						}
        -: 1019:
        -: 1020:						//draw 4
    #####: 1021:						for (j = 0; j < 4; j++)
        -: 1022:						{
    #####: 1023:							drawCard(i, state);
        -: 1024:						}
        -: 1025:					}
        -: 1026:				}
        -: 1027:			}
        -: 1028:
        -: 1029:		}
        1: 1030:		return 0;
        -: 1031:
        -: 1032:	case steward:
    #####: 1033:		if (choice1 == 1)
        -: 1034:		{
        -: 1035:			//+2 cards
    #####: 1036:			drawCard(currentPlayer, state);
    #####: 1037:			drawCard(currentPlayer, state);
        -: 1038:		}
    #####: 1039:		else if (choice1 == 2)
        -: 1040:		{
        -: 1041:			//+2 coins
    #####: 1042:			state->coins = state->coins + 2;
        -: 1043:		}
        -: 1044:		else
        -: 1045:		{
        -: 1046:			//trash 2 cards in hand
    #####: 1047:			discardCard(choice2, currentPlayer, state, 1);
    #####: 1048:			discardCard(choice3, currentPlayer, state, 1);
        -: 1049:		}
        -: 1050:
        -: 1051:		//discard card from hand
    #####: 1052:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1053:		return 0;
        -: 1054:
        -: 1055:	case tribute:
        2: 1056:		if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####: 1057:			if (state->deckCount[nextPlayer] > 0){
    #####: 1058:				tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1059:				state->deckCount[nextPlayer]--;
        -: 1060:			}
    #####: 1061:			else if (state->discardCount[nextPlayer] > 0){
    #####: 1062:				tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer] - 1];
    #####: 1063:				state->discardCount[nextPlayer]--;
        -: 1064:			}
        -: 1065:			else{
        -: 1066:				//No Card to Reveal
        -: 1067:				if (DEBUG){
        -: 1068:					printf("No cards to reveal\n");
        -: 1069:				}
        -: 1070:			}
        -: 1071:		}
        -: 1072:
        -: 1073:		else{
        2: 1074:			if (state->deckCount[nextPlayer] == 0){
    #####: 1075:				for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####: 1076:					state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1077:					state->deckCount[nextPlayer]++;
    #####: 1078:					state->discard[nextPlayer][i] = -1;
    #####: 1079:					state->discardCount[nextPlayer]--;
        -: 1080:				}
        -: 1081:
    #####: 1082:				shuffle(nextPlayer, state);//Shuffle the deck
        -: 1083:			}
        2: 1084:			tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
        2: 1085:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
        2: 1086:			state->deckCount[nextPlayer]--;
        2: 1087:			tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
        2: 1088:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
        2: 1089:			state->deckCount[nextPlayer]--;
        -: 1090:		}
        -: 1091:
        2: 1092:		if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
        1: 1093:			state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
        1: 1094:			state->playedCardCount++;
        1: 1095:			tributeRevealedCards[1] = -1;
        -: 1096:		}
        -: 1097:
        8: 1098:		for (i = 0; i <= 2; i++){
        6: 1099:			if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
        4: 1100:				state->coins += 2;
        -: 1101:			}
        -: 1102:
        2: 1103:			else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
    #####: 1104:				drawCard(currentPlayer, state);
    #####: 1105:				drawCard(currentPlayer, state);
        -: 1106:			}
        -: 1107:			else{//Action Card
        2: 1108:				state->numActions = state->numActions + 2;
        -: 1109:			}
        -: 1110:		}
        -: 1111:
        2: 1112:		return 0;
        -: 1113:
        -: 1114:	case ambassador:
       39: 1115:		j = 0;		//used to check if player has enough cards to discard
        -: 1116:
       39: 1117:		if (choice2 > 2 || choice2 < 0)
        -: 1118:		{
       36: 1119:			return -1;
        -: 1120:		}
        -: 1121:
        3: 1122:		if (choice1 == handPos)
        -: 1123:		{
    #####: 1124:			return -1;
        -: 1125:		}
        -: 1126:
       18: 1127:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1128:		{
       15: 1129:			if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1130:			{
        2: 1131:				j++;
        -: 1132:			}
        -: 1133:		}
        3: 1134:		if (j < choice2)
        -: 1135:		{
        1: 1136:			return -1;
        -: 1137:		}
        -: 1138:
        -: 1139:		if (DEBUG)
        -: 1140:			printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1141:
        -: 1142:		//increase supply count for choosen card by amount being discarded
        2: 1143:		state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1144:
        -: 1145:		//each other player gains a copy of revealed card
       10: 1146:		for (i = 0; i < state->numPlayers; i++)
        -: 1147:		{
        8: 1148:			if (i != currentPlayer)
        -: 1149:			{
        6: 1150:				gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1151:			}
        -: 1152:		}
        -: 1153:
        -: 1154:		//discard played card from hand
        2: 1155:		discardCard(handPos, currentPlayer, state, 0);
        -: 1156:
        -: 1157:		//trash copies of cards returned to supply
        2: 1158:		for (j = 0; j < choice2; j++)
        -: 1159:		{
    #####: 1160:			for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1161:			{
    #####: 1162:				if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1163:				{
    #####: 1164:					discardCard(i, currentPlayer, state, 1);
    #####: 1165:					break;
        -: 1166:				}
        -: 1167:			}
        -: 1168:		}
        -: 1169:
        2: 1170:		return 0;
        -: 1171:
        -: 1172:	case cutpurse:
        -: 1173:
        1: 1174:		updateCoins(currentPlayer, state, 2);
        5: 1175:		for (i = 0; i < state->numPlayers; i++)
        -: 1176:		{
        4: 1177:			if (i != currentPlayer)
        -: 1178:			{
        3: 1179:				for (j = 0; j < state->handCount[i]; j++)
        -: 1180:				{
    #####: 1181:					if (state->hand[i][j] == copper)
        -: 1182:					{
    #####: 1183:						discardCard(j, i, state, 0);
    #####: 1184:						break;
        -: 1185:					}
    #####: 1186:					if (j == state->handCount[i])
        -: 1187:					{
    #####: 1188:						for (k = 0; k < state->handCount[i]; k++)
        -: 1189:						{
        -: 1190:							if (DEBUG)
        -: 1191:								printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1192:						}
    #####: 1193:						break;
        -: 1194:					}
        -: 1195:				}
        -: 1196:
        -: 1197:			}
        -: 1198:
        -: 1199:		}
        -: 1200:
        -: 1201:		//discard played card from hand
        1: 1202:		discardCard(handPos, currentPlayer, state, 0);
        -: 1203:
        1: 1204:		return 0;
        -: 1205:
        -: 1206:
        -: 1207:	case embargo:
        -: 1208:		//+2 Coins
    #####: 1209:		state->coins = state->coins + 2;
        -: 1210:
        -: 1211:		//see if selected pile is in play
    #####: 1212:		if (state->supplyCount[choice1] == -1)
        -: 1213:		{
    #####: 1214:			return -1;
        -: 1215:		}
        -: 1216:
        -: 1217:		//add embargo token to selected supply pile
    #####: 1218:		state->embargoTokens[choice1]++;
        -: 1219:
        -: 1220:		//trash card
    #####: 1221:		discardCard(handPos, currentPlayer, state, 1);
    #####: 1222:		return 0;
        -: 1223:
        -: 1224:	case outpost:
        -: 1225:		//set outpost flag
    #####: 1226:		state->outpostPlayed++;
        -: 1227:
        -: 1228:		//discard card
    #####: 1229:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1230:		return 0;
        -: 1231:
        -: 1232:	case salvager:
        -: 1233:		//+1 buy
        6: 1234:		state->numBuys++;
        -: 1235:
        6: 1236:		if (choice1)
        -: 1237:		{
        -: 1238:			//gain coins equal to trashed card
        6: 1239:			state->coins = state->coins + getCost(handCard(choice1, state));
        -: 1240:			//trash card
        6: 1241:			discardCard(choice1, currentPlayer, state, 1);
        -: 1242:		}
        -: 1243:
        -: 1244:		//discard card
        6: 1245:		discardCard(handPos, currentPlayer, state, 0);
        6: 1246:		return 0;
        -: 1247:
        -: 1248:	case sea_hag:
       33: 1249:		for (i = 0; i < state->numPlayers; i++){
       24: 1250:			if (i != currentPlayer){
       15: 1251:				state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
       15: 1252:				state->discardCount[i]++;
       15: 1253:				state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1254:			}
        -: 1255:		}
        9: 1256:		return 0;
        -: 1257:
        -: 1258:	case treasure_map:
        -: 1259:
        5: 1260:		return playTreasureMap(state, currentPlayer, handPos);
        -: 1261:	}
    #####: 1262:	return -1;
        -: 1263:}
        -: 1264:
       30: 1265:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1266:{
        -: 1267:
        -: 1268:	//if card is not trashed, added to Played pile 
       30: 1269:	if (trashFlag < 1)
        -: 1270:	{
        -: 1271:		//add card to played pile
       14: 1272:		state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
       14: 1273:		state->playedCardCount++;
        -: 1274:	}
        -: 1275:
        -: 1276:	//set played card to -1
       30: 1277:	state->hand[currentPlayer][handPos] = -1;
        -: 1278:
        -: 1279:	//remove card from player's hand
       30: 1280:	if (handPos == (state->handCount[currentPlayer] - 1)) 	//last card in hand array is played
        -: 1281:	{
        -: 1282:		//reduce number of cards in hand
        6: 1283:		state->handCount[currentPlayer]--;
        -: 1284:	}
       24: 1285:	else if (state->handCount[currentPlayer] == 1) //only one card in hand
        -: 1286:	{
        -: 1287:		//reduce number of cards in hand
    #####: 1288:		state->handCount[currentPlayer]--;
        -: 1289:	}
        -: 1290:	else
        -: 1291:	{
        -: 1292:		//replace discarded card with last card in hand
       24: 1293:		state->hand[currentPlayer][handPos] = state->hand[currentPlayer][(state->handCount[currentPlayer] - 1)];
        -: 1294:		//set last card to -1
       24: 1295:		state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1296:		//reduce number of cards in hand
       24: 1297:		state->handCount[currentPlayer]--;
        -: 1298:	}
        -: 1299:
       30: 1300:	return 0;
        -: 1301:}
        -: 1302:
      261: 1303:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1304:{
        -: 1305:	//Note: supplyPos is enum of choosen card
        -: 1306:
        -: 1307:	//check if supply pile is empty (0) or card is not used in game (-1)
      261: 1308:	if (supplyCount(supplyPos, state) < 1)
        -: 1309:	{
    #####: 1310:		return -1;
        -: 1311:	}
        -: 1312:
        -: 1313:	//added card for [whoseTurn] current player:
        -: 1314:	// toFlag = 0 : add to discard
        -: 1315:	// toFlag = 1 : add to deck
        -: 1316:	// toFlag = 2 : add to hand
        -: 1317:
      261: 1318:	if (toFlag == 1)
        -: 1319:	{
       20: 1320:		state->deck[player][state->deckCount[player]] = supplyPos;
       20: 1321:		state->deckCount[player]++;
        -: 1322:	}
      241: 1323:	else if (toFlag == 2)
        -: 1324:	{
    #####: 1325:		state->hand[player][state->handCount[player]] = supplyPos;
    #####: 1326:		state->handCount[player]++;
        -: 1327:	}
        -: 1328:	else
        -: 1329:	{
      241: 1330:		state->discard[player][state->discardCount[player]] = supplyPos;
      241: 1331:		state->discardCount[player]++;
        -: 1332:	}
        -: 1333:
        -: 1334:	//decrease number in supply pile
      261: 1335:	state->supplyCount[supplyPos]--;
        -: 1336:
      261: 1337:	return 0;
        -: 1338:}
        -: 1339:
      335: 1340:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1341:{
        -: 1342:	int i;
        -: 1343:
        -: 1344:	//reset coin count
      335: 1345:	state->coins = 0;
        -: 1346:
        -: 1347:	//add coins for each Treasure card in player's hand
     1975: 1348:	for (i = 0; i < state->handCount[player]; i++)
        -: 1349:	{
     1640: 1350:		if (state->hand[player][i] == copper)
        -: 1351:		{
      709: 1352:			state->coins += 1;
        -: 1353:		}
      931: 1354:		else if (state->hand[player][i] == silver)
        -: 1355:		{
      100: 1356:			state->coins += 2;
        -: 1357:		}
      831: 1358:		else if (state->hand[player][i] == gold)
        -: 1359:		{
       58: 1360:			state->coins += 3;
        -: 1361:		}
        -: 1362:	}
        -: 1363:
        -: 1364:	//add bonus
      335: 1365:	state->coins += bonus;
        -: 1366:
      335: 1367:	return 0;
        -: 1368:}
        -: 1369:
        -: 1370:
        -: 1371://end of dominion.c
File 'dominion.c'
Lines executed:65.53% of 557
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
     4160:    8:int compare(const void* a, const void* b) {
     4160:    9:	if (*(int*)a > *(int*)b)
     1751:   10:		return 1;
     2409:   11:	if (*(int*)a < *(int*)b)
     1121:   12:		return -1;
     1288:   13:	return 0;
        -:   14:}
        -:   15:
        4:   16:struct gameState* newGame() {
        4:   17:	struct gameState* g = malloc(sizeof(struct gameState));
        4:   18:	return g;
        -:   19:}
        -:   20:
       21:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:	int k8, int k9, int k10) {
       21:   23:	int* k = malloc(10 * sizeof(int));
       21:   24:	k[0] = k1;
       21:   25:	k[1] = k2;
       21:   26:	k[2] = k3;
       21:   27:	k[3] = k4;
       21:   28:	k[4] = k5;
       21:   29:	k[5] = k6;
       21:   30:	k[6] = k7;
       21:   31:	k[7] = k8;
       21:   32:	k[8] = k9;
       21:   33:	k[9] = k10;
       21:   34:	return k;
        -:   35:}
        -:   36:
       21:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		struct gameState *state) {
        -:   39:
        -:   40:	int i;
        -:   41:	int j;
        -:   42:	int it;
        -:   43:	//set up random number generator
       21:   44:	SelectStream(1);
       21:   45:	PutSeed((long)randomSeed);
        -:   46:
        -:   47:	//check number of players
       21:   48:	if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:	{
    #####:   50:		return -1;
        -:   51:	}
        -:   52:
        -:   53:	//set number of players
       21:   54:	state->numPlayers = numPlayers;
        -:   55:
        -:   56:	//check selected kingdom cards are different
       70:   57:	for (i = 0; i < 10; i++)
        -:   58:	{
      650:   59:		for (j = 0; j < 10; j++)
        -:   60:		{
      601:   61:			if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:			{
       19:   63:				return -1;
        -:   64:			}
        -:   65:		}
        -:   66:	}
        -:   67:
        -:   68:
        -:   69:	//initialize supply
        -:   70:	///////////////////////////////
        -:   71:
        -:   72:	//set number of Curse cards
        2:   73:	if (numPlayers == 2)
        -:   74:	{
        1:   75:		state->supplyCount[curse] = 10;
        -:   76:	}
        1:   77:	else if (numPlayers == 3)
        -:   78:	{
    #####:   79:		state->supplyCount[curse] = 20;
        -:   80:	}
        -:   81:	else
        -:   82:	{
        1:   83:		state->supplyCount[curse] = 30;
        -:   84:	}
        -:   85:
        -:   86:	//set number of Victory cards
        2:   87:	if (numPlayers == 2)
        -:   88:	{
        1:   89:		state->supplyCount[estate] = 8;
        1:   90:		state->supplyCount[duchy] = 8;
        1:   91:		state->supplyCount[province] = 8;
        -:   92:	}
        -:   93:	else
        -:   94:	{
        1:   95:		state->supplyCount[estate] = 12;
        1:   96:		state->supplyCount[duchy] = 12;
        1:   97:		state->supplyCount[province] = 12;
        -:   98:	}
        -:   99:
        -:  100:	//set number of Treasure cards
        2:  101:	state->supplyCount[copper] = 60 - (7 * numPlayers);
        2:  102:	state->supplyCount[silver] = 40;
        2:  103:	state->supplyCount[gold] = 30;
        -:  104:
        -:  105:	//set number of Kingdom cards
       42:  106:	for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:	{
      330:  108:		for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:		{
      310:  110:			if (kingdomCards[j] == i)
        -:  111:			{
        -:  112:				//check if card is a 'Victory' Kingdom card
       20:  113:				if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:				{
        4:  115:					if (numPlayers == 2){
        1:  116:						state->supplyCount[i] = 8;
        -:  117:					}
        1:  118:					else{ state->supplyCount[i] = 12; }
        -:  119:				}
        -:  120:				else
        -:  121:				{
       18:  122:					state->supplyCount[i] = 10;
        -:  123:				}
       20:  124:				break;
        -:  125:			}
        -:  126:			else    //card is not in the set choosen for the game
        -:  127:			{
      290:  128:				state->supplyCount[i] = -1;
        -:  129:			}
        -:  130:		}
        -:  131:
        -:  132:	}
        -:  133:
        -:  134:	////////////////////////
        -:  135:	//supply intilization complete
        -:  136:
        -:  137:	//set player decks
        8:  138:	for (i = 0; i < numPlayers; i++)
        -:  139:	{
        6:  140:		state->deckCount[i] = 0;
       24:  141:		for (j = 0; j < 3; j++)
        -:  142:		{
       18:  143:			state->deck[i][j] = estate;
       18:  144:			state->deckCount[i]++;
        -:  145:		}
       48:  146:		for (j = 3; j < 10; j++)
        -:  147:		{
       42:  148:			state->deck[i][j] = copper;
       42:  149:			state->deckCount[i]++;
        -:  150:		}
        -:  151:	}
        -:  152:
        -:  153:	//shuffle player decks
        8:  154:	for (i = 0; i < numPlayers; i++)
        -:  155:	{
        6:  156:		if (shuffle(i, state) < 0)
        -:  157:		{
    #####:  158:			return -1;
        -:  159:		}
        -:  160:	}
        -:  161:
        -:  162:	//draw player hands
        8:  163:	for (i = 0; i < numPlayers; i++)
        -:  164:	{
        -:  165:		//initialize hand size to zero
        6:  166:		state->handCount[i] = 0;
        6:  167:		state->discardCount[i] = 0;
        -:  168:		//draw 5 cards
        -:  169:		// for (j = 0; j < 5; j++)
        -:  170:		//	{
        -:  171:		//	  drawCard(i, state);
        -:  172:		//	}
        -:  173:	}
        -:  174:
        -:  175:	//set embargo tokens to 0 for all supply piles
       56:  176:	for (i = 0; i <= treasure_map; i++)
        -:  177:	{
       54:  178:		state->embargoTokens[i] = 0;
        -:  179:	}
        -:  180:
        -:  181:	//initialize first player's turn
        2:  182:	state->outpostPlayed = 0;
        2:  183:	state->phase = 0;
        2:  184:	state->numActions = 1;
        2:  185:	state->numBuys = 1;
        2:  186:	state->playedCardCount = 0;
        2:  187:	state->whoseTurn = 0;
        2:  188:	state->handCount[state->whoseTurn] = 0;
        -:  189:	//int it; move to top
        -:  190:
        -:  191:	//Moved draw cards to here, only drawing at the start of a turn
       12:  192:	for (it = 0; it < 5; it++){
       10:  193:		drawCard(state->whoseTurn, state);
        -:  194:	}
        -:  195:
        2:  196:	updateCoins(state->whoseTurn, state, 0);
        -:  197:
        2:  198:	return 0;
        -:  199:}
        -:  200:
      135:  201:int shuffle(int player, struct gameState *state) {
        -:  202:
        -:  203:
        -:  204:	int newDeck[MAX_DECK];
      135:  205:	int newDeckPos = 0;
        -:  206:	int card;
        -:  207:	int i;
        -:  208:
      135:  209:	if (state->deckCount[player] < 1)
        7:  210:		return -1;
      128:  211:	qsort((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
        -:  212:	/* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
     2039:  214:	while (state->deckCount[player] > 0) {
     1783:  215:		card = floor(Random() * state->deckCount[player]);
     1783:  216:		newDeck[newDeckPos] = state->deck[player][card];
     1783:  217:		newDeckPos++;
     9977:  218:		for (i = card; i < state->deckCount[player] - 1; i++) {
     8194:  219:			state->deck[player][i] = state->deck[player][i + 1];
        -:  220:		}
     1783:  221:		state->deckCount[player]--;
        -:  222:	}
     1911:  223:	for (i = 0; i < newDeckPos; i++) {
     1783:  224:		state->deck[player][i] = newDeck[i];
     1783:  225:		state->deckCount[player]++;
        -:  226:	}
        -:  227:
      128:  228:	return 0;
        -:  229:}
        -:  230:
     1823:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state)
        -:  232:{
        -:  233:	int card;
     1823:  234:	int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:	//check if it is the right phase
     1823:  237:	if (state->phase != 0)
        -:  238:	{
      260:  239:		return -1;
        -:  240:	}
        -:  241:
        -:  242:	//check if player has enough actions
     1563:  243:	if (state->numActions < 1)
        -:  244:	{
       26:  245:		return -1;
        -:  246:	}
        -:  247:
        -:  248:	//get card played
     1537:  249:	card = handCard(handPos, state);
        -:  250:
        -:  251:	//check if selected card is an action
     1537:  252:	if (card < adventurer || card > treasure_map)
        -:  253:	{
     1402:  254:		return -1;
        -:  255:	}
        -:  256:
        -:  257:	//play card
      135:  258:	if (cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0)
        -:  259:	{
       57:  260:		return -1;
        -:  261:	}
        -:  262:
        -:  263:	//reduce number of actions
       78:  264:	state->numActions--;
        -:  265:
        -:  266:	//update coins (Treasure cards may be added with card draws)
       78:  267:	updateCoins(state->whoseTurn, state, coin_bonus);
        -:  268:
       78:  269:	return 0;
        -:  270:}
        -:  271:
     1880:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:	int who;
        -:  274:	if (DEBUG){
        -:  275:		printf("Entering buyCard...\n");
        -:  276:	}
        -:  277:
        -:  278:	// I don't know what to do about the phase thing.
        -:  279:
     1880:  280:	who = state->whoseTurn;
        -:  281:
     1880:  282:	if (state->numBuys < 1){
        -:  283:		if (DEBUG)
        -:  284:			printf("You do not have any buys left\n");
      261:  285:		return -1;
        -:  286:	}
     1619:  287:	else if (supplyCount(supplyPos, state) < 1){
        -:  288:		if (DEBUG)
        -:  289:			printf("There are not any of that type of card left\n");
      687:  290:		return -1;
        -:  291:	}
      932:  292:	else if (state->coins < getCost(supplyPos)){
        -:  293:		if (DEBUG)
        -:  294:			printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
      683:  295:		return -1;
        -:  296:	}
        -:  297:	else {
      249:  298:		state->phase = 1;
        -:  299:		//state->supplyCount[supplyPos]--;
      249:  300:		gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  301:
      249:  302:		state->coins = (state->coins) - (getCost(supplyPos));
      249:  303:		state->numBuys--;
        -:  304:		if (DEBUG)
        -:  305:			printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  306:	}
        -:  307:
        -:  308:	//state->discard[who][state->discardCount[who]] = supplyPos;
        -:  309:	//state->discardCount[who]++;
        -:  310:
      249:  311:	return 0;
        -:  312:}
        -:  313:
    #####:  314:int numHandCards(struct gameState *state) {
    #####:  315:	return state->handCount[whoseTurn(state)];
        -:  316:}
        -:  317:
     1541:  318:int handCard(int handPos, struct gameState *state) {
     1541:  319:	int currentPlayer = whoseTurn(state);
     1541:  320:	return state->hand[currentPlayer][handPos];
        -:  321:}
        -:  322:
     1890:  323:int supplyCount(int card, struct gameState *state) {
     1890:  324:	return state->supplyCount[card];
        -:  325:}
        -:  326:
    #####:  327:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  328:	int i;
    #####:  329:	int count = 0;
        -:  330:
    #####:  331:	for (i = 0; i < state->deckCount[player]; i++)
        -:  332:	{
    #####:  333:		if (state->deck[player][i] == card) count++;
        -:  334:	}
        -:  335:
    #####:  336:	for (i = 0; i < state->handCount[player]; i++)
        -:  337:	{
    #####:  338:		if (state->hand[player][i] == card) count++;
        -:  339:	}
        -:  340:
    #####:  341:	for (i = 0; i < state->discardCount[player]; i++)
        -:  342:	{
    #####:  343:		if (state->discard[player][i] == card) count++;
        -:  344:	}
        -:  345:
    #####:  346:	return count;
        -:  347:}
        -:  348:
     1984:  349:int whoseTurn(struct gameState *state) {
     1984:  350:	return state->whoseTurn;
        -:  351:}
        -:  352:
      308:  353:int endTurn(struct gameState *state) {
        -:  354:	int k;
        -:  355:	int i;
      308:  356:	int currentPlayer = whoseTurn(state);
        -:  357:
        -:  358:	//Discard hand
     1840:  359:	for (i = 0; i < state->handCount[currentPlayer]; i++){
     1532:  360:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
     1532:  361:		state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  362:	}
      308:  363:	state->handCount[currentPlayer] = 0;//Reset hand count
        -:  364:
        -:  365:	//Code for determining the player
      308:  366:	if (currentPlayer < (state->numPlayers - 1)){
      195:  367:		state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  368:	}
        -:  369:	else{
      113:  370:		state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  371:	}
        -:  372:
      308:  373:	state->outpostPlayed = 0;
      308:  374:	state->phase = 0;
      308:  375:	state->numActions = 1;
      308:  376:	state->coins = 0;
      308:  377:	state->numBuys = 1;
      308:  378:	state->playedCardCount = 0;
      308:  379:	state->handCount[state->whoseTurn] = 0;
        -:  380:
        -:  381:	//int k; move to top
        -:  382:	//Next player draws hand
     1848:  383:	for (k = 0; k < 5; k++){
     1540:  384:		drawCard(state->whoseTurn, state);//Draw a card
        -:  385:	}
        -:  386:
        -:  387:	//Update money
      308:  388:	updateCoins(state->whoseTurn, state, 0);
        -:  389:
      308:  390:	return 0;
        -:  391:}
        -:  392:
     5601:  393:int isGameOver(struct gameState *state) {
        -:  394:	int i;
        -:  395:	int j;
        -:  396:
        -:  397:	//if stack of Province cards is empty, the game ends
     5601:  398:	if (state->supplyCount[province] == 0)
        -:  399:	{
    #####:  400:		return 1;
        -:  401:	}
        -:  402:
        -:  403:	//if three supply pile are at 0, the game ends
     5601:  404:	j = 0;
   145626:  405:	for (i = 0; i < 25; i++)
        -:  406:	{
   140025:  407:		if (state->supplyCount[i] == 0)
        -:  408:		{
     6447:  409:			j++;
        -:  410:		}
        -:  411:	}
     5601:  412:	if (j >= 3)
        -:  413:	{
        2:  414:		return 1;
        -:  415:	}
        -:  416:
     5599:  417:	return 0;
        -:  418:}
        -:  419:
    #####:  420:int scoreFor(int player, struct gameState *state) {
        -:  421:
        -:  422:	int i;
    #####:  423:	int score = 0;
        -:  424:	//score from hand
    #####:  425:	for (i = 0; i < state->handCount[player]; i++)
        -:  426:	{
    #####:  427:		if (state->hand[player][i] == curse) { score = score - 1; };
    #####:  428:		if (state->hand[player][i] == estate) { score = score + 1; };
    #####:  429:		if (state->hand[player][i] == duchy) { score = score + 3; };
    #####:  430:		if (state->hand[player][i] == province) { score = score + 6; };
    #####:  431:		if (state->hand[player][i] == great_hall) { score = score + 1; };
    #####:  432:		if (state->hand[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  433:	}
        -:  434:
        -:  435:	//score from discard
    #####:  436:	for (i = 0; i < state->discardCount[player]; i++)
        -:  437:	{
    #####:  438:		if (state->discard[player][i] == curse) { score = score - 1; };
    #####:  439:		if (state->discard[player][i] == estate) { score = score + 1; };
    #####:  440:		if (state->discard[player][i] == duchy) { score = score + 3; };
    #####:  441:		if (state->discard[player][i] == province) { score = score + 6; };
    #####:  442:		if (state->discard[player][i] == great_hall) { score = score + 1; };
    #####:  443:		if (state->discard[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  444:	}
        -:  445:
        -:  446:	//score from deck
    #####:  447:	for (i = 0; i < state->discardCount[player]; i++)
        -:  448:	{
    #####:  449:		if (state->deck[player][i] == curse) { score = score - 1; };
    #####:  450:		if (state->deck[player][i] == estate) { score = score + 1; };
    #####:  451:		if (state->deck[player][i] == duchy) { score = score + 3; };
    #####:  452:		if (state->deck[player][i] == province) { score = score + 6; };
    #####:  453:		if (state->deck[player][i] == great_hall) { score = score + 1; };
    #####:  454:		if (state->deck[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  455:	}
        -:  456:
    #####:  457:	return score;
        -:  458:}
        -:  459:
    #####:  460:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  461:	int i;
        -:  462:	int j;
        -:  463:	int highScore;
        -:  464:	int currentPlayer;
        -:  465:
        -:  466:	//get score for each player
    #####:  467:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  468:	{
        -:  469:		//set unused player scores to -9999
    #####:  470:		if (i >= state->numPlayers)
        -:  471:		{
    #####:  472:			players[i] = -9999;
        -:  473:		}
        -:  474:		else
        -:  475:		{
    #####:  476:			players[i] = scoreFor(i, state);
        -:  477:		}
        -:  478:	}
        -:  479:
        -:  480:	//find highest score
    #####:  481:	j = 0;
    #####:  482:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  483:	{
    #####:  484:		if (players[i] > players[j])
        -:  485:		{
    #####:  486:			j = i;
        -:  487:		}
        -:  488:	}
    #####:  489:	highScore = players[j];
        -:  490:
        -:  491:	//add 1 to players who had less turns
    #####:  492:	currentPlayer = whoseTurn(state);
    #####:  493:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  494:	{
    #####:  495:		if (players[i] == highScore && i > currentPlayer)
        -:  496:		{
    #####:  497:			players[i]++;
        -:  498:		}
        -:  499:	}
        -:  500:
        -:  501:	//find new highest score
    #####:  502:	j = 0;
    #####:  503:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  504:	{
    #####:  505:		if (players[i] > players[j])
        -:  506:		{
    #####:  507:			j = i;
        -:  508:		}
        -:  509:	}
    #####:  510:	highScore = players[j];
        -:  511:
        -:  512:	//set winners in array to 1 and rest to 0
    #####:  513:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  514:	{
    #####:  515:		if (players[i] == highScore)
        -:  516:		{
    #####:  517:			players[i] = 1;
        -:  518:		}
        -:  519:		else
        -:  520:		{
    #####:  521:			players[i] = 0;
        -:  522:		}
        -:  523:	}
        -:  524:
    #####:  525:	return 0;
        -:  526:}
        -:  527:
     1606:  528:int drawCard(int player, struct gameState *state)
        -:  529:{
        -:  530:	int count;
        -:  531:	int deckCounter;
     1606:  532:	if (state->deckCount[player] <= 0){//Deck is empty
        -:  533:
        -:  534:		//Step 1 Shuffle the discard pile back into a deck
        -:  535:		int i;
        -:  536:		//Move discard to deck
     1837:  537:		for (i = 0; i < state->discardCount[player]; i++){
     1711:  538:			state->deck[player][i] = state->discard[player][i];
     1711:  539:			state->discard[player][i] = -1;
        -:  540:		}
        -:  541:
      126:  542:		state->deckCount[player] = state->discardCount[player];
      126:  543:		state->discardCount[player] = 0;//Reset discard
        -:  544:
        -:  545:		//Shufffle the deck
      126:  546:		shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  547:
        -:  548:		if (DEBUG){//Debug statements
        -:  549:			printf("Deck count now: %d\n", state->deckCount[player]);
        -:  550:		}
        -:  551:
      126:  552:		state->discardCount[player] = 0;
        -:  553:
        -:  554:		//Step 2 Draw Card
      126:  555:		count = state->handCount[player];//Get current player's hand count
        -:  556:
        -:  557:		if (DEBUG){//Debug statements
        -:  558:			printf("Current hand count: %d\n", count);
        -:  559:		}
        -:  560:
      126:  561:		deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  562:
      126:  563:		if (deckCounter == 0)
        7:  564:			return -1;
        -:  565:
      119:  566:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
      119:  567:		state->deckCount[player]--;
      119:  568:		state->handCount[player]++;//Increment hand count
        -:  569:	}
        -:  570:
        -:  571:	else{
     1480:  572:		int count = state->handCount[player];//Get current hand count for player
        -:  573:		int deckCounter;
        -:  574:		if (DEBUG){//Debug statements
        -:  575:			printf("Current hand count: %d\n", count);
        -:  576:		}
        -:  577:
     1480:  578:		deckCounter = state->deckCount[player];//Create holder for the deck count
     1480:  579:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
     1480:  580:		state->deckCount[player]--;
     1480:  581:		state->handCount[player]++;//Increment hand count
        -:  582:	}
        -:  583:
     1599:  584:	return 0;
        -:  585:}
        -:  586:
     1185:  587:int getCost(int cardNumber)
        -:  588:{
     1185:  589:	switch (cardNumber)
        -:  590:	{
        -:  591:	case curse:
       76:  592:		return 0;
        -:  593:	case estate:
       40:  594:		return 2;
        -:  595:	case duchy:
       63:  596:		return 5;
        -:  597:	case province:
       70:  598:		return 8;
        -:  599:	case copper:
      138:  600:		return 0;
        -:  601:	case silver:
       97:  602:		return 3;
        -:  603:	case gold:
       49:  604:		return 6;
        -:  605:	case adventurer:
       47:  606:		return 6;
        -:  607:	case council_room:
       25:  608:		return 5;
        -:  609:	case feast:
    #####:  610:		return 4;
        -:  611:	case gardens:
    #####:  612:		return 4;
        -:  613:	case mine:
       39:  614:		return 5;
        -:  615:	case remodel:
    #####:  616:		return 4;
        -:  617:	case smithy:
       53:  618:		return 4;
        -:  619:	case village:
    #####:  620:		return 3;
        -:  621:	case baron:
       42:  622:		return 4;
        -:  623:	case great_hall:
       79:  624:		return 3;
        -:  625:	case minion:
       67:  626:		return 5;
        -:  627:	case steward:
    #####:  628:		return 3;
        -:  629:	case tribute:
       65:  630:		return 5;
        -:  631:	case ambassador:
       66:  632:		return 3;
        -:  633:	case cutpurse:
    #####:  634:		return 4;
        -:  635:	case embargo:
    #####:  636:		return 2;
        -:  637:	case outpost:
       63:  638:		return 5;
        -:  639:	case salvager:
       21:  640:		return 4;
        -:  641:	case sea_hag:
       61:  642:		return 4;
        -:  643:	case treasure_map:
       24:  644:		return 4;
        -:  645:	}
        -:  646:
    #####:  647:	return -1;
        -:  648:}
        -:  649:
    #####:  650:void playAdventurer(struct gameState *state, int currentPlayer)
        -:  651:// Reveal cards from deck until 2 Treasure cards are found.  Put those Treasure cards in the hand and discard the rest.
        -:  652:{
    #####:  653:	int drawntreasure = 0;
        -:  654:	int temphand[MAX_HAND];
        -:  655:	int cardDrawn;
    #####:  656:	int z = 0; // this is the counter for the temp hand
        -:  657:
    #####:  658:	while (drawntreasure < 2){
    #####:  659:		if (state->deckCount[currentPlayer] < 1){//if the deck is empty we need to shuffle discard and add to deck
    #####:  660:			shuffle(currentPlayer, state);
        -:  661:		}
    #####:  662:		drawCard(currentPlayer, state);
    #####:  663:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer] - 1];//top card of hand is most recently drawn card.
    #####:  664:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
    #####:  665:			drawntreasure++;
        -:  666:		else{
    #####:  667:			temphand[z] = cardDrawn;
    #####:  668:			state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####:  669:			z++;
        -:  670:		}
        -:  671:	}
    #####:  672:	while (z - 1 >= 0){
    #####:  673:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; // discard all cards in play that have been drawn
    #####:  674:		z = z - 1;
        -:  675:	}
    #####:  676:}
        -:  677:
    #####:  678:int playRemodel(struct gameState *state, int currentPlayer, int choice1, int choice2, int handPos)
        -:  679://Trash a card in the hand, and gain a card costing up to $2 more than the trashed card
        -:  680:{
        -:  681:	int i;
    #####:  682:	int j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  683:
    #####:  684:	if ((getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2))
        -:  685:	{
    #####:  686:		return -1;
        -:  687:	}
        -:  688:
    #####:  689:	gainCard(choice2, state, 0, currentPlayer);
        -:  690:
        -:  691:	//discard card from hand
    #####:  692:	discardCard(handPos, currentPlayer, state, 0);
        -:  693:
        -:  694:	//discard trashed card
    #####:  695:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  696:	{
    #####:  697:		if (state->hand[currentPlayer][i] == j)
        -:  698:		{
    #####:  699:			discardCard(i, currentPlayer, state, 0);
    #####:  700:			break;
        -:  701:		}
        -:  702:	}
        -:  703:
    #####:  704:	return 0;
        -:  705:}
        -:  706:
        4:  707:void playSmithy(struct gameState *state, int currentPlayer, int handPos)
        -:  708:// Draw 3 cards
        -:  709:{
        -:  710:	int i;
       16:  711:	for (i = 0; i < 3; i++)
        -:  712:	{
       12:  713:		drawCard(currentPlayer, state);
        -:  714:	}
        -:  715:
        -:  716:	//discard card from hand
        4:  717:	discardCard(handPos, currentPlayer, state, 0);
        4:  718:}
        -:  719:
        2:  720:void playBaron(struct gameState *state, int currentPlayer, int choice1, int handPos)
        -:  721://Add a buy.  OPTION:  Discard an Estate card and gain $4.  Otherwise, gain an Estate card.
        -:  722:{
        2:  723:	state->numBuys++;//Increase buys by 1!
        2:  724:	if (choice1 > 0){//Boolean true or going to discard an estate
        2:  725:		int p = 0;//Iterator for hand!
        2:  726:		int card_not_discarded = 1;//Flag for discard set!
       12:  727:		while (card_not_discarded){
        8:  728:			if (state->hand[currentPlayer][p] == estate){ //Found an estate card!
        1:  729:				state->coins += 4;//Add 4 coins to the amount of coins
        1:  730:				state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
        1:  731:				state->discardCount[currentPlayer]++;
        6:  732:				for (; p < state->handCount[currentPlayer]; p++){
        5:  733:					state->hand[currentPlayer][p] = state->hand[currentPlayer][p + 1];
        -:  734:				}
        1:  735:				state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
        1:  736:				state->handCount[currentPlayer]--;
        1:  737:				card_not_discarded = 0;//Exit the loop
        -:  738:			}
        7:  739:			else if (p > state->handCount[currentPlayer]){
        -:  740:				if (DEBUG) {
        -:  741:					printf("No estate cards in your hand, invalid choice\n");
        -:  742:					printf("Must gain an estate if there are any\n");
        -:  743:				}
        1:  744:				if (supplyCount(estate, state) > 0){
    #####:  745:					gainCard(estate, state, 1, currentPlayer);
    #####:  746:					state->supplyCount[estate]--;//Decrement estates
    #####:  747:					if (supplyCount(estate, state) == 0){
    #####:  748:						isGameOver(state);
        -:  749:					}
        -:  750:				}
        1:  751:				card_not_discarded = 0;//Exit the loop
        -:  752:			}
        -:  753:
        -:  754:			else{
        6:  755:				p++;//Next card
        -:  756:			}
        -:  757:		}
        -:  758:	}
        -:  759:
        -:  760:	else{
    #####:  761:		if (supplyCount(estate, state) > 0){
    #####:  762:			gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  763:			state->supplyCount[estate]--;//Decrement Estates
    #####:  764:			if (supplyCount(estate, state) == 0){
    #####:  765:				isGameOver(state);
        -:  766:			}
        -:  767:		}
        -:  768:	}
        2:  769:}
        -:  770:
        4:  771:int playTreasureMap(struct gameState *state, int currentPlayer, int handPos)
        -:  772://Trashing two treasure map cards from the hand = four gold on top of the deck.
        -:  773:{
        -:  774:	int i;
        -:  775:	int index;
        -:  776:
        -:  777:	//search hand for another treasure_map
       24:  778:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  779:	{
       20:  780:		if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -:  781:		{
    #####:  782:			index = i;
    #####:  783:			break;
        -:  784:		}
        -:  785:	}
        4:  786:	if (index > -1)
        -:  787:	{
        -:  788:		//trash both treasure cards
        4:  789:		discardCard(handPos, currentPlayer, state, 1);
        4:  790:		discardCard(index, currentPlayer, state, 1);
        -:  791:
        -:  792:		//gain 4 Gold cards
       20:  793:		for (i = 0; i < 4; i++)
        -:  794:		{
       16:  795:			gainCard(gold, state, 1, currentPlayer);
        -:  796:		}
        -:  797:
        -:  798:		//return success
        4:  799:		return 1;
        -:  800:	}
        -:  801:
        -:  802:	//no second treasure_map found in hand
    #####:  803:	return -1;
        -:  804:}
        -:  805:
      135:  806:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  807:{
        -:  808:	int i;
        -:  809:	int j;
        -:  810:	int k;
        -:  811:	//int x;  //Unused after while loop removed from feast.
      135:  812:	int currentPlayer = whoseTurn(state);
      135:  813:	int nextPlayer = currentPlayer + 1;
        -:  814:	int temphand[MAX_HAND];
        -:  815:
      135:  816:	int tributeRevealedCards[2] = { -1, -1 };
        -:  817:
      135:  818:	if (nextPlayer > (state->numPlayers - 1)){
       65:  819:		nextPlayer = 0;
        -:  820:	}
        -:  821:
        -:  822:	//uses switch to select card and perform actions
      135:  823:	switch (card)
        -:  824:	{
        -:  825:	case adventurer:
        -:  826:
    #####:  827:		playAdventurer(state, currentPlayer);
    #####:  828:		return 0;
        -:  829:
        -:  830:	case council_room:
        -:  831:		//+4 Cards
       15:  832:		for (i = 0; i < 4; i++)
        -:  833:		{
       12:  834:			drawCard(currentPlayer, state);
        -:  835:		}
        -:  836:
        -:  837:		//+1 Buy
        3:  838:		state->numBuys++;
        -:  839:
        -:  840:		//Each other player draws a card
       15:  841:		for (i = 0; i < state->numPlayers; i++)
        -:  842:		{
       12:  843:			if (i != currentPlayer)
        -:  844:			{
        9:  845:				drawCard(i, state);
        -:  846:			}
        -:  847:		}
        -:  848:
        -:  849:		//put played card in played card pile
        3:  850:		discardCard(handPos, currentPlayer, state, 0);
        -:  851:
        3:  852:		return 0;
        -:  853:
        -:  854:	case feast:
        -:  855:		//gain card with cost up to 5
        -:  856:		//Backup hand
    #####:  857:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  858:			temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  859:			state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  860:		}
        -:  861:		//Backup hand
        -:  862:
        -:  863:		//Update Coins for Buy
    #####:  864:		updateCoins(currentPlayer, state, 5);
        -:  865://		x = 1;//Condition to loop on
        -:  866://		while (x == 1) {//Buy one card
    #####:  867:			if (supplyCount(choice1, state) <= 0){
        -:  868:				if (DEBUG)
        -:  869:					printf("None of that card left, sorry!\n");
        -:  870:
        -:  871:				if (DEBUG){
        -:  872:					printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  873:				}
        -:  874:			}
    #####:  875:			else if (state->coins < getCost(choice1)){
    #####:  876:				printf("That card is too expensive!\n");
        -:  877:
        -:  878:				if (DEBUG){
        -:  879:					printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  880:				}
        -:  881:			}
        -:  882:			else{
        -:  883:
        -:  884:				if (DEBUG){
        -:  885:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  886:				}
        -:  887:
    #####:  888:				gainCard(choice1, state, 0, currentPlayer);//Gain the card
        -:  889://				x = 0;//No more buying cards
        -:  890:
        -:  891:				if (DEBUG){
        -:  892:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  893:				}
        -:  894:
        -:  895:			}
        -:  896://		}
        -:  897:
        -:  898:		//Reset Hand
    #####:  899:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  900:			state->hand[currentPlayer][i] = temphand[i];
    #####:  901:			temphand[i] = -1;
        -:  902:		}
        -:  903:		//Reset Hand
        -:  904:
    #####:  905:		return 0;
        -:  906:
        -:  907:	case gardens:
    #####:  908:		return -1;
        -:  909:
        -:  910:	case mine:
        1:  911:		j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  912:
        1:  913:		if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  914:		{
        1:  915:			return -1;
        -:  916:		}
        -:  917:
    #####:  918:		if (choice2 > treasure_map || choice2 < curse)
        -:  919:		{
    #####:  920:			return -1;
        -:  921:		}
        -:  922:
    #####:  923:		if ((getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2))
        -:  924:		{
    #####:  925:			return -1;
        -:  926:		}
        -:  927:
    #####:  928:		gainCard(choice2, state, 2, currentPlayer);
        -:  929:
        -:  930:		//discard card from hand
    #####:  931:		discardCard(handPos, currentPlayer, state, 0);
        -:  932:
        -:  933:		//discard trashed card
    #####:  934:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  935:		{
    #####:  936:			if (state->hand[currentPlayer][i] == j)
        -:  937:			{
    #####:  938:				discardCard(i, currentPlayer, state, 0);
    #####:  939:				break;
        -:  940:			}
        -:  941:		}
        -:  942:
    #####:  943:		return 0;
        -:  944:
        -:  945:	case remodel:
        -:  946:
    #####:  947:		return playRemodel(state, currentPlayer, choice1, choice2, handPos);
        -:  948:
        -:  949:	case smithy:
        -:  950:
        4:  951:		playSmithy(state, currentPlayer, handPos);
        4:  952:		return 0;
        -:  953:
        -:  954:	case village:
        -:  955:		//+1 Card
    #####:  956:		drawCard(currentPlayer, state);
        -:  957:
        -:  958:		//+2 Actions
    #####:  959:		state->numActions = state->numActions + 2;
        -:  960:
        -:  961:		//discard played card from hand
    #####:  962:		discardCard(handPos, currentPlayer, state, 0);
    #####:  963:		return 0;
        -:  964:
        -:  965:	case baron:
        -:  966:
        2:  967:		playBaron(state, currentPlayer, choice1, handPos);
        2:  968:		return 0;
        -:  969:
        -:  970:	case great_hall:
        -:  971:		//+1 Card
       13:  972:		drawCard(currentPlayer, state);
        -:  973:
        -:  974:		//+1 Actions
       13:  975:		state->numActions++;
        -:  976:
        -:  977:		//discard card from hand
       13:  978:		discardCard(handPos, currentPlayer, state, 0);
       13:  979:		return 0;
        -:  980:
        -:  981:	case minion:
        -:  982:		//+1 action
        4:  983:		state->numActions++;
        -:  984:
        -:  985:		//discard card from hand
        4:  986:		discardCard(handPos, currentPlayer, state, 0);
        -:  987:
        4:  988:		if (choice1)		//+2 coins
        -:  989:		{
        4:  990:			state->coins = state->coins + 2;
        -:  991:		}
        -:  992:
    #####:  993:		else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  994:		{
        -:  995:			//discard hand
    #####:  996:			while (numHandCards(state) > 0)
        -:  997:			{
    #####:  998:				discardCard(handPos, currentPlayer, state, 0);
        -:  999:			}
        -: 1000:
        -: 1001:			//draw 4
    #####: 1002:			for (i = 0; i < 4; i++)
        -: 1003:			{
    #####: 1004:				drawCard(currentPlayer, state);
        -: 1005:			}
        -: 1006:
        -: 1007:			//other players discard hand and redraw if hand size > 4
    #####: 1008:			for (i = 0; i < state->numPlayers; i++)
        -: 1009:			{
    #####: 1010:				if (i != currentPlayer)
        -: 1011:				{
    #####: 1012:					if (state->handCount[i] > 4)
        -: 1013:					{
        -: 1014:						//discard hand
    #####: 1015:						while (state->handCount[i] > 0)
        -: 1016:						{
    #####: 1017:							discardCard(handPos, i, state, 0);
        -: 1018:						}
        -: 1019:
        -: 1020:						//draw 4
    #####: 1021:						for (j = 0; j < 4; j++)
        -: 1022:						{
    #####: 1023:							drawCard(i, state);
        -: 1024:						}
        -: 1025:					}
        -: 1026:				}
        -: 1027:			}
        -: 1028:
        -: 1029:		}
        4: 1030:		return 0;
        -: 1031:
        -: 1032:	case steward:
    #####: 1033:		if (choice1 == 1)
        -: 1034:		{
        -: 1035:			//+2 cards
    #####: 1036:			drawCard(currentPlayer, state);
    #####: 1037:			drawCard(currentPlayer, state);
        -: 1038:		}
    #####: 1039:		else if (choice1 == 2)
        -: 1040:		{
        -: 1041:			//+2 coins
    #####: 1042:			state->coins = state->coins + 2;
        -: 1043:		}
        -: 1044:		else
        -: 1045:		{
        -: 1046:			//trash 2 cards in hand
    #####: 1047:			discardCard(choice2, currentPlayer, state, 1);
    #####: 1048:			discardCard(choice3, currentPlayer, state, 1);
        -: 1049:		}
        -: 1050:
        -: 1051:		//discard card from hand
    #####: 1052:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1053:		return 0;
        -: 1054:
        -: 1055:	case tribute:
       21: 1056:		if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####: 1057:			if (state->deckCount[nextPlayer] > 0){
    #####: 1058:				tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1059:				state->deckCount[nextPlayer]--;
        -: 1060:			}
    #####: 1061:			else if (state->discardCount[nextPlayer] > 0){
    #####: 1062:				tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer] - 1];
    #####: 1063:				state->discardCount[nextPlayer]--;
        -: 1064:			}
        -: 1065:			else{
        -: 1066:				//No Card to Reveal
        -: 1067:				if (DEBUG){
        -: 1068:					printf("No cards to reveal\n");
        -: 1069:				}
        -: 1070:			}
        -: 1071:		}
        -: 1072:
        -: 1073:		else{
       21: 1074:			if (state->deckCount[nextPlayer] == 0){
       15: 1075:				for (i = 0; i < state->discardCount[nextPlayer]; i++){
       12: 1076:					state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
       12: 1077:					state->deckCount[nextPlayer]++;
       12: 1078:					state->discard[nextPlayer][i] = -1;
       12: 1079:					state->discardCount[nextPlayer]--;
        -: 1080:				}
        -: 1081:
        3: 1082:				shuffle(nextPlayer, state);//Shuffle the deck
        -: 1083:			}
       21: 1084:			tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
       21: 1085:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
       21: 1086:			state->deckCount[nextPlayer]--;
       21: 1087:			tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
       21: 1088:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
       21: 1089:			state->deckCount[nextPlayer]--;
        -: 1090:		}
        -: 1091:
       21: 1092:		if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
        5: 1093:			state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
        5: 1094:			state->playedCardCount++;
        5: 1095:			tributeRevealedCards[1] = -1;
        -: 1096:		}
        -: 1097:
       84: 1098:		for (i = 0; i <= 2; i++){
       63: 1099:			if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
       32: 1100:				state->coins += 2;
        -: 1101:			}
        -: 1102:
       31: 1103:			else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
        5: 1104:				drawCard(currentPlayer, state);
        5: 1105:				drawCard(currentPlayer, state);
        -: 1106:			}
        -: 1107:			else{//Action Card
       26: 1108:				state->numActions = state->numActions + 2;
        -: 1109:			}
        -: 1110:		}
        -: 1111:
       21: 1112:		return 0;
        -: 1113:
        -: 1114:	case ambassador:
       59: 1115:		j = 0;		//used to check if player has enough cards to discard
        -: 1116:
       59: 1117:		if (choice2 > 2 || choice2 < 0)
        -: 1118:		{
       52: 1119:			return -1;
        -: 1120:		}
        -: 1121:
        7: 1122:		if (choice1 == handPos)
        -: 1123:		{
        1: 1124:			return -1;
        -: 1125:		}
        -: 1126:
       36: 1127:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1128:		{
       30: 1129:			if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1130:			{
        3: 1131:				j++;
        -: 1132:			}
        -: 1133:		}
        6: 1134:		if (j < choice2)
        -: 1135:		{
        3: 1136:			return -1;
        -: 1137:		}
        -: 1138:
        -: 1139:		if (DEBUG)
        -: 1140:			printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1141:
        -: 1142:		//increase supply count for choosen card by amount being discarded
        3: 1143:		state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1144:
        -: 1145:		//each other player gains a copy of revealed card
       11: 1146:		for (i = 0; i < state->numPlayers; i++)
        -: 1147:		{
        8: 1148:			if (i != currentPlayer)
        -: 1149:			{
        5: 1150:				gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1151:			}
        -: 1152:		}
        -: 1153:
        -: 1154:		//discard played card from hand
        3: 1155:		discardCard(handPos, currentPlayer, state, 0);
        -: 1156:
        -: 1157:		//trash copies of cards returned to supply
        5: 1158:		for (j = 0; j < choice2; j++)
        -: 1159:		{
        6: 1160:			for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1161:			{
        5: 1162:				if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1163:				{
        1: 1164:					discardCard(i, currentPlayer, state, 1);
        1: 1165:					break;
        -: 1166:				}
        -: 1167:			}
        -: 1168:		}
        -: 1169:
        3: 1170:		return 0;
        -: 1171:
        -: 1172:	case cutpurse:
        -: 1173:
    #####: 1174:		updateCoins(currentPlayer, state, 2);
    #####: 1175:		for (i = 0; i < state->numPlayers; i++)
        -: 1176:		{
    #####: 1177:			if (i != currentPlayer)
        -: 1178:			{
    #####: 1179:				for (j = 0; j < state->handCount[i]; j++)
        -: 1180:				{
    #####: 1181:					if (state->hand[i][j] == copper)
        -: 1182:					{
    #####: 1183:						discardCard(j, i, state, 0);
    #####: 1184:						break;
        -: 1185:					}
    #####: 1186:					if (j == state->handCount[i])
        -: 1187:					{
    #####: 1188:						for (k = 0; k < state->handCount[i]; k++)
        -: 1189:						{
        -: 1190:							if (DEBUG)
        -: 1191:								printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1192:						}
    #####: 1193:						break;
        -: 1194:					}
        -: 1195:				}
        -: 1196:
        -: 1197:			}
        -: 1198:
        -: 1199:		}
        -: 1200:
        -: 1201:		//discard played card from hand
    #####: 1202:		discardCard(handPos, currentPlayer, state, 0);
        -: 1203:
    #####: 1204:		return 0;
        -: 1205:
        -: 1206:
        -: 1207:	case embargo:
        -: 1208:		//+2 Coins
    #####: 1209:		state->coins = state->coins + 2;
        -: 1210:
        -: 1211:		//see if selected pile is in play
    #####: 1212:		if (state->supplyCount[choice1] == -1)
        -: 1213:		{
    #####: 1214:			return -1;
        -: 1215:		}
        -: 1216:
        -: 1217:		//add embargo token to selected supply pile
    #####: 1218:		state->embargoTokens[choice1]++;
        -: 1219:
        -: 1220:		//trash card
    #####: 1221:		discardCard(handPos, currentPlayer, state, 1);
    #####: 1222:		return 0;
        -: 1223:
        -: 1224:	case outpost:
        -: 1225:		//set outpost flag
        2: 1226:		state->outpostPlayed++;
        -: 1227:
        -: 1228:		//discard card
        2: 1229:		discardCard(handPos, currentPlayer, state, 0);
        2: 1230:		return 0;
        -: 1231:
        -: 1232:	case salvager:
        -: 1233:		//+1 buy
        5: 1234:		state->numBuys++;
        -: 1235:
        5: 1236:		if (choice1)
        -: 1237:		{
        -: 1238:			//gain coins equal to trashed card
        4: 1239:			state->coins = state->coins + getCost(handCard(choice1, state));
        -: 1240:			//trash card
        4: 1241:			discardCard(choice1, currentPlayer, state, 1);
        -: 1242:		}
        -: 1243:
        -: 1244:		//discard card
        5: 1245:		discardCard(handPos, currentPlayer, state, 0);
        5: 1246:		return 0;
        -: 1247:
        -: 1248:	case sea_hag:
       53: 1249:		for (i = 0; i < state->numPlayers; i++){
       36: 1250:			if (i != currentPlayer){
       19: 1251:				state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
       19: 1252:				state->discardCount[i]++;
       19: 1253:				state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1254:			}
        -: 1255:		}
       17: 1256:		return 0;
        -: 1257:
        -: 1258:	case treasure_map:
        -: 1259:
        4: 1260:		return playTreasureMap(state, currentPlayer, handPos);
        -: 1261:	}
    #####: 1262:	return -1;
        -: 1263:}
        -: 1264:
       47: 1265:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1266:{
        -: 1267:
        -: 1268:	//if card is not trashed, added to Played pile 
       47: 1269:	if (trashFlag < 1)
        -: 1270:	{
        -: 1271:		//add card to played pile
       34: 1272:		state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
       34: 1273:		state->playedCardCount++;
        -: 1274:	}
        -: 1275:
        -: 1276:	//set played card to -1
       47: 1277:	state->hand[currentPlayer][handPos] = -1;
        -: 1278:
        -: 1279:	//remove card from player's hand
       47: 1280:	if (handPos == (state->handCount[currentPlayer] - 1)) 	//last card in hand array is played
        -: 1281:	{
        -: 1282:		//reduce number of cards in hand
        4: 1283:		state->handCount[currentPlayer]--;
        -: 1284:	}
       43: 1285:	else if (state->handCount[currentPlayer] == 1) //only one card in hand
        -: 1286:	{
        -: 1287:		//reduce number of cards in hand
    #####: 1288:		state->handCount[currentPlayer]--;
        -: 1289:	}
        -: 1290:	else
        -: 1291:	{
        -: 1292:		//replace discarded card with last card in hand
       43: 1293:		state->hand[currentPlayer][handPos] = state->hand[currentPlayer][(state->handCount[currentPlayer] - 1)];
        -: 1294:		//set last card to -1
       43: 1295:		state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1296:		//reduce number of cards in hand
       43: 1297:		state->handCount[currentPlayer]--;
        -: 1298:	}
        -: 1299:
       47: 1300:	return 0;
        -: 1301:}
        -: 1302:
      270: 1303:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1304:{
        -: 1305:	//Note: supplyPos is enum of choosen card
        -: 1306:
        -: 1307:	//check if supply pile is empty (0) or card is not used in game (-1)
      270: 1308:	if (supplyCount(supplyPos, state) < 1)
        -: 1309:	{
    #####: 1310:		return -1;
        -: 1311:	}
        -: 1312:
        -: 1313:	//added card for [whoseTurn] current player:
        -: 1314:	// toFlag = 0 : add to discard
        -: 1315:	// toFlag = 1 : add to deck
        -: 1316:	// toFlag = 2 : add to hand
        -: 1317:
      270: 1318:	if (toFlag == 1)
        -: 1319:	{
       16: 1320:		state->deck[player][state->deckCount[player]] = supplyPos;
       16: 1321:		state->deckCount[player]++;
        -: 1322:	}
      254: 1323:	else if (toFlag == 2)
        -: 1324:	{
    #####: 1325:		state->hand[player][state->handCount[player]] = supplyPos;
    #####: 1326:		state->handCount[player]++;
        -: 1327:	}
        -: 1328:	else
        -: 1329:	{
      254: 1330:		state->discard[player][state->discardCount[player]] = supplyPos;
      254: 1331:		state->discardCount[player]++;
        -: 1332:	}
        -: 1333:
        -: 1334:	//decrease number in supply pile
      270: 1335:	state->supplyCount[supplyPos]--;
        -: 1336:
      270: 1337:	return 0;
        -: 1338:}
        -: 1339:
      388: 1340:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1341:{
        -: 1342:	int i;
        -: 1343:
        -: 1344:	//reset coin count
      388: 1345:	state->coins = 0;
        -: 1346:
        -: 1347:	//add coins for each Treasure card in player's hand
     2320: 1348:	for (i = 0; i < state->handCount[player]; i++)
        -: 1349:	{
     1932: 1350:		if (state->hand[player][i] == copper)
        -: 1351:		{
      721: 1352:			state->coins += 1;
        -: 1353:		}
     1211: 1354:		else if (state->hand[player][i] == silver)
        -: 1355:		{
      155: 1356:			state->coins += 2;
        -: 1357:		}
     1056: 1358:		else if (state->hand[player][i] == gold)
        -: 1359:		{
       79: 1360:			state->coins += 3;
        -: 1361:		}
        -: 1362:	}
        -: 1363:
        -: 1364:	//add bonus
      388: 1365:	state->coins += bonus;
        -: 1366:
      388: 1367:	return 0;
        -: 1368:}
        -: 1369:
        -: 1370:
        -: 1371://end of dominion.c
File 'dominion.c'
Lines executed:64.45% of 557
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
     3694:    8:int compare(const void* a, const void* b) {
     3694:    9:	if (*(int*)a > *(int*)b)
     1321:   10:		return 1;
     2373:   11:	if (*(int*)a < *(int*)b)
     1204:   12:		return -1;
     1169:   13:	return 0;
        -:   14:}
        -:   15:
        4:   16:struct gameState* newGame() {
        4:   17:	struct gameState* g = malloc(sizeof(struct gameState));
        4:   18:	return g;
        -:   19:}
        -:   20:
       30:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:	int k8, int k9, int k10) {
       30:   23:	int* k = malloc(10 * sizeof(int));
       30:   24:	k[0] = k1;
       30:   25:	k[1] = k2;
       30:   26:	k[2] = k3;
       30:   27:	k[3] = k4;
       30:   28:	k[4] = k5;
       30:   29:	k[5] = k6;
       30:   30:	k[6] = k7;
       30:   31:	k[7] = k8;
       30:   32:	k[8] = k9;
       30:   33:	k[9] = k10;
       30:   34:	return k;
        -:   35:}
        -:   36:
       30:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		struct gameState *state) {
        -:   39:
        -:   40:	int i;
        -:   41:	int j;
        -:   42:	int it;
        -:   43:	//set up random number generator
       30:   44:	SelectStream(1);
       30:   45:	PutSeed((long)randomSeed);
        -:   46:
        -:   47:	//check number of players
       30:   48:	if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:	{
    #####:   50:		return -1;
        -:   51:	}
        -:   52:
        -:   53:	//set number of players
       30:   54:	state->numPlayers = numPlayers;
        -:   55:
        -:   56:	//check selected kingdom cards are different
       78:   57:	for (i = 0; i < 10; i++)
        -:   58:	{
      676:   59:		for (j = 0; j < 10; j++)
        -:   60:		{
      628:   61:			if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:			{
       28:   63:				return -1;
        -:   64:			}
        -:   65:		}
        -:   66:	}
        -:   67:
        -:   68:
        -:   69:	//initialize supply
        -:   70:	///////////////////////////////
        -:   71:
        -:   72:	//set number of Curse cards
        2:   73:	if (numPlayers == 2)
        -:   74:	{
        1:   75:		state->supplyCount[curse] = 10;
        -:   76:	}
        1:   77:	else if (numPlayers == 3)
        -:   78:	{
    #####:   79:		state->supplyCount[curse] = 20;
        -:   80:	}
        -:   81:	else
        -:   82:	{
        1:   83:		state->supplyCount[curse] = 30;
        -:   84:	}
        -:   85:
        -:   86:	//set number of Victory cards
        2:   87:	if (numPlayers == 2)
        -:   88:	{
        1:   89:		state->supplyCount[estate] = 8;
        1:   90:		state->supplyCount[duchy] = 8;
        1:   91:		state->supplyCount[province] = 8;
        -:   92:	}
        -:   93:	else
        -:   94:	{
        1:   95:		state->supplyCount[estate] = 12;
        1:   96:		state->supplyCount[duchy] = 12;
        1:   97:		state->supplyCount[province] = 12;
        -:   98:	}
        -:   99:
        -:  100:	//set number of Treasure cards
        2:  101:	state->supplyCount[copper] = 60 - (7 * numPlayers);
        2:  102:	state->supplyCount[silver] = 40;
        2:  103:	state->supplyCount[gold] = 30;
        -:  104:
        -:  105:	//set number of Kingdom cards
       42:  106:	for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:	{
      330:  108:		for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:		{
      310:  110:			if (kingdomCards[j] == i)
        -:  111:			{
        -:  112:				//check if card is a 'Victory' Kingdom card
       20:  113:				if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:				{
        4:  115:					if (numPlayers == 2){
        1:  116:						state->supplyCount[i] = 8;
        -:  117:					}
        1:  118:					else{ state->supplyCount[i] = 12; }
        -:  119:				}
        -:  120:				else
        -:  121:				{
       18:  122:					state->supplyCount[i] = 10;
        -:  123:				}
       20:  124:				break;
        -:  125:			}
        -:  126:			else    //card is not in the set choosen for the game
        -:  127:			{
      290:  128:				state->supplyCount[i] = -1;
        -:  129:			}
        -:  130:		}
        -:  131:
        -:  132:	}
        -:  133:
        -:  134:	////////////////////////
        -:  135:	//supply intilization complete
        -:  136:
        -:  137:	//set player decks
        8:  138:	for (i = 0; i < numPlayers; i++)
        -:  139:	{
        6:  140:		state->deckCount[i] = 0;
       24:  141:		for (j = 0; j < 3; j++)
        -:  142:		{
       18:  143:			state->deck[i][j] = estate;
       18:  144:			state->deckCount[i]++;
        -:  145:		}
       48:  146:		for (j = 3; j < 10; j++)
        -:  147:		{
       42:  148:			state->deck[i][j] = copper;
       42:  149:			state->deckCount[i]++;
        -:  150:		}
        -:  151:	}
        -:  152:
        -:  153:	//shuffle player decks
        8:  154:	for (i = 0; i < numPlayers; i++)
        -:  155:	{
        6:  156:		if (shuffle(i, state) < 0)
        -:  157:		{
    #####:  158:			return -1;
        -:  159:		}
        -:  160:	}
        -:  161:
        -:  162:	//draw player hands
        8:  163:	for (i = 0; i < numPlayers; i++)
        -:  164:	{
        -:  165:		//initialize hand size to zero
        6:  166:		state->handCount[i] = 0;
        6:  167:		state->discardCount[i] = 0;
        -:  168:		//draw 5 cards
        -:  169:		// for (j = 0; j < 5; j++)
        -:  170:		//	{
        -:  171:		//	  drawCard(i, state);
        -:  172:		//	}
        -:  173:	}
        -:  174:
        -:  175:	//set embargo tokens to 0 for all supply piles
       56:  176:	for (i = 0; i <= treasure_map; i++)
        -:  177:	{
       54:  178:		state->embargoTokens[i] = 0;
        -:  179:	}
        -:  180:
        -:  181:	//initialize first player's turn
        2:  182:	state->outpostPlayed = 0;
        2:  183:	state->phase = 0;
        2:  184:	state->numActions = 1;
        2:  185:	state->numBuys = 1;
        2:  186:	state->playedCardCount = 0;
        2:  187:	state->whoseTurn = 0;
        2:  188:	state->handCount[state->whoseTurn] = 0;
        -:  189:	//int it; move to top
        -:  190:
        -:  191:	//Moved draw cards to here, only drawing at the start of a turn
       12:  192:	for (it = 0; it < 5; it++){
       10:  193:		drawCard(state->whoseTurn, state);
        -:  194:	}
        -:  195:
        2:  196:	updateCoins(state->whoseTurn, state, 0);
        -:  197:
        2:  198:	return 0;
        -:  199:}
        -:  200:
       81:  201:int shuffle(int player, struct gameState *state) {
        -:  202:
        -:  203:
        -:  204:	int newDeck[MAX_DECK];
       81:  205:	int newDeckPos = 0;
        -:  206:	int card;
        -:  207:	int i;
        -:  208:
       81:  209:	if (state->deckCount[player] < 1)
    #####:  210:		return -1;
       81:  211:	qsort((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
        -:  212:	/* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
     1714:  214:	while (state->deckCount[player] > 0) {
     1552:  215:		card = floor(Random() * state->deckCount[player]);
     1552:  216:		newDeck[newDeckPos] = state->deck[player][card];
     1552:  217:		newDeckPos++;
    10076:  218:		for (i = card; i < state->deckCount[player] - 1; i++) {
     8524:  219:			state->deck[player][i] = state->deck[player][i + 1];
        -:  220:		}
     1552:  221:		state->deckCount[player]--;
        -:  222:	}
     1633:  223:	for (i = 0; i < newDeckPos; i++) {
     1552:  224:		state->deck[player][i] = newDeck[i];
     1552:  225:		state->deckCount[player]++;
        -:  226:	}
        -:  227:
       81:  228:	return 0;
        -:  229:}
        -:  230:
     1387:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state)
        -:  232:{
        -:  233:	int card;
     1387:  234:	int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:	//check if it is the right phase
     1387:  237:	if (state->phase != 0)
        -:  238:	{
      218:  239:		return -1;
        -:  240:	}
        -:  241:
        -:  242:	//check if player has enough actions
     1169:  243:	if (state->numActions < 1)
        -:  244:	{
       51:  245:		return -1;
        -:  246:	}
        -:  247:
        -:  248:	//get card played
     1118:  249:	card = handCard(handPos, state);
        -:  250:
        -:  251:	//check if selected card is an action
     1118:  252:	if (card < adventurer || card > treasure_map)
        -:  253:	{
      960:  254:		return -1;
        -:  255:	}
        -:  256:
        -:  257:	//play card
      158:  258:	if (cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0)
        -:  259:	{
       81:  260:		return -1;
        -:  261:	}
        -:  262:
        -:  263:	//reduce number of actions
       77:  264:	state->numActions--;
        -:  265:
        -:  266:	//update coins (Treasure cards may be added with card draws)
       77:  267:	updateCoins(state->whoseTurn, state, coin_bonus);
        -:  268:
       77:  269:	return 0;
        -:  270:}
        -:  271:
     1443:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:	int who;
        -:  274:	if (DEBUG){
        -:  275:		printf("Entering buyCard...\n");
        -:  276:	}
        -:  277:
        -:  278:	// I don't know what to do about the phase thing.
        -:  279:
     1443:  280:	who = state->whoseTurn;
        -:  281:
     1443:  282:	if (state->numBuys < 1){
        -:  283:		if (DEBUG)
        -:  284:			printf("You do not have any buys left\n");
      204:  285:		return -1;
        -:  286:	}
     1239:  287:	else if (supplyCount(supplyPos, state) < 1){
        -:  288:		if (DEBUG)
        -:  289:			printf("There are not any of that type of card left\n");
      495:  290:		return -1;
        -:  291:	}
      744:  292:	else if (state->coins < getCost(supplyPos)){
        -:  293:		if (DEBUG)
        -:  294:			printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
      526:  295:		return -1;
        -:  296:	}
        -:  297:	else {
      218:  298:		state->phase = 1;
        -:  299:		//state->supplyCount[supplyPos]--;
      218:  300:		gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  301:
      218:  302:		state->coins = (state->coins) - (getCost(supplyPos));
      218:  303:		state->numBuys--;
        -:  304:		if (DEBUG)
        -:  305:			printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  306:	}
        -:  307:
        -:  308:	//state->discard[who][state->discardCount[who]] = supplyPos;
        -:  309:	//state->discardCount[who]++;
        -:  310:
      218:  311:	return 0;
        -:  312:}
        -:  313:
    #####:  314:int numHandCards(struct gameState *state) {
    #####:  315:	return state->handCount[whoseTurn(state)];
        -:  316:}
        -:  317:
     1118:  318:int handCard(int handPos, struct gameState *state) {
     1118:  319:	int currentPlayer = whoseTurn(state);
     1118:  320:	return state->hand[currentPlayer][handPos];
        -:  321:}
        -:  322:
     1511:  323:int supplyCount(int card, struct gameState *state) {
     1511:  324:	return state->supplyCount[card];
        -:  325:}
        -:  326:
    #####:  327:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  328:	int i;
    #####:  329:	int count = 0;
        -:  330:
    #####:  331:	for (i = 0; i < state->deckCount[player]; i++)
        -:  332:	{
    #####:  333:		if (state->deck[player][i] == card) count++;
        -:  334:	}
        -:  335:
    #####:  336:	for (i = 0; i < state->handCount[player]; i++)
        -:  337:	{
    #####:  338:		if (state->hand[player][i] == card) count++;
        -:  339:	}
        -:  340:
    #####:  341:	for (i = 0; i < state->discardCount[player]; i++)
        -:  342:	{
    #####:  343:		if (state->discard[player][i] == card) count++;
        -:  344:	}
        -:  345:
    #####:  346:	return count;
        -:  347:}
        -:  348:
     1553:  349:int whoseTurn(struct gameState *state) {
     1553:  350:	return state->whoseTurn;
        -:  351:}
        -:  352:
      277:  353:int endTurn(struct gameState *state) {
        -:  354:	int k;
        -:  355:	int i;
      277:  356:	int currentPlayer = whoseTurn(state);
        -:  357:
        -:  358:	//Discard hand
     1638:  359:	for (i = 0; i < state->handCount[currentPlayer]; i++){
     1361:  360:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
     1361:  361:		state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  362:	}
      277:  363:	state->handCount[currentPlayer] = 0;//Reset hand count
        -:  364:
        -:  365:	//Code for determining the player
      277:  366:	if (currentPlayer < (state->numPlayers - 1)){
      185:  367:		state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  368:	}
        -:  369:	else{
       92:  370:		state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  371:	}
        -:  372:
      277:  373:	state->outpostPlayed = 0;
      277:  374:	state->phase = 0;
      277:  375:	state->numActions = 1;
      277:  376:	state->coins = 0;
      277:  377:	state->numBuys = 1;
      277:  378:	state->playedCardCount = 0;
      277:  379:	state->handCount[state->whoseTurn] = 0;
        -:  380:
        -:  381:	//int k; move to top
        -:  382:	//Next player draws hand
     1662:  383:	for (k = 0; k < 5; k++){
     1385:  384:		drawCard(state->whoseTurn, state);//Draw a card
        -:  385:	}
        -:  386:
        -:  387:	//Update money
      277:  388:	updateCoins(state->whoseTurn, state, 0);
        -:  389:
      277:  390:	return 0;
        -:  391:}
        -:  392:
     4192:  393:int isGameOver(struct gameState *state) {
        -:  394:	int i;
        -:  395:	int j;
        -:  396:
        -:  397:	//if stack of Province cards is empty, the game ends
     4192:  398:	if (state->supplyCount[province] == 0)
        -:  399:	{
    #####:  400:		return 1;
        -:  401:	}
        -:  402:
        -:  403:	//if three supply pile are at 0, the game ends
     4192:  404:	j = 0;
   108992:  405:	for (i = 0; i < 25; i++)
        -:  406:	{
   104800:  407:		if (state->supplyCount[i] == 0)
        -:  408:		{
     3796:  409:			j++;
        -:  410:		}
        -:  411:	}
     4192:  412:	if (j >= 3)
        -:  413:	{
        2:  414:		return 1;
        -:  415:	}
        -:  416:
     4190:  417:	return 0;
        -:  418:}
        -:  419:
    #####:  420:int scoreFor(int player, struct gameState *state) {
        -:  421:
        -:  422:	int i;
    #####:  423:	int score = 0;
        -:  424:	//score from hand
    #####:  425:	for (i = 0; i < state->handCount[player]; i++)
        -:  426:	{
    #####:  427:		if (state->hand[player][i] == curse) { score = score - 1; };
    #####:  428:		if (state->hand[player][i] == estate) { score = score + 1; };
    #####:  429:		if (state->hand[player][i] == duchy) { score = score + 3; };
    #####:  430:		if (state->hand[player][i] == province) { score = score + 6; };
    #####:  431:		if (state->hand[player][i] == great_hall) { score = score + 1; };
    #####:  432:		if (state->hand[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  433:	}
        -:  434:
        -:  435:	//score from discard
    #####:  436:	for (i = 0; i < state->discardCount[player]; i++)
        -:  437:	{
    #####:  438:		if (state->discard[player][i] == curse) { score = score - 1; };
    #####:  439:		if (state->discard[player][i] == estate) { score = score + 1; };
    #####:  440:		if (state->discard[player][i] == duchy) { score = score + 3; };
    #####:  441:		if (state->discard[player][i] == province) { score = score + 6; };
    #####:  442:		if (state->discard[player][i] == great_hall) { score = score + 1; };
    #####:  443:		if (state->discard[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  444:	}
        -:  445:
        -:  446:	//score from deck
    #####:  447:	for (i = 0; i < state->discardCount[player]; i++)
        -:  448:	{
    #####:  449:		if (state->deck[player][i] == curse) { score = score - 1; };
    #####:  450:		if (state->deck[player][i] == estate) { score = score + 1; };
    #####:  451:		if (state->deck[player][i] == duchy) { score = score + 3; };
    #####:  452:		if (state->deck[player][i] == province) { score = score + 6; };
    #####:  453:		if (state->deck[player][i] == great_hall) { score = score + 1; };
    #####:  454:		if (state->deck[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  455:	}
        -:  456:
    #####:  457:	return score;
        -:  458:}
        -:  459:
    #####:  460:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  461:	int i;
        -:  462:	int j;
        -:  463:	int highScore;
        -:  464:	int currentPlayer;
        -:  465:
        -:  466:	//get score for each player
    #####:  467:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  468:	{
        -:  469:		//set unused player scores to -9999
    #####:  470:		if (i >= state->numPlayers)
        -:  471:		{
    #####:  472:			players[i] = -9999;
        -:  473:		}
        -:  474:		else
        -:  475:		{
    #####:  476:			players[i] = scoreFor(i, state);
        -:  477:		}
        -:  478:	}
        -:  479:
        -:  480:	//find highest score
    #####:  481:	j = 0;
    #####:  482:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  483:	{
    #####:  484:		if (players[i] > players[j])
        -:  485:		{
    #####:  486:			j = i;
        -:  487:		}
        -:  488:	}
    #####:  489:	highScore = players[j];
        -:  490:
        -:  491:	//add 1 to players who had less turns
    #####:  492:	currentPlayer = whoseTurn(state);
    #####:  493:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  494:	{
    #####:  495:		if (players[i] == highScore && i > currentPlayer)
        -:  496:		{
    #####:  497:			players[i]++;
        -:  498:		}
        -:  499:	}
        -:  500:
        -:  501:	//find new highest score
    #####:  502:	j = 0;
    #####:  503:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  504:	{
    #####:  505:		if (players[i] > players[j])
        -:  506:		{
    #####:  507:			j = i;
        -:  508:		}
        -:  509:	}
    #####:  510:	highScore = players[j];
        -:  511:
        -:  512:	//set winners in array to 1 and rest to 0
    #####:  513:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  514:	{
    #####:  515:		if (players[i] == highScore)
        -:  516:		{
    #####:  517:			players[i] = 1;
        -:  518:		}
        -:  519:		else
        -:  520:		{
    #####:  521:			players[i] = 0;
        -:  522:		}
        -:  523:	}
        -:  524:
    #####:  525:	return 0;
        -:  526:}
        -:  527:
     1433:  528:int drawCard(int player, struct gameState *state)
        -:  529:{
        -:  530:	int count;
        -:  531:	int deckCounter;
     1433:  532:	if (state->deckCount[player] <= 0){//Deck is empty
        -:  533:
        -:  534:		//Step 1 Shuffle the discard pile back into a deck
        -:  535:		int i;
        -:  536:		//Move discard to deck
     1567:  537:		for (i = 0; i < state->discardCount[player]; i++){
     1492:  538:			state->deck[player][i] = state->discard[player][i];
     1492:  539:			state->discard[player][i] = -1;
        -:  540:		}
        -:  541:
       75:  542:		state->deckCount[player] = state->discardCount[player];
       75:  543:		state->discardCount[player] = 0;//Reset discard
        -:  544:
        -:  545:		//Shufffle the deck
       75:  546:		shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  547:
        -:  548:		if (DEBUG){//Debug statements
        -:  549:			printf("Deck count now: %d\n", state->deckCount[player]);
        -:  550:		}
        -:  551:
       75:  552:		state->discardCount[player] = 0;
        -:  553:
        -:  554:		//Step 2 Draw Card
       75:  555:		count = state->handCount[player];//Get current player's hand count
        -:  556:
        -:  557:		if (DEBUG){//Debug statements
        -:  558:			printf("Current hand count: %d\n", count);
        -:  559:		}
        -:  560:
       75:  561:		deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  562:
       75:  563:		if (deckCounter == 0)
    #####:  564:			return -1;
        -:  565:
       75:  566:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
       75:  567:		state->deckCount[player]--;
       75:  568:		state->handCount[player]++;//Increment hand count
        -:  569:	}
        -:  570:
        -:  571:	else{
     1358:  572:		int count = state->handCount[player];//Get current hand count for player
        -:  573:		int deckCounter;
        -:  574:		if (DEBUG){//Debug statements
        -:  575:			printf("Current hand count: %d\n", count);
        -:  576:		}
        -:  577:
     1358:  578:		deckCounter = state->deckCount[player];//Create holder for the deck count
     1358:  579:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
     1358:  580:		state->deckCount[player]--;
     1358:  581:		state->handCount[player]++;//Increment hand count
        -:  582:	}
        -:  583:
     1433:  584:	return 0;
        -:  585:}
        -:  586:
      972:  587:int getCost(int cardNumber)
        -:  588:{
      972:  589:	switch (cardNumber)
        -:  590:	{
        -:  591:	case curse:
       67:  592:		return 0;
        -:  593:	case estate:
       21:  594:		return 2;
        -:  595:	case duchy:
       52:  596:		return 5;
        -:  597:	case province:
       47:  598:		return 8;
        -:  599:	case copper:
       88:  600:		return 0;
        -:  601:	case silver:
       89:  602:		return 3;
        -:  603:	case gold:
       62:  604:		return 6;
        -:  605:	case adventurer:
       22:  606:		return 6;
        -:  607:	case council_room:
       49:  608:		return 5;
        -:  609:	case feast:
       20:  610:		return 4;
        -:  611:	case gardens:
       37:  612:		return 4;
        -:  613:	case mine:
    #####:  614:		return 5;
        -:  615:	case remodel:
       60:  616:		return 4;
        -:  617:	case smithy:
    #####:  618:		return 4;
        -:  619:	case village:
       25:  620:		return 3;
        -:  621:	case baron:
       60:  622:		return 4;
        -:  623:	case great_hall:
       30:  624:		return 3;
        -:  625:	case minion:
       17:  626:		return 5;
        -:  627:	case steward:
    #####:  628:		return 3;
        -:  629:	case tribute:
       27:  630:		return 5;
        -:  631:	case ambassador:
       38:  632:		return 3;
        -:  633:	case cutpurse:
       53:  634:		return 4;
        -:  635:	case embargo:
    #####:  636:		return 2;
        -:  637:	case outpost:
       17:  638:		return 5;
        -:  639:	case salvager:
       23:  640:		return 4;
        -:  641:	case sea_hag:
       29:  642:		return 4;
        -:  643:	case treasure_map:
       39:  644:		return 4;
        -:  645:	}
        -:  646:
    #####:  647:	return -1;
        -:  648:}
        -:  649:
    #####:  650:void playAdventurer(struct gameState *state, int currentPlayer)
        -:  651:// Reveal cards from deck until 2 Treasure cards are found.  Put those Treasure cards in the hand and discard the rest.
        -:  652:{
    #####:  653:	int drawntreasure = 0;
        -:  654:	int temphand[MAX_HAND];
        -:  655:	int cardDrawn;
    #####:  656:	int z = 0; // this is the counter for the temp hand
        -:  657:
    #####:  658:	while (drawntreasure < 2){
    #####:  659:		if (state->deckCount[currentPlayer] < 1){//if the deck is empty we need to shuffle discard and add to deck
    #####:  660:			shuffle(currentPlayer, state);
        -:  661:		}
    #####:  662:		drawCard(currentPlayer, state);
    #####:  663:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer] - 1];//top card of hand is most recently drawn card.
    #####:  664:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
    #####:  665:			drawntreasure++;
        -:  666:		else{
    #####:  667:			temphand[z] = cardDrawn;
    #####:  668:			state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####:  669:			z++;
        -:  670:		}
        -:  671:	}
    #####:  672:	while (z - 1 >= 0){
    #####:  673:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; // discard all cards in play that have been drawn
    #####:  674:		z = z - 1;
        -:  675:	}
    #####:  676:}
        -:  677:
        3:  678:int playRemodel(struct gameState *state, int currentPlayer, int choice1, int choice2, int handPos)
        -:  679://Trash a card in the hand, and gain a card costing up to $2 more than the trashed card
        -:  680:{
        -:  681:	int i;
        3:  682:	int j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  683:
        3:  684:	if ((getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2))
        -:  685:	{
    #####:  686:		return -1;
        -:  687:	}
        -:  688:
        3:  689:	gainCard(choice2, state, 0, currentPlayer);
        -:  690:
        -:  691:	//discard card from hand
        3:  692:	discardCard(handPos, currentPlayer, state, 0);
        -:  693:
        -:  694:	//discard trashed card
       12:  695:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  696:	{
       10:  697:		if (state->hand[currentPlayer][i] == j)
        -:  698:		{
        1:  699:			discardCard(i, currentPlayer, state, 0);
        1:  700:			break;
        -:  701:		}
        -:  702:	}
        -:  703:
        3:  704:	return 0;
        -:  705:}
        -:  706:
    #####:  707:void playSmithy(struct gameState *state, int currentPlayer, int handPos)
        -:  708:// Draw 3 cards
        -:  709:{
        -:  710:	int i;
    #####:  711:	for (i = 0; i < 3; i++)
        -:  712:	{
    #####:  713:		drawCard(currentPlayer, state);
        -:  714:	}
        -:  715:
        -:  716:	//discard card from hand
    #####:  717:	discardCard(handPos, currentPlayer, state, 0);
    #####:  718:}
        -:  719:
       28:  720:void playBaron(struct gameState *state, int currentPlayer, int choice1, int handPos)
        -:  721://Add a buy.  OPTION:  Discard an Estate card and gain $4.  Otherwise, gain an Estate card.
        -:  722:{
       28:  723:	state->numBuys++;//Increase buys by 1!
       28:  724:	if (choice1 > 0){//Boolean true or going to discard an estate
       25:  725:		int p = 0;//Iterator for hand!
       25:  726:		int card_not_discarded = 1;//Flag for discard set!
      176:  727:		while (card_not_discarded){
      126:  728:			if (state->hand[currentPlayer][p] == estate){ //Found an estate card!
       13:  729:				state->coins += 4;//Add 4 coins to the amount of coins
       13:  730:				state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
       13:  731:				state->discardCount[currentPlayer]++;
       49:  732:				for (; p < state->handCount[currentPlayer]; p++){
       36:  733:					state->hand[currentPlayer][p] = state->hand[currentPlayer][p + 1];
        -:  734:				}
       13:  735:				state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
       13:  736:				state->handCount[currentPlayer]--;
       13:  737:				card_not_discarded = 0;//Exit the loop
        -:  738:			}
      113:  739:			else if (p > state->handCount[currentPlayer]){
        -:  740:				if (DEBUG) {
        -:  741:					printf("No estate cards in your hand, invalid choice\n");
        -:  742:					printf("Must gain an estate if there are any\n");
        -:  743:				}
       12:  744:				if (supplyCount(estate, state) > 0){
        5:  745:					gainCard(estate, state, 1, currentPlayer);
        5:  746:					state->supplyCount[estate]--;//Decrement estates
        5:  747:					if (supplyCount(estate, state) == 0){
    #####:  748:						isGameOver(state);
        -:  749:					}
        -:  750:				}
       12:  751:				card_not_discarded = 0;//Exit the loop
        -:  752:			}
        -:  753:
        -:  754:			else{
      101:  755:				p++;//Next card
        -:  756:			}
        -:  757:		}
        -:  758:	}
        -:  759:
        -:  760:	else{
        3:  761:		if (supplyCount(estate, state) > 0){
        1:  762:			gainCard(estate, state, 0, currentPlayer);//Gain an estate
        1:  763:			state->supplyCount[estate]--;//Decrement Estates
        1:  764:			if (supplyCount(estate, state) == 0){
    #####:  765:				isGameOver(state);
        -:  766:			}
        -:  767:		}
        -:  768:	}
       28:  769:}
        -:  770:
        3:  771:int playTreasureMap(struct gameState *state, int currentPlayer, int handPos)
        -:  772://Trashing two treasure map cards from the hand = four gold on top of the deck.
        -:  773:{
        -:  774:	int i;
        -:  775:	int index;
        -:  776:
        -:  777:	//search hand for another treasure_map
       18:  778:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  779:	{
       15:  780:		if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -:  781:		{
    #####:  782:			index = i;
    #####:  783:			break;
        -:  784:		}
        -:  785:	}
        3:  786:	if (index > -1)
        -:  787:	{
        -:  788:		//trash both treasure cards
        3:  789:		discardCard(handPos, currentPlayer, state, 1);
        3:  790:		discardCard(index, currentPlayer, state, 1);
        -:  791:
        -:  792:		//gain 4 Gold cards
       15:  793:		for (i = 0; i < 4; i++)
        -:  794:		{
       12:  795:			gainCard(gold, state, 1, currentPlayer);
        -:  796:		}
        -:  797:
        -:  798:		//return success
        3:  799:		return 1;
        -:  800:	}
        -:  801:
        -:  802:	//no second treasure_map found in hand
    #####:  803:	return -1;
        -:  804:}
        -:  805:
      158:  806:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  807:{
        -:  808:	int i;
        -:  809:	int j;
        -:  810:	int k;
        -:  811:	//int x;  //Unused after while loop removed from feast.
      158:  812:	int currentPlayer = whoseTurn(state);
      158:  813:	int nextPlayer = currentPlayer + 1;
        -:  814:	int temphand[MAX_HAND];
        -:  815:
      158:  816:	int tributeRevealedCards[2] = { -1, -1 };
        -:  817:
      158:  818:	if (nextPlayer > (state->numPlayers - 1)){
       64:  819:		nextPlayer = 0;
        -:  820:	}
        -:  821:
        -:  822:	//uses switch to select card and perform actions
      158:  823:	switch (card)
        -:  824:	{
        -:  825:	case adventurer:
        -:  826:
    #####:  827:		playAdventurer(state, currentPlayer);
    #####:  828:		return 0;
        -:  829:
        -:  830:	case council_room:
        -:  831:		//+4 Cards
       15:  832:		for (i = 0; i < 4; i++)
        -:  833:		{
       12:  834:			drawCard(currentPlayer, state);
        -:  835:		}
        -:  836:
        -:  837:		//+1 Buy
        3:  838:		state->numBuys++;
        -:  839:
        -:  840:		//Each other player draws a card
       13:  841:		for (i = 0; i < state->numPlayers; i++)
        -:  842:		{
       10:  843:			if (i != currentPlayer)
        -:  844:			{
        7:  845:				drawCard(i, state);
        -:  846:			}
        -:  847:		}
        -:  848:
        -:  849:		//put played card in played card pile
        3:  850:		discardCard(handPos, currentPlayer, state, 0);
        -:  851:
        3:  852:		return 0;
        -:  853:
        -:  854:	case feast:
        -:  855:		//gain card with cost up to 5
        -:  856:		//Backup hand
       35:  857:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
       30:  858:			temphand[i] = state->hand[currentPlayer][i];//Backup card
       30:  859:			state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  860:		}
        -:  861:		//Backup hand
        -:  862:
        -:  863:		//Update Coins for Buy
        5:  864:		updateCoins(currentPlayer, state, 5);
        -:  865://		x = 1;//Condition to loop on
        -:  866://		while (x == 1) {//Buy one card
        5:  867:			if (supplyCount(choice1, state) <= 0){
        -:  868:				if (DEBUG)
        -:  869:					printf("None of that card left, sorry!\n");
        -:  870:
        -:  871:				if (DEBUG){
        -:  872:					printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  873:				}
        -:  874:			}
        4:  875:			else if (state->coins < getCost(choice1)){
    #####:  876:				printf("That card is too expensive!\n");
        -:  877:
        -:  878:				if (DEBUG){
        -:  879:					printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  880:				}
        -:  881:			}
        -:  882:			else{
        -:  883:
        -:  884:				if (DEBUG){
        -:  885:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  886:				}
        -:  887:
        4:  888:				gainCard(choice1, state, 0, currentPlayer);//Gain the card
        -:  889://				x = 0;//No more buying cards
        -:  890:
        -:  891:				if (DEBUG){
        -:  892:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  893:				}
        -:  894:
        -:  895:			}
        -:  896://		}
        -:  897:
        -:  898:		//Reset Hand
       35:  899:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
       30:  900:			state->hand[currentPlayer][i] = temphand[i];
       30:  901:			temphand[i] = -1;
        -:  902:		}
        -:  903:		//Reset Hand
        -:  904:
        5:  905:		return 0;
        -:  906:
        -:  907:	case gardens:
       23:  908:		return -1;
        -:  909:
        -:  910:	case mine:
    #####:  911:		j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  912:
    #####:  913:		if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  914:		{
    #####:  915:			return -1;
        -:  916:		}
        -:  917:
    #####:  918:		if (choice2 > treasure_map || choice2 < curse)
        -:  919:		{
    #####:  920:			return -1;
        -:  921:		}
        -:  922:
    #####:  923:		if ((getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2))
        -:  924:		{
    #####:  925:			return -1;
        -:  926:		}
        -:  927:
    #####:  928:		gainCard(choice2, state, 2, currentPlayer);
        -:  929:
        -:  930:		//discard card from hand
    #####:  931:		discardCard(handPos, currentPlayer, state, 0);
        -:  932:
        -:  933:		//discard trashed card
    #####:  934:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  935:		{
    #####:  936:			if (state->hand[currentPlayer][i] == j)
        -:  937:			{
    #####:  938:				discardCard(i, currentPlayer, state, 0);
    #####:  939:				break;
        -:  940:			}
        -:  941:		}
        -:  942:
    #####:  943:		return 0;
        -:  944:
        -:  945:	case remodel:
        -:  946:
        3:  947:		return playRemodel(state, currentPlayer, choice1, choice2, handPos);
        -:  948:
        -:  949:	case smithy:
        -:  950:
    #####:  951:		playSmithy(state, currentPlayer, handPos);
    #####:  952:		return 0;
        -:  953:
        -:  954:	case village:
        -:  955:		//+1 Card
       11:  956:		drawCard(currentPlayer, state);
        -:  957:
        -:  958:		//+2 Actions
       11:  959:		state->numActions = state->numActions + 2;
        -:  960:
        -:  961:		//discard played card from hand
       11:  962:		discardCard(handPos, currentPlayer, state, 0);
       11:  963:		return 0;
        -:  964:
        -:  965:	case baron:
        -:  966:
       28:  967:		playBaron(state, currentPlayer, choice1, handPos);
       28:  968:		return 0;
        -:  969:
        -:  970:	case great_hall:
        -:  971:		//+1 Card
        8:  972:		drawCard(currentPlayer, state);
        -:  973:
        -:  974:		//+1 Actions
        8:  975:		state->numActions++;
        -:  976:
        -:  977:		//discard card from hand
        8:  978:		discardCard(handPos, currentPlayer, state, 0);
        8:  979:		return 0;
        -:  980:
        -:  981:	case minion:
        -:  982:		//+1 action
        1:  983:		state->numActions++;
        -:  984:
        -:  985:		//discard card from hand
        1:  986:		discardCard(handPos, currentPlayer, state, 0);
        -:  987:
        1:  988:		if (choice1)		//+2 coins
        -:  989:		{
        1:  990:			state->coins = state->coins + 2;
        -:  991:		}
        -:  992:
    #####:  993:		else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  994:		{
        -:  995:			//discard hand
    #####:  996:			while (numHandCards(state) > 0)
        -:  997:			{
    #####:  998:				discardCard(handPos, currentPlayer, state, 0);
        -:  999:			}
        -: 1000:
        -: 1001:			//draw 4
    #####: 1002:			for (i = 0; i < 4; i++)
        -: 1003:			{
    #####: 1004:				drawCard(currentPlayer, state);
        -: 1005:			}
        -: 1006:
        -: 1007:			//other players discard hand and redraw if hand size > 4
    #####: 1008:			for (i = 0; i < state->numPlayers; i++)
        -: 1009:			{
    #####: 1010:				if (i != currentPlayer)
        -: 1011:				{
    #####: 1012:					if (state->handCount[i] > 4)
        -: 1013:					{
        -: 1014:						//discard hand
    #####: 1015:						while (state->handCount[i] > 0)
        -: 1016:						{
    #####: 1017:							discardCard(handPos, i, state, 0);
        -: 1018:						}
        -: 1019:
        -: 1020:						//draw 4
    #####: 1021:						for (j = 0; j < 4; j++)
        -: 1022:						{
    #####: 1023:							drawCard(i, state);
        -: 1024:						}
        -: 1025:					}
        -: 1026:				}
        -: 1027:			}
        -: 1028:
        -: 1029:		}
        1: 1030:		return 0;
        -: 1031:
        -: 1032:	case steward:
    #####: 1033:		if (choice1 == 1)
        -: 1034:		{
        -: 1035:			//+2 cards
    #####: 1036:			drawCard(currentPlayer, state);
    #####: 1037:			drawCard(currentPlayer, state);
        -: 1038:		}
    #####: 1039:		else if (choice1 == 2)
        -: 1040:		{
        -: 1041:			//+2 coins
    #####: 1042:			state->coins = state->coins + 2;
        -: 1043:		}
        -: 1044:		else
        -: 1045:		{
        -: 1046:			//trash 2 cards in hand
    #####: 1047:			discardCard(choice2, currentPlayer, state, 1);
    #####: 1048:			discardCard(choice3, currentPlayer, state, 1);
        -: 1049:		}
        -: 1050:
        -: 1051:		//discard card from hand
    #####: 1052:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1053:		return 0;
        -: 1054:
        -: 1055:	case tribute:
    #####: 1056:		if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####: 1057:			if (state->deckCount[nextPlayer] > 0){
    #####: 1058:				tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1059:				state->deckCount[nextPlayer]--;
        -: 1060:			}
    #####: 1061:			else if (state->discardCount[nextPlayer] > 0){
    #####: 1062:				tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer] - 1];
    #####: 1063:				state->discardCount[nextPlayer]--;
        -: 1064:			}
        -: 1065:			else{
        -: 1066:				//No Card to Reveal
        -: 1067:				if (DEBUG){
        -: 1068:					printf("No cards to reveal\n");
        -: 1069:				}
        -: 1070:			}
        -: 1071:		}
        -: 1072:
        -: 1073:		else{
    #####: 1074:			if (state->deckCount[nextPlayer] == 0){
    #####: 1075:				for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####: 1076:					state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1077:					state->deckCount[nextPlayer]++;
    #####: 1078:					state->discard[nextPlayer][i] = -1;
    #####: 1079:					state->discardCount[nextPlayer]--;
        -: 1080:				}
        -: 1081:
    #####: 1082:				shuffle(nextPlayer, state);//Shuffle the deck
        -: 1083:			}
    #####: 1084:			tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1085:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1086:			state->deckCount[nextPlayer]--;
    #####: 1087:			tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1088:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1089:			state->deckCount[nextPlayer]--;
        -: 1090:		}
        -: 1091:
    #####: 1092:		if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
    #####: 1093:			state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1094:			state->playedCardCount++;
    #####: 1095:			tributeRevealedCards[1] = -1;
        -: 1096:		}
        -: 1097:
    #####: 1098:		for (i = 0; i <= 2; i++){
    #####: 1099:			if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
    #####: 1100:				state->coins += 2;
        -: 1101:			}
        -: 1102:
    #####: 1103:			else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
    #####: 1104:				drawCard(currentPlayer, state);
    #####: 1105:				drawCard(currentPlayer, state);
        -: 1106:			}
        -: 1107:			else{//Action Card
    #####: 1108:				state->numActions = state->numActions + 2;
        -: 1109:			}
        -: 1110:		}
        -: 1111:
    #####: 1112:		return 0;
        -: 1113:
        -: 1114:	case ambassador:
       61: 1115:		j = 0;		//used to check if player has enough cards to discard
        -: 1116:
       61: 1117:		if (choice2 > 2 || choice2 < 0)
        -: 1118:		{
       56: 1119:			return -1;
        -: 1120:		}
        -: 1121:
        5: 1122:		if (choice1 == handPos)
        -: 1123:		{
    #####: 1124:			return -1;
        -: 1125:		}
        -: 1126:
       30: 1127:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1128:		{
       25: 1129:			if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1130:			{
        5: 1131:				j++;
        -: 1132:			}
        -: 1133:		}
        5: 1134:		if (j < choice2)
        -: 1135:		{
        2: 1136:			return -1;
        -: 1137:		}
        -: 1138:
        -: 1139:		if (DEBUG)
        -: 1140:			printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1141:
        -: 1142:		//increase supply count for choosen card by amount being discarded
        3: 1143:		state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1144:
        -: 1145:		//each other player gains a copy of revealed card
        9: 1146:		for (i = 0; i < state->numPlayers; i++)
        -: 1147:		{
        6: 1148:			if (i != currentPlayer)
        -: 1149:			{
        3: 1150:				gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1151:			}
        -: 1152:		}
        -: 1153:
        -: 1154:		//discard played card from hand
        3: 1155:		discardCard(handPos, currentPlayer, state, 0);
        -: 1156:
        -: 1157:		//trash copies of cards returned to supply
        5: 1158:		for (j = 0; j < choice2; j++)
        -: 1159:		{
       10: 1160:			for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1161:			{
        8: 1162:				if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1163:				{
    #####: 1164:					discardCard(i, currentPlayer, state, 1);
    #####: 1165:					break;
        -: 1166:				}
        -: 1167:			}
        -: 1168:		}
        -: 1169:
        3: 1170:		return 0;
        -: 1171:
        -: 1172:	case cutpurse:
        -: 1173:
        6: 1174:		updateCoins(currentPlayer, state, 2);
       24: 1175:		for (i = 0; i < state->numPlayers; i++)
        -: 1176:		{
       18: 1177:			if (i != currentPlayer)
        -: 1178:			{
       12: 1179:				for (j = 0; j < state->handCount[i]; j++)
        -: 1180:				{
    #####: 1181:					if (state->hand[i][j] == copper)
        -: 1182:					{
    #####: 1183:						discardCard(j, i, state, 0);
    #####: 1184:						break;
        -: 1185:					}
    #####: 1186:					if (j == state->handCount[i])
        -: 1187:					{
    #####: 1188:						for (k = 0; k < state->handCount[i]; k++)
        -: 1189:						{
        -: 1190:							if (DEBUG)
        -: 1191:								printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1192:						}
    #####: 1193:						break;
        -: 1194:					}
        -: 1195:				}
        -: 1196:
        -: 1197:			}
        -: 1198:
        -: 1199:		}
        -: 1200:
        -: 1201:		//discard played card from hand
        6: 1202:		discardCard(handPos, currentPlayer, state, 0);
        -: 1203:
        6: 1204:		return 0;
        -: 1205:
        -: 1206:
        -: 1207:	case embargo:
        -: 1208:		//+2 Coins
    #####: 1209:		state->coins = state->coins + 2;
        -: 1210:
        -: 1211:		//see if selected pile is in play
    #####: 1212:		if (state->supplyCount[choice1] == -1)
        -: 1213:		{
    #####: 1214:			return -1;
        -: 1215:		}
        -: 1216:
        -: 1217:		//add embargo token to selected supply pile
    #####: 1218:		state->embargoTokens[choice1]++;
        -: 1219:
        -: 1220:		//trash card
    #####: 1221:		discardCard(handPos, currentPlayer, state, 1);
    #####: 1222:		return 0;
        -: 1223:
        -: 1224:	case outpost:
        -: 1225:		//set outpost flag
    #####: 1226:		state->outpostPlayed++;
        -: 1227:
        -: 1228:		//discard card
    #####: 1229:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1230:		return 0;
        -: 1231:
        -: 1232:	case salvager:
        -: 1233:		//+1 buy
    #####: 1234:		state->numBuys++;
        -: 1235:
    #####: 1236:		if (choice1)
        -: 1237:		{
        -: 1238:			//gain coins equal to trashed card
    #####: 1239:			state->coins = state->coins + getCost(handCard(choice1, state));
        -: 1240:			//trash card
    #####: 1241:			discardCard(choice1, currentPlayer, state, 1);
        -: 1242:		}
        -: 1243:
        -: 1244:		//discard card
    #####: 1245:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1246:		return 0;
        -: 1247:
        -: 1248:	case sea_hag:
       30: 1249:		for (i = 0; i < state->numPlayers; i++){
       24: 1250:			if (i != currentPlayer){
       18: 1251:				state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
       18: 1252:				state->discardCount[i]++;
       18: 1253:				state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1254:			}
        -: 1255:		}
        6: 1256:		return 0;
        -: 1257:
        -: 1258:	case treasure_map:
        -: 1259:
        3: 1260:		return playTreasureMap(state, currentPlayer, handPos);
        -: 1261:	}
    #####: 1262:	return -1;
        -: 1263:}
        -: 1264:
       42: 1265:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1266:{
        -: 1267:
        -: 1268:	//if card is not trashed, added to Played pile 
       42: 1269:	if (trashFlag < 1)
        -: 1270:	{
        -: 1271:		//add card to played pile
       36: 1272:		state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
       36: 1273:		state->playedCardCount++;
        -: 1274:	}
        -: 1275:
        -: 1276:	//set played card to -1
       42: 1277:	state->hand[currentPlayer][handPos] = -1;
        -: 1278:
        -: 1279:	//remove card from player's hand
       42: 1280:	if (handPos == (state->handCount[currentPlayer] - 1)) 	//last card in hand array is played
        -: 1281:	{
        -: 1282:		//reduce number of cards in hand
        2: 1283:		state->handCount[currentPlayer]--;
        -: 1284:	}
       40: 1285:	else if (state->handCount[currentPlayer] == 1) //only one card in hand
        -: 1286:	{
        -: 1287:		//reduce number of cards in hand
    #####: 1288:		state->handCount[currentPlayer]--;
        -: 1289:	}
        -: 1290:	else
        -: 1291:	{
        -: 1292:		//replace discarded card with last card in hand
       40: 1293:		state->hand[currentPlayer][handPos] = state->hand[currentPlayer][(state->handCount[currentPlayer] - 1)];
        -: 1294:		//set last card to -1
       40: 1295:		state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1296:		//reduce number of cards in hand
       40: 1297:		state->handCount[currentPlayer]--;
        -: 1298:	}
        -: 1299:
       42: 1300:	return 0;
        -: 1301:}
        -: 1302:
      246: 1303:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1304:{
        -: 1305:	//Note: supplyPos is enum of choosen card
        -: 1306:
        -: 1307:	//check if supply pile is empty (0) or card is not used in game (-1)
      246: 1308:	if (supplyCount(supplyPos, state) < 1)
        -: 1309:	{
        1: 1310:		return -1;
        -: 1311:	}
        -: 1312:
        -: 1313:	//added card for [whoseTurn] current player:
        -: 1314:	// toFlag = 0 : add to discard
        -: 1315:	// toFlag = 1 : add to deck
        -: 1316:	// toFlag = 2 : add to hand
        -: 1317:
      245: 1318:	if (toFlag == 1)
        -: 1319:	{
       17: 1320:		state->deck[player][state->deckCount[player]] = supplyPos;
       17: 1321:		state->deckCount[player]++;
        -: 1322:	}
      228: 1323:	else if (toFlag == 2)
        -: 1324:	{
    #####: 1325:		state->hand[player][state->handCount[player]] = supplyPos;
    #####: 1326:		state->handCount[player]++;
        -: 1327:	}
        -: 1328:	else
        -: 1329:	{
      228: 1330:		state->discard[player][state->discardCount[player]] = supplyPos;
      228: 1331:		state->discardCount[player]++;
        -: 1332:	}
        -: 1333:
        -: 1334:	//decrease number in supply pile
      245: 1335:	state->supplyCount[supplyPos]--;
        -: 1336:
      245: 1337:	return 0;
        -: 1338:}
        -: 1339:
      367: 1340:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1341:{
        -: 1342:	int i;
        -: 1343:
        -: 1344:	//reset coin count
      367: 1345:	state->coins = 0;
        -: 1346:
        -: 1347:	//add coins for each Treasure card in player's hand
     2178: 1348:	for (i = 0; i < state->handCount[player]; i++)
        -: 1349:	{
     1811: 1350:		if (state->hand[player][i] == copper)
        -: 1351:		{
      709: 1352:			state->coins += 1;
        -: 1353:		}
     1102: 1354:		else if (state->hand[player][i] == silver)
        -: 1355:		{
      154: 1356:			state->coins += 2;
        -: 1357:		}
      948: 1358:		else if (state->hand[player][i] == gold)
        -: 1359:		{
       73: 1360:			state->coins += 3;
        -: 1361:		}
        -: 1362:	}
        -: 1363:
        -: 1364:	//add bonus
      367: 1365:	state->coins += bonus;
        -: 1366:
      367: 1367:	return 0;
        -: 1368:}
        -: 1369:
        -: 1370:
        -: 1371://end of dominion.c
File 'dominion.c'
Lines executed:64.63% of 557
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
     2663:    8:int compare(const void* a, const void* b) {
     2663:    9:	if (*(int*)a > *(int*)b)
      983:   10:		return 1;
     1680:   11:	if (*(int*)a < *(int*)b)
      748:   12:		return -1;
      932:   13:	return 0;
        -:   14:}
        -:   15:
        4:   16:struct gameState* newGame() {
        4:   17:	struct gameState* g = malloc(sizeof(struct gameState));
        4:   18:	return g;
        -:   19:}
        -:   20:
       16:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:	int k8, int k9, int k10) {
       16:   23:	int* k = malloc(10 * sizeof(int));
       16:   24:	k[0] = k1;
       16:   25:	k[1] = k2;
       16:   26:	k[2] = k3;
       16:   27:	k[3] = k4;
       16:   28:	k[4] = k5;
       16:   29:	k[5] = k6;
       16:   30:	k[6] = k7;
       16:   31:	k[7] = k8;
       16:   32:	k[8] = k9;
       16:   33:	k[9] = k10;
       16:   34:	return k;
        -:   35:}
        -:   36:
       16:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		struct gameState *state) {
        -:   39:
        -:   40:	int i;
        -:   41:	int j;
        -:   42:	int it;
        -:   43:	//set up random number generator
       16:   44:	SelectStream(1);
       16:   45:	PutSeed((long)randomSeed);
        -:   46:
        -:   47:	//check number of players
       16:   48:	if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:	{
    #####:   50:		return -1;
        -:   51:	}
        -:   52:
        -:   53:	//set number of players
       16:   54:	state->numPlayers = numPlayers;
        -:   55:
        -:   56:	//check selected kingdom cards are different
       53:   57:	for (i = 0; i < 10; i++)
        -:   58:	{
      495:   59:		for (j = 0; j < 10; j++)
        -:   60:		{
      458:   61:			if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:			{
       14:   63:				return -1;
        -:   64:			}
        -:   65:		}
        -:   66:	}
        -:   67:
        -:   68:
        -:   69:	//initialize supply
        -:   70:	///////////////////////////////
        -:   71:
        -:   72:	//set number of Curse cards
        2:   73:	if (numPlayers == 2)
        -:   74:	{
        1:   75:		state->supplyCount[curse] = 10;
        -:   76:	}
        1:   77:	else if (numPlayers == 3)
        -:   78:	{
        1:   79:		state->supplyCount[curse] = 20;
        -:   80:	}
        -:   81:	else
        -:   82:	{
    #####:   83:		state->supplyCount[curse] = 30;
        -:   84:	}
        -:   85:
        -:   86:	//set number of Victory cards
        2:   87:	if (numPlayers == 2)
        -:   88:	{
        1:   89:		state->supplyCount[estate] = 8;
        1:   90:		state->supplyCount[duchy] = 8;
        1:   91:		state->supplyCount[province] = 8;
        -:   92:	}
        -:   93:	else
        -:   94:	{
        1:   95:		state->supplyCount[estate] = 12;
        1:   96:		state->supplyCount[duchy] = 12;
        1:   97:		state->supplyCount[province] = 12;
        -:   98:	}
        -:   99:
        -:  100:	//set number of Treasure cards
        2:  101:	state->supplyCount[copper] = 60 - (7 * numPlayers);
        2:  102:	state->supplyCount[silver] = 40;
        2:  103:	state->supplyCount[gold] = 30;
        -:  104:
        -:  105:	//set number of Kingdom cards
       42:  106:	for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:	{
      330:  108:		for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:		{
      310:  110:			if (kingdomCards[j] == i)
        -:  111:			{
        -:  112:				//check if card is a 'Victory' Kingdom card
       20:  113:				if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:				{
        6:  115:					if (numPlayers == 2){
        2:  116:						state->supplyCount[i] = 8;
        -:  117:					}
        1:  118:					else{ state->supplyCount[i] = 12; }
        -:  119:				}
        -:  120:				else
        -:  121:				{
       17:  122:					state->supplyCount[i] = 10;
        -:  123:				}
       20:  124:				break;
        -:  125:			}
        -:  126:			else    //card is not in the set choosen for the game
        -:  127:			{
      290:  128:				state->supplyCount[i] = -1;
        -:  129:			}
        -:  130:		}
        -:  131:
        -:  132:	}
        -:  133:
        -:  134:	////////////////////////
        -:  135:	//supply intilization complete
        -:  136:
        -:  137:	//set player decks
        7:  138:	for (i = 0; i < numPlayers; i++)
        -:  139:	{
        5:  140:		state->deckCount[i] = 0;
       20:  141:		for (j = 0; j < 3; j++)
        -:  142:		{
       15:  143:			state->deck[i][j] = estate;
       15:  144:			state->deckCount[i]++;
        -:  145:		}
       40:  146:		for (j = 3; j < 10; j++)
        -:  147:		{
       35:  148:			state->deck[i][j] = copper;
       35:  149:			state->deckCount[i]++;
        -:  150:		}
        -:  151:	}
        -:  152:
        -:  153:	//shuffle player decks
        7:  154:	for (i = 0; i < numPlayers; i++)
        -:  155:	{
        5:  156:		if (shuffle(i, state) < 0)
        -:  157:		{
    #####:  158:			return -1;
        -:  159:		}
        -:  160:	}
        -:  161:
        -:  162:	//draw player hands
        7:  163:	for (i = 0; i < numPlayers; i++)
        -:  164:	{
        -:  165:		//initialize hand size to zero
        5:  166:		state->handCount[i] = 0;
        5:  167:		state->discardCount[i] = 0;
        -:  168:		//draw 5 cards
        -:  169:		// for (j = 0; j < 5; j++)
        -:  170:		//	{
        -:  171:		//	  drawCard(i, state);
        -:  172:		//	}
        -:  173:	}
        -:  174:
        -:  175:	//set embargo tokens to 0 for all supply piles
       56:  176:	for (i = 0; i <= treasure_map; i++)
        -:  177:	{
       54:  178:		state->embargoTokens[i] = 0;
        -:  179:	}
        -:  180:
        -:  181:	//initialize first player's turn
        2:  182:	state->outpostPlayed = 0;
        2:  183:	state->phase = 0;
        2:  184:	state->numActions = 1;
        2:  185:	state->numBuys = 1;
        2:  186:	state->playedCardCount = 0;
        2:  187:	state->whoseTurn = 0;
        2:  188:	state->handCount[state->whoseTurn] = 0;
        -:  189:	//int it; move to top
        -:  190:
        -:  191:	//Moved draw cards to here, only drawing at the start of a turn
       12:  192:	for (it = 0; it < 5; it++){
       10:  193:		drawCard(state->whoseTurn, state);
        -:  194:	}
        -:  195:
        2:  196:	updateCoins(state->whoseTurn, state, 0);
        -:  197:
        2:  198:	return 0;
        -:  199:}
        -:  200:
       67:  201:int shuffle(int player, struct gameState *state) {
        -:  202:
        -:  203:
        -:  204:	int newDeck[MAX_DECK];
       67:  205:	int newDeckPos = 0;
        -:  206:	int card;
        -:  207:	int i;
        -:  208:
       67:  209:	if (state->deckCount[player] < 1)
        1:  210:		return -1;
       66:  211:	qsort((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
        -:  212:	/* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
     1344:  214:	while (state->deckCount[player] > 0) {
     1212:  215:		card = floor(Random() * state->deckCount[player]);
     1212:  216:		newDeck[newDeckPos] = state->deck[player][card];
     1212:  217:		newDeckPos++;
     7422:  218:		for (i = card; i < state->deckCount[player] - 1; i++) {
     6210:  219:			state->deck[player][i] = state->deck[player][i + 1];
        -:  220:		}
     1212:  221:		state->deckCount[player]--;
        -:  222:	}
     1278:  223:	for (i = 0; i < newDeckPos; i++) {
     1212:  224:		state->deck[player][i] = newDeck[i];
     1212:  225:		state->deckCount[player]++;
        -:  226:	}
        -:  227:
       66:  228:	return 0;
        -:  229:}
        -:  230:
     1262:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state)
        -:  232:{
        -:  233:	int card;
     1262:  234:	int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:	//check if it is the right phase
     1262:  237:	if (state->phase != 0)
        -:  238:	{
      144:  239:		return -1;
        -:  240:	}
        -:  241:
        -:  242:	//check if player has enough actions
     1118:  243:	if (state->numActions < 1)
        -:  244:	{
       35:  245:		return -1;
        -:  246:	}
        -:  247:
        -:  248:	//get card played
     1083:  249:	card = handCard(handPos, state);
        -:  250:
        -:  251:	//check if selected card is an action
     1083:  252:	if (card < adventurer || card > treasure_map)
        -:  253:	{
      996:  254:		return -1;
        -:  255:	}
        -:  256:
        -:  257:	//play card
       87:  258:	if (cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0)
        -:  259:	{
       37:  260:		return -1;
        -:  261:	}
        -:  262:
        -:  263:	//reduce number of actions
       50:  264:	state->numActions--;
        -:  265:
        -:  266:	//update coins (Treasure cards may be added with card draws)
       50:  267:	updateCoins(state->whoseTurn, state, coin_bonus);
        -:  268:
       50:  269:	return 0;
        -:  270:}
        -:  271:
     1291:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:	int who;
        -:  274:	if (DEBUG){
        -:  275:		printf("Entering buyCard...\n");
        -:  276:	}
        -:  277:
        -:  278:	// I don't know what to do about the phase thing.
        -:  279:
     1291:  280:	who = state->whoseTurn;
        -:  281:
     1291:  282:	if (state->numBuys < 1){
        -:  283:		if (DEBUG)
        -:  284:			printf("You do not have any buys left\n");
      152:  285:		return -1;
        -:  286:	}
     1139:  287:	else if (supplyCount(supplyPos, state) < 1){
        -:  288:		if (DEBUG)
        -:  289:			printf("There are not any of that type of card left\n");
      464:  290:		return -1;
        -:  291:	}
      675:  292:	else if (state->coins < getCost(supplyPos)){
        -:  293:		if (DEBUG)
        -:  294:			printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
      509:  295:		return -1;
        -:  296:	}
        -:  297:	else {
      166:  298:		state->phase = 1;
        -:  299:		//state->supplyCount[supplyPos]--;
      166:  300:		gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  301:
      166:  302:		state->coins = (state->coins) - (getCost(supplyPos));
      166:  303:		state->numBuys--;
        -:  304:		if (DEBUG)
        -:  305:			printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  306:	}
        -:  307:
        -:  308:	//state->discard[who][state->discardCount[who]] = supplyPos;
        -:  309:	//state->discardCount[who]++;
        -:  310:
      166:  311:	return 0;
        -:  312:}
        -:  313:
    #####:  314:int numHandCards(struct gameState *state) {
    #####:  315:	return state->handCount[whoseTurn(state)];
        -:  316:}
        -:  317:
     1084:  318:int handCard(int handPos, struct gameState *state) {
     1084:  319:	int currentPlayer = whoseTurn(state);
     1084:  320:	return state->hand[currentPlayer][handPos];
        -:  321:}
        -:  322:
     1315:  323:int supplyCount(int card, struct gameState *state) {
     1315:  324:	return state->supplyCount[card];
        -:  325:}
        -:  326:
    #####:  327:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  328:	int i;
    #####:  329:	int count = 0;
        -:  330:
    #####:  331:	for (i = 0; i < state->deckCount[player]; i++)
        -:  332:	{
    #####:  333:		if (state->deck[player][i] == card) count++;
        -:  334:	}
        -:  335:
    #####:  336:	for (i = 0; i < state->handCount[player]; i++)
        -:  337:	{
    #####:  338:		if (state->hand[player][i] == card) count++;
        -:  339:	}
        -:  340:
    #####:  341:	for (i = 0; i < state->discardCount[player]; i++)
        -:  342:	{
    #####:  343:		if (state->discard[player][i] == card) count++;
        -:  344:	}
        -:  345:
    #####:  346:	return count;
        -:  347:}
        -:  348:
     1378:  349:int whoseTurn(struct gameState *state) {
     1378:  350:	return state->whoseTurn;
        -:  351:}
        -:  352:
      207:  353:int endTurn(struct gameState *state) {
        -:  354:	int k;
        -:  355:	int i;
      207:  356:	int currentPlayer = whoseTurn(state);
        -:  357:
        -:  358:	//Discard hand
     1222:  359:	for (i = 0; i < state->handCount[currentPlayer]; i++){
     1015:  360:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
     1015:  361:		state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  362:	}
      207:  363:	state->handCount[currentPlayer] = 0;//Reset hand count
        -:  364:
        -:  365:	//Code for determining the player
      207:  366:	if (currentPlayer < (state->numPlayers - 1)){
      123:  367:		state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  368:	}
        -:  369:	else{
       84:  370:		state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  371:	}
        -:  372:
      207:  373:	state->outpostPlayed = 0;
      207:  374:	state->phase = 0;
      207:  375:	state->numActions = 1;
      207:  376:	state->coins = 0;
      207:  377:	state->numBuys = 1;
      207:  378:	state->playedCardCount = 0;
      207:  379:	state->handCount[state->whoseTurn] = 0;
        -:  380:
        -:  381:	//int k; move to top
        -:  382:	//Next player draws hand
     1242:  383:	for (k = 0; k < 5; k++){
     1035:  384:		drawCard(state->whoseTurn, state);//Draw a card
        -:  385:	}
        -:  386:
        -:  387:	//Update money
      207:  388:	updateCoins(state->whoseTurn, state, 0);
        -:  389:
      207:  390:	return 0;
        -:  391:}
        -:  392:
     3959:  393:int isGameOver(struct gameState *state) {
        -:  394:	int i;
        -:  395:	int j;
        -:  396:
        -:  397:	//if stack of Province cards is empty, the game ends
     3959:  398:	if (state->supplyCount[province] == 0)
        -:  399:	{
    #####:  400:		return 1;
        -:  401:	}
        -:  402:
        -:  403:	//if three supply pile are at 0, the game ends
     3959:  404:	j = 0;
   102934:  405:	for (i = 0; i < 25; i++)
        -:  406:	{
    98975:  407:		if (state->supplyCount[i] == 0)
        -:  408:		{
     2372:  409:			j++;
        -:  410:		}
        -:  411:	}
     3959:  412:	if (j >= 3)
        -:  413:	{
        2:  414:		return 1;
        -:  415:	}
        -:  416:
     3957:  417:	return 0;
        -:  418:}
        -:  419:
    #####:  420:int scoreFor(int player, struct gameState *state) {
        -:  421:
        -:  422:	int i;
    #####:  423:	int score = 0;
        -:  424:	//score from hand
    #####:  425:	for (i = 0; i < state->handCount[player]; i++)
        -:  426:	{
    #####:  427:		if (state->hand[player][i] == curse) { score = score - 1; };
    #####:  428:		if (state->hand[player][i] == estate) { score = score + 1; };
    #####:  429:		if (state->hand[player][i] == duchy) { score = score + 3; };
    #####:  430:		if (state->hand[player][i] == province) { score = score + 6; };
    #####:  431:		if (state->hand[player][i] == great_hall) { score = score + 1; };
    #####:  432:		if (state->hand[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  433:	}
        -:  434:
        -:  435:	//score from discard
    #####:  436:	for (i = 0; i < state->discardCount[player]; i++)
        -:  437:	{
    #####:  438:		if (state->discard[player][i] == curse) { score = score - 1; };
    #####:  439:		if (state->discard[player][i] == estate) { score = score + 1; };
    #####:  440:		if (state->discard[player][i] == duchy) { score = score + 3; };
    #####:  441:		if (state->discard[player][i] == province) { score = score + 6; };
    #####:  442:		if (state->discard[player][i] == great_hall) { score = score + 1; };
    #####:  443:		if (state->discard[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  444:	}
        -:  445:
        -:  446:	//score from deck
    #####:  447:	for (i = 0; i < state->discardCount[player]; i++)
        -:  448:	{
    #####:  449:		if (state->deck[player][i] == curse) { score = score - 1; };
    #####:  450:		if (state->deck[player][i] == estate) { score = score + 1; };
    #####:  451:		if (state->deck[player][i] == duchy) { score = score + 3; };
    #####:  452:		if (state->deck[player][i] == province) { score = score + 6; };
    #####:  453:		if (state->deck[player][i] == great_hall) { score = score + 1; };
    #####:  454:		if (state->deck[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  455:	}
        -:  456:
    #####:  457:	return score;
        -:  458:}
        -:  459:
    #####:  460:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  461:	int i;
        -:  462:	int j;
        -:  463:	int highScore;
        -:  464:	int currentPlayer;
        -:  465:
        -:  466:	//get score for each player
    #####:  467:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  468:	{
        -:  469:		//set unused player scores to -9999
    #####:  470:		if (i >= state->numPlayers)
        -:  471:		{
    #####:  472:			players[i] = -9999;
        -:  473:		}
        -:  474:		else
        -:  475:		{
    #####:  476:			players[i] = scoreFor(i, state);
        -:  477:		}
        -:  478:	}
        -:  479:
        -:  480:	//find highest score
    #####:  481:	j = 0;
    #####:  482:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  483:	{
    #####:  484:		if (players[i] > players[j])
        -:  485:		{
    #####:  486:			j = i;
        -:  487:		}
        -:  488:	}
    #####:  489:	highScore = players[j];
        -:  490:
        -:  491:	//add 1 to players who had less turns
    #####:  492:	currentPlayer = whoseTurn(state);
    #####:  493:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  494:	{
    #####:  495:		if (players[i] == highScore && i > currentPlayer)
        -:  496:		{
    #####:  497:			players[i]++;
        -:  498:		}
        -:  499:	}
        -:  500:
        -:  501:	//find new highest score
    #####:  502:	j = 0;
    #####:  503:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  504:	{
    #####:  505:		if (players[i] > players[j])
        -:  506:		{
    #####:  507:			j = i;
        -:  508:		}
        -:  509:	}
    #####:  510:	highScore = players[j];
        -:  511:
        -:  512:	//set winners in array to 1 and rest to 0
    #####:  513:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  514:	{
    #####:  515:		if (players[i] == highScore)
        -:  516:		{
    #####:  517:			players[i] = 1;
        -:  518:		}
        -:  519:		else
        -:  520:		{
    #####:  521:			players[i] = 0;
        -:  522:		}
        -:  523:	}
        -:  524:
    #####:  525:	return 0;
        -:  526:}
        -:  527:
     1095:  528:int drawCard(int player, struct gameState *state)
        -:  529:{
        -:  530:	int count;
        -:  531:	int deckCounter;
     1095:  532:	if (state->deckCount[player] <= 0){//Deck is empty
        -:  533:
        -:  534:		//Step 1 Shuffle the discard pile back into a deck
        -:  535:		int i;
        -:  536:		//Move discard to deck
     1223:  537:		for (i = 0; i < state->discardCount[player]; i++){
     1162:  538:			state->deck[player][i] = state->discard[player][i];
     1162:  539:			state->discard[player][i] = -1;
        -:  540:		}
        -:  541:
       61:  542:		state->deckCount[player] = state->discardCount[player];
       61:  543:		state->discardCount[player] = 0;//Reset discard
        -:  544:
        -:  545:		//Shufffle the deck
       61:  546:		shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  547:
        -:  548:		if (DEBUG){//Debug statements
        -:  549:			printf("Deck count now: %d\n", state->deckCount[player]);
        -:  550:		}
        -:  551:
       61:  552:		state->discardCount[player] = 0;
        -:  553:
        -:  554:		//Step 2 Draw Card
       61:  555:		count = state->handCount[player];//Get current player's hand count
        -:  556:
        -:  557:		if (DEBUG){//Debug statements
        -:  558:			printf("Current hand count: %d\n", count);
        -:  559:		}
        -:  560:
       61:  561:		deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  562:
       61:  563:		if (deckCounter == 0)
    #####:  564:			return -1;
        -:  565:
       61:  566:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
       61:  567:		state->deckCount[player]--;
       61:  568:		state->handCount[player]++;//Increment hand count
        -:  569:	}
        -:  570:
        -:  571:	else{
     1034:  572:		int count = state->handCount[player];//Get current hand count for player
        -:  573:		int deckCounter;
        -:  574:		if (DEBUG){//Debug statements
        -:  575:			printf("Current hand count: %d\n", count);
        -:  576:		}
        -:  577:
     1034:  578:		deckCounter = state->deckCount[player];//Create holder for the deck count
     1034:  579:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
     1034:  580:		state->deckCount[player]--;
     1034:  581:		state->handCount[player]++;//Increment hand count
        -:  582:	}
        -:  583:
     1095:  584:	return 0;
        -:  585:}
        -:  586:
      848:  587:int getCost(int cardNumber)
        -:  588:{
      848:  589:	switch (cardNumber)
        -:  590:	{
        -:  591:	case curse:
       60:  592:		return 0;
        -:  593:	case estate:
       41:  594:		return 2;
        -:  595:	case duchy:
       41:  596:		return 5;
        -:  597:	case province:
       47:  598:		return 8;
        -:  599:	case copper:
       78:  600:		return 0;
        -:  601:	case silver:
       52:  602:		return 3;
        -:  603:	case gold:
       38:  604:		return 6;
        -:  605:	case adventurer:
       21:  606:		return 6;
        -:  607:	case council_room:
        1:  608:		return 5;
        -:  609:	case feast:
       30:  610:		return 4;
        -:  611:	case gardens:
       25:  612:		return 4;
        -:  613:	case mine:
       37:  614:		return 5;
        -:  615:	case remodel:
       23:  616:		return 4;
        -:  617:	case smithy:
       56:  618:		return 4;
        -:  619:	case village:
        1:  620:		return 3;
        -:  621:	case baron:
       41:  622:		return 4;
        -:  623:	case great_hall:
       64:  624:		return 3;
        -:  625:	case minion:
       16:  626:		return 5;
        -:  627:	case steward:
       28:  628:		return 3;
        -:  629:	case tribute:
       40:  630:		return 5;
        -:  631:	case ambassador:
       26:  632:		return 3;
        -:  633:	case cutpurse:
    #####:  634:		return 4;
        -:  635:	case embargo:
    #####:  636:		return 2;
        -:  637:	case outpost:
       46:  638:		return 5;
        -:  639:	case salvager:
       13:  640:		return 4;
        -:  641:	case sea_hag:
       23:  642:		return 4;
        -:  643:	case treasure_map:
    #####:  644:		return 4;
        -:  645:	}
        -:  646:
    #####:  647:	return -1;
        -:  648:}
        -:  649:
        5:  650:void playAdventurer(struct gameState *state, int currentPlayer)
        -:  651:// Reveal cards from deck until 2 Treasure cards are found.  Put those Treasure cards in the hand and discard the rest.
        -:  652:{
        5:  653:	int drawntreasure = 0;
        -:  654:	int temphand[MAX_HAND];
        -:  655:	int cardDrawn;
        5:  656:	int z = 0; // this is the counter for the temp hand
        -:  657:
       30:  658:	while (drawntreasure < 2){
       20:  659:		if (state->deckCount[currentPlayer] < 1){//if the deck is empty we need to shuffle discard and add to deck
        1:  660:			shuffle(currentPlayer, state);
        -:  661:		}
       20:  662:		drawCard(currentPlayer, state);
       20:  663:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer] - 1];//top card of hand is most recently drawn card.
       20:  664:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
       10:  665:			drawntreasure++;
        -:  666:		else{
       10:  667:			temphand[z] = cardDrawn;
       10:  668:			state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
       10:  669:			z++;
        -:  670:		}
        -:  671:	}
       20:  672:	while (z - 1 >= 0){
       10:  673:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; // discard all cards in play that have been drawn
       10:  674:		z = z - 1;
        -:  675:	}
        5:  676:}
        -:  677:
        3:  678:int playRemodel(struct gameState *state, int currentPlayer, int choice1, int choice2, int handPos)
        -:  679://Trash a card in the hand, and gain a card costing up to $2 more than the trashed card
        -:  680:{
        -:  681:	int i;
        3:  682:	int j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  683:
        3:  684:	if ((getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2))
        -:  685:	{
    #####:  686:		return -1;
        -:  687:	}
        -:  688:
        3:  689:	gainCard(choice2, state, 0, currentPlayer);
        -:  690:
        -:  691:	//discard card from hand
        3:  692:	discardCard(handPos, currentPlayer, state, 0);
        -:  693:
        -:  694:	//discard trashed card
        5:  695:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  696:	{
        5:  697:		if (state->hand[currentPlayer][i] == j)
        -:  698:		{
        3:  699:			discardCard(i, currentPlayer, state, 0);
        3:  700:			break;
        -:  701:		}
        -:  702:	}
        -:  703:
        3:  704:	return 0;
        -:  705:}
        -:  706:
        8:  707:void playSmithy(struct gameState *state, int currentPlayer, int handPos)
        -:  708:// Draw 3 cards
        -:  709:{
        -:  710:	int i;
       32:  711:	for (i = 0; i < 3; i++)
        -:  712:	{
       24:  713:		drawCard(currentPlayer, state);
        -:  714:	}
        -:  715:
        -:  716:	//discard card from hand
        8:  717:	discardCard(handPos, currentPlayer, state, 0);
        8:  718:}
        -:  719:
       13:  720:void playBaron(struct gameState *state, int currentPlayer, int choice1, int handPos)
        -:  721://Add a buy.  OPTION:  Discard an Estate card and gain $4.  Otherwise, gain an Estate card.
        -:  722:{
       13:  723:	state->numBuys++;//Increase buys by 1!
       13:  724:	if (choice1 > 0){//Boolean true or going to discard an estate
       12:  725:		int p = 0;//Iterator for hand!
       12:  726:		int card_not_discarded = 1;//Flag for discard set!
       66:  727:		while (card_not_discarded){
       42:  728:			if (state->hand[currentPlayer][p] == estate){ //Found an estate card!
       10:  729:				state->coins += 4;//Add 4 coins to the amount of coins
       10:  730:				state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
       10:  731:				state->discardCount[currentPlayer]++;
       43:  732:				for (; p < state->handCount[currentPlayer]; p++){
       33:  733:					state->hand[currentPlayer][p] = state->hand[currentPlayer][p + 1];
        -:  734:				}
       10:  735:				state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
       10:  736:				state->handCount[currentPlayer]--;
       10:  737:				card_not_discarded = 0;//Exit the loop
        -:  738:			}
       32:  739:			else if (p > state->handCount[currentPlayer]){
        -:  740:				if (DEBUG) {
        -:  741:					printf("No estate cards in your hand, invalid choice\n");
        -:  742:					printf("Must gain an estate if there are any\n");
        -:  743:				}
        2:  744:				if (supplyCount(estate, state) > 0){
    #####:  745:					gainCard(estate, state, 1, currentPlayer);
    #####:  746:					state->supplyCount[estate]--;//Decrement estates
    #####:  747:					if (supplyCount(estate, state) == 0){
    #####:  748:						isGameOver(state);
        -:  749:					}
        -:  750:				}
        2:  751:				card_not_discarded = 0;//Exit the loop
        -:  752:			}
        -:  753:
        -:  754:			else{
       30:  755:				p++;//Next card
        -:  756:			}
        -:  757:		}
        -:  758:	}
        -:  759:
        -:  760:	else{
        1:  761:		if (supplyCount(estate, state) > 0){
        1:  762:			gainCard(estate, state, 0, currentPlayer);//Gain an estate
        1:  763:			state->supplyCount[estate]--;//Decrement Estates
        1:  764:			if (supplyCount(estate, state) == 0){
    #####:  765:				isGameOver(state);
        -:  766:			}
        -:  767:		}
        -:  768:	}
       13:  769:}
        -:  770:
    #####:  771:int playTreasureMap(struct gameState *state, int currentPlayer, int handPos)
        -:  772://Trashing two treasure map cards from the hand = four gold on top of the deck.
        -:  773:{
        -:  774:	int i;
        -:  775:	int index;
        -:  776:
        -:  777:	//search hand for another treasure_map
    #####:  778:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  779:	{
    #####:  780:		if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -:  781:		{
    #####:  782:			index = i;
    #####:  783:			break;
        -:  784:		}
        -:  785:	}
    #####:  786:	if (index > -1)
        -:  787:	{
        -:  788:		//trash both treasure cards
    #####:  789:		discardCard(handPos, currentPlayer, state, 1);
    #####:  790:		discardCard(index, currentPlayer, state, 1);
        -:  791:
        -:  792:		//gain 4 Gold cards
    #####:  793:		for (i = 0; i < 4; i++)
        -:  794:		{
    #####:  795:			gainCard(gold, state, 1, currentPlayer);
        -:  796:		}
        -:  797:
        -:  798:		//return success
    #####:  799:		return 1;
        -:  800:	}
        -:  801:
        -:  802:	//no second treasure_map found in hand
    #####:  803:	return -1;
        -:  804:}
        -:  805:
       87:  806:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  807:{
        -:  808:	int i;
        -:  809:	int j;
        -:  810:	int k;
        -:  811:	//int x;  //Unused after while loop removed from feast.
       87:  812:	int currentPlayer = whoseTurn(state);
       87:  813:	int nextPlayer = currentPlayer + 1;
        -:  814:	int temphand[MAX_HAND];
        -:  815:
       87:  816:	int tributeRevealedCards[2] = { -1, -1 };
        -:  817:
       87:  818:	if (nextPlayer > (state->numPlayers - 1)){
       28:  819:		nextPlayer = 0;
        -:  820:	}
        -:  821:
        -:  822:	//uses switch to select card and perform actions
       87:  823:	switch (card)
        -:  824:	{
        -:  825:	case adventurer:
        -:  826:
        5:  827:		playAdventurer(state, currentPlayer);
        5:  828:		return 0;
        -:  829:
        -:  830:	case council_room:
        -:  831:		//+4 Cards
    #####:  832:		for (i = 0; i < 4; i++)
        -:  833:		{
    #####:  834:			drawCard(currentPlayer, state);
        -:  835:		}
        -:  836:
        -:  837:		//+1 Buy
    #####:  838:		state->numBuys++;
        -:  839:
        -:  840:		//Each other player draws a card
    #####:  841:		for (i = 0; i < state->numPlayers; i++)
        -:  842:		{
    #####:  843:			if (i != currentPlayer)
        -:  844:			{
    #####:  845:				drawCard(i, state);
        -:  846:			}
        -:  847:		}
        -:  848:
        -:  849:		//put played card in played card pile
    #####:  850:		discardCard(handPos, currentPlayer, state, 0);
        -:  851:
    #####:  852:		return 0;
        -:  853:
        -:  854:	case feast:
        -:  855:		//gain card with cost up to 5
        -:  856:		//Backup hand
    #####:  857:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  858:			temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  859:			state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  860:		}
        -:  861:		//Backup hand
        -:  862:
        -:  863:		//Update Coins for Buy
    #####:  864:		updateCoins(currentPlayer, state, 5);
        -:  865://		x = 1;//Condition to loop on
        -:  866://		while (x == 1) {//Buy one card
    #####:  867:			if (supplyCount(choice1, state) <= 0){
        -:  868:				if (DEBUG)
        -:  869:					printf("None of that card left, sorry!\n");
        -:  870:
        -:  871:				if (DEBUG){
        -:  872:					printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  873:				}
        -:  874:			}
    #####:  875:			else if (state->coins < getCost(choice1)){
    #####:  876:				printf("That card is too expensive!\n");
        -:  877:
        -:  878:				if (DEBUG){
        -:  879:					printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  880:				}
        -:  881:			}
        -:  882:			else{
        -:  883:
        -:  884:				if (DEBUG){
        -:  885:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  886:				}
        -:  887:
    #####:  888:				gainCard(choice1, state, 0, currentPlayer);//Gain the card
        -:  889://				x = 0;//No more buying cards
        -:  890:
        -:  891:				if (DEBUG){
        -:  892:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  893:				}
        -:  894:
        -:  895:			}
        -:  896://		}
        -:  897:
        -:  898:		//Reset Hand
    #####:  899:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  900:			state->hand[currentPlayer][i] = temphand[i];
    #####:  901:			temphand[i] = -1;
        -:  902:		}
        -:  903:		//Reset Hand
        -:  904:
    #####:  905:		return 0;
        -:  906:
        -:  907:	case gardens:
        6:  908:		return -1;
        -:  909:
        -:  910:	case mine:
       11:  911:		j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  912:
       11:  913:		if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  914:		{
       11:  915:			return -1;
        -:  916:		}
        -:  917:
    #####:  918:		if (choice2 > treasure_map || choice2 < curse)
        -:  919:		{
    #####:  920:			return -1;
        -:  921:		}
        -:  922:
    #####:  923:		if ((getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2))
        -:  924:		{
    #####:  925:			return -1;
        -:  926:		}
        -:  927:
    #####:  928:		gainCard(choice2, state, 2, currentPlayer);
        -:  929:
        -:  930:		//discard card from hand
    #####:  931:		discardCard(handPos, currentPlayer, state, 0);
        -:  932:
        -:  933:		//discard trashed card
    #####:  934:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  935:		{
    #####:  936:			if (state->hand[currentPlayer][i] == j)
        -:  937:			{
    #####:  938:				discardCard(i, currentPlayer, state, 0);
    #####:  939:				break;
        -:  940:			}
        -:  941:		}
        -:  942:
    #####:  943:		return 0;
        -:  944:
        -:  945:	case remodel:
        -:  946:
        3:  947:		return playRemodel(state, currentPlayer, choice1, choice2, handPos);
        -:  948:
        -:  949:	case smithy:
        -:  950:
        8:  951:		playSmithy(state, currentPlayer, handPos);
        8:  952:		return 0;
        -:  953:
        -:  954:	case village:
        -:  955:		//+1 Card
    #####:  956:		drawCard(currentPlayer, state);
        -:  957:
        -:  958:		//+2 Actions
    #####:  959:		state->numActions = state->numActions + 2;
        -:  960:
        -:  961:		//discard played card from hand
    #####:  962:		discardCard(handPos, currentPlayer, state, 0);
    #####:  963:		return 0;
        -:  964:
        -:  965:	case baron:
        -:  966:
       13:  967:		playBaron(state, currentPlayer, choice1, handPos);
       13:  968:		return 0;
        -:  969:
        -:  970:	case great_hall:
        -:  971:		//+1 Card
        6:  972:		drawCard(currentPlayer, state);
        -:  973:
        -:  974:		//+1 Actions
        6:  975:		state->numActions++;
        -:  976:
        -:  977:		//discard card from hand
        6:  978:		discardCard(handPos, currentPlayer, state, 0);
        6:  979:		return 0;
        -:  980:
        -:  981:	case minion:
        -:  982:		//+1 action
        1:  983:		state->numActions++;
        -:  984:
        -:  985:		//discard card from hand
        1:  986:		discardCard(handPos, currentPlayer, state, 0);
        -:  987:
        1:  988:		if (choice1)		//+2 coins
        -:  989:		{
        1:  990:			state->coins = state->coins + 2;
        -:  991:		}
        -:  992:
    #####:  993:		else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  994:		{
        -:  995:			//discard hand
    #####:  996:			while (numHandCards(state) > 0)
        -:  997:			{
    #####:  998:				discardCard(handPos, currentPlayer, state, 0);
        -:  999:			}
        -: 1000:
        -: 1001:			//draw 4
    #####: 1002:			for (i = 0; i < 4; i++)
        -: 1003:			{
    #####: 1004:				drawCard(currentPlayer, state);
        -: 1005:			}
        -: 1006:
        -: 1007:			//other players discard hand and redraw if hand size > 4
    #####: 1008:			for (i = 0; i < state->numPlayers; i++)
        -: 1009:			{
    #####: 1010:				if (i != currentPlayer)
        -: 1011:				{
    #####: 1012:					if (state->handCount[i] > 4)
        -: 1013:					{
        -: 1014:						//discard hand
    #####: 1015:						while (state->handCount[i] > 0)
        -: 1016:						{
    #####: 1017:							discardCard(handPos, i, state, 0);
        -: 1018:						}
        -: 1019:
        -: 1020:						//draw 4
    #####: 1021:						for (j = 0; j < 4; j++)
        -: 1022:						{
    #####: 1023:							drawCard(i, state);
        -: 1024:						}
        -: 1025:					}
        -: 1026:				}
        -: 1027:			}
        -: 1028:
        -: 1029:		}
        1: 1030:		return 0;
        -: 1031:
        -: 1032:	case steward:
        8: 1033:		if (choice1 == 1)
        -: 1034:		{
        -: 1035:			//+2 cards
    #####: 1036:			drawCard(currentPlayer, state);
    #####: 1037:			drawCard(currentPlayer, state);
        -: 1038:		}
        8: 1039:		else if (choice1 == 2)
        -: 1040:		{
        -: 1041:			//+2 coins
    #####: 1042:			state->coins = state->coins + 2;
        -: 1043:		}
        -: 1044:		else
        -: 1045:		{
        -: 1046:			//trash 2 cards in hand
        8: 1047:			discardCard(choice2, currentPlayer, state, 1);
        8: 1048:			discardCard(choice3, currentPlayer, state, 1);
        -: 1049:		}
        -: 1050:
        -: 1051:		//discard card from hand
        8: 1052:		discardCard(handPos, currentPlayer, state, 0);
        8: 1053:		return 0;
        -: 1054:
        -: 1055:	case tribute:
    #####: 1056:		if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####: 1057:			if (state->deckCount[nextPlayer] > 0){
    #####: 1058:				tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1059:				state->deckCount[nextPlayer]--;
        -: 1060:			}
    #####: 1061:			else if (state->discardCount[nextPlayer] > 0){
    #####: 1062:				tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer] - 1];
    #####: 1063:				state->discardCount[nextPlayer]--;
        -: 1064:			}
        -: 1065:			else{
        -: 1066:				//No Card to Reveal
        -: 1067:				if (DEBUG){
        -: 1068:					printf("No cards to reveal\n");
        -: 1069:				}
        -: 1070:			}
        -: 1071:		}
        -: 1072:
        -: 1073:		else{
    #####: 1074:			if (state->deckCount[nextPlayer] == 0){
    #####: 1075:				for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####: 1076:					state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1077:					state->deckCount[nextPlayer]++;
    #####: 1078:					state->discard[nextPlayer][i] = -1;
    #####: 1079:					state->discardCount[nextPlayer]--;
        -: 1080:				}
        -: 1081:
    #####: 1082:				shuffle(nextPlayer, state);//Shuffle the deck
        -: 1083:			}
    #####: 1084:			tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1085:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1086:			state->deckCount[nextPlayer]--;
    #####: 1087:			tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1088:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1089:			state->deckCount[nextPlayer]--;
        -: 1090:		}
        -: 1091:
    #####: 1092:		if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
    #####: 1093:			state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1094:			state->playedCardCount++;
    #####: 1095:			tributeRevealedCards[1] = -1;
        -: 1096:		}
        -: 1097:
    #####: 1098:		for (i = 0; i <= 2; i++){
    #####: 1099:			if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
    #####: 1100:				state->coins += 2;
        -: 1101:			}
        -: 1102:
    #####: 1103:			else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
    #####: 1104:				drawCard(currentPlayer, state);
    #####: 1105:				drawCard(currentPlayer, state);
        -: 1106:			}
        -: 1107:			else{//Action Card
    #####: 1108:				state->numActions = state->numActions + 2;
        -: 1109:			}
        -: 1110:		}
        -: 1111:
    #####: 1112:		return 0;
        -: 1113:
        -: 1114:	case ambassador:
       21: 1115:		j = 0;		//used to check if player has enough cards to discard
        -: 1116:
       21: 1117:		if (choice2 > 2 || choice2 < 0)
        -: 1118:		{
       18: 1119:			return -1;
        -: 1120:		}
        -: 1121:
        3: 1122:		if (choice1 == handPos)
        -: 1123:		{
    #####: 1124:			return -1;
        -: 1125:		}
        -: 1126:
       18: 1127:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1128:		{
       15: 1129:			if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1130:			{
        3: 1131:				j++;
        -: 1132:			}
        -: 1133:		}
        3: 1134:		if (j < choice2)
        -: 1135:		{
        2: 1136:			return -1;
        -: 1137:		}
        -: 1138:
        -: 1139:		if (DEBUG)
        -: 1140:			printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1141:
        -: 1142:		//increase supply count for choosen card by amount being discarded
        1: 1143:		state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1144:
        -: 1145:		//each other player gains a copy of revealed card
        4: 1146:		for (i = 0; i < state->numPlayers; i++)
        -: 1147:		{
        3: 1148:			if (i != currentPlayer)
        -: 1149:			{
        2: 1150:				gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1151:			}
        -: 1152:		}
        -: 1153:
        -: 1154:		//discard played card from hand
        1: 1155:		discardCard(handPos, currentPlayer, state, 0);
        -: 1156:
        -: 1157:		//trash copies of cards returned to supply
        2: 1158:		for (j = 0; j < choice2; j++)
        -: 1159:		{
        5: 1160:			for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1161:			{
        4: 1162:				if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1163:				{
    #####: 1164:					discardCard(i, currentPlayer, state, 1);
    #####: 1165:					break;
        -: 1166:				}
        -: 1167:			}
        -: 1168:		}
        -: 1169:
        1: 1170:		return 0;
        -: 1171:
        -: 1172:	case cutpurse:
        -: 1173:
    #####: 1174:		updateCoins(currentPlayer, state, 2);
    #####: 1175:		for (i = 0; i < state->numPlayers; i++)
        -: 1176:		{
    #####: 1177:			if (i != currentPlayer)
        -: 1178:			{
    #####: 1179:				for (j = 0; j < state->handCount[i]; j++)
        -: 1180:				{
    #####: 1181:					if (state->hand[i][j] == copper)
        -: 1182:					{
    #####: 1183:						discardCard(j, i, state, 0);
    #####: 1184:						break;
        -: 1185:					}
    #####: 1186:					if (j == state->handCount[i])
        -: 1187:					{
    #####: 1188:						for (k = 0; k < state->handCount[i]; k++)
        -: 1189:						{
        -: 1190:							if (DEBUG)
        -: 1191:								printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1192:						}
    #####: 1193:						break;
        -: 1194:					}
        -: 1195:				}
        -: 1196:
        -: 1197:			}
        -: 1198:
        -: 1199:		}
        -: 1200:
        -: 1201:		//discard played card from hand
    #####: 1202:		discardCard(handPos, currentPlayer, state, 0);
        -: 1203:
    #####: 1204:		return 0;
        -: 1205:
        -: 1206:
        -: 1207:	case embargo:
        -: 1208:		//+2 Coins
    #####: 1209:		state->coins = state->coins + 2;
        -: 1210:
        -: 1211:		//see if selected pile is in play
    #####: 1212:		if (state->supplyCount[choice1] == -1)
        -: 1213:		{
    #####: 1214:			return -1;
        -: 1215:		}
        -: 1216:
        -: 1217:		//add embargo token to selected supply pile
    #####: 1218:		state->embargoTokens[choice1]++;
        -: 1219:
        -: 1220:		//trash card
    #####: 1221:		discardCard(handPos, currentPlayer, state, 1);
    #####: 1222:		return 0;
        -: 1223:
        -: 1224:	case outpost:
        -: 1225:		//set outpost flag
        2: 1226:		state->outpostPlayed++;
        -: 1227:
        -: 1228:		//discard card
        2: 1229:		discardCard(handPos, currentPlayer, state, 0);
        2: 1230:		return 0;
        -: 1231:
        -: 1232:	case salvager:
        -: 1233:		//+1 buy
        1: 1234:		state->numBuys++;
        -: 1235:
        1: 1236:		if (choice1)
        -: 1237:		{
        -: 1238:			//gain coins equal to trashed card
        1: 1239:			state->coins = state->coins + getCost(handCard(choice1, state));
        -: 1240:			//trash card
        1: 1241:			discardCard(choice1, currentPlayer, state, 1);
        -: 1242:		}
        -: 1243:
        -: 1244:		//discard card
        1: 1245:		discardCard(handPos, currentPlayer, state, 0);
        1: 1246:		return 0;
        -: 1247:
        -: 1248:	case sea_hag:
        6: 1249:		for (i = 0; i < state->numPlayers; i++){
        4: 1250:			if (i != currentPlayer){
        2: 1251:				state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
        2: 1252:				state->discardCount[i]++;
        2: 1253:				state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1254:			}
        -: 1255:		}
        2: 1256:		return 0;
        -: 1257:
        -: 1258:	case treasure_map:
        -: 1259:
    #####: 1260:		return playTreasureMap(state, currentPlayer, handPos);
        -: 1261:	}
    #####: 1262:	return -1;
        -: 1263:}
        -: 1264:
       50: 1265:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1266:{
        -: 1267:
        -: 1268:	//if card is not trashed, added to Played pile 
       50: 1269:	if (trashFlag < 1)
        -: 1270:	{
        -: 1271:		//add card to played pile
       33: 1272:		state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
       33: 1273:		state->playedCardCount++;
        -: 1274:	}
        -: 1275:
        -: 1276:	//set played card to -1
       50: 1277:	state->hand[currentPlayer][handPos] = -1;
        -: 1278:
        -: 1279:	//remove card from player's hand
       50: 1280:	if (handPos == (state->handCount[currentPlayer] - 1)) 	//last card in hand array is played
        -: 1281:	{
        -: 1282:		//reduce number of cards in hand
        5: 1283:		state->handCount[currentPlayer]--;
        -: 1284:	}
       45: 1285:	else if (state->handCount[currentPlayer] == 1) //only one card in hand
        -: 1286:	{
        -: 1287:		//reduce number of cards in hand
    #####: 1288:		state->handCount[currentPlayer]--;
        -: 1289:	}
        -: 1290:	else
        -: 1291:	{
        -: 1292:		//replace discarded card with last card in hand
       45: 1293:		state->hand[currentPlayer][handPos] = state->hand[currentPlayer][(state->handCount[currentPlayer] - 1)];
        -: 1294:		//set last card to -1
       45: 1295:		state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1296:		//reduce number of cards in hand
       45: 1297:		state->handCount[currentPlayer]--;
        -: 1298:	}
        -: 1299:
       50: 1300:	return 0;
        -: 1301:}
        -: 1302:
      172: 1303:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1304:{
        -: 1305:	//Note: supplyPos is enum of choosen card
        -: 1306:
        -: 1307:	//check if supply pile is empty (0) or card is not used in game (-1)
      172: 1308:	if (supplyCount(supplyPos, state) < 1)
        -: 1309:	{
        3: 1310:		return -1;
        -: 1311:	}
        -: 1312:
        -: 1313:	//added card for [whoseTurn] current player:
        -: 1314:	// toFlag = 0 : add to discard
        -: 1315:	// toFlag = 1 : add to deck
        -: 1316:	// toFlag = 2 : add to hand
        -: 1317:
      169: 1318:	if (toFlag == 1)
        -: 1319:	{
    #####: 1320:		state->deck[player][state->deckCount[player]] = supplyPos;
    #####: 1321:		state->deckCount[player]++;
        -: 1322:	}
      169: 1323:	else if (toFlag == 2)
        -: 1324:	{
    #####: 1325:		state->hand[player][state->handCount[player]] = supplyPos;
    #####: 1326:		state->handCount[player]++;
        -: 1327:	}
        -: 1328:	else
        -: 1329:	{
      169: 1330:		state->discard[player][state->discardCount[player]] = supplyPos;
      169: 1331:		state->discardCount[player]++;
        -: 1332:	}
        -: 1333:
        -: 1334:	//decrease number in supply pile
      169: 1335:	state->supplyCount[supplyPos]--;
        -: 1336:
      169: 1337:	return 0;
        -: 1338:}
        -: 1339:
      259: 1340:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1341:{
        -: 1342:	int i;
        -: 1343:
        -: 1344:	//reset coin count
      259: 1345:	state->coins = 0;
        -: 1346:
        -: 1347:	//add coins for each Treasure card in player's hand
     1534: 1348:	for (i = 0; i < state->handCount[player]; i++)
        -: 1349:	{
     1275: 1350:		if (state->hand[player][i] == copper)
        -: 1351:		{
      592: 1352:			state->coins += 1;
        -: 1353:		}
      683: 1354:		else if (state->hand[player][i] == silver)
        -: 1355:		{
       77: 1356:			state->coins += 2;
        -: 1357:		}
      606: 1358:		else if (state->hand[player][i] == gold)
        -: 1359:		{
    #####: 1360:			state->coins += 3;
        -: 1361:		}
        -: 1362:	}
        -: 1363:
        -: 1364:	//add bonus
      259: 1365:	state->coins += bonus;
        -: 1366:
      259: 1367:	return 0;
        -: 1368:}
        -: 1369:
        -: 1370:
        -: 1371://end of dominion.c
File 'dominion.c'
Lines executed:63.20% of 557
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
     2636:    8:int compare(const void* a, const void* b) {
     2636:    9:	if (*(int*)a > *(int*)b)
      891:   10:		return 1;
     1745:   11:	if (*(int*)a < *(int*)b)
      724:   12:		return -1;
     1021:   13:	return 0;
        -:   14:}
        -:   15:
        4:   16:struct gameState* newGame() {
        4:   17:	struct gameState* g = malloc(sizeof(struct gameState));
        4:   18:	return g;
        -:   19:}
        -:   20:
       32:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:	int k8, int k9, int k10) {
       32:   23:	int* k = malloc(10 * sizeof(int));
       32:   24:	k[0] = k1;
       32:   25:	k[1] = k2;
       32:   26:	k[2] = k3;
       32:   27:	k[3] = k4;
       32:   28:	k[4] = k5;
       32:   29:	k[5] = k6;
       32:   30:	k[6] = k7;
       32:   31:	k[7] = k8;
       32:   32:	k[8] = k9;
       32:   33:	k[9] = k10;
       32:   34:	return k;
        -:   35:}
        -:   36:
       32:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		struct gameState *state) {
        -:   39:
        -:   40:	int i;
        -:   41:	int j;
        -:   42:	int it;
        -:   43:	//set up random number generator
       32:   44:	SelectStream(1);
       32:   45:	PutSeed((long)randomSeed);
        -:   46:
        -:   47:	//check number of players
       32:   48:	if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:	{
    #####:   50:		return -1;
        -:   51:	}
        -:   52:
        -:   53:	//set number of players
       32:   54:	state->numPlayers = numPlayers;
        -:   55:
        -:   56:	//check selected kingdom cards are different
      113:   57:	for (i = 0; i < 10; i++)
        -:   58:	{
     1104:   59:		for (j = 0; j < 10; j++)
        -:   60:		{
     1023:   61:			if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:			{
       30:   63:				return -1;
        -:   64:			}
        -:   65:		}
        -:   66:	}
        -:   67:
        -:   68:
        -:   69:	//initialize supply
        -:   70:	///////////////////////////////
        -:   71:
        -:   72:	//set number of Curse cards
        2:   73:	if (numPlayers == 2)
        -:   74:	{
    #####:   75:		state->supplyCount[curse] = 10;
        -:   76:	}
        2:   77:	else if (numPlayers == 3)
        -:   78:	{
    #####:   79:		state->supplyCount[curse] = 20;
        -:   80:	}
        -:   81:	else
        -:   82:	{
        2:   83:		state->supplyCount[curse] = 30;
        -:   84:	}
        -:   85:
        -:   86:	//set number of Victory cards
        2:   87:	if (numPlayers == 2)
        -:   88:	{
    #####:   89:		state->supplyCount[estate] = 8;
    #####:   90:		state->supplyCount[duchy] = 8;
    #####:   91:		state->supplyCount[province] = 8;
        -:   92:	}
        -:   93:	else
        -:   94:	{
        2:   95:		state->supplyCount[estate] = 12;
        2:   96:		state->supplyCount[duchy] = 12;
        2:   97:		state->supplyCount[province] = 12;
        -:   98:	}
        -:   99:
        -:  100:	//set number of Treasure cards
        2:  101:	state->supplyCount[copper] = 60 - (7 * numPlayers);
        2:  102:	state->supplyCount[silver] = 40;
        2:  103:	state->supplyCount[gold] = 30;
        -:  104:
        -:  105:	//set number of Kingdom cards
       42:  106:	for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:	{
      330:  108:		for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:		{
      310:  110:			if (kingdomCards[j] == i)
        -:  111:			{
        -:  112:				//check if card is a 'Victory' Kingdom card
       20:  113:				if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:				{
        4:  115:					if (numPlayers == 2){
    #####:  116:						state->supplyCount[i] = 8;
        -:  117:					}
        2:  118:					else{ state->supplyCount[i] = 12; }
        -:  119:				}
        -:  120:				else
        -:  121:				{
       18:  122:					state->supplyCount[i] = 10;
        -:  123:				}
       20:  124:				break;
        -:  125:			}
        -:  126:			else    //card is not in the set choosen for the game
        -:  127:			{
      290:  128:				state->supplyCount[i] = -1;
        -:  129:			}
        -:  130:		}
        -:  131:
        -:  132:	}
        -:  133:
        -:  134:	////////////////////////
        -:  135:	//supply intilization complete
        -:  136:
        -:  137:	//set player decks
       10:  138:	for (i = 0; i < numPlayers; i++)
        -:  139:	{
        8:  140:		state->deckCount[i] = 0;
       32:  141:		for (j = 0; j < 3; j++)
        -:  142:		{
       24:  143:			state->deck[i][j] = estate;
       24:  144:			state->deckCount[i]++;
        -:  145:		}
       64:  146:		for (j = 3; j < 10; j++)
        -:  147:		{
       56:  148:			state->deck[i][j] = copper;
       56:  149:			state->deckCount[i]++;
        -:  150:		}
        -:  151:	}
        -:  152:
        -:  153:	//shuffle player decks
       10:  154:	for (i = 0; i < numPlayers; i++)
        -:  155:	{
        8:  156:		if (shuffle(i, state) < 0)
        -:  157:		{
    #####:  158:			return -1;
        -:  159:		}
        -:  160:	}
        -:  161:
        -:  162:	//draw player hands
       10:  163:	for (i = 0; i < numPlayers; i++)
        -:  164:	{
        -:  165:		//initialize hand size to zero
        8:  166:		state->handCount[i] = 0;
        8:  167:		state->discardCount[i] = 0;
        -:  168:		//draw 5 cards
        -:  169:		// for (j = 0; j < 5; j++)
        -:  170:		//	{
        -:  171:		//	  drawCard(i, state);
        -:  172:		//	}
        -:  173:	}
        -:  174:
        -:  175:	//set embargo tokens to 0 for all supply piles
       56:  176:	for (i = 0; i <= treasure_map; i++)
        -:  177:	{
       54:  178:		state->embargoTokens[i] = 0;
        -:  179:	}
        -:  180:
        -:  181:	//initialize first player's turn
        2:  182:	state->outpostPlayed = 0;
        2:  183:	state->phase = 0;
        2:  184:	state->numActions = 1;
        2:  185:	state->numBuys = 1;
        2:  186:	state->playedCardCount = 0;
        2:  187:	state->whoseTurn = 0;
        2:  188:	state->handCount[state->whoseTurn] = 0;
        -:  189:	//int it; move to top
        -:  190:
        -:  191:	//Moved draw cards to here, only drawing at the start of a turn
       12:  192:	for (it = 0; it < 5; it++){
       10:  193:		drawCard(state->whoseTurn, state);
        -:  194:	}
        -:  195:
        2:  196:	updateCoins(state->whoseTurn, state, 0);
        -:  197:
        2:  198:	return 0;
        -:  199:}
        -:  200:
      203:  201:int shuffle(int player, struct gameState *state) {
        -:  202:
        -:  203:
        -:  204:	int newDeck[MAX_DECK];
      203:  205:	int newDeckPos = 0;
        -:  206:	int card;
        -:  207:	int i;
        -:  208:
      203:  209:	if (state->deckCount[player] < 1)
       65:  210:		return -1;
      138:  211:	qsort((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
        -:  212:	/* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
     1720:  214:	while (state->deckCount[player] > 0) {
     1444:  215:		card = floor(Random() * state->deckCount[player]);
     1444:  216:		newDeck[newDeckPos] = state->deck[player][card];
     1444:  217:		newDeckPos++;
     5903:  218:		for (i = card; i < state->deckCount[player] - 1; i++) {
     4459:  219:			state->deck[player][i] = state->deck[player][i + 1];
        -:  220:		}
     1444:  221:		state->deckCount[player]--;
        -:  222:	}
     1582:  223:	for (i = 0; i < newDeckPos; i++) {
     1444:  224:		state->deck[player][i] = newDeck[i];
     1444:  225:		state->deckCount[player]++;
        -:  226:	}
        -:  227:
      138:  228:	return 0;
        -:  229:}
        -:  230:
     1439:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state)
        -:  232:{
        -:  233:	int card;
     1439:  234:	int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:	//check if it is the right phase
     1439:  237:	if (state->phase != 0)
        -:  238:	{
      172:  239:		return -1;
        -:  240:	}
        -:  241:
        -:  242:	//check if player has enough actions
     1267:  243:	if (state->numActions < 1)
        -:  244:	{
       27:  245:		return -1;
        -:  246:	}
        -:  247:
        -:  248:	//get card played
     1240:  249:	card = handCard(handPos, state);
        -:  250:
        -:  251:	//check if selected card is an action
     1240:  252:	if (card < adventurer || card > treasure_map)
        -:  253:	{
     1163:  254:		return -1;
        -:  255:	}
        -:  256:
        -:  257:	//play card
       77:  258:	if (cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0)
        -:  259:	{
        6:  260:		return -1;
        -:  261:	}
        -:  262:
        -:  263:	//reduce number of actions
       71:  264:	state->numActions--;
        -:  265:
        -:  266:	//update coins (Treasure cards may be added with card draws)
       71:  267:	updateCoins(state->whoseTurn, state, coin_bonus);
        -:  268:
       71:  269:	return 0;
        -:  270:}
        -:  271:
     1466:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:	int who;
        -:  274:	if (DEBUG){
        -:  275:		printf("Entering buyCard...\n");
        -:  276:	}
        -:  277:
        -:  278:	// I don't know what to do about the phase thing.
        -:  279:
     1466:  280:	who = state->whoseTurn;
        -:  281:
     1466:  282:	if (state->numBuys < 1){
        -:  283:		if (DEBUG)
        -:  284:			printf("You do not have any buys left\n");
      159:  285:		return -1;
        -:  286:	}
     1307:  287:	else if (supplyCount(supplyPos, state) < 1){
        -:  288:		if (DEBUG)
        -:  289:			printf("There are not any of that type of card left\n");
      484:  290:		return -1;
        -:  291:	}
      823:  292:	else if (state->coins < getCost(supplyPos)){
        -:  293:		if (DEBUG)
        -:  294:			printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
      625:  295:		return -1;
        -:  296:	}
        -:  297:	else {
      198:  298:		state->phase = 1;
        -:  299:		//state->supplyCount[supplyPos]--;
      198:  300:		gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  301:
      198:  302:		state->coins = (state->coins) - (getCost(supplyPos));
      198:  303:		state->numBuys--;
        -:  304:		if (DEBUG)
        -:  305:			printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  306:	}
        -:  307:
        -:  308:	//state->discard[who][state->discardCount[who]] = supplyPos;
        -:  309:	//state->discardCount[who]++;
        -:  310:
      198:  311:	return 0;
        -:  312:}
        -:  313:
    #####:  314:int numHandCards(struct gameState *state) {
    #####:  315:	return state->handCount[whoseTurn(state)];
        -:  316:}
        -:  317:
     1241:  318:int handCard(int handPos, struct gameState *state) {
     1241:  319:	int currentPlayer = whoseTurn(state);
     1241:  320:	return state->hand[currentPlayer][handPos];
        -:  321:}
        -:  322:
     1517:  323:int supplyCount(int card, struct gameState *state) {
     1517:  324:	return state->supplyCount[card];
        -:  325:}
        -:  326:
    #####:  327:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  328:	int i;
    #####:  329:	int count = 0;
        -:  330:
    #####:  331:	for (i = 0; i < state->deckCount[player]; i++)
        -:  332:	{
    #####:  333:		if (state->deck[player][i] == card) count++;
        -:  334:	}
        -:  335:
    #####:  336:	for (i = 0; i < state->handCount[player]; i++)
        -:  337:	{
    #####:  338:		if (state->hand[player][i] == card) count++;
        -:  339:	}
        -:  340:
    #####:  341:	for (i = 0; i < state->discardCount[player]; i++)
        -:  342:	{
    #####:  343:		if (state->discard[player][i] == card) count++;
        -:  344:	}
        -:  345:
    #####:  346:	return count;
        -:  347:}
        -:  348:
     1576:  349:int whoseTurn(struct gameState *state) {
     1576:  350:	return state->whoseTurn;
        -:  351:}
        -:  352:
      258:  353:int endTurn(struct gameState *state) {
        -:  354:	int k;
        -:  355:	int i;
      258:  356:	int currentPlayer = whoseTurn(state);
        -:  357:
        -:  358:	//Discard hand
     1446:  359:	for (i = 0; i < state->handCount[currentPlayer]; i++){
     1188:  360:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
     1188:  361:		state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  362:	}
      258:  363:	state->handCount[currentPlayer] = 0;//Reset hand count
        -:  364:
        -:  365:	//Code for determining the player
      258:  366:	if (currentPlayer < (state->numPlayers - 1)){
      194:  367:		state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  368:	}
        -:  369:	else{
       64:  370:		state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  371:	}
        -:  372:
      258:  373:	state->outpostPlayed = 0;
      258:  374:	state->phase = 0;
      258:  375:	state->numActions = 1;
      258:  376:	state->coins = 0;
      258:  377:	state->numBuys = 1;
      258:  378:	state->playedCardCount = 0;
      258:  379:	state->handCount[state->whoseTurn] = 0;
        -:  380:
        -:  381:	//int k; move to top
        -:  382:	//Next player draws hand
     1548:  383:	for (k = 0; k < 5; k++){
     1290:  384:		drawCard(state->whoseTurn, state);//Draw a card
        -:  385:	}
        -:  386:
        -:  387:	//Update money
      258:  388:	updateCoins(state->whoseTurn, state, 0);
        -:  389:
      258:  390:	return 0;
        -:  391:}
        -:  392:
     4323:  393:int isGameOver(struct gameState *state) {
        -:  394:	int i;
        -:  395:	int j;
        -:  396:
        -:  397:	//if stack of Province cards is empty, the game ends
     4323:  398:	if (state->supplyCount[province] == 0)
        -:  399:	{
    #####:  400:		return 1;
        -:  401:	}
        -:  402:
        -:  403:	//if three supply pile are at 0, the game ends
     4323:  404:	j = 0;
   112398:  405:	for (i = 0; i < 25; i++)
        -:  406:	{
   108075:  407:		if (state->supplyCount[i] == 0)
        -:  408:		{
     2283:  409:			j++;
        -:  410:		}
        -:  411:	}
     4323:  412:	if (j >= 3)
        -:  413:	{
        2:  414:		return 1;
        -:  415:	}
        -:  416:
     4321:  417:	return 0;
        -:  418:}
        -:  419:
    #####:  420:int scoreFor(int player, struct gameState *state) {
        -:  421:
        -:  422:	int i;
    #####:  423:	int score = 0;
        -:  424:	//score from hand
    #####:  425:	for (i = 0; i < state->handCount[player]; i++)
        -:  426:	{
    #####:  427:		if (state->hand[player][i] == curse) { score = score - 1; };
    #####:  428:		if (state->hand[player][i] == estate) { score = score + 1; };
    #####:  429:		if (state->hand[player][i] == duchy) { score = score + 3; };
    #####:  430:		if (state->hand[player][i] == province) { score = score + 6; };
    #####:  431:		if (state->hand[player][i] == great_hall) { score = score + 1; };
    #####:  432:		if (state->hand[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  433:	}
        -:  434:
        -:  435:	//score from discard
    #####:  436:	for (i = 0; i < state->discardCount[player]; i++)
        -:  437:	{
    #####:  438:		if (state->discard[player][i] == curse) { score = score - 1; };
    #####:  439:		if (state->discard[player][i] == estate) { score = score + 1; };
    #####:  440:		if (state->discard[player][i] == duchy) { score = score + 3; };
    #####:  441:		if (state->discard[player][i] == province) { score = score + 6; };
    #####:  442:		if (state->discard[player][i] == great_hall) { score = score + 1; };
    #####:  443:		if (state->discard[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  444:	}
        -:  445:
        -:  446:	//score from deck
    #####:  447:	for (i = 0; i < state->discardCount[player]; i++)
        -:  448:	{
    #####:  449:		if (state->deck[player][i] == curse) { score = score - 1; };
    #####:  450:		if (state->deck[player][i] == estate) { score = score + 1; };
    #####:  451:		if (state->deck[player][i] == duchy) { score = score + 3; };
    #####:  452:		if (state->deck[player][i] == province) { score = score + 6; };
    #####:  453:		if (state->deck[player][i] == great_hall) { score = score + 1; };
    #####:  454:		if (state->deck[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  455:	}
        -:  456:
    #####:  457:	return score;
        -:  458:}
        -:  459:
    #####:  460:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  461:	int i;
        -:  462:	int j;
        -:  463:	int highScore;
        -:  464:	int currentPlayer;
        -:  465:
        -:  466:	//get score for each player
    #####:  467:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  468:	{
        -:  469:		//set unused player scores to -9999
    #####:  470:		if (i >= state->numPlayers)
        -:  471:		{
    #####:  472:			players[i] = -9999;
        -:  473:		}
        -:  474:		else
        -:  475:		{
    #####:  476:			players[i] = scoreFor(i, state);
        -:  477:		}
        -:  478:	}
        -:  479:
        -:  480:	//find highest score
    #####:  481:	j = 0;
    #####:  482:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  483:	{
    #####:  484:		if (players[i] > players[j])
        -:  485:		{
    #####:  486:			j = i;
        -:  487:		}
        -:  488:	}
    #####:  489:	highScore = players[j];
        -:  490:
        -:  491:	//add 1 to players who had less turns
    #####:  492:	currentPlayer = whoseTurn(state);
    #####:  493:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  494:	{
    #####:  495:		if (players[i] == highScore && i > currentPlayer)
        -:  496:		{
    #####:  497:			players[i]++;
        -:  498:		}
        -:  499:	}
        -:  500:
        -:  501:	//find new highest score
    #####:  502:	j = 0;
    #####:  503:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  504:	{
    #####:  505:		if (players[i] > players[j])
        -:  506:		{
    #####:  507:			j = i;
        -:  508:		}
        -:  509:	}
    #####:  510:	highScore = players[j];
        -:  511:
        -:  512:	//set winners in array to 1 and rest to 0
    #####:  513:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  514:	{
    #####:  515:		if (players[i] == highScore)
        -:  516:		{
    #####:  517:			players[i] = 1;
        -:  518:		}
        -:  519:		else
        -:  520:		{
    #####:  521:			players[i] = 0;
        -:  522:		}
        -:  523:	}
        -:  524:
    #####:  525:	return 0;
        -:  526:}
        -:  527:
     1328:  528:int drawCard(int player, struct gameState *state)
        -:  529:{
        -:  530:	int count;
        -:  531:	int deckCounter;
     1328:  532:	if (state->deckCount[player] <= 0){//Deck is empty
        -:  533:
        -:  534:		//Step 1 Shuffle the discard pile back into a deck
        -:  535:		int i;
        -:  536:		//Move discard to deck
     1551:  537:		for (i = 0; i < state->discardCount[player]; i++){
     1357:  538:			state->deck[player][i] = state->discard[player][i];
     1357:  539:			state->discard[player][i] = -1;
        -:  540:		}
        -:  541:
      194:  542:		state->deckCount[player] = state->discardCount[player];
      194:  543:		state->discardCount[player] = 0;//Reset discard
        -:  544:
        -:  545:		//Shufffle the deck
      194:  546:		shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  547:
        -:  548:		if (DEBUG){//Debug statements
        -:  549:			printf("Deck count now: %d\n", state->deckCount[player]);
        -:  550:		}
        -:  551:
      194:  552:		state->discardCount[player] = 0;
        -:  553:
        -:  554:		//Step 2 Draw Card
      194:  555:		count = state->handCount[player];//Get current player's hand count
        -:  556:
        -:  557:		if (DEBUG){//Debug statements
        -:  558:			printf("Current hand count: %d\n", count);
        -:  559:		}
        -:  560:
      194:  561:		deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  562:
      194:  563:		if (deckCounter == 0)
       65:  564:			return -1;
        -:  565:
      129:  566:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
      129:  567:		state->deckCount[player]--;
      129:  568:		state->handCount[player]++;//Increment hand count
        -:  569:	}
        -:  570:
        -:  571:	else{
     1134:  572:		int count = state->handCount[player];//Get current hand count for player
        -:  573:		int deckCounter;
        -:  574:		if (DEBUG){//Debug statements
        -:  575:			printf("Current hand count: %d\n", count);
        -:  576:		}
        -:  577:
     1134:  578:		deckCounter = state->deckCount[player];//Create holder for the deck count
     1134:  579:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
     1134:  580:		state->deckCount[player]--;
     1134:  581:		state->handCount[player]++;//Increment hand count
        -:  582:	}
        -:  583:
     1263:  584:	return 0;
        -:  585:}
        -:  586:
     1028:  587:int getCost(int cardNumber)
        -:  588:{
     1028:  589:	switch (cardNumber)
        -:  590:	{
        -:  591:	case curse:
       92:  592:		return 0;
        -:  593:	case estate:
       49:  594:		return 2;
        -:  595:	case duchy:
       54:  596:		return 5;
        -:  597:	case province:
       53:  598:		return 8;
        -:  599:	case copper:
       91:  600:		return 0;
        -:  601:	case silver:
       59:  602:		return 3;
        -:  603:	case gold:
       48:  604:		return 6;
        -:  605:	case adventurer:
       56:  606:		return 6;
        -:  607:	case council_room:
       18:  608:		return 5;
        -:  609:	case feast:
    #####:  610:		return 4;
        -:  611:	case gardens:
       19:  612:		return 4;
        -:  613:	case mine:
    #####:  614:		return 5;
        -:  615:	case remodel:
       30:  616:		return 4;
        -:  617:	case smithy:
       25:  618:		return 4;
        -:  619:	case village:
       41:  620:		return 3;
        -:  621:	case baron:
       20:  622:		return 4;
        -:  623:	case great_hall:
       48:  624:		return 3;
        -:  625:	case minion:
       37:  626:		return 5;
        -:  627:	case steward:
       35:  628:		return 3;
        -:  629:	case tribute:
       48:  630:		return 5;
        -:  631:	case ambassador:
    #####:  632:		return 3;
        -:  633:	case cutpurse:
       57:  634:		return 4;
        -:  635:	case embargo:
       26:  636:		return 2;
        -:  637:	case outpost:
    #####:  638:		return 5;
        -:  639:	case salvager:
       52:  640:		return 4;
        -:  641:	case sea_hag:
       44:  642:		return 4;
        -:  643:	case treasure_map:
       25:  644:		return 4;
        -:  645:	}
        -:  646:
        1:  647:	return -1;
        -:  648:}
        -:  649:
    #####:  650:void playAdventurer(struct gameState *state, int currentPlayer)
        -:  651:// Reveal cards from deck until 2 Treasure cards are found.  Put those Treasure cards in the hand and discard the rest.
        -:  652:{
    #####:  653:	int drawntreasure = 0;
        -:  654:	int temphand[MAX_HAND];
        -:  655:	int cardDrawn;
    #####:  656:	int z = 0; // this is the counter for the temp hand
        -:  657:
    #####:  658:	while (drawntreasure < 2){
    #####:  659:		if (state->deckCount[currentPlayer] < 1){//if the deck is empty we need to shuffle discard and add to deck
    #####:  660:			shuffle(currentPlayer, state);
        -:  661:		}
    #####:  662:		drawCard(currentPlayer, state);
    #####:  663:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer] - 1];//top card of hand is most recently drawn card.
    #####:  664:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
    #####:  665:			drawntreasure++;
        -:  666:		else{
    #####:  667:			temphand[z] = cardDrawn;
    #####:  668:			state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####:  669:			z++;
        -:  670:		}
        -:  671:	}
    #####:  672:	while (z - 1 >= 0){
    #####:  673:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; // discard all cards in play that have been drawn
    #####:  674:		z = z - 1;
        -:  675:	}
    #####:  676:}
        -:  677:
        3:  678:int playRemodel(struct gameState *state, int currentPlayer, int choice1, int choice2, int handPos)
        -:  679://Trash a card in the hand, and gain a card costing up to $2 more than the trashed card
        -:  680:{
        -:  681:	int i;
        3:  682:	int j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  683:
        3:  684:	if ((getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2))
        -:  685:	{
        2:  686:		return -1;
        -:  687:	}
        -:  688:
        1:  689:	gainCard(choice2, state, 0, currentPlayer);
        -:  690:
        -:  691:	//discard card from hand
        1:  692:	discardCard(handPos, currentPlayer, state, 0);
        -:  693:
        -:  694:	//discard trashed card
        5:  695:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  696:	{
        4:  697:		if (state->hand[currentPlayer][i] == j)
        -:  698:		{
    #####:  699:			discardCard(i, currentPlayer, state, 0);
    #####:  700:			break;
        -:  701:		}
        -:  702:	}
        -:  703:
        1:  704:	return 0;
        -:  705:}
        -:  706:
    #####:  707:void playSmithy(struct gameState *state, int currentPlayer, int handPos)
        -:  708:// Draw 3 cards
        -:  709:{
        -:  710:	int i;
    #####:  711:	for (i = 0; i < 3; i++)
        -:  712:	{
    #####:  713:		drawCard(currentPlayer, state);
        -:  714:	}
        -:  715:
        -:  716:	//discard card from hand
    #####:  717:	discardCard(handPos, currentPlayer, state, 0);
    #####:  718:}
        -:  719:
        3:  720:void playBaron(struct gameState *state, int currentPlayer, int choice1, int handPos)
        -:  721://Add a buy.  OPTION:  Discard an Estate card and gain $4.  Otherwise, gain an Estate card.
        -:  722:{
        3:  723:	state->numBuys++;//Increase buys by 1!
        3:  724:	if (choice1 > 0){//Boolean true or going to discard an estate
        3:  725:		int p = 0;//Iterator for hand!
        3:  726:		int card_not_discarded = 1;//Flag for discard set!
       19:  727:		while (card_not_discarded){
       13:  728:			if (state->hand[currentPlayer][p] == estate){ //Found an estate card!
        2:  729:				state->coins += 4;//Add 4 coins to the amount of coins
        2:  730:				state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
        2:  731:				state->discardCount[currentPlayer]++;
        8:  732:				for (; p < state->handCount[currentPlayer]; p++){
        6:  733:					state->hand[currentPlayer][p] = state->hand[currentPlayer][p + 1];
        -:  734:				}
        2:  735:				state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
        2:  736:				state->handCount[currentPlayer]--;
        2:  737:				card_not_discarded = 0;//Exit the loop
        -:  738:			}
       11:  739:			else if (p > state->handCount[currentPlayer]){
        -:  740:				if (DEBUG) {
        -:  741:					printf("No estate cards in your hand, invalid choice\n");
        -:  742:					printf("Must gain an estate if there are any\n");
        -:  743:				}
        1:  744:				if (supplyCount(estate, state) > 0){
        1:  745:					gainCard(estate, state, 1, currentPlayer);
        1:  746:					state->supplyCount[estate]--;//Decrement estates
        1:  747:					if (supplyCount(estate, state) == 0){
    #####:  748:						isGameOver(state);
        -:  749:					}
        -:  750:				}
        1:  751:				card_not_discarded = 0;//Exit the loop
        -:  752:			}
        -:  753:
        -:  754:			else{
       10:  755:				p++;//Next card
        -:  756:			}
        -:  757:		}
        -:  758:	}
        -:  759:
        -:  760:	else{
    #####:  761:		if (supplyCount(estate, state) > 0){
    #####:  762:			gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  763:			state->supplyCount[estate]--;//Decrement Estates
    #####:  764:			if (supplyCount(estate, state) == 0){
    #####:  765:				isGameOver(state);
        -:  766:			}
        -:  767:		}
        -:  768:	}
        3:  769:}
        -:  770:
        2:  771:int playTreasureMap(struct gameState *state, int currentPlayer, int handPos)
        -:  772://Trashing two treasure map cards from the hand = four gold on top of the deck.
        -:  773:{
        -:  774:	int i;
        -:  775:	int index;
        -:  776:
        -:  777:	//search hand for another treasure_map
       12:  778:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  779:	{
       10:  780:		if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -:  781:		{
    #####:  782:			index = i;
    #####:  783:			break;
        -:  784:		}
        -:  785:	}
        2:  786:	if (index > -1)
        -:  787:	{
        -:  788:		//trash both treasure cards
        2:  789:		discardCard(handPos, currentPlayer, state, 1);
        2:  790:		discardCard(index, currentPlayer, state, 1);
        -:  791:
        -:  792:		//gain 4 Gold cards
       10:  793:		for (i = 0; i < 4; i++)
        -:  794:		{
        8:  795:			gainCard(gold, state, 1, currentPlayer);
        -:  796:		}
        -:  797:
        -:  798:		//return success
        2:  799:		return 1;
        -:  800:	}
        -:  801:
        -:  802:	//no second treasure_map found in hand
    #####:  803:	return -1;
        -:  804:}
        -:  805:
       77:  806:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  807:{
        -:  808:	int i;
        -:  809:	int j;
        -:  810:	int k;
        -:  811:	//int x;  //Unused after while loop removed from feast.
       77:  812:	int currentPlayer = whoseTurn(state);
       77:  813:	int nextPlayer = currentPlayer + 1;
        -:  814:	int temphand[MAX_HAND];
        -:  815:
       77:  816:	int tributeRevealedCards[2] = { -1, -1 };
        -:  817:
       77:  818:	if (nextPlayer > (state->numPlayers - 1)){
       32:  819:		nextPlayer = 0;
        -:  820:	}
        -:  821:
        -:  822:	//uses switch to select card and perform actions
       77:  823:	switch (card)
        -:  824:	{
        -:  825:	case adventurer:
        -:  826:
    #####:  827:		playAdventurer(state, currentPlayer);
    #####:  828:		return 0;
        -:  829:
        -:  830:	case council_room:
        -:  831:		//+4 Cards
    #####:  832:		for (i = 0; i < 4; i++)
        -:  833:		{
    #####:  834:			drawCard(currentPlayer, state);
        -:  835:		}
        -:  836:
        -:  837:		//+1 Buy
    #####:  838:		state->numBuys++;
        -:  839:
        -:  840:		//Each other player draws a card
    #####:  841:		for (i = 0; i < state->numPlayers; i++)
        -:  842:		{
    #####:  843:			if (i != currentPlayer)
        -:  844:			{
    #####:  845:				drawCard(i, state);
        -:  846:			}
        -:  847:		}
        -:  848:
        -:  849:		//put played card in played card pile
    #####:  850:		discardCard(handPos, currentPlayer, state, 0);
        -:  851:
    #####:  852:		return 0;
        -:  853:
        -:  854:	case feast:
        -:  855:		//gain card with cost up to 5
        -:  856:		//Backup hand
    #####:  857:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  858:			temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  859:			state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  860:		}
        -:  861:		//Backup hand
        -:  862:
        -:  863:		//Update Coins for Buy
    #####:  864:		updateCoins(currentPlayer, state, 5);
        -:  865://		x = 1;//Condition to loop on
        -:  866://		while (x == 1) {//Buy one card
    #####:  867:			if (supplyCount(choice1, state) <= 0){
        -:  868:				if (DEBUG)
        -:  869:					printf("None of that card left, sorry!\n");
        -:  870:
        -:  871:				if (DEBUG){
        -:  872:					printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  873:				}
        -:  874:			}
    #####:  875:			else if (state->coins < getCost(choice1)){
    #####:  876:				printf("That card is too expensive!\n");
        -:  877:
        -:  878:				if (DEBUG){
        -:  879:					printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  880:				}
        -:  881:			}
        -:  882:			else{
        -:  883:
        -:  884:				if (DEBUG){
        -:  885:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  886:				}
        -:  887:
    #####:  888:				gainCard(choice1, state, 0, currentPlayer);//Gain the card
        -:  889://				x = 0;//No more buying cards
        -:  890:
        -:  891:				if (DEBUG){
        -:  892:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  893:				}
        -:  894:
        -:  895:			}
        -:  896://		}
        -:  897:
        -:  898:		//Reset Hand
    #####:  899:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  900:			state->hand[currentPlayer][i] = temphand[i];
    #####:  901:			temphand[i] = -1;
        -:  902:		}
        -:  903:		//Reset Hand
        -:  904:
    #####:  905:		return 0;
        -:  906:
        -:  907:	case gardens:
    #####:  908:		return -1;
        -:  909:
        -:  910:	case mine:
    #####:  911:		j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  912:
    #####:  913:		if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  914:		{
    #####:  915:			return -1;
        -:  916:		}
        -:  917:
    #####:  918:		if (choice2 > treasure_map || choice2 < curse)
        -:  919:		{
    #####:  920:			return -1;
        -:  921:		}
        -:  922:
    #####:  923:		if ((getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2))
        -:  924:		{
    #####:  925:			return -1;
        -:  926:		}
        -:  927:
    #####:  928:		gainCard(choice2, state, 2, currentPlayer);
        -:  929:
        -:  930:		//discard card from hand
    #####:  931:		discardCard(handPos, currentPlayer, state, 0);
        -:  932:
        -:  933:		//discard trashed card
    #####:  934:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  935:		{
    #####:  936:			if (state->hand[currentPlayer][i] == j)
        -:  937:			{
    #####:  938:				discardCard(i, currentPlayer, state, 0);
    #####:  939:				break;
        -:  940:			}
        -:  941:		}
        -:  942:
    #####:  943:		return 0;
        -:  944:
        -:  945:	case remodel:
        -:  946:
        3:  947:		return playRemodel(state, currentPlayer, choice1, choice2, handPos);
        -:  948:
        -:  949:	case smithy:
        -:  950:
    #####:  951:		playSmithy(state, currentPlayer, handPos);
    #####:  952:		return 0;
        -:  953:
        -:  954:	case village:
        -:  955:		//+1 Card
        9:  956:		drawCard(currentPlayer, state);
        -:  957:
        -:  958:		//+2 Actions
        9:  959:		state->numActions = state->numActions + 2;
        -:  960:
        -:  961:		//discard played card from hand
        9:  962:		discardCard(handPos, currentPlayer, state, 0);
        9:  963:		return 0;
        -:  964:
        -:  965:	case baron:
        -:  966:
        3:  967:		playBaron(state, currentPlayer, choice1, handPos);
        3:  968:		return 0;
        -:  969:
        -:  970:	case great_hall:
        -:  971:		//+1 Card
        9:  972:		drawCard(currentPlayer, state);
        -:  973:
        -:  974:		//+1 Actions
        9:  975:		state->numActions++;
        -:  976:
        -:  977:		//discard card from hand
        9:  978:		discardCard(handPos, currentPlayer, state, 0);
        9:  979:		return 0;
        -:  980:
        -:  981:	case minion:
        -:  982:		//+1 action
    #####:  983:		state->numActions++;
        -:  984:
        -:  985:		//discard card from hand
    #####:  986:		discardCard(handPos, currentPlayer, state, 0);
        -:  987:
    #####:  988:		if (choice1)		//+2 coins
        -:  989:		{
    #####:  990:			state->coins = state->coins + 2;
        -:  991:		}
        -:  992:
    #####:  993:		else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  994:		{
        -:  995:			//discard hand
    #####:  996:			while (numHandCards(state) > 0)
        -:  997:			{
    #####:  998:				discardCard(handPos, currentPlayer, state, 0);
        -:  999:			}
        -: 1000:
        -: 1001:			//draw 4
    #####: 1002:			for (i = 0; i < 4; i++)
        -: 1003:			{
    #####: 1004:				drawCard(currentPlayer, state);
        -: 1005:			}
        -: 1006:
        -: 1007:			//other players discard hand and redraw if hand size > 4
    #####: 1008:			for (i = 0; i < state->numPlayers; i++)
        -: 1009:			{
    #####: 1010:				if (i != currentPlayer)
        -: 1011:				{
    #####: 1012:					if (state->handCount[i] > 4)
        -: 1013:					{
        -: 1014:						//discard hand
    #####: 1015:						while (state->handCount[i] > 0)
        -: 1016:						{
    #####: 1017:							discardCard(handPos, i, state, 0);
        -: 1018:						}
        -: 1019:
        -: 1020:						//draw 4
    #####: 1021:						for (j = 0; j < 4; j++)
        -: 1022:						{
    #####: 1023:							drawCard(i, state);
        -: 1024:						}
        -: 1025:					}
        -: 1026:				}
        -: 1027:			}
        -: 1028:
        -: 1029:		}
    #####: 1030:		return 0;
        -: 1031:
        -: 1032:	case steward:
        6: 1033:		if (choice1 == 1)
        -: 1034:		{
        -: 1035:			//+2 cards
    #####: 1036:			drawCard(currentPlayer, state);
    #####: 1037:			drawCard(currentPlayer, state);
        -: 1038:		}
        6: 1039:		else if (choice1 == 2)
        -: 1040:		{
        -: 1041:			//+2 coins
    #####: 1042:			state->coins = state->coins + 2;
        -: 1043:		}
        -: 1044:		else
        -: 1045:		{
        -: 1046:			//trash 2 cards in hand
        6: 1047:			discardCard(choice2, currentPlayer, state, 1);
        6: 1048:			discardCard(choice3, currentPlayer, state, 1);
        -: 1049:		}
        -: 1050:
        -: 1051:		//discard card from hand
        6: 1052:		discardCard(handPos, currentPlayer, state, 0);
        6: 1053:		return 0;
        -: 1054:
        -: 1055:	case tribute:
        8: 1056:		if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####: 1057:			if (state->deckCount[nextPlayer] > 0){
    #####: 1058:				tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1059:				state->deckCount[nextPlayer]--;
        -: 1060:			}
    #####: 1061:			else if (state->discardCount[nextPlayer] > 0){
    #####: 1062:				tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer] - 1];
    #####: 1063:				state->discardCount[nextPlayer]--;
        -: 1064:			}
        -: 1065:			else{
        -: 1066:				//No Card to Reveal
        -: 1067:				if (DEBUG){
        -: 1068:					printf("No cards to reveal\n");
        -: 1069:				}
        -: 1070:			}
        -: 1071:		}
        -: 1072:
        -: 1073:		else{
        8: 1074:			if (state->deckCount[nextPlayer] == 0){
        8: 1075:				for (i = 0; i < state->discardCount[nextPlayer]; i++){
        7: 1076:					state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
        7: 1077:					state->deckCount[nextPlayer]++;
        7: 1078:					state->discard[nextPlayer][i] = -1;
        7: 1079:					state->discardCount[nextPlayer]--;
        -: 1080:				}
        -: 1081:
        1: 1082:				shuffle(nextPlayer, state);//Shuffle the deck
        -: 1083:			}
        8: 1084:			tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
        8: 1085:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
        8: 1086:			state->deckCount[nextPlayer]--;
        8: 1087:			tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
        8: 1088:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
        8: 1089:			state->deckCount[nextPlayer]--;
        -: 1090:		}
        -: 1091:
        8: 1092:		if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
        5: 1093:			state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
        5: 1094:			state->playedCardCount++;
        5: 1095:			tributeRevealedCards[1] = -1;
        -: 1096:		}
        -: 1097:
       32: 1098:		for (i = 0; i <= 2; i++){
       24: 1099:			if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
        3: 1100:				state->coins += 2;
        -: 1101:			}
        -: 1102:
       21: 1103:			else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
        5: 1104:				drawCard(currentPlayer, state);
        5: 1105:				drawCard(currentPlayer, state);
        -: 1106:			}
        -: 1107:			else{//Action Card
       16: 1108:				state->numActions = state->numActions + 2;
        -: 1109:			}
        -: 1110:		}
        -: 1111:
        8: 1112:		return 0;
        -: 1113:
        -: 1114:	case ambassador:
    #####: 1115:		j = 0;		//used to check if player has enough cards to discard
        -: 1116:
    #####: 1117:		if (choice2 > 2 || choice2 < 0)
        -: 1118:		{
    #####: 1119:			return -1;
        -: 1120:		}
        -: 1121:
    #####: 1122:		if (choice1 == handPos)
        -: 1123:		{
    #####: 1124:			return -1;
        -: 1125:		}
        -: 1126:
    #####: 1127:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1128:		{
    #####: 1129:			if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1130:			{
    #####: 1131:				j++;
        -: 1132:			}
        -: 1133:		}
    #####: 1134:		if (j < choice2)
        -: 1135:		{
    #####: 1136:			return -1;
        -: 1137:		}
        -: 1138:
        -: 1139:		if (DEBUG)
        -: 1140:			printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1141:
        -: 1142:		//increase supply count for choosen card by amount being discarded
    #####: 1143:		state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1144:
        -: 1145:		//each other player gains a copy of revealed card
    #####: 1146:		for (i = 0; i < state->numPlayers; i++)
        -: 1147:		{
    #####: 1148:			if (i != currentPlayer)
        -: 1149:			{
    #####: 1150:				gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1151:			}
        -: 1152:		}
        -: 1153:
        -: 1154:		//discard played card from hand
    #####: 1155:		discardCard(handPos, currentPlayer, state, 0);
        -: 1156:
        -: 1157:		//trash copies of cards returned to supply
    #####: 1158:		for (j = 0; j < choice2; j++)
        -: 1159:		{
    #####: 1160:			for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1161:			{
    #####: 1162:				if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1163:				{
    #####: 1164:					discardCard(i, currentPlayer, state, 1);
    #####: 1165:					break;
        -: 1166:				}
        -: 1167:			}
        -: 1168:		}
        -: 1169:
    #####: 1170:		return 0;
        -: 1171:
        -: 1172:	case cutpurse:
        -: 1173:
        3: 1174:		updateCoins(currentPlayer, state, 2);
       15: 1175:		for (i = 0; i < state->numPlayers; i++)
        -: 1176:		{
       12: 1177:			if (i != currentPlayer)
        -: 1178:			{
        9: 1179:				for (j = 0; j < state->handCount[i]; j++)
        -: 1180:				{
    #####: 1181:					if (state->hand[i][j] == copper)
        -: 1182:					{
    #####: 1183:						discardCard(j, i, state, 0);
    #####: 1184:						break;
        -: 1185:					}
    #####: 1186:					if (j == state->handCount[i])
        -: 1187:					{
    #####: 1188:						for (k = 0; k < state->handCount[i]; k++)
        -: 1189:						{
        -: 1190:							if (DEBUG)
        -: 1191:								printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1192:						}
    #####: 1193:						break;
        -: 1194:					}
        -: 1195:				}
        -: 1196:
        -: 1197:			}
        -: 1198:
        -: 1199:		}
        -: 1200:
        -: 1201:		//discard played card from hand
        3: 1202:		discardCard(handPos, currentPlayer, state, 0);
        -: 1203:
        3: 1204:		return 0;
        -: 1205:
        -: 1206:
        -: 1207:	case embargo:
        -: 1208:		//+2 Coins
       12: 1209:		state->coins = state->coins + 2;
        -: 1210:
        -: 1211:		//see if selected pile is in play
       12: 1212:		if (state->supplyCount[choice1] == -1)
        -: 1213:		{
        4: 1214:			return -1;
        -: 1215:		}
        -: 1216:
        -: 1217:		//add embargo token to selected supply pile
        8: 1218:		state->embargoTokens[choice1]++;
        -: 1219:
        -: 1220:		//trash card
        8: 1221:		discardCard(handPos, currentPlayer, state, 1);
        8: 1222:		return 0;
        -: 1223:
        -: 1224:	case outpost:
        -: 1225:		//set outpost flag
    #####: 1226:		state->outpostPlayed++;
        -: 1227:
        -: 1228:		//discard card
    #####: 1229:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1230:		return 0;
        -: 1231:
        -: 1232:	case salvager:
        -: 1233:		//+1 buy
        1: 1234:		state->numBuys++;
        -: 1235:
        1: 1236:		if (choice1)
        -: 1237:		{
        -: 1238:			//gain coins equal to trashed card
        1: 1239:			state->coins = state->coins + getCost(handCard(choice1, state));
        -: 1240:			//trash card
        1: 1241:			discardCard(choice1, currentPlayer, state, 1);
        -: 1242:		}
        -: 1243:
        -: 1244:		//discard card
        1: 1245:		discardCard(handPos, currentPlayer, state, 0);
        1: 1246:		return 0;
        -: 1247:
        -: 1248:	case sea_hag:
      105: 1249:		for (i = 0; i < state->numPlayers; i++){
       84: 1250:			if (i != currentPlayer){
       63: 1251:				state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
       63: 1252:				state->discardCount[i]++;
       63: 1253:				state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1254:			}
        -: 1255:		}
       21: 1256:		return 0;
        -: 1257:
        -: 1258:	case treasure_map:
        -: 1259:
        2: 1260:		return playTreasureMap(state, currentPlayer, handPos);
        -: 1261:	}
    #####: 1262:	return -1;
        -: 1263:}
        -: 1264:
       54: 1265:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1266:{
        -: 1267:
        -: 1268:	//if card is not trashed, added to Played pile 
       54: 1269:	if (trashFlag < 1)
        -: 1270:	{
        -: 1271:		//add card to played pile
       29: 1272:		state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
       29: 1273:		state->playedCardCount++;
        -: 1274:	}
        -: 1275:
        -: 1276:	//set played card to -1
       54: 1277:	state->hand[currentPlayer][handPos] = -1;
        -: 1278:
        -: 1279:	//remove card from player's hand
       54: 1280:	if (handPos == (state->handCount[currentPlayer] - 1)) 	//last card in hand array is played
        -: 1281:	{
        -: 1282:		//reduce number of cards in hand
        6: 1283:		state->handCount[currentPlayer]--;
        -: 1284:	}
       48: 1285:	else if (state->handCount[currentPlayer] == 1) //only one card in hand
        -: 1286:	{
        -: 1287:		//reduce number of cards in hand
    #####: 1288:		state->handCount[currentPlayer]--;
        -: 1289:	}
        -: 1290:	else
        -: 1291:	{
        -: 1292:		//replace discarded card with last card in hand
       48: 1293:		state->hand[currentPlayer][handPos] = state->hand[currentPlayer][(state->handCount[currentPlayer] - 1)];
        -: 1294:		//set last card to -1
       48: 1295:		state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1296:		//reduce number of cards in hand
       48: 1297:		state->handCount[currentPlayer]--;
        -: 1298:	}
        -: 1299:
       54: 1300:	return 0;
        -: 1301:}
        -: 1302:
      208: 1303:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1304:{
        -: 1305:	//Note: supplyPos is enum of choosen card
        -: 1306:
        -: 1307:	//check if supply pile is empty (0) or card is not used in game (-1)
      208: 1308:	if (supplyCount(supplyPos, state) < 1)
        -: 1309:	{
    #####: 1310:		return -1;
        -: 1311:	}
        -: 1312:
        -: 1313:	//added card for [whoseTurn] current player:
        -: 1314:	// toFlag = 0 : add to discard
        -: 1315:	// toFlag = 1 : add to deck
        -: 1316:	// toFlag = 2 : add to hand
        -: 1317:
      208: 1318:	if (toFlag == 1)
        -: 1319:	{
        9: 1320:		state->deck[player][state->deckCount[player]] = supplyPos;
        9: 1321:		state->deckCount[player]++;
        -: 1322:	}
      199: 1323:	else if (toFlag == 2)
        -: 1324:	{
    #####: 1325:		state->hand[player][state->handCount[player]] = supplyPos;
    #####: 1326:		state->handCount[player]++;
        -: 1327:	}
        -: 1328:	else
        -: 1329:	{
      199: 1330:		state->discard[player][state->discardCount[player]] = supplyPos;
      199: 1331:		state->discardCount[player]++;
        -: 1332:	}
        -: 1333:
        -: 1334:	//decrease number in supply pile
      208: 1335:	state->supplyCount[supplyPos]--;
        -: 1336:
      208: 1337:	return 0;
        -: 1338:}
        -: 1339:
      334: 1340:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1341:{
        -: 1342:	int i;
        -: 1343:
        -: 1344:	//reset coin count
      334: 1345:	state->coins = 0;
        -: 1346:
        -: 1347:	//add coins for each Treasure card in player's hand
     1853: 1348:	for (i = 0; i < state->handCount[player]; i++)
        -: 1349:	{
     1519: 1350:		if (state->hand[player][i] == copper)
        -: 1351:		{
      657: 1352:			state->coins += 1;
        -: 1353:		}
      862: 1354:		else if (state->hand[player][i] == silver)
        -: 1355:		{
       89: 1356:			state->coins += 2;
        -: 1357:		}
      773: 1358:		else if (state->hand[player][i] == gold)
        -: 1359:		{
       23: 1360:			state->coins += 3;
        -: 1361:		}
        -: 1362:	}
        -: 1363:
        -: 1364:	//add bonus
      334: 1365:	state->coins += bonus;
        -: 1366:
      334: 1367:	return 0;
        -: 1368:}
        -: 1369:
        -: 1370:
        -: 1371://end of dominion.c
File 'dominion.c'
Lines executed:67.32% of 557
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
     4388:    8:int compare(const void* a, const void* b) {
     4388:    9:	if (*(int*)a > *(int*)b)
     1588:   10:		return 1;
     2800:   11:	if (*(int*)a < *(int*)b)
     1415:   12:		return -1;
     1385:   13:	return 0;
        -:   14:}
        -:   15:
        4:   16:struct gameState* newGame() {
        4:   17:	struct gameState* g = malloc(sizeof(struct gameState));
        4:   18:	return g;
        -:   19:}
        -:   20:
       32:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:	int k8, int k9, int k10) {
       32:   23:	int* k = malloc(10 * sizeof(int));
       32:   24:	k[0] = k1;
       32:   25:	k[1] = k2;
       32:   26:	k[2] = k3;
       32:   27:	k[3] = k4;
       32:   28:	k[4] = k5;
       32:   29:	k[5] = k6;
       32:   30:	k[6] = k7;
       32:   31:	k[7] = k8;
       32:   32:	k[8] = k9;
       32:   33:	k[9] = k10;
       32:   34:	return k;
        -:   35:}
        -:   36:
       32:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		struct gameState *state) {
        -:   39:
        -:   40:	int i;
        -:   41:	int j;
        -:   42:	int it;
        -:   43:	//set up random number generator
       32:   44:	SelectStream(1);
       32:   45:	PutSeed((long)randomSeed);
        -:   46:
        -:   47:	//check number of players
       32:   48:	if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:	{
    #####:   50:		return -1;
        -:   51:	}
        -:   52:
        -:   53:	//set number of players
       32:   54:	state->numPlayers = numPlayers;
        -:   55:
        -:   56:	//check selected kingdom cards are different
      105:   57:	for (i = 0; i < 10; i++)
        -:   58:	{
      996:   59:		for (j = 0; j < 10; j++)
        -:   60:		{
      923:   61:			if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:			{
       30:   63:				return -1;
        -:   64:			}
        -:   65:		}
        -:   66:	}
        -:   67:
        -:   68:
        -:   69:	//initialize supply
        -:   70:	///////////////////////////////
        -:   71:
        -:   72:	//set number of Curse cards
        2:   73:	if (numPlayers == 2)
        -:   74:	{
    #####:   75:		state->supplyCount[curse] = 10;
        -:   76:	}
        2:   77:	else if (numPlayers == 3)
        -:   78:	{
    #####:   79:		state->supplyCount[curse] = 20;
        -:   80:	}
        -:   81:	else
        -:   82:	{
        2:   83:		state->supplyCount[curse] = 30;
        -:   84:	}
        -:   85:
        -:   86:	//set number of Victory cards
        2:   87:	if (numPlayers == 2)
        -:   88:	{
    #####:   89:		state->supplyCount[estate] = 8;
    #####:   90:		state->supplyCount[duchy] = 8;
    #####:   91:		state->supplyCount[province] = 8;
        -:   92:	}
        -:   93:	else
        -:   94:	{
        2:   95:		state->supplyCount[estate] = 12;
        2:   96:		state->supplyCount[duchy] = 12;
        2:   97:		state->supplyCount[province] = 12;
        -:   98:	}
        -:   99:
        -:  100:	//set number of Treasure cards
        2:  101:	state->supplyCount[copper] = 60 - (7 * numPlayers);
        2:  102:	state->supplyCount[silver] = 40;
        2:  103:	state->supplyCount[gold] = 30;
        -:  104:
        -:  105:	//set number of Kingdom cards
       42:  106:	for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:	{
      330:  108:		for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:		{
      310:  110:			if (kingdomCards[j] == i)
        -:  111:			{
        -:  112:				//check if card is a 'Victory' Kingdom card
       20:  113:				if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:				{
        4:  115:					if (numPlayers == 2){
    #####:  116:						state->supplyCount[i] = 8;
        -:  117:					}
        2:  118:					else{ state->supplyCount[i] = 12; }
        -:  119:				}
        -:  120:				else
        -:  121:				{
       18:  122:					state->supplyCount[i] = 10;
        -:  123:				}
       20:  124:				break;
        -:  125:			}
        -:  126:			else    //card is not in the set choosen for the game
        -:  127:			{
      290:  128:				state->supplyCount[i] = -1;
        -:  129:			}
        -:  130:		}
        -:  131:
        -:  132:	}
        -:  133:
        -:  134:	////////////////////////
        -:  135:	//supply intilization complete
        -:  136:
        -:  137:	//set player decks
       10:  138:	for (i = 0; i < numPlayers; i++)
        -:  139:	{
        8:  140:		state->deckCount[i] = 0;
       32:  141:		for (j = 0; j < 3; j++)
        -:  142:		{
       24:  143:			state->deck[i][j] = estate;
       24:  144:			state->deckCount[i]++;
        -:  145:		}
       64:  146:		for (j = 3; j < 10; j++)
        -:  147:		{
       56:  148:			state->deck[i][j] = copper;
       56:  149:			state->deckCount[i]++;
        -:  150:		}
        -:  151:	}
        -:  152:
        -:  153:	//shuffle player decks
       10:  154:	for (i = 0; i < numPlayers; i++)
        -:  155:	{
        8:  156:		if (shuffle(i, state) < 0)
        -:  157:		{
    #####:  158:			return -1;
        -:  159:		}
        -:  160:	}
        -:  161:
        -:  162:	//draw player hands
       10:  163:	for (i = 0; i < numPlayers; i++)
        -:  164:	{
        -:  165:		//initialize hand size to zero
        8:  166:		state->handCount[i] = 0;
        8:  167:		state->discardCount[i] = 0;
        -:  168:		//draw 5 cards
        -:  169:		// for (j = 0; j < 5; j++)
        -:  170:		//	{
        -:  171:		//	  drawCard(i, state);
        -:  172:		//	}
        -:  173:	}
        -:  174:
        -:  175:	//set embargo tokens to 0 for all supply piles
       56:  176:	for (i = 0; i <= treasure_map; i++)
        -:  177:	{
       54:  178:		state->embargoTokens[i] = 0;
        -:  179:	}
        -:  180:
        -:  181:	//initialize first player's turn
        2:  182:	state->outpostPlayed = 0;
        2:  183:	state->phase = 0;
        2:  184:	state->numActions = 1;
        2:  185:	state->numBuys = 1;
        2:  186:	state->playedCardCount = 0;
        2:  187:	state->whoseTurn = 0;
        2:  188:	state->handCount[state->whoseTurn] = 0;
        -:  189:	//int it; move to top
        -:  190:
        -:  191:	//Moved draw cards to here, only drawing at the start of a turn
       12:  192:	for (it = 0; it < 5; it++){
       10:  193:		drawCard(state->whoseTurn, state);
        -:  194:	}
        -:  195:
        2:  196:	updateCoins(state->whoseTurn, state, 0);
        -:  197:
        2:  198:	return 0;
        -:  199:}
        -:  200:
      105:  201:int shuffle(int player, struct gameState *state) {
        -:  202:
        -:  203:
        -:  204:	int newDeck[MAX_DECK];
      105:  205:	int newDeckPos = 0;
        -:  206:	int card;
        -:  207:	int i;
        -:  208:
      105:  209:	if (state->deckCount[player] < 1)
    #####:  210:		return -1;
      105:  211:	qsort((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
        -:  212:	/* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
     2094:  214:	while (state->deckCount[player] > 0) {
     1884:  215:		card = floor(Random() * state->deckCount[player]);
     1884:  216:		newDeck[newDeckPos] = state->deck[player][card];
     1884:  217:		newDeckPos++;
    11388:  218:		for (i = card; i < state->deckCount[player] - 1; i++) {
     9504:  219:			state->deck[player][i] = state->deck[player][i + 1];
        -:  220:		}
     1884:  221:		state->deckCount[player]--;
        -:  222:	}
     1989:  223:	for (i = 0; i < newDeckPos; i++) {
     1884:  224:		state->deck[player][i] = newDeck[i];
     1884:  225:		state->deckCount[player]++;
        -:  226:	}
        -:  227:
      105:  228:	return 0;
        -:  229:}
        -:  230:
     1576:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state)
        -:  232:{
        -:  233:	int card;
     1576:  234:	int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:	//check if it is the right phase
     1576:  237:	if (state->phase != 0)
        -:  238:	{
      248:  239:		return -1;
        -:  240:	}
        -:  241:
        -:  242:	//check if player has enough actions
     1328:  243:	if (state->numActions < 1)
        -:  244:	{
       72:  245:		return -1;
        -:  246:	}
        -:  247:
        -:  248:	//get card played
     1256:  249:	card = handCard(handPos, state);
        -:  250:
        -:  251:	//check if selected card is an action
     1256:  252:	if (card < adventurer || card > treasure_map)
        -:  253:	{
     1104:  254:		return -1;
        -:  255:	}
        -:  256:
        -:  257:	//play card
      152:  258:	if (cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0)
        -:  259:	{
       68:  260:		return -1;
        -:  261:	}
        -:  262:
        -:  263:	//reduce number of actions
       84:  264:	state->numActions--;
        -:  265:
        -:  266:	//update coins (Treasure cards may be added with card draws)
       84:  267:	updateCoins(state->whoseTurn, state, coin_bonus);
        -:  268:
       84:  269:	return 0;
        -:  270:}
        -:  271:
     1555:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:	int who;
        -:  274:	if (DEBUG){
        -:  275:		printf("Entering buyCard...\n");
        -:  276:	}
        -:  277:
        -:  278:	// I don't know what to do about the phase thing.
        -:  279:
     1555:  280:	who = state->whoseTurn;
        -:  281:
     1555:  282:	if (state->numBuys < 1){
        -:  283:		if (DEBUG)
        -:  284:			printf("You do not have any buys left\n");
      250:  285:		return -1;
        -:  286:	}
     1305:  287:	else if (supplyCount(supplyPos, state) < 1){
        -:  288:		if (DEBUG)
        -:  289:			printf("There are not any of that type of card left\n");
      532:  290:		return -1;
        -:  291:	}
      773:  292:	else if (state->coins < getCost(supplyPos)){
        -:  293:		if (DEBUG)
        -:  294:			printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
      511:  295:		return -1;
        -:  296:	}
        -:  297:	else {
      262:  298:		state->phase = 1;
        -:  299:		//state->supplyCount[supplyPos]--;
      262:  300:		gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  301:
      262:  302:		state->coins = (state->coins) - (getCost(supplyPos));
      262:  303:		state->numBuys--;
        -:  304:		if (DEBUG)
        -:  305:			printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  306:	}
        -:  307:
        -:  308:	//state->discard[who][state->discardCount[who]] = supplyPos;
        -:  309:	//state->discardCount[who]++;
        -:  310:
      262:  311:	return 0;
        -:  312:}
        -:  313:
    #####:  314:int numHandCards(struct gameState *state) {
    #####:  315:	return state->handCount[whoseTurn(state)];
        -:  316:}
        -:  317:
     1256:  318:int handCard(int handPos, struct gameState *state) {
     1256:  319:	int currentPlayer = whoseTurn(state);
     1256:  320:	return state->hand[currentPlayer][handPos];
        -:  321:}
        -:  322:
     1628:  323:int supplyCount(int card, struct gameState *state) {
     1628:  324:	return state->supplyCount[card];
        -:  325:}
        -:  326:
    #####:  327:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  328:	int i;
    #####:  329:	int count = 0;
        -:  330:
    #####:  331:	for (i = 0; i < state->deckCount[player]; i++)
        -:  332:	{
    #####:  333:		if (state->deck[player][i] == card) count++;
        -:  334:	}
        -:  335:
    #####:  336:	for (i = 0; i < state->handCount[player]; i++)
        -:  337:	{
    #####:  338:		if (state->hand[player][i] == card) count++;
        -:  339:	}
        -:  340:
    #####:  341:	for (i = 0; i < state->discardCount[player]; i++)
        -:  342:	{
    #####:  343:		if (state->discard[player][i] == card) count++;
        -:  344:	}
        -:  345:
    #####:  346:	return count;
        -:  347:}
        -:  348:
     1739:  349:int whoseTurn(struct gameState *state) {
     1739:  350:	return state->whoseTurn;
        -:  351:}
        -:  352:
      331:  353:int endTurn(struct gameState *state) {
        -:  354:	int k;
        -:  355:	int i;
      331:  356:	int currentPlayer = whoseTurn(state);
        -:  357:
        -:  358:	//Discard hand
     1937:  359:	for (i = 0; i < state->handCount[currentPlayer]; i++){
     1606:  360:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
     1606:  361:		state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  362:	}
      331:  363:	state->handCount[currentPlayer] = 0;//Reset hand count
        -:  364:
        -:  365:	//Code for determining the player
      331:  366:	if (currentPlayer < (state->numPlayers - 1)){
      249:  367:		state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  368:	}
        -:  369:	else{
       82:  370:		state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  371:	}
        -:  372:
      331:  373:	state->outpostPlayed = 0;
      331:  374:	state->phase = 0;
      331:  375:	state->numActions = 1;
      331:  376:	state->coins = 0;
      331:  377:	state->numBuys = 1;
      331:  378:	state->playedCardCount = 0;
      331:  379:	state->handCount[state->whoseTurn] = 0;
        -:  380:
        -:  381:	//int k; move to top
        -:  382:	//Next player draws hand
     1986:  383:	for (k = 0; k < 5; k++){
     1655:  384:		drawCard(state->whoseTurn, state);//Draw a card
        -:  385:	}
        -:  386:
        -:  387:	//Update money
      331:  388:	updateCoins(state->whoseTurn, state, 0);
        -:  389:
      331:  390:	return 0;
        -:  391:}
        -:  392:
     4637:  393:int isGameOver(struct gameState *state) {
        -:  394:	int i;
        -:  395:	int j;
        -:  396:
        -:  397:	//if stack of Province cards is empty, the game ends
     4637:  398:	if (state->supplyCount[province] == 0)
        -:  399:	{
    #####:  400:		return 1;
        -:  401:	}
        -:  402:
        -:  403:	//if three supply pile are at 0, the game ends
     4637:  404:	j = 0;
   120562:  405:	for (i = 0; i < 25; i++)
        -:  406:	{
   115925:  407:		if (state->supplyCount[i] == 0)
        -:  408:		{
     3233:  409:			j++;
        -:  410:		}
        -:  411:	}
     4637:  412:	if (j >= 3)
        -:  413:	{
        2:  414:		return 1;
        -:  415:	}
        -:  416:
     4635:  417:	return 0;
        -:  418:}
        -:  419:
    #####:  420:int scoreFor(int player, struct gameState *state) {
        -:  421:
        -:  422:	int i;
    #####:  423:	int score = 0;
        -:  424:	//score from hand
    #####:  425:	for (i = 0; i < state->handCount[player]; i++)
        -:  426:	{
    #####:  427:		if (state->hand[player][i] == curse) { score = score - 1; };
    #####:  428:		if (state->hand[player][i] == estate) { score = score + 1; };
    #####:  429:		if (state->hand[player][i] == duchy) { score = score + 3; };
    #####:  430:		if (state->hand[player][i] == province) { score = score + 6; };
    #####:  431:		if (state->hand[player][i] == great_hall) { score = score + 1; };
    #####:  432:		if (state->hand[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  433:	}
        -:  434:
        -:  435:	//score from discard
    #####:  436:	for (i = 0; i < state->discardCount[player]; i++)
        -:  437:	{
    #####:  438:		if (state->discard[player][i] == curse) { score = score - 1; };
    #####:  439:		if (state->discard[player][i] == estate) { score = score + 1; };
    #####:  440:		if (state->discard[player][i] == duchy) { score = score + 3; };
    #####:  441:		if (state->discard[player][i] == province) { score = score + 6; };
    #####:  442:		if (state->discard[player][i] == great_hall) { score = score + 1; };
    #####:  443:		if (state->discard[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  444:	}
        -:  445:
        -:  446:	//score from deck
    #####:  447:	for (i = 0; i < state->discardCount[player]; i++)
        -:  448:	{
    #####:  449:		if (state->deck[player][i] == curse) { score = score - 1; };
    #####:  450:		if (state->deck[player][i] == estate) { score = score + 1; };
    #####:  451:		if (state->deck[player][i] == duchy) { score = score + 3; };
    #####:  452:		if (state->deck[player][i] == province) { score = score + 6; };
    #####:  453:		if (state->deck[player][i] == great_hall) { score = score + 1; };
    #####:  454:		if (state->deck[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  455:	}
        -:  456:
    #####:  457:	return score;
        -:  458:}
        -:  459:
    #####:  460:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  461:	int i;
        -:  462:	int j;
        -:  463:	int highScore;
        -:  464:	int currentPlayer;
        -:  465:
        -:  466:	//get score for each player
    #####:  467:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  468:	{
        -:  469:		//set unused player scores to -9999
    #####:  470:		if (i >= state->numPlayers)
        -:  471:		{
    #####:  472:			players[i] = -9999;
        -:  473:		}
        -:  474:		else
        -:  475:		{
    #####:  476:			players[i] = scoreFor(i, state);
        -:  477:		}
        -:  478:	}
        -:  479:
        -:  480:	//find highest score
    #####:  481:	j = 0;
    #####:  482:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  483:	{
    #####:  484:		if (players[i] > players[j])
        -:  485:		{
    #####:  486:			j = i;
        -:  487:		}
        -:  488:	}
    #####:  489:	highScore = players[j];
        -:  490:
        -:  491:	//add 1 to players who had less turns
    #####:  492:	currentPlayer = whoseTurn(state);
    #####:  493:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  494:	{
    #####:  495:		if (players[i] == highScore && i > currentPlayer)
        -:  496:		{
    #####:  497:			players[i]++;
        -:  498:		}
        -:  499:	}
        -:  500:
        -:  501:	//find new highest score
    #####:  502:	j = 0;
    #####:  503:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  504:	{
    #####:  505:		if (players[i] > players[j])
        -:  506:		{
    #####:  507:			j = i;
        -:  508:		}
        -:  509:	}
    #####:  510:	highScore = players[j];
        -:  511:
        -:  512:	//set winners in array to 1 and rest to 0
    #####:  513:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  514:	{
    #####:  515:		if (players[i] == highScore)
        -:  516:		{
    #####:  517:			players[i] = 1;
        -:  518:		}
        -:  519:		else
        -:  520:		{
    #####:  521:			players[i] = 0;
        -:  522:		}
        -:  523:	}
        -:  524:
    #####:  525:	return 0;
        -:  526:}
        -:  527:
     1724:  528:int drawCard(int player, struct gameState *state)
        -:  529:{
        -:  530:	int count;
        -:  531:	int deckCounter;
     1724:  532:	if (state->deckCount[player] <= 0){//Deck is empty
        -:  533:
        -:  534:		//Step 1 Shuffle the discard pile back into a deck
        -:  535:		int i;
        -:  536:		//Move discard to deck
     1901:  537:		for (i = 0; i < state->discardCount[player]; i++){
     1804:  538:			state->deck[player][i] = state->discard[player][i];
     1804:  539:			state->discard[player][i] = -1;
        -:  540:		}
        -:  541:
       97:  542:		state->deckCount[player] = state->discardCount[player];
       97:  543:		state->discardCount[player] = 0;//Reset discard
        -:  544:
        -:  545:		//Shufffle the deck
       97:  546:		shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  547:
        -:  548:		if (DEBUG){//Debug statements
        -:  549:			printf("Deck count now: %d\n", state->deckCount[player]);
        -:  550:		}
        -:  551:
       97:  552:		state->discardCount[player] = 0;
        -:  553:
        -:  554:		//Step 2 Draw Card
       97:  555:		count = state->handCount[player];//Get current player's hand count
        -:  556:
        -:  557:		if (DEBUG){//Debug statements
        -:  558:			printf("Current hand count: %d\n", count);
        -:  559:		}
        -:  560:
       97:  561:		deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  562:
       97:  563:		if (deckCounter == 0)
    #####:  564:			return -1;
        -:  565:
       97:  566:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
       97:  567:		state->deckCount[player]--;
       97:  568:		state->handCount[player]++;//Increment hand count
        -:  569:	}
        -:  570:
        -:  571:	else{
     1627:  572:		int count = state->handCount[player];//Get current hand count for player
        -:  573:		int deckCounter;
        -:  574:		if (DEBUG){//Debug statements
        -:  575:			printf("Current hand count: %d\n", count);
        -:  576:		}
        -:  577:
     1627:  578:		deckCounter = state->deckCount[player];//Create holder for the deck count
     1627:  579:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
     1627:  580:		state->deckCount[player]--;
     1627:  581:		state->handCount[player]++;//Increment hand count
        -:  582:	}
        -:  583:
     1724:  584:	return 0;
        -:  585:}
        -:  586:
     1042:  587:int getCost(int cardNumber)
        -:  588:{
     1042:  589:	switch (cardNumber)
        -:  590:	{
        -:  591:	case curse:
       70:  592:		return 0;
        -:  593:	case estate:
       43:  594:		return 2;
        -:  595:	case duchy:
       43:  596:		return 5;
        -:  597:	case province:
       61:  598:		return 8;
        -:  599:	case copper:
      105:  600:		return 0;
        -:  601:	case silver:
       75:  602:		return 3;
        -:  603:	case gold:
       54:  604:		return 6;
        -:  605:	case adventurer:
       31:  606:		return 6;
        -:  607:	case council_room:
       44:  608:		return 5;
        -:  609:	case feast:
       24:  610:		return 4;
        -:  611:	case gardens:
       69:  612:		return 4;
        -:  613:	case mine:
       37:  614:		return 5;
        -:  615:	case remodel:
    #####:  616:		return 4;
        -:  617:	case smithy:
    #####:  618:		return 4;
        -:  619:	case village:
       25:  620:		return 3;
        -:  621:	case baron:
       37:  622:		return 4;
        -:  623:	case great_hall:
    #####:  624:		return 3;
        -:  625:	case minion:
       38:  626:		return 5;
        -:  627:	case steward:
       23:  628:		return 3;
        -:  629:	case tribute:
       27:  630:		return 5;
        -:  631:	case ambassador:
       23:  632:		return 3;
        -:  633:	case cutpurse:
       19:  634:		return 4;
        -:  635:	case embargo:
       30:  636:		return 2;
        -:  637:	case outpost:
       68:  638:		return 5;
        -:  639:	case salvager:
       11:  640:		return 4;
        -:  641:	case sea_hag:
       28:  642:		return 4;
        -:  643:	case treasure_map:
       57:  644:		return 4;
        -:  645:	}
        -:  646:
    #####:  647:	return -1;
        -:  648:}
        -:  649:
    #####:  650:void playAdventurer(struct gameState *state, int currentPlayer)
        -:  651:// Reveal cards from deck until 2 Treasure cards are found.  Put those Treasure cards in the hand and discard the rest.
        -:  652:{
    #####:  653:	int drawntreasure = 0;
        -:  654:	int temphand[MAX_HAND];
        -:  655:	int cardDrawn;
    #####:  656:	int z = 0; // this is the counter for the temp hand
        -:  657:
    #####:  658:	while (drawntreasure < 2){
    #####:  659:		if (state->deckCount[currentPlayer] < 1){//if the deck is empty we need to shuffle discard and add to deck
    #####:  660:			shuffle(currentPlayer, state);
        -:  661:		}
    #####:  662:		drawCard(currentPlayer, state);
    #####:  663:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer] - 1];//top card of hand is most recently drawn card.
    #####:  664:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
    #####:  665:			drawntreasure++;
        -:  666:		else{
    #####:  667:			temphand[z] = cardDrawn;
    #####:  668:			state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####:  669:			z++;
        -:  670:		}
        -:  671:	}
    #####:  672:	while (z - 1 >= 0){
    #####:  673:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; // discard all cards in play that have been drawn
    #####:  674:		z = z - 1;
        -:  675:	}
    #####:  676:}
        -:  677:
    #####:  678:int playRemodel(struct gameState *state, int currentPlayer, int choice1, int choice2, int handPos)
        -:  679://Trash a card in the hand, and gain a card costing up to $2 more than the trashed card
        -:  680:{
        -:  681:	int i;
    #####:  682:	int j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  683:
    #####:  684:	if ((getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2))
        -:  685:	{
    #####:  686:		return -1;
        -:  687:	}
        -:  688:
    #####:  689:	gainCard(choice2, state, 0, currentPlayer);
        -:  690:
        -:  691:	//discard card from hand
    #####:  692:	discardCard(handPos, currentPlayer, state, 0);
        -:  693:
        -:  694:	//discard trashed card
    #####:  695:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  696:	{
    #####:  697:		if (state->hand[currentPlayer][i] == j)
        -:  698:		{
    #####:  699:			discardCard(i, currentPlayer, state, 0);
    #####:  700:			break;
        -:  701:		}
        -:  702:	}
        -:  703:
    #####:  704:	return 0;
        -:  705:}
        -:  706:
    #####:  707:void playSmithy(struct gameState *state, int currentPlayer, int handPos)
        -:  708:// Draw 3 cards
        -:  709:{
        -:  710:	int i;
    #####:  711:	for (i = 0; i < 3; i++)
        -:  712:	{
    #####:  713:		drawCard(currentPlayer, state);
        -:  714:	}
        -:  715:
        -:  716:	//discard card from hand
    #####:  717:	discardCard(handPos, currentPlayer, state, 0);
    #####:  718:}
        -:  719:
       17:  720:void playBaron(struct gameState *state, int currentPlayer, int choice1, int handPos)
        -:  721://Add a buy.  OPTION:  Discard an Estate card and gain $4.  Otherwise, gain an Estate card.
        -:  722:{
       17:  723:	state->numBuys++;//Increase buys by 1!
       17:  724:	if (choice1 > 0){//Boolean true or going to discard an estate
       16:  725:		int p = 0;//Iterator for hand!
       16:  726:		int card_not_discarded = 1;//Flag for discard set!
       97:  727:		while (card_not_discarded){
       65:  728:			if (state->hand[currentPlayer][p] == estate){ //Found an estate card!
       10:  729:				state->coins += 4;//Add 4 coins to the amount of coins
       10:  730:				state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
       10:  731:				state->discardCount[currentPlayer]++;
       47:  732:				for (; p < state->handCount[currentPlayer]; p++){
       37:  733:					state->hand[currentPlayer][p] = state->hand[currentPlayer][p + 1];
        -:  734:				}
       10:  735:				state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
       10:  736:				state->handCount[currentPlayer]--;
       10:  737:				card_not_discarded = 0;//Exit the loop
        -:  738:			}
       55:  739:			else if (p > state->handCount[currentPlayer]){
        -:  740:				if (DEBUG) {
        -:  741:					printf("No estate cards in your hand, invalid choice\n");
        -:  742:					printf("Must gain an estate if there are any\n");
        -:  743:				}
        6:  744:				if (supplyCount(estate, state) > 0){
        2:  745:					gainCard(estate, state, 1, currentPlayer);
        2:  746:					state->supplyCount[estate]--;//Decrement estates
        2:  747:					if (supplyCount(estate, state) == 0){
        1:  748:						isGameOver(state);
        -:  749:					}
        -:  750:				}
        6:  751:				card_not_discarded = 0;//Exit the loop
        -:  752:			}
        -:  753:
        -:  754:			else{
       49:  755:				p++;//Next card
        -:  756:			}
        -:  757:		}
        -:  758:	}
        -:  759:
        -:  760:	else{
        1:  761:		if (supplyCount(estate, state) > 0){
    #####:  762:			gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  763:			state->supplyCount[estate]--;//Decrement Estates
    #####:  764:			if (supplyCount(estate, state) == 0){
    #####:  765:				isGameOver(state);
        -:  766:			}
        -:  767:		}
        -:  768:	}
       17:  769:}
        -:  770:
       10:  771:int playTreasureMap(struct gameState *state, int currentPlayer, int handPos)
        -:  772://Trashing two treasure map cards from the hand = four gold on top of the deck.
        -:  773:{
        -:  774:	int i;
        -:  775:	int index;
        -:  776:
        -:  777:	//search hand for another treasure_map
       60:  778:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  779:	{
       50:  780:		if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -:  781:		{
    #####:  782:			index = i;
    #####:  783:			break;
        -:  784:		}
        -:  785:	}
       10:  786:	if (index > -1)
        -:  787:	{
        -:  788:		//trash both treasure cards
       10:  789:		discardCard(handPos, currentPlayer, state, 1);
       10:  790:		discardCard(index, currentPlayer, state, 1);
        -:  791:
        -:  792:		//gain 4 Gold cards
       50:  793:		for (i = 0; i < 4; i++)
        -:  794:		{
       40:  795:			gainCard(gold, state, 1, currentPlayer);
        -:  796:		}
        -:  797:
        -:  798:		//return success
       10:  799:		return 1;
        -:  800:	}
        -:  801:
        -:  802:	//no second treasure_map found in hand
    #####:  803:	return -1;
        -:  804:}
        -:  805:
      152:  806:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  807:{
        -:  808:	int i;
        -:  809:	int j;
        -:  810:	int k;
        -:  811:	//int x;  //Unused after while loop removed from feast.
      152:  812:	int currentPlayer = whoseTurn(state);
      152:  813:	int nextPlayer = currentPlayer + 1;
        -:  814:	int temphand[MAX_HAND];
        -:  815:
      152:  816:	int tributeRevealedCards[2] = { -1, -1 };
        -:  817:
      152:  818:	if (nextPlayer > (state->numPlayers - 1)){
       55:  819:		nextPlayer = 0;
        -:  820:	}
        -:  821:
        -:  822:	//uses switch to select card and perform actions
      152:  823:	switch (card)
        -:  824:	{
        -:  825:	case adventurer:
        -:  826:
    #####:  827:		playAdventurer(state, currentPlayer);
    #####:  828:		return 0;
        -:  829:
        -:  830:	case council_room:
        -:  831:		//+4 Cards
       35:  832:		for (i = 0; i < 4; i++)
        -:  833:		{
       28:  834:			drawCard(currentPlayer, state);
        -:  835:		}
        -:  836:
        -:  837:		//+1 Buy
        7:  838:		state->numBuys++;
        -:  839:
        -:  840:		//Each other player draws a card
       35:  841:		for (i = 0; i < state->numPlayers; i++)
        -:  842:		{
       28:  843:			if (i != currentPlayer)
        -:  844:			{
       21:  845:				drawCard(i, state);
        -:  846:			}
        -:  847:		}
        -:  848:
        -:  849:		//put played card in played card pile
        7:  850:		discardCard(handPos, currentPlayer, state, 0);
        -:  851:
        7:  852:		return 0;
        -:  853:
        -:  854:	case feast:
        -:  855:		//gain card with cost up to 5
        -:  856:		//Backup hand
       35:  857:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
       30:  858:			temphand[i] = state->hand[currentPlayer][i];//Backup card
       30:  859:			state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  860:		}
        -:  861:		//Backup hand
        -:  862:
        -:  863:		//Update Coins for Buy
        5:  864:		updateCoins(currentPlayer, state, 5);
        -:  865://		x = 1;//Condition to loop on
        -:  866://		while (x == 1) {//Buy one card
        5:  867:			if (supplyCount(choice1, state) <= 0){
        -:  868:				if (DEBUG)
        -:  869:					printf("None of that card left, sorry!\n");
        -:  870:
        -:  871:				if (DEBUG){
        -:  872:					printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  873:				}
        -:  874:			}
        5:  875:			else if (state->coins < getCost(choice1)){
        1:  876:				printf("That card is too expensive!\n");
        -:  877:
        -:  878:				if (DEBUG){
        -:  879:					printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  880:				}
        -:  881:			}
        -:  882:			else{
        -:  883:
        -:  884:				if (DEBUG){
        -:  885:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  886:				}
        -:  887:
        4:  888:				gainCard(choice1, state, 0, currentPlayer);//Gain the card
        -:  889://				x = 0;//No more buying cards
        -:  890:
        -:  891:				if (DEBUG){
        -:  892:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  893:				}
        -:  894:
        -:  895:			}
        -:  896://		}
        -:  897:
        -:  898:		//Reset Hand
       35:  899:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
       30:  900:			state->hand[currentPlayer][i] = temphand[i];
       30:  901:			temphand[i] = -1;
        -:  902:		}
        -:  903:		//Reset Hand
        -:  904:
        5:  905:		return 0;
        -:  906:
        -:  907:	case gardens:
       30:  908:		return -1;
        -:  909:
        -:  910:	case mine:
       10:  911:		j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  912:
       10:  913:		if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  914:		{
        9:  915:			return -1;
        -:  916:		}
        -:  917:
        1:  918:		if (choice2 > treasure_map || choice2 < curse)
        -:  919:		{
    #####:  920:			return -1;
        -:  921:		}
        -:  922:
        1:  923:		if ((getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2))
        -:  924:		{
    #####:  925:			return -1;
        -:  926:		}
        -:  927:
        1:  928:		gainCard(choice2, state, 2, currentPlayer);
        -:  929:
        -:  930:		//discard card from hand
        1:  931:		discardCard(handPos, currentPlayer, state, 0);
        -:  932:
        -:  933:		//discard trashed card
        5:  934:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  935:		{
        4:  936:			if (state->hand[currentPlayer][i] == j)
        -:  937:			{
    #####:  938:				discardCard(i, currentPlayer, state, 0);
    #####:  939:				break;
        -:  940:			}
        -:  941:		}
        -:  942:
        1:  943:		return 0;
        -:  944:
        -:  945:	case remodel:
        -:  946:
    #####:  947:		return playRemodel(state, currentPlayer, choice1, choice2, handPos);
        -:  948:
        -:  949:	case smithy:
        -:  950:
    #####:  951:		playSmithy(state, currentPlayer, handPos);
    #####:  952:		return 0;
        -:  953:
        -:  954:	case village:
        -:  955:		//+1 Card
        4:  956:		drawCard(currentPlayer, state);
        -:  957:
        -:  958:		//+2 Actions
        4:  959:		state->numActions = state->numActions + 2;
        -:  960:
        -:  961:		//discard played card from hand
        4:  962:		discardCard(handPos, currentPlayer, state, 0);
        4:  963:		return 0;
        -:  964:
        -:  965:	case baron:
        -:  966:
       17:  967:		playBaron(state, currentPlayer, choice1, handPos);
       17:  968:		return 0;
        -:  969:
        -:  970:	case great_hall:
        -:  971:		//+1 Card
    #####:  972:		drawCard(currentPlayer, state);
        -:  973:
        -:  974:		//+1 Actions
    #####:  975:		state->numActions++;
        -:  976:
        -:  977:		//discard card from hand
    #####:  978:		discardCard(handPos, currentPlayer, state, 0);
    #####:  979:		return 0;
        -:  980:
        -:  981:	case minion:
        -:  982:		//+1 action
        4:  983:		state->numActions++;
        -:  984:
        -:  985:		//discard card from hand
        4:  986:		discardCard(handPos, currentPlayer, state, 0);
        -:  987:
        4:  988:		if (choice1)		//+2 coins
        -:  989:		{
        4:  990:			state->coins = state->coins + 2;
        -:  991:		}
        -:  992:
    #####:  993:		else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  994:		{
        -:  995:			//discard hand
    #####:  996:			while (numHandCards(state) > 0)
        -:  997:			{
    #####:  998:				discardCard(handPos, currentPlayer, state, 0);
        -:  999:			}
        -: 1000:
        -: 1001:			//draw 4
    #####: 1002:			for (i = 0; i < 4; i++)
        -: 1003:			{
    #####: 1004:				drawCard(currentPlayer, state);
        -: 1005:			}
        -: 1006:
        -: 1007:			//other players discard hand and redraw if hand size > 4
    #####: 1008:			for (i = 0; i < state->numPlayers; i++)
        -: 1009:			{
    #####: 1010:				if (i != currentPlayer)
        -: 1011:				{
    #####: 1012:					if (state->handCount[i] > 4)
        -: 1013:					{
        -: 1014:						//discard hand
    #####: 1015:						while (state->handCount[i] > 0)
        -: 1016:						{
    #####: 1017:							discardCard(handPos, i, state, 0);
        -: 1018:						}
        -: 1019:
        -: 1020:						//draw 4
    #####: 1021:						for (j = 0; j < 4; j++)
        -: 1022:						{
    #####: 1023:							drawCard(i, state);
        -: 1024:						}
        -: 1025:					}
        -: 1026:				}
        -: 1027:			}
        -: 1028:
        -: 1029:		}
        4: 1030:		return 0;
        -: 1031:
        -: 1032:	case steward:
       11: 1033:		if (choice1 == 1)
        -: 1034:		{
        -: 1035:			//+2 cards
    #####: 1036:			drawCard(currentPlayer, state);
    #####: 1037:			drawCard(currentPlayer, state);
        -: 1038:		}
       11: 1039:		else if (choice1 == 2)
        -: 1040:		{
        -: 1041:			//+2 coins
        1: 1042:			state->coins = state->coins + 2;
        -: 1043:		}
        -: 1044:		else
        -: 1045:		{
        -: 1046:			//trash 2 cards in hand
       10: 1047:			discardCard(choice2, currentPlayer, state, 1);
       10: 1048:			discardCard(choice3, currentPlayer, state, 1);
        -: 1049:		}
        -: 1050:
        -: 1051:		//discard card from hand
       11: 1052:		discardCard(handPos, currentPlayer, state, 0);
       11: 1053:		return 0;
        -: 1054:
        -: 1055:	case tribute:
        7: 1056:		if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####: 1057:			if (state->deckCount[nextPlayer] > 0){
    #####: 1058:				tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1059:				state->deckCount[nextPlayer]--;
        -: 1060:			}
    #####: 1061:			else if (state->discardCount[nextPlayer] > 0){
    #####: 1062:				tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer] - 1];
    #####: 1063:				state->discardCount[nextPlayer]--;
        -: 1064:			}
        -: 1065:			else{
        -: 1066:				//No Card to Reveal
        -: 1067:				if (DEBUG){
        -: 1068:					printf("No cards to reveal\n");
        -: 1069:				}
        -: 1070:			}
        -: 1071:		}
        -: 1072:
        -: 1073:		else{
        7: 1074:			if (state->deckCount[nextPlayer] == 0){
    #####: 1075:				for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####: 1076:					state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1077:					state->deckCount[nextPlayer]++;
    #####: 1078:					state->discard[nextPlayer][i] = -1;
    #####: 1079:					state->discardCount[nextPlayer]--;
        -: 1080:				}
        -: 1081:
    #####: 1082:				shuffle(nextPlayer, state);//Shuffle the deck
        -: 1083:			}
        7: 1084:			tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
        7: 1085:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
        7: 1086:			state->deckCount[nextPlayer]--;
        7: 1087:			tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
        7: 1088:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
        7: 1089:			state->deckCount[nextPlayer]--;
        -: 1090:		}
        -: 1091:
        7: 1092:		if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
        1: 1093:			state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
        1: 1094:			state->playedCardCount++;
        1: 1095:			tributeRevealedCards[1] = -1;
        -: 1096:		}
        -: 1097:
       28: 1098:		for (i = 0; i <= 2; i++){
       21: 1099:			if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
       11: 1100:				state->coins += 2;
        -: 1101:			}
        -: 1102:
       10: 1103:			else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
        3: 1104:				drawCard(currentPlayer, state);
        3: 1105:				drawCard(currentPlayer, state);
        -: 1106:			}
        -: 1107:			else{//Action Card
        7: 1108:				state->numActions = state->numActions + 2;
        -: 1109:			}
        -: 1110:		}
        -: 1111:
        7: 1112:		return 0;
        -: 1113:
        -: 1114:	case ambassador:
       29: 1115:		j = 0;		//used to check if player has enough cards to discard
        -: 1116:
       29: 1117:		if (choice2 > 2 || choice2 < 0)
        -: 1118:		{
       27: 1119:			return -1;
        -: 1120:		}
        -: 1121:
        2: 1122:		if (choice1 == handPos)
        -: 1123:		{
    #####: 1124:			return -1;
        -: 1125:		}
        -: 1126:
       12: 1127:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1128:		{
       10: 1129:			if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1130:			{
        1: 1131:				j++;
        -: 1132:			}
        -: 1133:		}
        2: 1134:		if (j < choice2)
        -: 1135:		{
        2: 1136:			return -1;
        -: 1137:		}
        -: 1138:
        -: 1139:		if (DEBUG)
        -: 1140:			printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1141:
        -: 1142:		//increase supply count for choosen card by amount being discarded
    #####: 1143:		state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1144:
        -: 1145:		//each other player gains a copy of revealed card
    #####: 1146:		for (i = 0; i < state->numPlayers; i++)
        -: 1147:		{
    #####: 1148:			if (i != currentPlayer)
        -: 1149:			{
    #####: 1150:				gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1151:			}
        -: 1152:		}
        -: 1153:
        -: 1154:		//discard played card from hand
    #####: 1155:		discardCard(handPos, currentPlayer, state, 0);
        -: 1156:
        -: 1157:		//trash copies of cards returned to supply
    #####: 1158:		for (j = 0; j < choice2; j++)
        -: 1159:		{
    #####: 1160:			for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1161:			{
    #####: 1162:				if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1163:				{
    #####: 1164:					discardCard(i, currentPlayer, state, 1);
    #####: 1165:					break;
        -: 1166:				}
        -: 1167:			}
        -: 1168:		}
        -: 1169:
    #####: 1170:		return 0;
        -: 1171:
        -: 1172:	case cutpurse:
        -: 1173:
        4: 1174:		updateCoins(currentPlayer, state, 2);
       20: 1175:		for (i = 0; i < state->numPlayers; i++)
        -: 1176:		{
       16: 1177:			if (i != currentPlayer)
        -: 1178:			{
       12: 1179:				for (j = 0; j < state->handCount[i]; j++)
        -: 1180:				{
    #####: 1181:					if (state->hand[i][j] == copper)
        -: 1182:					{
    #####: 1183:						discardCard(j, i, state, 0);
    #####: 1184:						break;
        -: 1185:					}
    #####: 1186:					if (j == state->handCount[i])
        -: 1187:					{
    #####: 1188:						for (k = 0; k < state->handCount[i]; k++)
        -: 1189:						{
        -: 1190:							if (DEBUG)
        -: 1191:								printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1192:						}
    #####: 1193:						break;
        -: 1194:					}
        -: 1195:				}
        -: 1196:
        -: 1197:			}
        -: 1198:
        -: 1199:		}
        -: 1200:
        -: 1201:		//discard played card from hand
        4: 1202:		discardCard(handPos, currentPlayer, state, 0);
        -: 1203:
        4: 1204:		return 0;
        -: 1205:
        -: 1206:
        -: 1207:	case embargo:
        -: 1208:		//+2 Coins
        4: 1209:		state->coins = state->coins + 2;
        -: 1210:
        -: 1211:		//see if selected pile is in play
        4: 1212:		if (state->supplyCount[choice1] == -1)
        -: 1213:		{
    #####: 1214:			return -1;
        -: 1215:		}
        -: 1216:
        -: 1217:		//add embargo token to selected supply pile
        4: 1218:		state->embargoTokens[choice1]++;
        -: 1219:
        -: 1220:		//trash card
        4: 1221:		discardCard(handPos, currentPlayer, state, 1);
        4: 1222:		return 0;
        -: 1223:
        -: 1224:	case outpost:
        -: 1225:		//set outpost flag
        2: 1226:		state->outpostPlayed++;
        -: 1227:
        -: 1228:		//discard card
        2: 1229:		discardCard(handPos, currentPlayer, state, 0);
        2: 1230:		return 0;
        -: 1231:
        -: 1232:	case salvager:
        -: 1233:		//+1 buy
    #####: 1234:		state->numBuys++;
        -: 1235:
    #####: 1236:		if (choice1)
        -: 1237:		{
        -: 1238:			//gain coins equal to trashed card
    #####: 1239:			state->coins = state->coins + getCost(handCard(choice1, state));
        -: 1240:			//trash card
    #####: 1241:			discardCard(choice1, currentPlayer, state, 1);
        -: 1242:		}
        -: 1243:
        -: 1244:		//discard card
    #####: 1245:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1246:		return 0;
        -: 1247:
        -: 1248:	case sea_hag:
       40: 1249:		for (i = 0; i < state->numPlayers; i++){
       32: 1250:			if (i != currentPlayer){
       24: 1251:				state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
       24: 1252:				state->discardCount[i]++;
       24: 1253:				state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1254:			}
        -: 1255:		}
        8: 1256:		return 0;
        -: 1257:
        -: 1258:	case treasure_map:
        -: 1259:
       10: 1260:		return playTreasureMap(state, currentPlayer, handPos);
        -: 1261:	}
    #####: 1262:	return -1;
        -: 1263:}
        -: 1264:
       77: 1265:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1266:{
        -: 1267:
        -: 1268:	//if card is not trashed, added to Played pile 
       77: 1269:	if (trashFlag < 1)
        -: 1270:	{
        -: 1271:		//add card to played pile
       33: 1272:		state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
       33: 1273:		state->playedCardCount++;
        -: 1274:	}
        -: 1275:
        -: 1276:	//set played card to -1
       77: 1277:	state->hand[currentPlayer][handPos] = -1;
        -: 1278:
        -: 1279:	//remove card from player's hand
       77: 1280:	if (handPos == (state->handCount[currentPlayer] - 1)) 	//last card in hand array is played
        -: 1281:	{
        -: 1282:		//reduce number of cards in hand
        3: 1283:		state->handCount[currentPlayer]--;
        -: 1284:	}
       74: 1285:	else if (state->handCount[currentPlayer] == 1) //only one card in hand
        -: 1286:	{
        -: 1287:		//reduce number of cards in hand
    #####: 1288:		state->handCount[currentPlayer]--;
        -: 1289:	}
        -: 1290:	else
        -: 1291:	{
        -: 1292:		//replace discarded card with last card in hand
       74: 1293:		state->hand[currentPlayer][handPos] = state->hand[currentPlayer][(state->handCount[currentPlayer] - 1)];
        -: 1294:		//set last card to -1
       74: 1295:		state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1296:		//reduce number of cards in hand
       74: 1297:		state->handCount[currentPlayer]--;
        -: 1298:	}
        -: 1299:
       77: 1300:	return 0;
        -: 1301:}
        -: 1302:
      309: 1303:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1304:{
        -: 1305:	//Note: supplyPos is enum of choosen card
        -: 1306:
        -: 1307:	//check if supply pile is empty (0) or card is not used in game (-1)
      309: 1308:	if (supplyCount(supplyPos, state) < 1)
        -: 1309:	{
        8: 1310:		return -1;
        -: 1311:	}
        -: 1312:
        -: 1313:	//added card for [whoseTurn] current player:
        -: 1314:	// toFlag = 0 : add to discard
        -: 1315:	// toFlag = 1 : add to deck
        -: 1316:	// toFlag = 2 : add to hand
        -: 1317:
      301: 1318:	if (toFlag == 1)
        -: 1319:	{
       35: 1320:		state->deck[player][state->deckCount[player]] = supplyPos;
       35: 1321:		state->deckCount[player]++;
        -: 1322:	}
      266: 1323:	else if (toFlag == 2)
        -: 1324:	{
    #####: 1325:		state->hand[player][state->handCount[player]] = supplyPos;
    #####: 1326:		state->handCount[player]++;
        -: 1327:	}
        -: 1328:	else
        -: 1329:	{
      266: 1330:		state->discard[player][state->discardCount[player]] = supplyPos;
      266: 1331:		state->discardCount[player]++;
        -: 1332:	}
        -: 1333:
        -: 1334:	//decrease number in supply pile
      301: 1335:	state->supplyCount[supplyPos]--;
        -: 1336:
      301: 1337:	return 0;
        -: 1338:}
        -: 1339:
      426: 1340:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1341:{
        -: 1342:	int i;
        -: 1343:
        -: 1344:	//reset coin count
      426: 1345:	state->coins = 0;
        -: 1346:
        -: 1347:	//add coins for each Treasure card in player's hand
     2507: 1348:	for (i = 0; i < state->handCount[player]; i++)
        -: 1349:	{
     2081: 1350:		if (state->hand[player][i] == copper)
        -: 1351:		{
      788: 1352:			state->coins += 1;
        -: 1353:		}
     1293: 1354:		else if (state->hand[player][i] == silver)
        -: 1355:		{
      192: 1356:			state->coins += 2;
        -: 1357:		}
     1101: 1358:		else if (state->hand[player][i] == gold)
        -: 1359:		{
      162: 1360:			state->coins += 3;
        -: 1361:		}
        -: 1362:	}
        -: 1363:
        -: 1364:	//add bonus
      426: 1365:	state->coins += bonus;
        -: 1366:
      426: 1367:	return 0;
        -: 1368:}
        -: 1369:
        -: 1370:
        -: 1371://end of dominion.c
File 'dominion.c'
Lines executed:60.14% of 557
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
     3227:    8:int compare(const void* a, const void* b) {
     3227:    9:	if (*(int*)a > *(int*)b)
     1202:   10:		return 1;
     2025:   11:	if (*(int*)a < *(int*)b)
      995:   12:		return -1;
     1030:   13:	return 0;
        -:   14:}
        -:   15:
        4:   16:struct gameState* newGame() {
        4:   17:	struct gameState* g = malloc(sizeof(struct gameState));
        4:   18:	return g;
        -:   19:}
        -:   20:
       45:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:	int k8, int k9, int k10) {
       45:   23:	int* k = malloc(10 * sizeof(int));
       45:   24:	k[0] = k1;
       45:   25:	k[1] = k2;
       45:   26:	k[2] = k3;
       45:   27:	k[3] = k4;
       45:   28:	k[4] = k5;
       45:   29:	k[5] = k6;
       45:   30:	k[6] = k7;
       45:   31:	k[7] = k8;
       45:   32:	k[8] = k9;
       45:   33:	k[9] = k10;
       45:   34:	return k;
        -:   35:}
        -:   36:
       45:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		struct gameState *state) {
        -:   39:
        -:   40:	int i;
        -:   41:	int j;
        -:   42:	int it;
        -:   43:	//set up random number generator
       45:   44:	SelectStream(1);
       45:   45:	PutSeed((long)randomSeed);
        -:   46:
        -:   47:	//check number of players
       45:   48:	if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:	{
    #####:   50:		return -1;
        -:   51:	}
        -:   52:
        -:   53:	//set number of players
       45:   54:	state->numPlayers = numPlayers;
        -:   55:
        -:   56:	//check selected kingdom cards are different
      131:   57:	for (i = 0; i < 10; i++)
        -:   58:	{
     1214:   59:		for (j = 0; j < 10; j++)
        -:   60:		{
     1128:   61:			if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:			{
       43:   63:				return -1;
        -:   64:			}
        -:   65:		}
        -:   66:	}
        -:   67:
        -:   68:
        -:   69:	//initialize supply
        -:   70:	///////////////////////////////
        -:   71:
        -:   72:	//set number of Curse cards
        2:   73:	if (numPlayers == 2)
        -:   74:	{
    #####:   75:		state->supplyCount[curse] = 10;
        -:   76:	}
        2:   77:	else if (numPlayers == 3)
        -:   78:	{
        1:   79:		state->supplyCount[curse] = 20;
        -:   80:	}
        -:   81:	else
        -:   82:	{
        1:   83:		state->supplyCount[curse] = 30;
        -:   84:	}
        -:   85:
        -:   86:	//set number of Victory cards
        2:   87:	if (numPlayers == 2)
        -:   88:	{
    #####:   89:		state->supplyCount[estate] = 8;
    #####:   90:		state->supplyCount[duchy] = 8;
    #####:   91:		state->supplyCount[province] = 8;
        -:   92:	}
        -:   93:	else
        -:   94:	{
        2:   95:		state->supplyCount[estate] = 12;
        2:   96:		state->supplyCount[duchy] = 12;
        2:   97:		state->supplyCount[province] = 12;
        -:   98:	}
        -:   99:
        -:  100:	//set number of Treasure cards
        2:  101:	state->supplyCount[copper] = 60 - (7 * numPlayers);
        2:  102:	state->supplyCount[silver] = 40;
        2:  103:	state->supplyCount[gold] = 30;
        -:  104:
        -:  105:	//set number of Kingdom cards
       42:  106:	for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:	{
      330:  108:		for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:		{
      310:  110:			if (kingdomCards[j] == i)
        -:  111:			{
        -:  112:				//check if card is a 'Victory' Kingdom card
       20:  113:				if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:				{
        6:  115:					if (numPlayers == 2){
    #####:  116:						state->supplyCount[i] = 8;
        -:  117:					}
        3:  118:					else{ state->supplyCount[i] = 12; }
        -:  119:				}
        -:  120:				else
        -:  121:				{
       17:  122:					state->supplyCount[i] = 10;
        -:  123:				}
       20:  124:				break;
        -:  125:			}
        -:  126:			else    //card is not in the set choosen for the game
        -:  127:			{
      290:  128:				state->supplyCount[i] = -1;
        -:  129:			}
        -:  130:		}
        -:  131:
        -:  132:	}
        -:  133:
        -:  134:	////////////////////////
        -:  135:	//supply intilization complete
        -:  136:
        -:  137:	//set player decks
        9:  138:	for (i = 0; i < numPlayers; i++)
        -:  139:	{
        7:  140:		state->deckCount[i] = 0;
       28:  141:		for (j = 0; j < 3; j++)
        -:  142:		{
       21:  143:			state->deck[i][j] = estate;
       21:  144:			state->deckCount[i]++;
        -:  145:		}
       56:  146:		for (j = 3; j < 10; j++)
        -:  147:		{
       49:  148:			state->deck[i][j] = copper;
       49:  149:			state->deckCount[i]++;
        -:  150:		}
        -:  151:	}
        -:  152:
        -:  153:	//shuffle player decks
        9:  154:	for (i = 0; i < numPlayers; i++)
        -:  155:	{
        7:  156:		if (shuffle(i, state) < 0)
        -:  157:		{
    #####:  158:			return -1;
        -:  159:		}
        -:  160:	}
        -:  161:
        -:  162:	//draw player hands
        9:  163:	for (i = 0; i < numPlayers; i++)
        -:  164:	{
        -:  165:		//initialize hand size to zero
        7:  166:		state->handCount[i] = 0;
        7:  167:		state->discardCount[i] = 0;
        -:  168:		//draw 5 cards
        -:  169:		// for (j = 0; j < 5; j++)
        -:  170:		//	{
        -:  171:		//	  drawCard(i, state);
        -:  172:		//	}
        -:  173:	}
        -:  174:
        -:  175:	//set embargo tokens to 0 for all supply piles
       56:  176:	for (i = 0; i <= treasure_map; i++)
        -:  177:	{
       54:  178:		state->embargoTokens[i] = 0;
        -:  179:	}
        -:  180:
        -:  181:	//initialize first player's turn
        2:  182:	state->outpostPlayed = 0;
        2:  183:	state->phase = 0;
        2:  184:	state->numActions = 1;
        2:  185:	state->numBuys = 1;
        2:  186:	state->playedCardCount = 0;
        2:  187:	state->whoseTurn = 0;
        2:  188:	state->handCount[state->whoseTurn] = 0;
        -:  189:	//int it; move to top
        -:  190:
        -:  191:	//Moved draw cards to here, only drawing at the start of a turn
       12:  192:	for (it = 0; it < 5; it++){
       10:  193:		drawCard(state->whoseTurn, state);
        -:  194:	}
        -:  195:
        2:  196:	updateCoins(state->whoseTurn, state, 0);
        -:  197:
        2:  198:	return 0;
        -:  199:}
        -:  200:
       86:  201:int shuffle(int player, struct gameState *state) {
        -:  202:
        -:  203:
        -:  204:	int newDeck[MAX_DECK];
       86:  205:	int newDeckPos = 0;
        -:  206:	int card;
        -:  207:	int i;
        -:  208:
       86:  209:	if (state->deckCount[player] < 1)
    #####:  210:		return -1;
       86:  211:	qsort((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
        -:  212:	/* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
     1564:  214:	while (state->deckCount[player] > 0) {
     1392:  215:		card = floor(Random() * state->deckCount[player]);
     1392:  216:		newDeck[newDeckPos] = state->deck[player][card];
     1392:  217:		newDeckPos++;
     7249:  218:		for (i = card; i < state->deckCount[player] - 1; i++) {
     5857:  219:			state->deck[player][i] = state->deck[player][i + 1];
        -:  220:		}
     1392:  221:		state->deckCount[player]--;
        -:  222:	}
     1478:  223:	for (i = 0; i < newDeckPos; i++) {
     1392:  224:		state->deck[player][i] = newDeck[i];
     1392:  225:		state->deckCount[player]++;
        -:  226:	}
        -:  227:
       86:  228:	return 0;
        -:  229:}
        -:  230:
     1024:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state)
        -:  232:{
        -:  233:	int card;
     1024:  234:	int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:	//check if it is the right phase
     1024:  237:	if (state->phase != 0)
        -:  238:	{
      189:  239:		return -1;
        -:  240:	}
        -:  241:
        -:  242:	//check if player has enough actions
      835:  243:	if (state->numActions < 1)
        -:  244:	{
       58:  245:		return -1;
        -:  246:	}
        -:  247:
        -:  248:	//get card played
      777:  249:	card = handCard(handPos, state);
        -:  250:
        -:  251:	//check if selected card is an action
      777:  252:	if (card < adventurer || card > treasure_map)
        -:  253:	{
      682:  254:		return -1;
        -:  255:	}
        -:  256:
        -:  257:	//play card
       95:  258:	if (cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0)
        -:  259:	{
       28:  260:		return -1;
        -:  261:	}
        -:  262:
        -:  263:	//reduce number of actions
       67:  264:	state->numActions--;
        -:  265:
        -:  266:	//update coins (Treasure cards may be added with card draws)
       67:  267:	updateCoins(state->whoseTurn, state, coin_bonus);
        -:  268:
       67:  269:	return 0;
        -:  270:}
        -:  271:
     1014:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:	int who;
        -:  274:	if (DEBUG){
        -:  275:		printf("Entering buyCard...\n");
        -:  276:	}
        -:  277:
        -:  278:	// I don't know what to do about the phase thing.
        -:  279:
     1014:  280:	who = state->whoseTurn;
        -:  281:
     1014:  282:	if (state->numBuys < 1){
        -:  283:		if (DEBUG)
        -:  284:			printf("You do not have any buys left\n");
      186:  285:		return -1;
        -:  286:	}
      828:  287:	else if (supplyCount(supplyPos, state) < 1){
        -:  288:		if (DEBUG)
        -:  289:			printf("There are not any of that type of card left\n");
      318:  290:		return -1;
        -:  291:	}
      510:  292:	else if (state->coins < getCost(supplyPos)){
        -:  293:		if (DEBUG)
        -:  294:			printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
      312:  295:		return -1;
        -:  296:	}
        -:  297:	else {
      198:  298:		state->phase = 1;
        -:  299:		//state->supplyCount[supplyPos]--;
      198:  300:		gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  301:
      198:  302:		state->coins = (state->coins) - (getCost(supplyPos));
      198:  303:		state->numBuys--;
        -:  304:		if (DEBUG)
        -:  305:			printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  306:	}
        -:  307:
        -:  308:	//state->discard[who][state->discardCount[who]] = supplyPos;
        -:  309:	//state->discardCount[who]++;
        -:  310:
      198:  311:	return 0;
        -:  312:}
        -:  313:
    #####:  314:int numHandCards(struct gameState *state) {
    #####:  315:	return state->handCount[whoseTurn(state)];
        -:  316:}
        -:  317:
      782:  318:int handCard(int handPos, struct gameState *state) {
      782:  319:	int currentPlayer = whoseTurn(state);
      782:  320:	return state->hand[currentPlayer][handPos];
        -:  321:}
        -:  322:
     1051:  323:int supplyCount(int card, struct gameState *state) {
     1051:  324:	return state->supplyCount[card];
        -:  325:}
        -:  326:
    #####:  327:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  328:	int i;
    #####:  329:	int count = 0;
        -:  330:
    #####:  331:	for (i = 0; i < state->deckCount[player]; i++)
        -:  332:	{
    #####:  333:		if (state->deck[player][i] == card) count++;
        -:  334:	}
        -:  335:
    #####:  336:	for (i = 0; i < state->handCount[player]; i++)
        -:  337:	{
    #####:  338:		if (state->hand[player][i] == card) count++;
        -:  339:	}
        -:  340:
    #####:  341:	for (i = 0; i < state->discardCount[player]; i++)
        -:  342:	{
    #####:  343:		if (state->discard[player][i] == card) count++;
        -:  344:	}
        -:  345:
    #####:  346:	return count;
        -:  347:}
        -:  348:
     1125:  349:int whoseTurn(struct gameState *state) {
     1125:  350:	return state->whoseTurn;
        -:  351:}
        -:  352:
      248:  353:int endTurn(struct gameState *state) {
        -:  354:	int k;
        -:  355:	int i;
      248:  356:	int currentPlayer = whoseTurn(state);
        -:  357:
        -:  358:	//Discard hand
     1431:  359:	for (i = 0; i < state->handCount[currentPlayer]; i++){
     1183:  360:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
     1183:  361:		state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  362:	}
      248:  363:	state->handCount[currentPlayer] = 0;//Reset hand count
        -:  364:
        -:  365:	//Code for determining the player
      248:  366:	if (currentPlayer < (state->numPlayers - 1)){
      179:  367:		state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  368:	}
        -:  369:	else{
       69:  370:		state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  371:	}
        -:  372:
      248:  373:	state->outpostPlayed = 0;
      248:  374:	state->phase = 0;
      248:  375:	state->numActions = 1;
      248:  376:	state->coins = 0;
      248:  377:	state->numBuys = 1;
      248:  378:	state->playedCardCount = 0;
      248:  379:	state->handCount[state->whoseTurn] = 0;
        -:  380:
        -:  381:	//int k; move to top
        -:  382:	//Next player draws hand
     1488:  383:	for (k = 0; k < 5; k++){
     1240:  384:		drawCard(state->whoseTurn, state);//Draw a card
        -:  385:	}
        -:  386:
        -:  387:	//Update money
      248:  388:	updateCoins(state->whoseTurn, state, 0);
        -:  389:
      248:  390:	return 0;
        -:  391:}
        -:  392:
     2997:  393:int isGameOver(struct gameState *state) {
        -:  394:	int i;
        -:  395:	int j;
        -:  396:
        -:  397:	//if stack of Province cards is empty, the game ends
     2997:  398:	if (state->supplyCount[province] == 0)
        -:  399:	{
    #####:  400:		return 1;
        -:  401:	}
        -:  402:
        -:  403:	//if three supply pile are at 0, the game ends
     2997:  404:	j = 0;
    77922:  405:	for (i = 0; i < 25; i++)
        -:  406:	{
    74925:  407:		if (state->supplyCount[i] == 0)
        -:  408:		{
     1394:  409:			j++;
        -:  410:		}
        -:  411:	}
     2997:  412:	if (j >= 3)
        -:  413:	{
        2:  414:		return 1;
        -:  415:	}
        -:  416:
     2995:  417:	return 0;
        -:  418:}
        -:  419:
    #####:  420:int scoreFor(int player, struct gameState *state) {
        -:  421:
        -:  422:	int i;
    #####:  423:	int score = 0;
        -:  424:	//score from hand
    #####:  425:	for (i = 0; i < state->handCount[player]; i++)
        -:  426:	{
    #####:  427:		if (state->hand[player][i] == curse) { score = score - 1; };
    #####:  428:		if (state->hand[player][i] == estate) { score = score + 1; };
    #####:  429:		if (state->hand[player][i] == duchy) { score = score + 3; };
    #####:  430:		if (state->hand[player][i] == province) { score = score + 6; };
    #####:  431:		if (state->hand[player][i] == great_hall) { score = score + 1; };
    #####:  432:		if (state->hand[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  433:	}
        -:  434:
        -:  435:	//score from discard
    #####:  436:	for (i = 0; i < state->discardCount[player]; i++)
        -:  437:	{
    #####:  438:		if (state->discard[player][i] == curse) { score = score - 1; };
    #####:  439:		if (state->discard[player][i] == estate) { score = score + 1; };
    #####:  440:		if (state->discard[player][i] == duchy) { score = score + 3; };
    #####:  441:		if (state->discard[player][i] == province) { score = score + 6; };
    #####:  442:		if (state->discard[player][i] == great_hall) { score = score + 1; };
    #####:  443:		if (state->discard[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  444:	}
        -:  445:
        -:  446:	//score from deck
    #####:  447:	for (i = 0; i < state->discardCount[player]; i++)
        -:  448:	{
    #####:  449:		if (state->deck[player][i] == curse) { score = score - 1; };
    #####:  450:		if (state->deck[player][i] == estate) { score = score + 1; };
    #####:  451:		if (state->deck[player][i] == duchy) { score = score + 3; };
    #####:  452:		if (state->deck[player][i] == province) { score = score + 6; };
    #####:  453:		if (state->deck[player][i] == great_hall) { score = score + 1; };
    #####:  454:		if (state->deck[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  455:	}
        -:  456:
    #####:  457:	return score;
        -:  458:}
        -:  459:
    #####:  460:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  461:	int i;
        -:  462:	int j;
        -:  463:	int highScore;
        -:  464:	int currentPlayer;
        -:  465:
        -:  466:	//get score for each player
    #####:  467:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  468:	{
        -:  469:		//set unused player scores to -9999
    #####:  470:		if (i >= state->numPlayers)
        -:  471:		{
    #####:  472:			players[i] = -9999;
        -:  473:		}
        -:  474:		else
        -:  475:		{
    #####:  476:			players[i] = scoreFor(i, state);
        -:  477:		}
        -:  478:	}
        -:  479:
        -:  480:	//find highest score
    #####:  481:	j = 0;
    #####:  482:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  483:	{
    #####:  484:		if (players[i] > players[j])
        -:  485:		{
    #####:  486:			j = i;
        -:  487:		}
        -:  488:	}
    #####:  489:	highScore = players[j];
        -:  490:
        -:  491:	//add 1 to players who had less turns
    #####:  492:	currentPlayer = whoseTurn(state);
    #####:  493:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  494:	{
    #####:  495:		if (players[i] == highScore && i > currentPlayer)
        -:  496:		{
    #####:  497:			players[i]++;
        -:  498:		}
        -:  499:	}
        -:  500:
        -:  501:	//find new highest score
    #####:  502:	j = 0;
    #####:  503:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  504:	{
    #####:  505:		if (players[i] > players[j])
        -:  506:		{
    #####:  507:			j = i;
        -:  508:		}
        -:  509:	}
    #####:  510:	highScore = players[j];
        -:  511:
        -:  512:	//set winners in array to 1 and rest to 0
    #####:  513:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  514:	{
    #####:  515:		if (players[i] == highScore)
        -:  516:		{
    #####:  517:			players[i] = 1;
        -:  518:		}
        -:  519:		else
        -:  520:		{
    #####:  521:			players[i] = 0;
        -:  522:		}
        -:  523:	}
        -:  524:
    #####:  525:	return 0;
        -:  526:}
        -:  527:
     1267:  528:int drawCard(int player, struct gameState *state)
        -:  529:{
        -:  530:	int count;
        -:  531:	int deckCounter;
     1267:  532:	if (state->deckCount[player] <= 0){//Deck is empty
        -:  533:
        -:  534:		//Step 1 Shuffle the discard pile back into a deck
        -:  535:		int i;
        -:  536:		//Move discard to deck
     1401:  537:		for (i = 0; i < state->discardCount[player]; i++){
     1322:  538:			state->deck[player][i] = state->discard[player][i];
     1322:  539:			state->discard[player][i] = -1;
        -:  540:		}
        -:  541:
       79:  542:		state->deckCount[player] = state->discardCount[player];
       79:  543:		state->discardCount[player] = 0;//Reset discard
        -:  544:
        -:  545:		//Shufffle the deck
       79:  546:		shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  547:
        -:  548:		if (DEBUG){//Debug statements
        -:  549:			printf("Deck count now: %d\n", state->deckCount[player]);
        -:  550:		}
        -:  551:
       79:  552:		state->discardCount[player] = 0;
        -:  553:
        -:  554:		//Step 2 Draw Card
       79:  555:		count = state->handCount[player];//Get current player's hand count
        -:  556:
        -:  557:		if (DEBUG){//Debug statements
        -:  558:			printf("Current hand count: %d\n", count);
        -:  559:		}
        -:  560:
       79:  561:		deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  562:
       79:  563:		if (deckCounter == 0)
    #####:  564:			return -1;
        -:  565:
       79:  566:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
       79:  567:		state->deckCount[player]--;
       79:  568:		state->handCount[player]++;//Increment hand count
        -:  569:	}
        -:  570:
        -:  571:	else{
     1188:  572:		int count = state->handCount[player];//Get current hand count for player
        -:  573:		int deckCounter;
        -:  574:		if (DEBUG){//Debug statements
        -:  575:			printf("Current hand count: %d\n", count);
        -:  576:		}
        -:  577:
     1188:  578:		deckCounter = state->deckCount[player];//Create holder for the deck count
     1188:  579:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
     1188:  580:		state->deckCount[player]--;
     1188:  581:		state->handCount[player]++;//Increment hand count
        -:  582:	}
        -:  583:
     1267:  584:	return 0;
        -:  585:}
        -:  586:
      716:  587:int getCost(int cardNumber)
        -:  588:{
      716:  589:	switch (cardNumber)
        -:  590:	{
        -:  591:	case curse:
       74:  592:		return 0;
        -:  593:	case estate:
       40:  594:		return 2;
        -:  595:	case duchy:
       34:  596:		return 5;
        -:  597:	case province:
       31:  598:		return 8;
        -:  599:	case copper:
       58:  600:		return 0;
        -:  601:	case silver:
       42:  602:		return 3;
        -:  603:	case gold:
       32:  604:		return 6;
        -:  605:	case adventurer:
       32:  606:		return 6;
        -:  607:	case council_room:
       19:  608:		return 5;
        -:  609:	case feast:
       25:  610:		return 4;
        -:  611:	case gardens:
       24:  612:		return 4;
        -:  613:	case mine:
    #####:  614:		return 5;
        -:  615:	case remodel:
    #####:  616:		return 4;
        -:  617:	case smithy:
       26:  618:		return 4;
        -:  619:	case village:
    #####:  620:		return 3;
        -:  621:	case baron:
       24:  622:		return 4;
        -:  623:	case great_hall:
       27:  624:		return 3;
        -:  625:	case minion:
       17:  626:		return 5;
        -:  627:	case steward:
       41:  628:		return 3;
        -:  629:	case tribute:
       18:  630:		return 5;
        -:  631:	case ambassador:
    #####:  632:		return 3;
        -:  633:	case cutpurse:
       25:  634:		return 4;
        -:  635:	case embargo:
       25:  636:		return 2;
        -:  637:	case outpost:
       16:  638:		return 5;
        -:  639:	case salvager:
       28:  640:		return 4;
        -:  641:	case sea_hag:
       29:  642:		return 4;
        -:  643:	case treasure_map:
       29:  644:		return 4;
        -:  645:	}
        -:  646:
    #####:  647:	return -1;
        -:  648:}
        -:  649:
    #####:  650:void playAdventurer(struct gameState *state, int currentPlayer)
        -:  651:// Reveal cards from deck until 2 Treasure cards are found.  Put those Treasure cards in the hand and discard the rest.
        -:  652:{
    #####:  653:	int drawntreasure = 0;
        -:  654:	int temphand[MAX_HAND];
        -:  655:	int cardDrawn;
    #####:  656:	int z = 0; // this is the counter for the temp hand
        -:  657:
    #####:  658:	while (drawntreasure < 2){
    #####:  659:		if (state->deckCount[currentPlayer] < 1){//if the deck is empty we need to shuffle discard and add to deck
    #####:  660:			shuffle(currentPlayer, state);
        -:  661:		}
    #####:  662:		drawCard(currentPlayer, state);
    #####:  663:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer] - 1];//top card of hand is most recently drawn card.
    #####:  664:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
    #####:  665:			drawntreasure++;
        -:  666:		else{
    #####:  667:			temphand[z] = cardDrawn;
    #####:  668:			state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####:  669:			z++;
        -:  670:		}
        -:  671:	}
    #####:  672:	while (z - 1 >= 0){
    #####:  673:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; // discard all cards in play that have been drawn
    #####:  674:		z = z - 1;
        -:  675:	}
    #####:  676:}
        -:  677:
    #####:  678:int playRemodel(struct gameState *state, int currentPlayer, int choice1, int choice2, int handPos)
        -:  679://Trash a card in the hand, and gain a card costing up to $2 more than the trashed card
        -:  680:{
        -:  681:	int i;
    #####:  682:	int j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  683:
    #####:  684:	if ((getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2))
        -:  685:	{
    #####:  686:		return -1;
        -:  687:	}
        -:  688:
    #####:  689:	gainCard(choice2, state, 0, currentPlayer);
        -:  690:
        -:  691:	//discard card from hand
    #####:  692:	discardCard(handPos, currentPlayer, state, 0);
        -:  693:
        -:  694:	//discard trashed card
    #####:  695:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  696:	{
    #####:  697:		if (state->hand[currentPlayer][i] == j)
        -:  698:		{
    #####:  699:			discardCard(i, currentPlayer, state, 0);
    #####:  700:			break;
        -:  701:		}
        -:  702:	}
        -:  703:
    #####:  704:	return 0;
        -:  705:}
        -:  706:
        3:  707:void playSmithy(struct gameState *state, int currentPlayer, int handPos)
        -:  708:// Draw 3 cards
        -:  709:{
        -:  710:	int i;
       12:  711:	for (i = 0; i < 3; i++)
        -:  712:	{
        9:  713:		drawCard(currentPlayer, state);
        -:  714:	}
        -:  715:
        -:  716:	//discard card from hand
        3:  717:	discardCard(handPos, currentPlayer, state, 0);
        3:  718:}
        -:  719:
        8:  720:void playBaron(struct gameState *state, int currentPlayer, int choice1, int handPos)
        -:  721://Add a buy.  OPTION:  Discard an Estate card and gain $4.  Otherwise, gain an Estate card.
        -:  722:{
        8:  723:	state->numBuys++;//Increase buys by 1!
        8:  724:	if (choice1 > 0){//Boolean true or going to discard an estate
        8:  725:		int p = 0;//Iterator for hand!
        8:  726:		int card_not_discarded = 1;//Flag for discard set!
       52:  727:		while (card_not_discarded){
       36:  728:			if (state->hand[currentPlayer][p] == estate){ //Found an estate card!
        4:  729:				state->coins += 4;//Add 4 coins to the amount of coins
        4:  730:				state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
        4:  731:				state->discardCount[currentPlayer]++;
       20:  732:				for (; p < state->handCount[currentPlayer]; p++){
       16:  733:					state->hand[currentPlayer][p] = state->hand[currentPlayer][p + 1];
        -:  734:				}
        4:  735:				state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
        4:  736:				state->handCount[currentPlayer]--;
        4:  737:				card_not_discarded = 0;//Exit the loop
        -:  738:			}
       32:  739:			else if (p > state->handCount[currentPlayer]){
        -:  740:				if (DEBUG) {
        -:  741:					printf("No estate cards in your hand, invalid choice\n");
        -:  742:					printf("Must gain an estate if there are any\n");
        -:  743:				}
        4:  744:				if (supplyCount(estate, state) > 0){
    #####:  745:					gainCard(estate, state, 1, currentPlayer);
    #####:  746:					state->supplyCount[estate]--;//Decrement estates
    #####:  747:					if (supplyCount(estate, state) == 0){
    #####:  748:						isGameOver(state);
        -:  749:					}
        -:  750:				}
        4:  751:				card_not_discarded = 0;//Exit the loop
        -:  752:			}
        -:  753:
        -:  754:			else{
       28:  755:				p++;//Next card
        -:  756:			}
        -:  757:		}
        -:  758:	}
        -:  759:
        -:  760:	else{
    #####:  761:		if (supplyCount(estate, state) > 0){
    #####:  762:			gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  763:			state->supplyCount[estate]--;//Decrement Estates
    #####:  764:			if (supplyCount(estate, state) == 0){
    #####:  765:				isGameOver(state);
        -:  766:			}
        -:  767:		}
        -:  768:	}
        8:  769:}
        -:  770:
        3:  771:int playTreasureMap(struct gameState *state, int currentPlayer, int handPos)
        -:  772://Trashing two treasure map cards from the hand = four gold on top of the deck.
        -:  773:{
        -:  774:	int i;
        -:  775:	int index;
        -:  776:
        -:  777:	//search hand for another treasure_map
       18:  778:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  779:	{
       15:  780:		if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -:  781:		{
    #####:  782:			index = i;
    #####:  783:			break;
        -:  784:		}
        -:  785:	}
        3:  786:	if (index > -1)
        -:  787:	{
        -:  788:		//trash both treasure cards
        3:  789:		discardCard(handPos, currentPlayer, state, 1);
        3:  790:		discardCard(index, currentPlayer, state, 1);
        -:  791:
        -:  792:		//gain 4 Gold cards
       15:  793:		for (i = 0; i < 4; i++)
        -:  794:		{
       12:  795:			gainCard(gold, state, 1, currentPlayer);
        -:  796:		}
        -:  797:
        -:  798:		//return success
        3:  799:		return 1;
        -:  800:	}
        -:  801:
        -:  802:	//no second treasure_map found in hand
    #####:  803:	return -1;
        -:  804:}
        -:  805:
       95:  806:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  807:{
        -:  808:	int i;
        -:  809:	int j;
        -:  810:	int k;
        -:  811:	//int x;  //Unused after while loop removed from feast.
       95:  812:	int currentPlayer = whoseTurn(state);
       95:  813:	int nextPlayer = currentPlayer + 1;
        -:  814:	int temphand[MAX_HAND];
        -:  815:
       95:  816:	int tributeRevealedCards[2] = { -1, -1 };
        -:  817:
       95:  818:	if (nextPlayer > (state->numPlayers - 1)){
       27:  819:		nextPlayer = 0;
        -:  820:	}
        -:  821:
        -:  822:	//uses switch to select card and perform actions
       95:  823:	switch (card)
        -:  824:	{
        -:  825:	case adventurer:
        -:  826:
    #####:  827:		playAdventurer(state, currentPlayer);
    #####:  828:		return 0;
        -:  829:
        -:  830:	case council_room:
        -:  831:		//+4 Cards
    #####:  832:		for (i = 0; i < 4; i++)
        -:  833:		{
    #####:  834:			drawCard(currentPlayer, state);
        -:  835:		}
        -:  836:
        -:  837:		//+1 Buy
    #####:  838:		state->numBuys++;
        -:  839:
        -:  840:		//Each other player draws a card
    #####:  841:		for (i = 0; i < state->numPlayers; i++)
        -:  842:		{
    #####:  843:			if (i != currentPlayer)
        -:  844:			{
    #####:  845:				drawCard(i, state);
        -:  846:			}
        -:  847:		}
        -:  848:
        -:  849:		//put played card in played card pile
    #####:  850:		discardCard(handPos, currentPlayer, state, 0);
        -:  851:
    #####:  852:		return 0;
        -:  853:
        -:  854:	case feast:
        -:  855:		//gain card with cost up to 5
        -:  856:		//Backup hand
       49:  857:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
       42:  858:			temphand[i] = state->hand[currentPlayer][i];//Backup card
       42:  859:			state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  860:		}
        -:  861:		//Backup hand
        -:  862:
        -:  863:		//Update Coins for Buy
        7:  864:		updateCoins(currentPlayer, state, 5);
        -:  865://		x = 1;//Condition to loop on
        -:  866://		while (x == 1) {//Buy one card
        7:  867:			if (supplyCount(choice1, state) <= 0){
        -:  868:				if (DEBUG)
        -:  869:					printf("None of that card left, sorry!\n");
        -:  870:
        -:  871:				if (DEBUG){
        -:  872:					printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  873:				}
        -:  874:			}
        3:  875:			else if (state->coins < getCost(choice1)){
        1:  876:				printf("That card is too expensive!\n");
        -:  877:
        -:  878:				if (DEBUG){
        -:  879:					printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  880:				}
        -:  881:			}
        -:  882:			else{
        -:  883:
        -:  884:				if (DEBUG){
        -:  885:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  886:				}
        -:  887:
        2:  888:				gainCard(choice1, state, 0, currentPlayer);//Gain the card
        -:  889://				x = 0;//No more buying cards
        -:  890:
        -:  891:				if (DEBUG){
        -:  892:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  893:				}
        -:  894:
        -:  895:			}
        -:  896://		}
        -:  897:
        -:  898:		//Reset Hand
       49:  899:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
       42:  900:			state->hand[currentPlayer][i] = temphand[i];
       42:  901:			temphand[i] = -1;
        -:  902:		}
        -:  903:		//Reset Hand
        -:  904:
        7:  905:		return 0;
        -:  906:
        -:  907:	case gardens:
       22:  908:		return -1;
        -:  909:
        -:  910:	case mine:
    #####:  911:		j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  912:
    #####:  913:		if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  914:		{
    #####:  915:			return -1;
        -:  916:		}
        -:  917:
    #####:  918:		if (choice2 > treasure_map || choice2 < curse)
        -:  919:		{
    #####:  920:			return -1;
        -:  921:		}
        -:  922:
    #####:  923:		if ((getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2))
        -:  924:		{
    #####:  925:			return -1;
        -:  926:		}
        -:  927:
    #####:  928:		gainCard(choice2, state, 2, currentPlayer);
        -:  929:
        -:  930:		//discard card from hand
    #####:  931:		discardCard(handPos, currentPlayer, state, 0);
        -:  932:
        -:  933:		//discard trashed card
    #####:  934:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  935:		{
    #####:  936:			if (state->hand[currentPlayer][i] == j)
        -:  937:			{
    #####:  938:				discardCard(i, currentPlayer, state, 0);
    #####:  939:				break;
        -:  940:			}
        -:  941:		}
        -:  942:
    #####:  943:		return 0;
        -:  944:
        -:  945:	case remodel:
        -:  946:
    #####:  947:		return playRemodel(state, currentPlayer, choice1, choice2, handPos);
        -:  948:
        -:  949:	case smithy:
        -:  950:
        3:  951:		playSmithy(state, currentPlayer, handPos);
        3:  952:		return 0;
        -:  953:
        -:  954:	case village:
        -:  955:		//+1 Card
    #####:  956:		drawCard(currentPlayer, state);
        -:  957:
        -:  958:		//+2 Actions
    #####:  959:		state->numActions = state->numActions + 2;
        -:  960:
        -:  961:		//discard played card from hand
    #####:  962:		discardCard(handPos, currentPlayer, state, 0);
    #####:  963:		return 0;
        -:  964:
        -:  965:	case baron:
        -:  966:
        8:  967:		playBaron(state, currentPlayer, choice1, handPos);
        8:  968:		return 0;
        -:  969:
        -:  970:	case great_hall:
        -:  971:		//+1 Card
        8:  972:		drawCard(currentPlayer, state);
        -:  973:
        -:  974:		//+1 Actions
        8:  975:		state->numActions++;
        -:  976:
        -:  977:		//discard card from hand
        8:  978:		discardCard(handPos, currentPlayer, state, 0);
        8:  979:		return 0;
        -:  980:
        -:  981:	case minion:
        -:  982:		//+1 action
        1:  983:		state->numActions++;
        -:  984:
        -:  985:		//discard card from hand
        1:  986:		discardCard(handPos, currentPlayer, state, 0);
        -:  987:
        1:  988:		if (choice1)		//+2 coins
        -:  989:		{
        1:  990:			state->coins = state->coins + 2;
        -:  991:		}
        -:  992:
    #####:  993:		else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  994:		{
        -:  995:			//discard hand
    #####:  996:			while (numHandCards(state) > 0)
        -:  997:			{
    #####:  998:				discardCard(handPos, currentPlayer, state, 0);
        -:  999:			}
        -: 1000:
        -: 1001:			//draw 4
    #####: 1002:			for (i = 0; i < 4; i++)
        -: 1003:			{
    #####: 1004:				drawCard(currentPlayer, state);
        -: 1005:			}
        -: 1006:
        -: 1007:			//other players discard hand and redraw if hand size > 4
    #####: 1008:			for (i = 0; i < state->numPlayers; i++)
        -: 1009:			{
    #####: 1010:				if (i != currentPlayer)
        -: 1011:				{
    #####: 1012:					if (state->handCount[i] > 4)
        -: 1013:					{
        -: 1014:						//discard hand
    #####: 1015:						while (state->handCount[i] > 0)
        -: 1016:						{
    #####: 1017:							discardCard(handPos, i, state, 0);
        -: 1018:						}
        -: 1019:
        -: 1020:						//draw 4
    #####: 1021:						for (j = 0; j < 4; j++)
        -: 1022:						{
    #####: 1023:							drawCard(i, state);
        -: 1024:						}
        -: 1025:					}
        -: 1026:				}
        -: 1027:			}
        -: 1028:
        -: 1029:		}
        1: 1030:		return 0;
        -: 1031:
        -: 1032:	case steward:
        9: 1033:		if (choice1 == 1)
        -: 1034:		{
        -: 1035:			//+2 cards
    #####: 1036:			drawCard(currentPlayer, state);
    #####: 1037:			drawCard(currentPlayer, state);
        -: 1038:		}
        9: 1039:		else if (choice1 == 2)
        -: 1040:		{
        -: 1041:			//+2 coins
    #####: 1042:			state->coins = state->coins + 2;
        -: 1043:		}
        -: 1044:		else
        -: 1045:		{
        -: 1046:			//trash 2 cards in hand
        9: 1047:			discardCard(choice2, currentPlayer, state, 1);
        9: 1048:			discardCard(choice3, currentPlayer, state, 1);
        -: 1049:		}
        -: 1050:
        -: 1051:		//discard card from hand
        9: 1052:		discardCard(handPos, currentPlayer, state, 0);
        9: 1053:		return 0;
        -: 1054:
        -: 1055:	case tribute:
    #####: 1056:		if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####: 1057:			if (state->deckCount[nextPlayer] > 0){
    #####: 1058:				tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1059:				state->deckCount[nextPlayer]--;
        -: 1060:			}
    #####: 1061:			else if (state->discardCount[nextPlayer] > 0){
    #####: 1062:				tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer] - 1];
    #####: 1063:				state->discardCount[nextPlayer]--;
        -: 1064:			}
        -: 1065:			else{
        -: 1066:				//No Card to Reveal
        -: 1067:				if (DEBUG){
        -: 1068:					printf("No cards to reveal\n");
        -: 1069:				}
        -: 1070:			}
        -: 1071:		}
        -: 1072:
        -: 1073:		else{
    #####: 1074:			if (state->deckCount[nextPlayer] == 0){
    #####: 1075:				for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####: 1076:					state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1077:					state->deckCount[nextPlayer]++;
    #####: 1078:					state->discard[nextPlayer][i] = -1;
    #####: 1079:					state->discardCount[nextPlayer]--;
        -: 1080:				}
        -: 1081:
    #####: 1082:				shuffle(nextPlayer, state);//Shuffle the deck
        -: 1083:			}
    #####: 1084:			tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1085:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1086:			state->deckCount[nextPlayer]--;
    #####: 1087:			tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1088:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1089:			state->deckCount[nextPlayer]--;
        -: 1090:		}
        -: 1091:
    #####: 1092:		if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
    #####: 1093:			state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1094:			state->playedCardCount++;
    #####: 1095:			tributeRevealedCards[1] = -1;
        -: 1096:		}
        -: 1097:
    #####: 1098:		for (i = 0; i <= 2; i++){
    #####: 1099:			if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
    #####: 1100:				state->coins += 2;
        -: 1101:			}
        -: 1102:
    #####: 1103:			else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
    #####: 1104:				drawCard(currentPlayer, state);
    #####: 1105:				drawCard(currentPlayer, state);
        -: 1106:			}
        -: 1107:			else{//Action Card
    #####: 1108:				state->numActions = state->numActions + 2;
        -: 1109:			}
        -: 1110:		}
        -: 1111:
    #####: 1112:		return 0;
        -: 1113:
        -: 1114:	case ambassador:
    #####: 1115:		j = 0;		//used to check if player has enough cards to discard
        -: 1116:
    #####: 1117:		if (choice2 > 2 || choice2 < 0)
        -: 1118:		{
    #####: 1119:			return -1;
        -: 1120:		}
        -: 1121:
    #####: 1122:		if (choice1 == handPos)
        -: 1123:		{
    #####: 1124:			return -1;
        -: 1125:		}
        -: 1126:
    #####: 1127:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1128:		{
    #####: 1129:			if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1130:			{
    #####: 1131:				j++;
        -: 1132:			}
        -: 1133:		}
    #####: 1134:		if (j < choice2)
        -: 1135:		{
    #####: 1136:			return -1;
        -: 1137:		}
        -: 1138:
        -: 1139:		if (DEBUG)
        -: 1140:			printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1141:
        -: 1142:		//increase supply count for choosen card by amount being discarded
    #####: 1143:		state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1144:
        -: 1145:		//each other player gains a copy of revealed card
    #####: 1146:		for (i = 0; i < state->numPlayers; i++)
        -: 1147:		{
    #####: 1148:			if (i != currentPlayer)
        -: 1149:			{
    #####: 1150:				gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1151:			}
        -: 1152:		}
        -: 1153:
        -: 1154:		//discard played card from hand
    #####: 1155:		discardCard(handPos, currentPlayer, state, 0);
        -: 1156:
        -: 1157:		//trash copies of cards returned to supply
    #####: 1158:		for (j = 0; j < choice2; j++)
        -: 1159:		{
    #####: 1160:			for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1161:			{
    #####: 1162:				if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1163:				{
    #####: 1164:					discardCard(i, currentPlayer, state, 1);
    #####: 1165:					break;
        -: 1166:				}
        -: 1167:			}
        -: 1168:		}
        -: 1169:
    #####: 1170:		return 0;
        -: 1171:
        -: 1172:	case cutpurse:
        -: 1173:
        4: 1174:		updateCoins(currentPlayer, state, 2);
       20: 1175:		for (i = 0; i < state->numPlayers; i++)
        -: 1176:		{
       16: 1177:			if (i != currentPlayer)
        -: 1178:			{
       12: 1179:				for (j = 0; j < state->handCount[i]; j++)
        -: 1180:				{
    #####: 1181:					if (state->hand[i][j] == copper)
        -: 1182:					{
    #####: 1183:						discardCard(j, i, state, 0);
    #####: 1184:						break;
        -: 1185:					}
    #####: 1186:					if (j == state->handCount[i])
        -: 1187:					{
    #####: 1188:						for (k = 0; k < state->handCount[i]; k++)
        -: 1189:						{
        -: 1190:							if (DEBUG)
        -: 1191:								printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1192:						}
    #####: 1193:						break;
        -: 1194:					}
        -: 1195:				}
        -: 1196:
        -: 1197:			}
        -: 1198:
        -: 1199:		}
        -: 1200:
        -: 1201:		//discard played card from hand
        4: 1202:		discardCard(handPos, currentPlayer, state, 0);
        -: 1203:
        4: 1204:		return 0;
        -: 1205:
        -: 1206:
        -: 1207:	case embargo:
        -: 1208:		//+2 Coins
       16: 1209:		state->coins = state->coins + 2;
        -: 1210:
        -: 1211:		//see if selected pile is in play
       16: 1212:		if (state->supplyCount[choice1] == -1)
        -: 1213:		{
        6: 1214:			return -1;
        -: 1215:		}
        -: 1216:
        -: 1217:		//add embargo token to selected supply pile
       10: 1218:		state->embargoTokens[choice1]++;
        -: 1219:
        -: 1220:		//trash card
       10: 1221:		discardCard(handPos, currentPlayer, state, 1);
       10: 1222:		return 0;
        -: 1223:
        -: 1224:	case outpost:
        -: 1225:		//set outpost flag
        1: 1226:		state->outpostPlayed++;
        -: 1227:
        -: 1228:		//discard card
        1: 1229:		discardCard(handPos, currentPlayer, state, 0);
        1: 1230:		return 0;
        -: 1231:
        -: 1232:	case salvager:
        -: 1233:		//+1 buy
        5: 1234:		state->numBuys++;
        -: 1235:
        5: 1236:		if (choice1)
        -: 1237:		{
        -: 1238:			//gain coins equal to trashed card
        5: 1239:			state->coins = state->coins + getCost(handCard(choice1, state));
        -: 1240:			//trash card
        5: 1241:			discardCard(choice1, currentPlayer, state, 1);
        -: 1242:		}
        -: 1243:
        -: 1244:		//discard card
        5: 1245:		discardCard(handPos, currentPlayer, state, 0);
        5: 1246:		return 0;
        -: 1247:
        -: 1248:	case sea_hag:
       40: 1249:		for (i = 0; i < state->numPlayers; i++){
       32: 1250:			if (i != currentPlayer){
       24: 1251:				state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
       24: 1252:				state->discardCount[i]++;
       24: 1253:				state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1254:			}
        -: 1255:		}
        8: 1256:		return 0;
        -: 1257:
        -: 1258:	case treasure_map:
        -: 1259:
        3: 1260:		return playTreasureMap(state, currentPlayer, handPos);
        -: 1261:	}
    #####: 1262:	return -1;
        -: 1263:}
        -: 1264:
       70: 1265:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1266:{
        -: 1267:
        -: 1268:	//if card is not trashed, added to Played pile 
       70: 1269:	if (trashFlag < 1)
        -: 1270:	{
        -: 1271:		//add card to played pile
       31: 1272:		state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
       31: 1273:		state->playedCardCount++;
        -: 1274:	}
        -: 1275:
        -: 1276:	//set played card to -1
       70: 1277:	state->hand[currentPlayer][handPos] = -1;
        -: 1278:
        -: 1279:	//remove card from player's hand
       70: 1280:	if (handPos == (state->handCount[currentPlayer] - 1)) 	//last card in hand array is played
        -: 1281:	{
        -: 1282:		//reduce number of cards in hand
        6: 1283:		state->handCount[currentPlayer]--;
        -: 1284:	}
       64: 1285:	else if (state->handCount[currentPlayer] == 1) //only one card in hand
        -: 1286:	{
        -: 1287:		//reduce number of cards in hand
    #####: 1288:		state->handCount[currentPlayer]--;
        -: 1289:	}
        -: 1290:	else
        -: 1291:	{
        -: 1292:		//replace discarded card with last card in hand
       64: 1293:		state->hand[currentPlayer][handPos] = state->hand[currentPlayer][(state->handCount[currentPlayer] - 1)];
        -: 1294:		//set last card to -1
       64: 1295:		state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1296:		//reduce number of cards in hand
       64: 1297:		state->handCount[currentPlayer]--;
        -: 1298:	}
        -: 1299:
       70: 1300:	return 0;
        -: 1301:}
        -: 1302:
      212: 1303:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1304:{
        -: 1305:	//Note: supplyPos is enum of choosen card
        -: 1306:
        -: 1307:	//check if supply pile is empty (0) or card is not used in game (-1)
      212: 1308:	if (supplyCount(supplyPos, state) < 1)
        -: 1309:	{
    #####: 1310:		return -1;
        -: 1311:	}
        -: 1312:
        -: 1313:	//added card for [whoseTurn] current player:
        -: 1314:	// toFlag = 0 : add to discard
        -: 1315:	// toFlag = 1 : add to deck
        -: 1316:	// toFlag = 2 : add to hand
        -: 1317:
      212: 1318:	if (toFlag == 1)
        -: 1319:	{
       12: 1320:		state->deck[player][state->deckCount[player]] = supplyPos;
       12: 1321:		state->deckCount[player]++;
        -: 1322:	}
      200: 1323:	else if (toFlag == 2)
        -: 1324:	{
    #####: 1325:		state->hand[player][state->handCount[player]] = supplyPos;
    #####: 1326:		state->handCount[player]++;
        -: 1327:	}
        -: 1328:	else
        -: 1329:	{
      200: 1330:		state->discard[player][state->discardCount[player]] = supplyPos;
      200: 1331:		state->discardCount[player]++;
        -: 1332:	}
        -: 1333:
        -: 1334:	//decrease number in supply pile
      212: 1335:	state->supplyCount[supplyPos]--;
        -: 1336:
      212: 1337:	return 0;
        -: 1338:}
        -: 1339:
      328: 1340:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1341:{
        -: 1342:	int i;
        -: 1343:
        -: 1344:	//reset coin count
      328: 1345:	state->coins = 0;
        -: 1346:
        -: 1347:	//add coins for each Treasure card in player's hand
     1911: 1348:	for (i = 0; i < state->handCount[player]; i++)
        -: 1349:	{
     1583: 1350:		if (state->hand[player][i] == copper)
        -: 1351:		{
      655: 1352:			state->coins += 1;
        -: 1353:		}
      928: 1354:		else if (state->hand[player][i] == silver)
        -: 1355:		{
       91: 1356:			state->coins += 2;
        -: 1357:		}
      837: 1358:		else if (state->hand[player][i] == gold)
        -: 1359:		{
       93: 1360:			state->coins += 3;
        -: 1361:		}
        -: 1362:	}
        -: 1363:
        -: 1364:	//add bonus
      328: 1365:	state->coins += bonus;
        -: 1366:
      328: 1367:	return 0;
        -: 1368:}
        -: 1369:
        -: 1370:
        -: 1371://end of dominion.c
File 'dominion.c'
Lines executed:65.53% of 557
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
     4063:    8:int compare(const void* a, const void* b) {
     4063:    9:	if (*(int*)a > *(int*)b)
     1389:   10:		return 1;
     2674:   11:	if (*(int*)a < *(int*)b)
     1242:   12:		return -1;
     1432:   13:	return 0;
        -:   14:}
        -:   15:
        4:   16:struct gameState* newGame() {
        4:   17:	struct gameState* g = malloc(sizeof(struct gameState));
        4:   18:	return g;
        -:   19:}
        -:   20:
       48:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:	int k8, int k9, int k10) {
       48:   23:	int* k = malloc(10 * sizeof(int));
       48:   24:	k[0] = k1;
       48:   25:	k[1] = k2;
       48:   26:	k[2] = k3;
       48:   27:	k[3] = k4;
       48:   28:	k[4] = k5;
       48:   29:	k[5] = k6;
       48:   30:	k[6] = k7;
       48:   31:	k[7] = k8;
       48:   32:	k[8] = k9;
       48:   33:	k[9] = k10;
       48:   34:	return k;
        -:   35:}
        -:   36:
       48:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		struct gameState *state) {
        -:   39:
        -:   40:	int i;
        -:   41:	int j;
        -:   42:	int it;
        -:   43:	//set up random number generator
       48:   44:	SelectStream(1);
       48:   45:	PutSeed((long)randomSeed);
        -:   46:
        -:   47:	//check number of players
       48:   48:	if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:	{
    #####:   50:		return -1;
        -:   51:	}
        -:   52:
        -:   53:	//set number of players
       48:   54:	state->numPlayers = numPlayers;
        -:   55:
        -:   56:	//check selected kingdom cards are different
      151:   57:	for (i = 0; i < 10; i++)
        -:   58:	{
     1438:   59:		for (j = 0; j < 10; j++)
        -:   60:		{
     1335:   61:			if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:			{
       46:   63:				return -1;
        -:   64:			}
        -:   65:		}
        -:   66:	}
        -:   67:
        -:   68:
        -:   69:	//initialize supply
        -:   70:	///////////////////////////////
        -:   71:
        -:   72:	//set number of Curse cards
        2:   73:	if (numPlayers == 2)
        -:   74:	{
    #####:   75:		state->supplyCount[curse] = 10;
        -:   76:	}
        2:   77:	else if (numPlayers == 3)
        -:   78:	{
    #####:   79:		state->supplyCount[curse] = 20;
        -:   80:	}
        -:   81:	else
        -:   82:	{
        2:   83:		state->supplyCount[curse] = 30;
        -:   84:	}
        -:   85:
        -:   86:	//set number of Victory cards
        2:   87:	if (numPlayers == 2)
        -:   88:	{
    #####:   89:		state->supplyCount[estate] = 8;
    #####:   90:		state->supplyCount[duchy] = 8;
    #####:   91:		state->supplyCount[province] = 8;
        -:   92:	}
        -:   93:	else
        -:   94:	{
        2:   95:		state->supplyCount[estate] = 12;
        2:   96:		state->supplyCount[duchy] = 12;
        2:   97:		state->supplyCount[province] = 12;
        -:   98:	}
        -:   99:
        -:  100:	//set number of Treasure cards
        2:  101:	state->supplyCount[copper] = 60 - (7 * numPlayers);
        2:  102:	state->supplyCount[silver] = 40;
        2:  103:	state->supplyCount[gold] = 30;
        -:  104:
        -:  105:	//set number of Kingdom cards
       42:  106:	for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:	{
      330:  108:		for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:		{
      310:  110:			if (kingdomCards[j] == i)
        -:  111:			{
        -:  112:				//check if card is a 'Victory' Kingdom card
       20:  113:				if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:				{
        4:  115:					if (numPlayers == 2){
    #####:  116:						state->supplyCount[i] = 8;
        -:  117:					}
        2:  118:					else{ state->supplyCount[i] = 12; }
        -:  119:				}
        -:  120:				else
        -:  121:				{
       18:  122:					state->supplyCount[i] = 10;
        -:  123:				}
       20:  124:				break;
        -:  125:			}
        -:  126:			else    //card is not in the set choosen for the game
        -:  127:			{
      290:  128:				state->supplyCount[i] = -1;
        -:  129:			}
        -:  130:		}
        -:  131:
        -:  132:	}
        -:  133:
        -:  134:	////////////////////////
        -:  135:	//supply intilization complete
        -:  136:
        -:  137:	//set player decks
       10:  138:	for (i = 0; i < numPlayers; i++)
        -:  139:	{
        8:  140:		state->deckCount[i] = 0;
       32:  141:		for (j = 0; j < 3; j++)
        -:  142:		{
       24:  143:			state->deck[i][j] = estate;
       24:  144:			state->deckCount[i]++;
        -:  145:		}
       64:  146:		for (j = 3; j < 10; j++)
        -:  147:		{
       56:  148:			state->deck[i][j] = copper;
       56:  149:			state->deckCount[i]++;
        -:  150:		}
        -:  151:	}
        -:  152:
        -:  153:	//shuffle player decks
       10:  154:	for (i = 0; i < numPlayers; i++)
        -:  155:	{
        8:  156:		if (shuffle(i, state) < 0)
        -:  157:		{
    #####:  158:			return -1;
        -:  159:		}
        -:  160:	}
        -:  161:
        -:  162:	//draw player hands
       10:  163:	for (i = 0; i < numPlayers; i++)
        -:  164:	{
        -:  165:		//initialize hand size to zero
        8:  166:		state->handCount[i] = 0;
        8:  167:		state->discardCount[i] = 0;
        -:  168:		//draw 5 cards
        -:  169:		// for (j = 0; j < 5; j++)
        -:  170:		//	{
        -:  171:		//	  drawCard(i, state);
        -:  172:		//	}
        -:  173:	}
        -:  174:
        -:  175:	//set embargo tokens to 0 for all supply piles
       56:  176:	for (i = 0; i <= treasure_map; i++)
        -:  177:	{
       54:  178:		state->embargoTokens[i] = 0;
        -:  179:	}
        -:  180:
        -:  181:	//initialize first player's turn
        2:  182:	state->outpostPlayed = 0;
        2:  183:	state->phase = 0;
        2:  184:	state->numActions = 1;
        2:  185:	state->numBuys = 1;
        2:  186:	state->playedCardCount = 0;
        2:  187:	state->whoseTurn = 0;
        2:  188:	state->handCount[state->whoseTurn] = 0;
        -:  189:	//int it; move to top
        -:  190:
        -:  191:	//Moved draw cards to here, only drawing at the start of a turn
       12:  192:	for (it = 0; it < 5; it++){
       10:  193:		drawCard(state->whoseTurn, state);
        -:  194:	}
        -:  195:
        2:  196:	updateCoins(state->whoseTurn, state, 0);
        -:  197:
        2:  198:	return 0;
        -:  199:}
        -:  200:
      131:  201:int shuffle(int player, struct gameState *state) {
        -:  202:
        -:  203:
        -:  204:	int newDeck[MAX_DECK];
      131:  205:	int newDeckPos = 0;
        -:  206:	int card;
        -:  207:	int i;
        -:  208:
      131:  209:	if (state->deckCount[player] < 1)
    #####:  210:		return -1;
      131:  211:	qsort((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
        -:  212:	/* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
     2173:  214:	while (state->deckCount[player] > 0) {
     1911:  215:		card = floor(Random() * state->deckCount[player]);
     1911:  216:		newDeck[newDeckPos] = state->deck[player][card];
     1911:  217:		newDeckPos++;
    10012:  218:		for (i = card; i < state->deckCount[player] - 1; i++) {
     8101:  219:			state->deck[player][i] = state->deck[player][i + 1];
        -:  220:		}
     1911:  221:		state->deckCount[player]--;
        -:  222:	}
     2042:  223:	for (i = 0; i < newDeckPos; i++) {
     1911:  224:		state->deck[player][i] = newDeck[i];
     1911:  225:		state->deckCount[player]++;
        -:  226:	}
        -:  227:
      131:  228:	return 0;
        -:  229:}
        -:  230:
     1438:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state)
        -:  232:{
        -:  233:	int card;
     1438:  234:	int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:	//check if it is the right phase
     1438:  237:	if (state->phase != 0)
        -:  238:	{
      243:  239:		return -1;
        -:  240:	}
        -:  241:
        -:  242:	//check if player has enough actions
     1195:  243:	if (state->numActions < 1)
        -:  244:	{
       51:  245:		return -1;
        -:  246:	}
        -:  247:
        -:  248:	//get card played
     1144:  249:	card = handCard(handPos, state);
        -:  250:
        -:  251:	//check if selected card is an action
     1144:  252:	if (card < adventurer || card > treasure_map)
        -:  253:	{
     1030:  254:		return -1;
        -:  255:	}
        -:  256:
        -:  257:	//play card
      114:  258:	if (cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0)
        -:  259:	{
       29:  260:		return -1;
        -:  261:	}
        -:  262:
        -:  263:	//reduce number of actions
       85:  264:	state->numActions--;
        -:  265:
        -:  266:	//update coins (Treasure cards may be added with card draws)
       85:  267:	updateCoins(state->whoseTurn, state, coin_bonus);
        -:  268:
       85:  269:	return 0;
        -:  270:}
        -:  271:
     1497:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:	int who;
        -:  274:	if (DEBUG){
        -:  275:		printf("Entering buyCard...\n");
        -:  276:	}
        -:  277:
        -:  278:	// I don't know what to do about the phase thing.
        -:  279:
     1497:  280:	who = state->whoseTurn;
        -:  281:
     1497:  282:	if (state->numBuys < 1){
        -:  283:		if (DEBUG)
        -:  284:			printf("You do not have any buys left\n");
      230:  285:		return -1;
        -:  286:	}
     1267:  287:	else if (supplyCount(supplyPos, state) < 1){
        -:  288:		if (DEBUG)
        -:  289:			printf("There are not any of that type of card left\n");
      514:  290:		return -1;
        -:  291:	}
      753:  292:	else if (state->coins < getCost(supplyPos)){
        -:  293:		if (DEBUG)
        -:  294:			printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
      496:  295:		return -1;
        -:  296:	}
        -:  297:	else {
      257:  298:		state->phase = 1;
        -:  299:		//state->supplyCount[supplyPos]--;
      257:  300:		gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  301:
      257:  302:		state->coins = (state->coins) - (getCost(supplyPos));
      257:  303:		state->numBuys--;
        -:  304:		if (DEBUG)
        -:  305:			printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  306:	}
        -:  307:
        -:  308:	//state->discard[who][state->discardCount[who]] = supplyPos;
        -:  309:	//state->discardCount[who]++;
        -:  310:
      257:  311:	return 0;
        -:  312:}
        -:  313:
    #####:  314:int numHandCards(struct gameState *state) {
    #####:  315:	return state->handCount[whoseTurn(state)];
        -:  316:}
        -:  317:
     1147:  318:int handCard(int handPos, struct gameState *state) {
     1147:  319:	int currentPlayer = whoseTurn(state);
     1147:  320:	return state->hand[currentPlayer][handPos];
        -:  321:}
        -:  322:
     1569:  323:int supplyCount(int card, struct gameState *state) {
     1569:  324:	return state->supplyCount[card];
        -:  325:}
        -:  326:
    #####:  327:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  328:	int i;
    #####:  329:	int count = 0;
        -:  330:
    #####:  331:	for (i = 0; i < state->deckCount[player]; i++)
        -:  332:	{
    #####:  333:		if (state->deck[player][i] == card) count++;
        -:  334:	}
        -:  335:
    #####:  336:	for (i = 0; i < state->handCount[player]; i++)
        -:  337:	{
    #####:  338:		if (state->hand[player][i] == card) count++;
        -:  339:	}
        -:  340:
    #####:  341:	for (i = 0; i < state->discardCount[player]; i++)
        -:  342:	{
    #####:  343:		if (state->discard[player][i] == card) count++;
        -:  344:	}
        -:  345:
    #####:  346:	return count;
        -:  347:}
        -:  348:
     1587:  349:int whoseTurn(struct gameState *state) {
     1587:  350:	return state->whoseTurn;
        -:  351:}
        -:  352:
      326:  353:int endTurn(struct gameState *state) {
        -:  354:	int k;
        -:  355:	int i;
      326:  356:	int currentPlayer = whoseTurn(state);
        -:  357:
        -:  358:	//Discard hand
     1914:  359:	for (i = 0; i < state->handCount[currentPlayer]; i++){
     1588:  360:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
     1588:  361:		state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  362:	}
      326:  363:	state->handCount[currentPlayer] = 0;//Reset hand count
        -:  364:
        -:  365:	//Code for determining the player
      326:  366:	if (currentPlayer < (state->numPlayers - 1)){
      246:  367:		state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  368:	}
        -:  369:	else{
       80:  370:		state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  371:	}
        -:  372:
      326:  373:	state->outpostPlayed = 0;
      326:  374:	state->phase = 0;
      326:  375:	state->numActions = 1;
      326:  376:	state->coins = 0;
      326:  377:	state->numBuys = 1;
      326:  378:	state->playedCardCount = 0;
      326:  379:	state->handCount[state->whoseTurn] = 0;
        -:  380:
        -:  381:	//int k; move to top
        -:  382:	//Next player draws hand
     1956:  383:	for (k = 0; k < 5; k++){
     1630:  384:		drawCard(state->whoseTurn, state);//Draw a card
        -:  385:	}
        -:  386:
        -:  387:	//Update money
      326:  388:	updateCoins(state->whoseTurn, state, 0);
        -:  389:
      326:  390:	return 0;
        -:  391:}
        -:  392:
     4423:  393:int isGameOver(struct gameState *state) {
        -:  394:	int i;
        -:  395:	int j;
        -:  396:
        -:  397:	//if stack of Province cards is empty, the game ends
     4423:  398:	if (state->supplyCount[province] == 0)
        -:  399:	{
    #####:  400:		return 1;
        -:  401:	}
        -:  402:
        -:  403:	//if three supply pile are at 0, the game ends
     4423:  404:	j = 0;
   114998:  405:	for (i = 0; i < 25; i++)
        -:  406:	{
   110575:  407:		if (state->supplyCount[i] == 0)
        -:  408:		{
     3618:  409:			j++;
        -:  410:		}
        -:  411:	}
     4423:  412:	if (j >= 3)
        -:  413:	{
        2:  414:		return 1;
        -:  415:	}
        -:  416:
     4421:  417:	return 0;
        -:  418:}
        -:  419:
    #####:  420:int scoreFor(int player, struct gameState *state) {
        -:  421:
        -:  422:	int i;
    #####:  423:	int score = 0;
        -:  424:	//score from hand
    #####:  425:	for (i = 0; i < state->handCount[player]; i++)
        -:  426:	{
    #####:  427:		if (state->hand[player][i] == curse) { score = score - 1; };
    #####:  428:		if (state->hand[player][i] == estate) { score = score + 1; };
    #####:  429:		if (state->hand[player][i] == duchy) { score = score + 3; };
    #####:  430:		if (state->hand[player][i] == province) { score = score + 6; };
    #####:  431:		if (state->hand[player][i] == great_hall) { score = score + 1; };
    #####:  432:		if (state->hand[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  433:	}
        -:  434:
        -:  435:	//score from discard
    #####:  436:	for (i = 0; i < state->discardCount[player]; i++)
        -:  437:	{
    #####:  438:		if (state->discard[player][i] == curse) { score = score - 1; };
    #####:  439:		if (state->discard[player][i] == estate) { score = score + 1; };
    #####:  440:		if (state->discard[player][i] == duchy) { score = score + 3; };
    #####:  441:		if (state->discard[player][i] == province) { score = score + 6; };
    #####:  442:		if (state->discard[player][i] == great_hall) { score = score + 1; };
    #####:  443:		if (state->discard[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  444:	}
        -:  445:
        -:  446:	//score from deck
    #####:  447:	for (i = 0; i < state->discardCount[player]; i++)
        -:  448:	{
    #####:  449:		if (state->deck[player][i] == curse) { score = score - 1; };
    #####:  450:		if (state->deck[player][i] == estate) { score = score + 1; };
    #####:  451:		if (state->deck[player][i] == duchy) { score = score + 3; };
    #####:  452:		if (state->deck[player][i] == province) { score = score + 6; };
    #####:  453:		if (state->deck[player][i] == great_hall) { score = score + 1; };
    #####:  454:		if (state->deck[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  455:	}
        -:  456:
    #####:  457:	return score;
        -:  458:}
        -:  459:
    #####:  460:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  461:	int i;
        -:  462:	int j;
        -:  463:	int highScore;
        -:  464:	int currentPlayer;
        -:  465:
        -:  466:	//get score for each player
    #####:  467:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  468:	{
        -:  469:		//set unused player scores to -9999
    #####:  470:		if (i >= state->numPlayers)
        -:  471:		{
    #####:  472:			players[i] = -9999;
        -:  473:		}
        -:  474:		else
        -:  475:		{
    #####:  476:			players[i] = scoreFor(i, state);
        -:  477:		}
        -:  478:	}
        -:  479:
        -:  480:	//find highest score
    #####:  481:	j = 0;
    #####:  482:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  483:	{
    #####:  484:		if (players[i] > players[j])
        -:  485:		{
    #####:  486:			j = i;
        -:  487:		}
        -:  488:	}
    #####:  489:	highScore = players[j];
        -:  490:
        -:  491:	//add 1 to players who had less turns
    #####:  492:	currentPlayer = whoseTurn(state);
    #####:  493:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  494:	{
    #####:  495:		if (players[i] == highScore && i > currentPlayer)
        -:  496:		{
    #####:  497:			players[i]++;
        -:  498:		}
        -:  499:	}
        -:  500:
        -:  501:	//find new highest score
    #####:  502:	j = 0;
    #####:  503:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  504:	{
    #####:  505:		if (players[i] > players[j])
        -:  506:		{
    #####:  507:			j = i;
        -:  508:		}
        -:  509:	}
    #####:  510:	highScore = players[j];
        -:  511:
        -:  512:	//set winners in array to 1 and rest to 0
    #####:  513:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  514:	{
    #####:  515:		if (players[i] == highScore)
        -:  516:		{
    #####:  517:			players[i] = 1;
        -:  518:		}
        -:  519:		else
        -:  520:		{
    #####:  521:			players[i] = 0;
        -:  522:		}
        -:  523:	}
        -:  524:
    #####:  525:	return 0;
        -:  526:}
        -:  527:
     1657:  528:int drawCard(int player, struct gameState *state)
        -:  529:{
        -:  530:	int count;
        -:  531:	int deckCounter;
     1657:  532:	if (state->deckCount[player] <= 0){//Deck is empty
        -:  533:
        -:  534:		//Step 1 Shuffle the discard pile back into a deck
        -:  535:		int i;
        -:  536:		//Move discard to deck
     1954:  537:		for (i = 0; i < state->discardCount[player]; i++){
     1831:  538:			state->deck[player][i] = state->discard[player][i];
     1831:  539:			state->discard[player][i] = -1;
        -:  540:		}
        -:  541:
      123:  542:		state->deckCount[player] = state->discardCount[player];
      123:  543:		state->discardCount[player] = 0;//Reset discard
        -:  544:
        -:  545:		//Shufffle the deck
      123:  546:		shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  547:
        -:  548:		if (DEBUG){//Debug statements
        -:  549:			printf("Deck count now: %d\n", state->deckCount[player]);
        -:  550:		}
        -:  551:
      123:  552:		state->discardCount[player] = 0;
        -:  553:
        -:  554:		//Step 2 Draw Card
      123:  555:		count = state->handCount[player];//Get current player's hand count
        -:  556:
        -:  557:		if (DEBUG){//Debug statements
        -:  558:			printf("Current hand count: %d\n", count);
        -:  559:		}
        -:  560:
      123:  561:		deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  562:
      123:  563:		if (deckCounter == 0)
    #####:  564:			return -1;
        -:  565:
      123:  566:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
      123:  567:		state->deckCount[player]--;
      123:  568:		state->handCount[player]++;//Increment hand count
        -:  569:	}
        -:  570:
        -:  571:	else{
     1534:  572:		int count = state->handCount[player];//Get current hand count for player
        -:  573:		int deckCounter;
        -:  574:		if (DEBUG){//Debug statements
        -:  575:			printf("Current hand count: %d\n", count);
        -:  576:		}
        -:  577:
     1534:  578:		deckCounter = state->deckCount[player];//Create holder for the deck count
     1534:  579:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
     1534:  580:		state->deckCount[player]--;
     1534:  581:		state->handCount[player]++;//Increment hand count
        -:  582:	}
        -:  583:
     1657:  584:	return 0;
        -:  585:}
        -:  586:
     1032:  587:int getCost(int cardNumber)
        -:  588:{
     1032:  589:	switch (cardNumber)
        -:  590:	{
        -:  591:	case curse:
      105:  592:		return 0;
        -:  593:	case estate:
       48:  594:		return 2;
        -:  595:	case duchy:
       54:  596:		return 5;
        -:  597:	case province:
       42:  598:		return 8;
        -:  599:	case copper:
      122:  600:		return 0;
        -:  601:	case silver:
       58:  602:		return 3;
        -:  603:	case gold:
       80:  604:		return 6;
        -:  605:	case adventurer:
       26:  606:		return 6;
        -:  607:	case council_room:
       41:  608:		return 5;
        -:  609:	case feast:
       35:  610:		return 4;
        -:  611:	case gardens:
       33:  612:		return 4;
        -:  613:	case mine:
       52:  614:		return 5;
        -:  615:	case remodel:
       28:  616:		return 4;
        -:  617:	case smithy:
        1:  618:		return 4;
        -:  619:	case village:
    #####:  620:		return 3;
        -:  621:	case baron:
       31:  622:		return 4;
        -:  623:	case great_hall:
       28:  624:		return 3;
        -:  625:	case minion:
       21:  626:		return 5;
        -:  627:	case steward:
    #####:  628:		return 3;
        -:  629:	case tribute:
       40:  630:		return 5;
        -:  631:	case ambassador:
    #####:  632:		return 3;
        -:  633:	case cutpurse:
       21:  634:		return 4;
        -:  635:	case embargo:
       46:  636:		return 2;
        -:  637:	case outpost:
       26:  638:		return 5;
        -:  639:	case salvager:
       29:  640:		return 4;
        -:  641:	case sea_hag:
       35:  642:		return 4;
        -:  643:	case treasure_map:
       30:  644:		return 4;
        -:  645:	}
        -:  646:
    #####:  647:	return -1;
        -:  648:}
        -:  649:
    #####:  650:void playAdventurer(struct gameState *state, int currentPlayer)
        -:  651:// Reveal cards from deck until 2 Treasure cards are found.  Put those Treasure cards in the hand and discard the rest.
        -:  652:{
    #####:  653:	int drawntreasure = 0;
        -:  654:	int temphand[MAX_HAND];
        -:  655:	int cardDrawn;
    #####:  656:	int z = 0; // this is the counter for the temp hand
        -:  657:
    #####:  658:	while (drawntreasure < 2){
    #####:  659:		if (state->deckCount[currentPlayer] < 1){//if the deck is empty we need to shuffle discard and add to deck
    #####:  660:			shuffle(currentPlayer, state);
        -:  661:		}
    #####:  662:		drawCard(currentPlayer, state);
    #####:  663:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer] - 1];//top card of hand is most recently drawn card.
    #####:  664:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
    #####:  665:			drawntreasure++;
        -:  666:		else{
    #####:  667:			temphand[z] = cardDrawn;
    #####:  668:			state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####:  669:			z++;
        -:  670:		}
        -:  671:	}
    #####:  672:	while (z - 1 >= 0){
    #####:  673:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; // discard all cards in play that have been drawn
    #####:  674:		z = z - 1;
        -:  675:	}
    #####:  676:}
        -:  677:
        6:  678:int playRemodel(struct gameState *state, int currentPlayer, int choice1, int choice2, int handPos)
        -:  679://Trash a card in the hand, and gain a card costing up to $2 more than the trashed card
        -:  680:{
        -:  681:	int i;
        6:  682:	int j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  683:
        6:  684:	if ((getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2))
        -:  685:	{
        2:  686:		return -1;
        -:  687:	}
        -:  688:
        4:  689:	gainCard(choice2, state, 0, currentPlayer);
        -:  690:
        -:  691:	//discard card from hand
        4:  692:	discardCard(handPos, currentPlayer, state, 0);
        -:  693:
        -:  694:	//discard trashed card
       12:  695:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  696:	{
       10:  697:		if (state->hand[currentPlayer][i] == j)
        -:  698:		{
        2:  699:			discardCard(i, currentPlayer, state, 0);
        2:  700:			break;
        -:  701:		}
        -:  702:	}
        -:  703:
        4:  704:	return 0;
        -:  705:}
        -:  706:
    #####:  707:void playSmithy(struct gameState *state, int currentPlayer, int handPos)
        -:  708:// Draw 3 cards
        -:  709:{
        -:  710:	int i;
    #####:  711:	for (i = 0; i < 3; i++)
        -:  712:	{
    #####:  713:		drawCard(currentPlayer, state);
        -:  714:	}
        -:  715:
        -:  716:	//discard card from hand
    #####:  717:	discardCard(handPos, currentPlayer, state, 0);
    #####:  718:}
        -:  719:
       14:  720:void playBaron(struct gameState *state, int currentPlayer, int choice1, int handPos)
        -:  721://Add a buy.  OPTION:  Discard an Estate card and gain $4.  Otherwise, gain an Estate card.
        -:  722:{
       14:  723:	state->numBuys++;//Increase buys by 1!
       14:  724:	if (choice1 > 0){//Boolean true or going to discard an estate
       14:  725:		int p = 0;//Iterator for hand!
       14:  726:		int card_not_discarded = 1;//Flag for discard set!
       86:  727:		while (card_not_discarded){
       58:  728:			if (state->hand[currentPlayer][p] == estate){ //Found an estate card!
        9:  729:				state->coins += 4;//Add 4 coins to the amount of coins
        9:  730:				state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
        9:  731:				state->discardCount[currentPlayer]++;
       40:  732:				for (; p < state->handCount[currentPlayer]; p++){
       31:  733:					state->hand[currentPlayer][p] = state->hand[currentPlayer][p + 1];
        -:  734:				}
        9:  735:				state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
        9:  736:				state->handCount[currentPlayer]--;
        9:  737:				card_not_discarded = 0;//Exit the loop
        -:  738:			}
       49:  739:			else if (p > state->handCount[currentPlayer]){
        -:  740:				if (DEBUG) {
        -:  741:					printf("No estate cards in your hand, invalid choice\n");
        -:  742:					printf("Must gain an estate if there are any\n");
        -:  743:				}
        5:  744:				if (supplyCount(estate, state) > 0){
        1:  745:					gainCard(estate, state, 1, currentPlayer);
        1:  746:					state->supplyCount[estate]--;//Decrement estates
        1:  747:					if (supplyCount(estate, state) == 0){
    #####:  748:						isGameOver(state);
        -:  749:					}
        -:  750:				}
        5:  751:				card_not_discarded = 0;//Exit the loop
        -:  752:			}
        -:  753:
        -:  754:			else{
       44:  755:				p++;//Next card
        -:  756:			}
        -:  757:		}
        -:  758:	}
        -:  759:
        -:  760:	else{
    #####:  761:		if (supplyCount(estate, state) > 0){
    #####:  762:			gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  763:			state->supplyCount[estate]--;//Decrement Estates
    #####:  764:			if (supplyCount(estate, state) == 0){
    #####:  765:				isGameOver(state);
        -:  766:			}
        -:  767:		}
        -:  768:	}
       14:  769:}
        -:  770:
        6:  771:int playTreasureMap(struct gameState *state, int currentPlayer, int handPos)
        -:  772://Trashing two treasure map cards from the hand = four gold on top of the deck.
        -:  773:{
        -:  774:	int i;
        -:  775:	int index;
        -:  776:
        -:  777:	//search hand for another treasure_map
       36:  778:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  779:	{
       30:  780:		if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -:  781:		{
    #####:  782:			index = i;
    #####:  783:			break;
        -:  784:		}
        -:  785:	}
        6:  786:	if (index > -1)
        -:  787:	{
        -:  788:		//trash both treasure cards
        6:  789:		discardCard(handPos, currentPlayer, state, 1);
        6:  790:		discardCard(index, currentPlayer, state, 1);
        -:  791:
        -:  792:		//gain 4 Gold cards
       30:  793:		for (i = 0; i < 4; i++)
        -:  794:		{
       24:  795:			gainCard(gold, state, 1, currentPlayer);
        -:  796:		}
        -:  797:
        -:  798:		//return success
        6:  799:		return 1;
        -:  800:	}
        -:  801:
        -:  802:	//no second treasure_map found in hand
    #####:  803:	return -1;
        -:  804:}
        -:  805:
      114:  806:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  807:{
        -:  808:	int i;
        -:  809:	int j;
        -:  810:	int k;
        -:  811:	//int x;  //Unused after while loop removed from feast.
      114:  812:	int currentPlayer = whoseTurn(state);
      114:  813:	int nextPlayer = currentPlayer + 1;
        -:  814:	int temphand[MAX_HAND];
        -:  815:
      114:  816:	int tributeRevealedCards[2] = { -1, -1 };
        -:  817:
      114:  818:	if (nextPlayer > (state->numPlayers - 1)){
       41:  819:		nextPlayer = 0;
        -:  820:	}
        -:  821:
        -:  822:	//uses switch to select card and perform actions
      114:  823:	switch (card)
        -:  824:	{
        -:  825:	case adventurer:
        -:  826:
    #####:  827:		playAdventurer(state, currentPlayer);
    #####:  828:		return 0;
        -:  829:
        -:  830:	case council_room:
        -:  831:		//+4 Cards
        5:  832:		for (i = 0; i < 4; i++)
        -:  833:		{
        4:  834:			drawCard(currentPlayer, state);
        -:  835:		}
        -:  836:
        -:  837:		//+1 Buy
        1:  838:		state->numBuys++;
        -:  839:
        -:  840:		//Each other player draws a card
        5:  841:		for (i = 0; i < state->numPlayers; i++)
        -:  842:		{
        4:  843:			if (i != currentPlayer)
        -:  844:			{
        3:  845:				drawCard(i, state);
        -:  846:			}
        -:  847:		}
        -:  848:
        -:  849:		//put played card in played card pile
        1:  850:		discardCard(handPos, currentPlayer, state, 0);
        -:  851:
        1:  852:		return 0;
        -:  853:
        -:  854:	case feast:
        -:  855:		//gain card with cost up to 5
        -:  856:		//Backup hand
       49:  857:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
       42:  858:			temphand[i] = state->hand[currentPlayer][i];//Backup card
       42:  859:			state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  860:		}
        -:  861:		//Backup hand
        -:  862:
        -:  863:		//Update Coins for Buy
        7:  864:		updateCoins(currentPlayer, state, 5);
        -:  865://		x = 1;//Condition to loop on
        -:  866://		while (x == 1) {//Buy one card
        7:  867:			if (supplyCount(choice1, state) <= 0){
        -:  868:				if (DEBUG)
        -:  869:					printf("None of that card left, sorry!\n");
        -:  870:
        -:  871:				if (DEBUG){
        -:  872:					printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  873:				}
        -:  874:			}
        3:  875:			else if (state->coins < getCost(choice1)){
    #####:  876:				printf("That card is too expensive!\n");
        -:  877:
        -:  878:				if (DEBUG){
        -:  879:					printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  880:				}
        -:  881:			}
        -:  882:			else{
        -:  883:
        -:  884:				if (DEBUG){
        -:  885:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  886:				}
        -:  887:
        3:  888:				gainCard(choice1, state, 0, currentPlayer);//Gain the card
        -:  889://				x = 0;//No more buying cards
        -:  890:
        -:  891:				if (DEBUG){
        -:  892:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  893:				}
        -:  894:
        -:  895:			}
        -:  896://		}
        -:  897:
        -:  898:		//Reset Hand
       49:  899:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
       42:  900:			state->hand[currentPlayer][i] = temphand[i];
       42:  901:			temphand[i] = -1;
        -:  902:		}
        -:  903:		//Reset Hand
        -:  904:
        7:  905:		return 0;
        -:  906:
        -:  907:	case gardens:
        9:  908:		return -1;
        -:  909:
        -:  910:	case mine:
        7:  911:		j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  912:
        7:  913:		if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  914:		{
        5:  915:			return -1;
        -:  916:		}
        -:  917:
        2:  918:		if (choice2 > treasure_map || choice2 < curse)
        -:  919:		{
    #####:  920:			return -1;
        -:  921:		}
        -:  922:
        2:  923:		if ((getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2))
        -:  924:		{
        2:  925:			return -1;
        -:  926:		}
        -:  927:
    #####:  928:		gainCard(choice2, state, 2, currentPlayer);
        -:  929:
        -:  930:		//discard card from hand
    #####:  931:		discardCard(handPos, currentPlayer, state, 0);
        -:  932:
        -:  933:		//discard trashed card
    #####:  934:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  935:		{
    #####:  936:			if (state->hand[currentPlayer][i] == j)
        -:  937:			{
    #####:  938:				discardCard(i, currentPlayer, state, 0);
    #####:  939:				break;
        -:  940:			}
        -:  941:		}
        -:  942:
    #####:  943:		return 0;
        -:  944:
        -:  945:	case remodel:
        -:  946:
        6:  947:		return playRemodel(state, currentPlayer, choice1, choice2, handPos);
        -:  948:
        -:  949:	case smithy:
        -:  950:
    #####:  951:		playSmithy(state, currentPlayer, handPos);
    #####:  952:		return 0;
        -:  953:
        -:  954:	case village:
        -:  955:		//+1 Card
    #####:  956:		drawCard(currentPlayer, state);
        -:  957:
        -:  958:		//+2 Actions
    #####:  959:		state->numActions = state->numActions + 2;
        -:  960:
        -:  961:		//discard played card from hand
    #####:  962:		discardCard(handPos, currentPlayer, state, 0);
    #####:  963:		return 0;
        -:  964:
        -:  965:	case baron:
        -:  966:
       14:  967:		playBaron(state, currentPlayer, choice1, handPos);
       14:  968:		return 0;
        -:  969:
        -:  970:	case great_hall:
        -:  971:		//+1 Card
        4:  972:		drawCard(currentPlayer, state);
        -:  973:
        -:  974:		//+1 Actions
        4:  975:		state->numActions++;
        -:  976:
        -:  977:		//discard card from hand
        4:  978:		discardCard(handPos, currentPlayer, state, 0);
        4:  979:		return 0;
        -:  980:
        -:  981:	case minion:
        -:  982:		//+1 action
        2:  983:		state->numActions++;
        -:  984:
        -:  985:		//discard card from hand
        2:  986:		discardCard(handPos, currentPlayer, state, 0);
        -:  987:
        2:  988:		if (choice1)		//+2 coins
        -:  989:		{
        2:  990:			state->coins = state->coins + 2;
        -:  991:		}
        -:  992:
    #####:  993:		else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  994:		{
        -:  995:			//discard hand
    #####:  996:			while (numHandCards(state) > 0)
        -:  997:			{
    #####:  998:				discardCard(handPos, currentPlayer, state, 0);
        -:  999:			}
        -: 1000:
        -: 1001:			//draw 4
    #####: 1002:			for (i = 0; i < 4; i++)
        -: 1003:			{
    #####: 1004:				drawCard(currentPlayer, state);
        -: 1005:			}
        -: 1006:
        -: 1007:			//other players discard hand and redraw if hand size > 4
    #####: 1008:			for (i = 0; i < state->numPlayers; i++)
        -: 1009:			{
    #####: 1010:				if (i != currentPlayer)
        -: 1011:				{
    #####: 1012:					if (state->handCount[i] > 4)
        -: 1013:					{
        -: 1014:						//discard hand
    #####: 1015:						while (state->handCount[i] > 0)
        -: 1016:						{
    #####: 1017:							discardCard(handPos, i, state, 0);
        -: 1018:						}
        -: 1019:
        -: 1020:						//draw 4
    #####: 1021:						for (j = 0; j < 4; j++)
        -: 1022:						{
    #####: 1023:							drawCard(i, state);
        -: 1024:						}
        -: 1025:					}
        -: 1026:				}
        -: 1027:			}
        -: 1028:
        -: 1029:		}
        2: 1030:		return 0;
        -: 1031:
        -: 1032:	case steward:
    #####: 1033:		if (choice1 == 1)
        -: 1034:		{
        -: 1035:			//+2 cards
    #####: 1036:			drawCard(currentPlayer, state);
    #####: 1037:			drawCard(currentPlayer, state);
        -: 1038:		}
    #####: 1039:		else if (choice1 == 2)
        -: 1040:		{
        -: 1041:			//+2 coins
    #####: 1042:			state->coins = state->coins + 2;
        -: 1043:		}
        -: 1044:		else
        -: 1045:		{
        -: 1046:			//trash 2 cards in hand
    #####: 1047:			discardCard(choice2, currentPlayer, state, 1);
    #####: 1048:			discardCard(choice3, currentPlayer, state, 1);
        -: 1049:		}
        -: 1050:
        -: 1051:		//discard card from hand
    #####: 1052:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1053:		return 0;
        -: 1054:
        -: 1055:	case tribute:
        9: 1056:		if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####: 1057:			if (state->deckCount[nextPlayer] > 0){
    #####: 1058:				tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1059:				state->deckCount[nextPlayer]--;
        -: 1060:			}
    #####: 1061:			else if (state->discardCount[nextPlayer] > 0){
    #####: 1062:				tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer] - 1];
    #####: 1063:				state->discardCount[nextPlayer]--;
        -: 1064:			}
        -: 1065:			else{
        -: 1066:				//No Card to Reveal
        -: 1067:				if (DEBUG){
        -: 1068:					printf("No cards to reveal\n");
        -: 1069:				}
        -: 1070:			}
        -: 1071:		}
        -: 1072:
        -: 1073:		else{
        9: 1074:			if (state->deckCount[nextPlayer] == 0){
    #####: 1075:				for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####: 1076:					state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1077:					state->deckCount[nextPlayer]++;
    #####: 1078:					state->discard[nextPlayer][i] = -1;
    #####: 1079:					state->discardCount[nextPlayer]--;
        -: 1080:				}
        -: 1081:
    #####: 1082:				shuffle(nextPlayer, state);//Shuffle the deck
        -: 1083:			}
        9: 1084:			tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
        9: 1085:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
        9: 1086:			state->deckCount[nextPlayer]--;
        9: 1087:			tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
        9: 1088:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
        9: 1089:			state->deckCount[nextPlayer]--;
        -: 1090:		}
        -: 1091:
        9: 1092:		if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
        2: 1093:			state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
        2: 1094:			state->playedCardCount++;
        2: 1095:			tributeRevealedCards[1] = -1;
        -: 1096:		}
        -: 1097:
       36: 1098:		for (i = 0; i <= 2; i++){
       27: 1099:			if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
       15: 1100:				state->coins += 2;
        -: 1101:			}
        -: 1102:
       12: 1103:			else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
        3: 1104:				drawCard(currentPlayer, state);
        3: 1105:				drawCard(currentPlayer, state);
        -: 1106:			}
        -: 1107:			else{//Action Card
        9: 1108:				state->numActions = state->numActions + 2;
        -: 1109:			}
        -: 1110:		}
        -: 1111:
        9: 1112:		return 0;
        -: 1113:
        -: 1114:	case ambassador:
    #####: 1115:		j = 0;		//used to check if player has enough cards to discard
        -: 1116:
    #####: 1117:		if (choice2 > 2 || choice2 < 0)
        -: 1118:		{
    #####: 1119:			return -1;
        -: 1120:		}
        -: 1121:
    #####: 1122:		if (choice1 == handPos)
        -: 1123:		{
    #####: 1124:			return -1;
        -: 1125:		}
        -: 1126:
    #####: 1127:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1128:		{
    #####: 1129:			if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1130:			{
    #####: 1131:				j++;
        -: 1132:			}
        -: 1133:		}
    #####: 1134:		if (j < choice2)
        -: 1135:		{
    #####: 1136:			return -1;
        -: 1137:		}
        -: 1138:
        -: 1139:		if (DEBUG)
        -: 1140:			printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1141:
        -: 1142:		//increase supply count for choosen card by amount being discarded
    #####: 1143:		state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1144:
        -: 1145:		//each other player gains a copy of revealed card
    #####: 1146:		for (i = 0; i < state->numPlayers; i++)
        -: 1147:		{
    #####: 1148:			if (i != currentPlayer)
        -: 1149:			{
    #####: 1150:				gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1151:			}
        -: 1152:		}
        -: 1153:
        -: 1154:		//discard played card from hand
    #####: 1155:		discardCard(handPos, currentPlayer, state, 0);
        -: 1156:
        -: 1157:		//trash copies of cards returned to supply
    #####: 1158:		for (j = 0; j < choice2; j++)
        -: 1159:		{
    #####: 1160:			for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1161:			{
    #####: 1162:				if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1163:				{
    #####: 1164:					discardCard(i, currentPlayer, state, 1);
    #####: 1165:					break;
        -: 1166:				}
        -: 1167:			}
        -: 1168:		}
        -: 1169:
    #####: 1170:		return 0;
        -: 1171:
        -: 1172:	case cutpurse:
        -: 1173:
    #####: 1174:		updateCoins(currentPlayer, state, 2);
    #####: 1175:		for (i = 0; i < state->numPlayers; i++)
        -: 1176:		{
    #####: 1177:			if (i != currentPlayer)
        -: 1178:			{
    #####: 1179:				for (j = 0; j < state->handCount[i]; j++)
        -: 1180:				{
    #####: 1181:					if (state->hand[i][j] == copper)
        -: 1182:					{
    #####: 1183:						discardCard(j, i, state, 0);
    #####: 1184:						break;
        -: 1185:					}
    #####: 1186:					if (j == state->handCount[i])
        -: 1187:					{
    #####: 1188:						for (k = 0; k < state->handCount[i]; k++)
        -: 1189:						{
        -: 1190:							if (DEBUG)
        -: 1191:								printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1192:						}
    #####: 1193:						break;
        -: 1194:					}
        -: 1195:				}
        -: 1196:
        -: 1197:			}
        -: 1198:
        -: 1199:		}
        -: 1200:
        -: 1201:		//discard played card from hand
    #####: 1202:		discardCard(handPos, currentPlayer, state, 0);
        -: 1203:
    #####: 1204:		return 0;
        -: 1205:
        -: 1206:
        -: 1207:	case embargo:
        -: 1208:		//+2 Coins
       24: 1209:		state->coins = state->coins + 2;
        -: 1210:
        -: 1211:		//see if selected pile is in play
       24: 1212:		if (state->supplyCount[choice1] == -1)
        -: 1213:		{
       11: 1214:			return -1;
        -: 1215:		}
        -: 1216:
        -: 1217:		//add embargo token to selected supply pile
       13: 1218:		state->embargoTokens[choice1]++;
        -: 1219:
        -: 1220:		//trash card
       13: 1221:		discardCard(handPos, currentPlayer, state, 1);
       13: 1222:		return 0;
        -: 1223:
        -: 1224:	case outpost:
        -: 1225:		//set outpost flag
        3: 1226:		state->outpostPlayed++;
        -: 1227:
        -: 1228:		//discard card
        3: 1229:		discardCard(handPos, currentPlayer, state, 0);
        3: 1230:		return 0;
        -: 1231:
        -: 1232:	case salvager:
        -: 1233:		//+1 buy
        3: 1234:		state->numBuys++;
        -: 1235:
        3: 1236:		if (choice1)
        -: 1237:		{
        -: 1238:			//gain coins equal to trashed card
        3: 1239:			state->coins = state->coins + getCost(handCard(choice1, state));
        -: 1240:			//trash card
        3: 1241:			discardCard(choice1, currentPlayer, state, 1);
        -: 1242:		}
        -: 1243:
        -: 1244:		//discard card
        3: 1245:		discardCard(handPos, currentPlayer, state, 0);
        3: 1246:		return 0;
        -: 1247:
        -: 1248:	case sea_hag:
       95: 1249:		for (i = 0; i < state->numPlayers; i++){
       76: 1250:			if (i != currentPlayer){
       57: 1251:				state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
       57: 1252:				state->discardCount[i]++;
       57: 1253:				state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1254:			}
        -: 1255:		}
       19: 1256:		return 0;
        -: 1257:
        -: 1258:	case treasure_map:
        -: 1259:
        6: 1260:		return playTreasureMap(state, currentPlayer, handPos);
        -: 1261:	}
    #####: 1262:	return -1;
        -: 1263:}
        -: 1264:
       47: 1265:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1266:{
        -: 1267:
        -: 1268:	//if card is not trashed, added to Played pile 
       47: 1269:	if (trashFlag < 1)
        -: 1270:	{
        -: 1271:		//add card to played pile
       19: 1272:		state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
       19: 1273:		state->playedCardCount++;
        -: 1274:	}
        -: 1275:
        -: 1276:	//set played card to -1
       47: 1277:	state->hand[currentPlayer][handPos] = -1;
        -: 1278:
        -: 1279:	//remove card from player's hand
       47: 1280:	if (handPos == (state->handCount[currentPlayer] - 1)) 	//last card in hand array is played
        -: 1281:	{
        -: 1282:		//reduce number of cards in hand
        7: 1283:		state->handCount[currentPlayer]--;
        -: 1284:	}
       40: 1285:	else if (state->handCount[currentPlayer] == 1) //only one card in hand
        -: 1286:	{
        -: 1287:		//reduce number of cards in hand
    #####: 1288:		state->handCount[currentPlayer]--;
        -: 1289:	}
        -: 1290:	else
        -: 1291:	{
        -: 1292:		//replace discarded card with last card in hand
       40: 1293:		state->hand[currentPlayer][handPos] = state->hand[currentPlayer][(state->handCount[currentPlayer] - 1)];
        -: 1294:		//set last card to -1
       40: 1295:		state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1296:		//reduce number of cards in hand
       40: 1297:		state->handCount[currentPlayer]--;
        -: 1298:	}
        -: 1299:
       47: 1300:	return 0;
        -: 1301:}
        -: 1302:
      289: 1303:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1304:{
        -: 1305:	//Note: supplyPos is enum of choosen card
        -: 1306:
        -: 1307:	//check if supply pile is empty (0) or card is not used in game (-1)
      289: 1308:	if (supplyCount(supplyPos, state) < 1)
        -: 1309:	{
        1: 1310:		return -1;
        -: 1311:	}
        -: 1312:
        -: 1313:	//added card for [whoseTurn] current player:
        -: 1314:	// toFlag = 0 : add to discard
        -: 1315:	// toFlag = 1 : add to deck
        -: 1316:	// toFlag = 2 : add to hand
        -: 1317:
      288: 1318:	if (toFlag == 1)
        -: 1319:	{
       25: 1320:		state->deck[player][state->deckCount[player]] = supplyPos;
       25: 1321:		state->deckCount[player]++;
        -: 1322:	}
      263: 1323:	else if (toFlag == 2)
        -: 1324:	{
    #####: 1325:		state->hand[player][state->handCount[player]] = supplyPos;
    #####: 1326:		state->handCount[player]++;
        -: 1327:	}
        -: 1328:	else
        -: 1329:	{
      263: 1330:		state->discard[player][state->discardCount[player]] = supplyPos;
      263: 1331:		state->discardCount[player]++;
        -: 1332:	}
        -: 1333:
        -: 1334:	//decrease number in supply pile
      288: 1335:	state->supplyCount[supplyPos]--;
        -: 1336:
      288: 1337:	return 0;
        -: 1338:}
        -: 1339:
      420: 1340:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1341:{
        -: 1342:	int i;
        -: 1343:
        -: 1344:	//reset coin count
      420: 1345:	state->coins = 0;
        -: 1346:
        -: 1347:	//add coins for each Treasure card in player's hand
     2478: 1348:	for (i = 0; i < state->handCount[player]; i++)
        -: 1349:	{
     2058: 1350:		if (state->hand[player][i] == copper)
        -: 1351:		{
      913: 1352:			state->coins += 1;
        -: 1353:		}
     1145: 1354:		else if (state->hand[player][i] == silver)
        -: 1355:		{
      120: 1356:			state->coins += 2;
        -: 1357:		}
     1025: 1358:		else if (state->hand[player][i] == gold)
        -: 1359:		{
      101: 1360:			state->coins += 3;
        -: 1361:		}
        -: 1362:	}
        -: 1363:
        -: 1364:	//add bonus
      420: 1365:	state->coins += bonus;
        -: 1366:
      420: 1367:	return 0;
        -: 1368:}
        -: 1369:
        -: 1370:
        -: 1371://end of dominion.c
File 'dominion.c'
Lines executed:68.04% of 557
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
     4095:    8:int compare(const void* a, const void* b) {
     4095:    9:	if (*(int*)a > *(int*)b)
     1505:   10:		return 1;
     2590:   11:	if (*(int*)a < *(int*)b)
     1206:   12:		return -1;
     1384:   13:	return 0;
        -:   14:}
        -:   15:
        4:   16:struct gameState* newGame() {
        4:   17:	struct gameState* g = malloc(sizeof(struct gameState));
        4:   18:	return g;
        -:   19:}
        -:   20:
       16:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:	int k8, int k9, int k10) {
       16:   23:	int* k = malloc(10 * sizeof(int));
       16:   24:	k[0] = k1;
       16:   25:	k[1] = k2;
       16:   26:	k[2] = k3;
       16:   27:	k[3] = k4;
       16:   28:	k[4] = k5;
       16:   29:	k[5] = k6;
       16:   30:	k[6] = k7;
       16:   31:	k[7] = k8;
       16:   32:	k[8] = k9;
       16:   33:	k[9] = k10;
       16:   34:	return k;
        -:   35:}
        -:   36:
       16:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		struct gameState *state) {
        -:   39:
        -:   40:	int i;
        -:   41:	int j;
        -:   42:	int it;
        -:   43:	//set up random number generator
       16:   44:	SelectStream(1);
       16:   45:	PutSeed((long)randomSeed);
        -:   46:
        -:   47:	//check number of players
       16:   48:	if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:	{
    #####:   50:		return -1;
        -:   51:	}
        -:   52:
        -:   53:	//set number of players
       16:   54:	state->numPlayers = numPlayers;
        -:   55:
        -:   56:	//check selected kingdom cards are different
       60:   57:	for (i = 0; i < 10; i++)
        -:   58:	{
      586:   59:		for (j = 0; j < 10; j++)
        -:   60:		{
      542:   61:			if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:			{
       14:   63:				return -1;
        -:   64:			}
        -:   65:		}
        -:   66:	}
        -:   67:
        -:   68:
        -:   69:	//initialize supply
        -:   70:	///////////////////////////////
        -:   71:
        -:   72:	//set number of Curse cards
        2:   73:	if (numPlayers == 2)
        -:   74:	{
    #####:   75:		state->supplyCount[curse] = 10;
        -:   76:	}
        2:   77:	else if (numPlayers == 3)
        -:   78:	{
    #####:   79:		state->supplyCount[curse] = 20;
        -:   80:	}
        -:   81:	else
        -:   82:	{
        2:   83:		state->supplyCount[curse] = 30;
        -:   84:	}
        -:   85:
        -:   86:	//set number of Victory cards
        2:   87:	if (numPlayers == 2)
        -:   88:	{
    #####:   89:		state->supplyCount[estate] = 8;
    #####:   90:		state->supplyCount[duchy] = 8;
    #####:   91:		state->supplyCount[province] = 8;
        -:   92:	}
        -:   93:	else
        -:   94:	{
        2:   95:		state->supplyCount[estate] = 12;
        2:   96:		state->supplyCount[duchy] = 12;
        2:   97:		state->supplyCount[province] = 12;
        -:   98:	}
        -:   99:
        -:  100:	//set number of Treasure cards
        2:  101:	state->supplyCount[copper] = 60 - (7 * numPlayers);
        2:  102:	state->supplyCount[silver] = 40;
        2:  103:	state->supplyCount[gold] = 30;
        -:  104:
        -:  105:	//set number of Kingdom cards
       42:  106:	for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:	{
      330:  108:		for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:		{
      310:  110:			if (kingdomCards[j] == i)
        -:  111:			{
        -:  112:				//check if card is a 'Victory' Kingdom card
       20:  113:				if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:				{
        2:  115:					if (numPlayers == 2){
    #####:  116:						state->supplyCount[i] = 8;
        -:  117:					}
        1:  118:					else{ state->supplyCount[i] = 12; }
        -:  119:				}
        -:  120:				else
        -:  121:				{
       19:  122:					state->supplyCount[i] = 10;
        -:  123:				}
       20:  124:				break;
        -:  125:			}
        -:  126:			else    //card is not in the set choosen for the game
        -:  127:			{
      290:  128:				state->supplyCount[i] = -1;
        -:  129:			}
        -:  130:		}
        -:  131:
        -:  132:	}
        -:  133:
        -:  134:	////////////////////////
        -:  135:	//supply intilization complete
        -:  136:
        -:  137:	//set player decks
       10:  138:	for (i = 0; i < numPlayers; i++)
        -:  139:	{
        8:  140:		state->deckCount[i] = 0;
       32:  141:		for (j = 0; j < 3; j++)
        -:  142:		{
       24:  143:			state->deck[i][j] = estate;
       24:  144:			state->deckCount[i]++;
        -:  145:		}
       64:  146:		for (j = 3; j < 10; j++)
        -:  147:		{
       56:  148:			state->deck[i][j] = copper;
       56:  149:			state->deckCount[i]++;
        -:  150:		}
        -:  151:	}
        -:  152:
        -:  153:	//shuffle player decks
       10:  154:	for (i = 0; i < numPlayers; i++)
        -:  155:	{
        8:  156:		if (shuffle(i, state) < 0)
        -:  157:		{
    #####:  158:			return -1;
        -:  159:		}
        -:  160:	}
        -:  161:
        -:  162:	//draw player hands
       10:  163:	for (i = 0; i < numPlayers; i++)
        -:  164:	{
        -:  165:		//initialize hand size to zero
        8:  166:		state->handCount[i] = 0;
        8:  167:		state->discardCount[i] = 0;
        -:  168:		//draw 5 cards
        -:  169:		// for (j = 0; j < 5; j++)
        -:  170:		//	{
        -:  171:		//	  drawCard(i, state);
        -:  172:		//	}
        -:  173:	}
        -:  174:
        -:  175:	//set embargo tokens to 0 for all supply piles
       56:  176:	for (i = 0; i <= treasure_map; i++)
        -:  177:	{
       54:  178:		state->embargoTokens[i] = 0;
        -:  179:	}
        -:  180:
        -:  181:	//initialize first player's turn
        2:  182:	state->outpostPlayed = 0;
        2:  183:	state->phase = 0;
        2:  184:	state->numActions = 1;
        2:  185:	state->numBuys = 1;
        2:  186:	state->playedCardCount = 0;
        2:  187:	state->whoseTurn = 0;
        2:  188:	state->handCount[state->whoseTurn] = 0;
        -:  189:	//int it; move to top
        -:  190:
        -:  191:	//Moved draw cards to here, only drawing at the start of a turn
       12:  192:	for (it = 0; it < 5; it++){
       10:  193:		drawCard(state->whoseTurn, state);
        -:  194:	}
        -:  195:
        2:  196:	updateCoins(state->whoseTurn, state, 0);
        -:  197:
        2:  198:	return 0;
        -:  199:}
        -:  200:
      120:  201:int shuffle(int player, struct gameState *state) {
        -:  202:
        -:  203:
        -:  204:	int newDeck[MAX_DECK];
      120:  205:	int newDeckPos = 0;
        -:  206:	int card;
        -:  207:	int i;
        -:  208:
      120:  209:	if (state->deckCount[player] < 1)
        4:  210:		return -1;
      116:  211:	qsort((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
        -:  212:	/* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
     2095:  214:	while (state->deckCount[player] > 0) {
     1863:  215:		card = floor(Random() * state->deckCount[player]);
     1863:  216:		newDeck[newDeckPos] = state->deck[player][card];
     1863:  217:		newDeckPos++;
    10746:  218:		for (i = card; i < state->deckCount[player] - 1; i++) {
     8883:  219:			state->deck[player][i] = state->deck[player][i + 1];
        -:  220:		}
     1863:  221:		state->deckCount[player]--;
        -:  222:	}
     1979:  223:	for (i = 0; i < newDeckPos; i++) {
     1863:  224:		state->deck[player][i] = newDeck[i];
     1863:  225:		state->deckCount[player]++;
        -:  226:	}
        -:  227:
      116:  228:	return 0;
        -:  229:}
        -:  230:
     1729:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state)
        -:  232:{
        -:  233:	int card;
     1729:  234:	int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:	//check if it is the right phase
     1729:  237:	if (state->phase != 0)
        -:  238:	{
      244:  239:		return -1;
        -:  240:	}
        -:  241:
        -:  242:	//check if player has enough actions
     1485:  243:	if (state->numActions < 1)
        -:  244:	{
       85:  245:		return -1;
        -:  246:	}
        -:  247:
        -:  248:	//get card played
     1400:  249:	card = handCard(handPos, state);
        -:  250:
        -:  251:	//check if selected card is an action
     1400:  252:	if (card < adventurer || card > treasure_map)
        -:  253:	{
     1282:  254:		return -1;
        -:  255:	}
        -:  256:
        -:  257:	//play card
      118:  258:	if (cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0)
        -:  259:	{
       25:  260:		return -1;
        -:  261:	}
        -:  262:
        -:  263:	//reduce number of actions
       93:  264:	state->numActions--;
        -:  265:
        -:  266:	//update coins (Treasure cards may be added with card draws)
       93:  267:	updateCoins(state->whoseTurn, state, coin_bonus);
        -:  268:
       93:  269:	return 0;
        -:  270:}
        -:  271:
     1779:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:	int who;
        -:  274:	if (DEBUG){
        -:  275:		printf("Entering buyCard...\n");
        -:  276:	}
        -:  277:
        -:  278:	// I don't know what to do about the phase thing.
        -:  279:
     1779:  280:	who = state->whoseTurn;
        -:  281:
     1779:  282:	if (state->numBuys < 1){
        -:  283:		if (DEBUG)
        -:  284:			printf("You do not have any buys left\n");
      225:  285:		return -1;
        -:  286:	}
     1554:  287:	else if (supplyCount(supplyPos, state) < 1){
        -:  288:		if (DEBUG)
        -:  289:			printf("There are not any of that type of card left\n");
      651:  290:		return -1;
        -:  291:	}
      903:  292:	else if (state->coins < getCost(supplyPos)){
        -:  293:		if (DEBUG)
        -:  294:			printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
      654:  295:		return -1;
        -:  296:	}
        -:  297:	else {
      249:  298:		state->phase = 1;
        -:  299:		//state->supplyCount[supplyPos]--;
      249:  300:		gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  301:
      249:  302:		state->coins = (state->coins) - (getCost(supplyPos));
      249:  303:		state->numBuys--;
        -:  304:		if (DEBUG)
        -:  305:			printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  306:	}
        -:  307:
        -:  308:	//state->discard[who][state->discardCount[who]] = supplyPos;
        -:  309:	//state->discardCount[who]++;
        -:  310:
      249:  311:	return 0;
        -:  312:}
        -:  313:
    #####:  314:int numHandCards(struct gameState *state) {
    #####:  315:	return state->handCount[whoseTurn(state)];
        -:  316:}
        -:  317:
     1401:  318:int handCard(int handPos, struct gameState *state) {
     1401:  319:	int currentPlayer = whoseTurn(state);
     1401:  320:	return state->hand[currentPlayer][handPos];
        -:  321:}
        -:  322:
     1840:  323:int supplyCount(int card, struct gameState *state) {
     1840:  324:	return state->supplyCount[card];
        -:  325:}
        -:  326:
    #####:  327:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  328:	int i;
    #####:  329:	int count = 0;
        -:  330:
    #####:  331:	for (i = 0; i < state->deckCount[player]; i++)
        -:  332:	{
    #####:  333:		if (state->deck[player][i] == card) count++;
        -:  334:	}
        -:  335:
    #####:  336:	for (i = 0; i < state->handCount[player]; i++)
        -:  337:	{
    #####:  338:		if (state->hand[player][i] == card) count++;
        -:  339:	}
        -:  340:
    #####:  341:	for (i = 0; i < state->discardCount[player]; i++)
        -:  342:	{
    #####:  343:		if (state->discard[player][i] == card) count++;
        -:  344:	}
        -:  345:
    #####:  346:	return count;
        -:  347:}
        -:  348:
     1847:  349:int whoseTurn(struct gameState *state) {
     1847:  350:	return state->whoseTurn;
        -:  351:}
        -:  352:
      328:  353:int endTurn(struct gameState *state) {
        -:  354:	int k;
        -:  355:	int i;
      328:  356:	int currentPlayer = whoseTurn(state);
        -:  357:
        -:  358:	//Discard hand
     1916:  359:	for (i = 0; i < state->handCount[currentPlayer]; i++){
     1588:  360:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
     1588:  361:		state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  362:	}
      328:  363:	state->handCount[currentPlayer] = 0;//Reset hand count
        -:  364:
        -:  365:	//Code for determining the player
      328:  366:	if (currentPlayer < (state->numPlayers - 1)){
      247:  367:		state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  368:	}
        -:  369:	else{
       81:  370:		state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  371:	}
        -:  372:
      328:  373:	state->outpostPlayed = 0;
      328:  374:	state->phase = 0;
      328:  375:	state->numActions = 1;
      328:  376:	state->coins = 0;
      328:  377:	state->numBuys = 1;
      328:  378:	state->playedCardCount = 0;
      328:  379:	state->handCount[state->whoseTurn] = 0;
        -:  380:
        -:  381:	//int k; move to top
        -:  382:	//Next player draws hand
     1968:  383:	for (k = 0; k < 5; k++){
     1640:  384:		drawCard(state->whoseTurn, state);//Draw a card
        -:  385:	}
        -:  386:
        -:  387:	//Update money
      328:  388:	updateCoins(state->whoseTurn, state, 0);
        -:  389:
      328:  390:	return 0;
        -:  391:}
        -:  392:
     5266:  393:int isGameOver(struct gameState *state) {
        -:  394:	int i;
        -:  395:	int j;
        -:  396:
        -:  397:	//if stack of Province cards is empty, the game ends
     5266:  398:	if (state->supplyCount[province] == 0)
        -:  399:	{
    #####:  400:		return 1;
        -:  401:	}
        -:  402:
        -:  403:	//if three supply pile are at 0, the game ends
     5266:  404:	j = 0;
   136916:  405:	for (i = 0; i < 25; i++)
        -:  406:	{
   131650:  407:		if (state->supplyCount[i] == 0)
        -:  408:		{
     4762:  409:			j++;
        -:  410:		}
        -:  411:	}
     5266:  412:	if (j >= 3)
        -:  413:	{
        2:  414:		return 1;
        -:  415:	}
        -:  416:
     5264:  417:	return 0;
        -:  418:}
        -:  419:
    #####:  420:int scoreFor(int player, struct gameState *state) {
        -:  421:
        -:  422:	int i;
    #####:  423:	int score = 0;
        -:  424:	//score from hand
    #####:  425:	for (i = 0; i < state->handCount[player]; i++)
        -:  426:	{
    #####:  427:		if (state->hand[player][i] == curse) { score = score - 1; };
    #####:  428:		if (state->hand[player][i] == estate) { score = score + 1; };
    #####:  429:		if (state->hand[player][i] == duchy) { score = score + 3; };
    #####:  430:		if (state->hand[player][i] == province) { score = score + 6; };
    #####:  431:		if (state->hand[player][i] == great_hall) { score = score + 1; };
    #####:  432:		if (state->hand[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  433:	}
        -:  434:
        -:  435:	//score from discard
    #####:  436:	for (i = 0; i < state->discardCount[player]; i++)
        -:  437:	{
    #####:  438:		if (state->discard[player][i] == curse) { score = score - 1; };
    #####:  439:		if (state->discard[player][i] == estate) { score = score + 1; };
    #####:  440:		if (state->discard[player][i] == duchy) { score = score + 3; };
    #####:  441:		if (state->discard[player][i] == province) { score = score + 6; };
    #####:  442:		if (state->discard[player][i] == great_hall) { score = score + 1; };
    #####:  443:		if (state->discard[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  444:	}
        -:  445:
        -:  446:	//score from deck
    #####:  447:	for (i = 0; i < state->discardCount[player]; i++)
        -:  448:	{
    #####:  449:		if (state->deck[player][i] == curse) { score = score - 1; };
    #####:  450:		if (state->deck[player][i] == estate) { score = score + 1; };
    #####:  451:		if (state->deck[player][i] == duchy) { score = score + 3; };
    #####:  452:		if (state->deck[player][i] == province) { score = score + 6; };
    #####:  453:		if (state->deck[player][i] == great_hall) { score = score + 1; };
    #####:  454:		if (state->deck[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  455:	}
        -:  456:
    #####:  457:	return score;
        -:  458:}
        -:  459:
    #####:  460:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  461:	int i;
        -:  462:	int j;
        -:  463:	int highScore;
        -:  464:	int currentPlayer;
        -:  465:
        -:  466:	//get score for each player
    #####:  467:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  468:	{
        -:  469:		//set unused player scores to -9999
    #####:  470:		if (i >= state->numPlayers)
        -:  471:		{
    #####:  472:			players[i] = -9999;
        -:  473:		}
        -:  474:		else
        -:  475:		{
    #####:  476:			players[i] = scoreFor(i, state);
        -:  477:		}
        -:  478:	}
        -:  479:
        -:  480:	//find highest score
    #####:  481:	j = 0;
    #####:  482:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  483:	{
    #####:  484:		if (players[i] > players[j])
        -:  485:		{
    #####:  486:			j = i;
        -:  487:		}
        -:  488:	}
    #####:  489:	highScore = players[j];
        -:  490:
        -:  491:	//add 1 to players who had less turns
    #####:  492:	currentPlayer = whoseTurn(state);
    #####:  493:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  494:	{
    #####:  495:		if (players[i] == highScore && i > currentPlayer)
        -:  496:		{
    #####:  497:			players[i]++;
        -:  498:		}
        -:  499:	}
        -:  500:
        -:  501:	//find new highest score
    #####:  502:	j = 0;
    #####:  503:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  504:	{
    #####:  505:		if (players[i] > players[j])
        -:  506:		{
    #####:  507:			j = i;
        -:  508:		}
        -:  509:	}
    #####:  510:	highScore = players[j];
        -:  511:
        -:  512:	//set winners in array to 1 and rest to 0
    #####:  513:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  514:	{
    #####:  515:		if (players[i] == highScore)
        -:  516:		{
    #####:  517:			players[i] = 1;
        -:  518:		}
        -:  519:		else
        -:  520:		{
    #####:  521:			players[i] = 0;
        -:  522:		}
        -:  523:	}
        -:  524:
    #####:  525:	return 0;
        -:  526:}
        -:  527:
     1711:  528:int drawCard(int player, struct gameState *state)
        -:  529:{
        -:  530:	int count;
        -:  531:	int deckCounter;
     1711:  532:	if (state->deckCount[player] <= 0){//Deck is empty
        -:  533:
        -:  534:		//Step 1 Shuffle the discard pile back into a deck
        -:  535:		int i;
        -:  536:		//Move discard to deck
     1893:  537:		for (i = 0; i < state->discardCount[player]; i++){
     1783:  538:			state->deck[player][i] = state->discard[player][i];
     1783:  539:			state->discard[player][i] = -1;
        -:  540:		}
        -:  541:
      110:  542:		state->deckCount[player] = state->discardCount[player];
      110:  543:		state->discardCount[player] = 0;//Reset discard
        -:  544:
        -:  545:		//Shufffle the deck
      110:  546:		shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  547:
        -:  548:		if (DEBUG){//Debug statements
        -:  549:			printf("Deck count now: %d\n", state->deckCount[player]);
        -:  550:		}
        -:  551:
      110:  552:		state->discardCount[player] = 0;
        -:  553:
        -:  554:		//Step 2 Draw Card
      110:  555:		count = state->handCount[player];//Get current player's hand count
        -:  556:
        -:  557:		if (DEBUG){//Debug statements
        -:  558:			printf("Current hand count: %d\n", count);
        -:  559:		}
        -:  560:
      110:  561:		deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  562:
      110:  563:		if (deckCounter == 0)
        2:  564:			return -1;
        -:  565:
      108:  566:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
      108:  567:		state->deckCount[player]--;
      108:  568:		state->handCount[player]++;//Increment hand count
        -:  569:	}
        -:  570:
        -:  571:	else{
     1601:  572:		int count = state->handCount[player];//Get current hand count for player
        -:  573:		int deckCounter;
        -:  574:		if (DEBUG){//Debug statements
        -:  575:			printf("Current hand count: %d\n", count);
        -:  576:		}
        -:  577:
     1601:  578:		deckCounter = state->deckCount[player];//Create holder for the deck count
     1601:  579:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
     1601:  580:		state->deckCount[player]--;
     1601:  581:		state->handCount[player]++;//Increment hand count
        -:  582:	}
        -:  583:
     1709:  584:	return 0;
        -:  585:}
        -:  586:
     1185:  587:int getCost(int cardNumber)
        -:  588:{
     1185:  589:	switch (cardNumber)
        -:  590:	{
        -:  591:	case curse:
      117:  592:		return 0;
        -:  593:	case estate:
       44:  594:		return 2;
        -:  595:	case duchy:
       50:  596:		return 5;
        -:  597:	case province:
       55:  598:		return 8;
        -:  599:	case copper:
      103:  600:		return 0;
        -:  601:	case silver:
       83:  602:		return 3;
        -:  603:	case gold:
       62:  604:		return 6;
        -:  605:	case adventurer:
       65:  606:		return 6;
        -:  607:	case council_room:
       81:  608:		return 5;
        -:  609:	case feast:
       39:  610:		return 4;
        -:  611:	case gardens:
       41:  612:		return 4;
        -:  613:	case mine:
    #####:  614:		return 5;
        -:  615:	case remodel:
       76:  616:		return 4;
        -:  617:	case smithy:
       60:  618:		return 4;
        -:  619:	case village:
        1:  620:		return 3;
        -:  621:	case baron:
       61:  622:		return 4;
        -:  623:	case great_hall:
        2:  624:		return 3;
        -:  625:	case minion:
       32:  626:		return 5;
        -:  627:	case steward:
       40:  628:		return 3;
        -:  629:	case tribute:
       40:  630:		return 5;
        -:  631:	case ambassador:
    #####:  632:		return 3;
        -:  633:	case cutpurse:
        1:  634:		return 4;
        -:  635:	case embargo:
       45:  636:		return 2;
        -:  637:	case outpost:
       29:  638:		return 5;
        -:  639:	case salvager:
       33:  640:		return 4;
        -:  641:	case sea_hag:
       25:  642:		return 4;
        -:  643:	case treasure_map:
    #####:  644:		return 4;
        -:  645:	}
        -:  646:
    #####:  647:	return -1;
        -:  648:}
        -:  649:
        5:  650:void playAdventurer(struct gameState *state, int currentPlayer)
        -:  651:// Reveal cards from deck until 2 Treasure cards are found.  Put those Treasure cards in the hand and discard the rest.
        -:  652:{
        5:  653:	int drawntreasure = 0;
        -:  654:	int temphand[MAX_HAND];
        -:  655:	int cardDrawn;
        5:  656:	int z = 0; // this is the counter for the temp hand
        -:  657:
       26:  658:	while (drawntreasure < 2){
       16:  659:		if (state->deckCount[currentPlayer] < 1){//if the deck is empty we need to shuffle discard and add to deck
        2:  660:			shuffle(currentPlayer, state);
        -:  661:		}
       16:  662:		drawCard(currentPlayer, state);
       16:  663:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer] - 1];//top card of hand is most recently drawn card.
       16:  664:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
       10:  665:			drawntreasure++;
        -:  666:		else{
        6:  667:			temphand[z] = cardDrawn;
        6:  668:			state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
        6:  669:			z++;
        -:  670:		}
        -:  671:	}
       16:  672:	while (z - 1 >= 0){
        6:  673:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; // discard all cards in play that have been drawn
        6:  674:		z = z - 1;
        -:  675:	}
        5:  676:}
        -:  677:
       12:  678:int playRemodel(struct gameState *state, int currentPlayer, int choice1, int choice2, int handPos)
        -:  679://Trash a card in the hand, and gain a card costing up to $2 more than the trashed card
        -:  680:{
        -:  681:	int i;
       12:  682:	int j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  683:
       12:  684:	if ((getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2))
        -:  685:	{
        1:  686:		return -1;
        -:  687:	}
        -:  688:
       11:  689:	gainCard(choice2, state, 0, currentPlayer);
        -:  690:
        -:  691:	//discard card from hand
       11:  692:	discardCard(handPos, currentPlayer, state, 0);
        -:  693:
        -:  694:	//discard trashed card
       44:  695:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  696:	{
       38:  697:		if (state->hand[currentPlayer][i] == j)
        -:  698:		{
        5:  699:			discardCard(i, currentPlayer, state, 0);
        5:  700:			break;
        -:  701:		}
        -:  702:	}
        -:  703:
       11:  704:	return 0;
        -:  705:}
        -:  706:
        5:  707:void playSmithy(struct gameState *state, int currentPlayer, int handPos)
        -:  708:// Draw 3 cards
        -:  709:{
        -:  710:	int i;
       20:  711:	for (i = 0; i < 3; i++)
        -:  712:	{
       15:  713:		drawCard(currentPlayer, state);
        -:  714:	}
        -:  715:
        -:  716:	//discard card from hand
        5:  717:	discardCard(handPos, currentPlayer, state, 0);
        5:  718:}
        -:  719:
       23:  720:void playBaron(struct gameState *state, int currentPlayer, int choice1, int handPos)
        -:  721://Add a buy.  OPTION:  Discard an Estate card and gain $4.  Otherwise, gain an Estate card.
        -:  722:{
       23:  723:	state->numBuys++;//Increase buys by 1!
       23:  724:	if (choice1 > 0){//Boolean true or going to discard an estate
       23:  725:		int p = 0;//Iterator for hand!
       23:  726:		int card_not_discarded = 1;//Flag for discard set!
      135:  727:		while (card_not_discarded){
       89:  728:			if (state->hand[currentPlayer][p] == estate){ //Found an estate card!
       17:  729:				state->coins += 4;//Add 4 coins to the amount of coins
       17:  730:				state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
       17:  731:				state->discardCount[currentPlayer]++;
       74:  732:				for (; p < state->handCount[currentPlayer]; p++){
       57:  733:					state->hand[currentPlayer][p] = state->hand[currentPlayer][p + 1];
        -:  734:				}
       17:  735:				state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
       17:  736:				state->handCount[currentPlayer]--;
       17:  737:				card_not_discarded = 0;//Exit the loop
        -:  738:			}
       72:  739:			else if (p > state->handCount[currentPlayer]){
        -:  740:				if (DEBUG) {
        -:  741:					printf("No estate cards in your hand, invalid choice\n");
        -:  742:					printf("Must gain an estate if there are any\n");
        -:  743:				}
        6:  744:				if (supplyCount(estate, state) > 0){
        2:  745:					gainCard(estate, state, 1, currentPlayer);
        2:  746:					state->supplyCount[estate]--;//Decrement estates
        2:  747:					if (supplyCount(estate, state) == 0){
    #####:  748:						isGameOver(state);
        -:  749:					}
        -:  750:				}
        6:  751:				card_not_discarded = 0;//Exit the loop
        -:  752:			}
        -:  753:
        -:  754:			else{
       66:  755:				p++;//Next card
        -:  756:			}
        -:  757:		}
        -:  758:	}
        -:  759:
        -:  760:	else{
    #####:  761:		if (supplyCount(estate, state) > 0){
    #####:  762:			gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  763:			state->supplyCount[estate]--;//Decrement Estates
    #####:  764:			if (supplyCount(estate, state) == 0){
    #####:  765:				isGameOver(state);
        -:  766:			}
        -:  767:		}
        -:  768:	}
       23:  769:}
        -:  770:
    #####:  771:int playTreasureMap(struct gameState *state, int currentPlayer, int handPos)
        -:  772://Trashing two treasure map cards from the hand = four gold on top of the deck.
        -:  773:{
        -:  774:	int i;
        -:  775:	int index;
        -:  776:
        -:  777:	//search hand for another treasure_map
    #####:  778:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  779:	{
    #####:  780:		if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -:  781:		{
    #####:  782:			index = i;
    #####:  783:			break;
        -:  784:		}
        -:  785:	}
    #####:  786:	if (index > -1)
        -:  787:	{
        -:  788:		//trash both treasure cards
    #####:  789:		discardCard(handPos, currentPlayer, state, 1);
    #####:  790:		discardCard(index, currentPlayer, state, 1);
        -:  791:
        -:  792:		//gain 4 Gold cards
    #####:  793:		for (i = 0; i < 4; i++)
        -:  794:		{
    #####:  795:			gainCard(gold, state, 1, currentPlayer);
        -:  796:		}
        -:  797:
        -:  798:		//return success
    #####:  799:		return 1;
        -:  800:	}
        -:  801:
        -:  802:	//no second treasure_map found in hand
    #####:  803:	return -1;
        -:  804:}
        -:  805:
      118:  806:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  807:{
        -:  808:	int i;
        -:  809:	int j;
        -:  810:	int k;
        -:  811:	//int x;  //Unused after while loop removed from feast.
      118:  812:	int currentPlayer = whoseTurn(state);
      118:  813:	int nextPlayer = currentPlayer + 1;
        -:  814:	int temphand[MAX_HAND];
        -:  815:
      118:  816:	int tributeRevealedCards[2] = { -1, -1 };
        -:  817:
      118:  818:	if (nextPlayer > (state->numPlayers - 1)){
       22:  819:		nextPlayer = 0;
        -:  820:	}
        -:  821:
        -:  822:	//uses switch to select card and perform actions
      118:  823:	switch (card)
        -:  824:	{
        -:  825:	case adventurer:
        -:  826:
        5:  827:		playAdventurer(state, currentPlayer);
        5:  828:		return 0;
        -:  829:
        -:  830:	case council_room:
        -:  831:		//+4 Cards
       20:  832:		for (i = 0; i < 4; i++)
        -:  833:		{
       16:  834:			drawCard(currentPlayer, state);
        -:  835:		}
        -:  836:
        -:  837:		//+1 Buy
        4:  838:		state->numBuys++;
        -:  839:
        -:  840:		//Each other player draws a card
       20:  841:		for (i = 0; i < state->numPlayers; i++)
        -:  842:		{
       16:  843:			if (i != currentPlayer)
        -:  844:			{
       12:  845:				drawCard(i, state);
        -:  846:			}
        -:  847:		}
        -:  848:
        -:  849:		//put played card in played card pile
        4:  850:		discardCard(handPos, currentPlayer, state, 0);
        -:  851:
        4:  852:		return 0;
        -:  853:
        -:  854:	case feast:
        -:  855:		//gain card with cost up to 5
        -:  856:		//Backup hand
       70:  857:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
       60:  858:			temphand[i] = state->hand[currentPlayer][i];//Backup card
       60:  859:			state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  860:		}
        -:  861:		//Backup hand
        -:  862:
        -:  863:		//Update Coins for Buy
       10:  864:		updateCoins(currentPlayer, state, 5);
        -:  865://		x = 1;//Condition to loop on
        -:  866://		while (x == 1) {//Buy one card
       10:  867:			if (supplyCount(choice1, state) <= 0){
        -:  868:				if (DEBUG)
        -:  869:					printf("None of that card left, sorry!\n");
        -:  870:
        -:  871:				if (DEBUG){
        -:  872:					printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  873:				}
        -:  874:			}
        8:  875:			else if (state->coins < getCost(choice1)){
        2:  876:				printf("That card is too expensive!\n");
        -:  877:
        -:  878:				if (DEBUG){
        -:  879:					printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  880:				}
        -:  881:			}
        -:  882:			else{
        -:  883:
        -:  884:				if (DEBUG){
        -:  885:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  886:				}
        -:  887:
        6:  888:				gainCard(choice1, state, 0, currentPlayer);//Gain the card
        -:  889://				x = 0;//No more buying cards
        -:  890:
        -:  891:				if (DEBUG){
        -:  892:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  893:				}
        -:  894:
        -:  895:			}
        -:  896://		}
        -:  897:
        -:  898:		//Reset Hand
       70:  899:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
       60:  900:			state->hand[currentPlayer][i] = temphand[i];
       60:  901:			temphand[i] = -1;
        -:  902:		}
        -:  903:		//Reset Hand
        -:  904:
       10:  905:		return 0;
        -:  906:
        -:  907:	case gardens:
       12:  908:		return -1;
        -:  909:
        -:  910:	case mine:
    #####:  911:		j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  912:
    #####:  913:		if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  914:		{
    #####:  915:			return -1;
        -:  916:		}
        -:  917:
    #####:  918:		if (choice2 > treasure_map || choice2 < curse)
        -:  919:		{
    #####:  920:			return -1;
        -:  921:		}
        -:  922:
    #####:  923:		if ((getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2))
        -:  924:		{
    #####:  925:			return -1;
        -:  926:		}
        -:  927:
    #####:  928:		gainCard(choice2, state, 2, currentPlayer);
        -:  929:
        -:  930:		//discard card from hand
    #####:  931:		discardCard(handPos, currentPlayer, state, 0);
        -:  932:
        -:  933:		//discard trashed card
    #####:  934:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  935:		{
    #####:  936:			if (state->hand[currentPlayer][i] == j)
        -:  937:			{
    #####:  938:				discardCard(i, currentPlayer, state, 0);
    #####:  939:				break;
        -:  940:			}
        -:  941:		}
        -:  942:
    #####:  943:		return 0;
        -:  944:
        -:  945:	case remodel:
        -:  946:
       12:  947:		return playRemodel(state, currentPlayer, choice1, choice2, handPos);
        -:  948:
        -:  949:	case smithy:
        -:  950:
        5:  951:		playSmithy(state, currentPlayer, handPos);
        5:  952:		return 0;
        -:  953:
        -:  954:	case village:
        -:  955:		//+1 Card
    #####:  956:		drawCard(currentPlayer, state);
        -:  957:
        -:  958:		//+2 Actions
    #####:  959:		state->numActions = state->numActions + 2;
        -:  960:
        -:  961:		//discard played card from hand
    #####:  962:		discardCard(handPos, currentPlayer, state, 0);
    #####:  963:		return 0;
        -:  964:
        -:  965:	case baron:
        -:  966:
       23:  967:		playBaron(state, currentPlayer, choice1, handPos);
       23:  968:		return 0;
        -:  969:
        -:  970:	case great_hall:
        -:  971:		//+1 Card
    #####:  972:		drawCard(currentPlayer, state);
        -:  973:
        -:  974:		//+1 Actions
    #####:  975:		state->numActions++;
        -:  976:
        -:  977:		//discard card from hand
    #####:  978:		discardCard(handPos, currentPlayer, state, 0);
    #####:  979:		return 0;
        -:  980:
        -:  981:	case minion:
        -:  982:		//+1 action
        2:  983:		state->numActions++;
        -:  984:
        -:  985:		//discard card from hand
        2:  986:		discardCard(handPos, currentPlayer, state, 0);
        -:  987:
        2:  988:		if (choice1)		//+2 coins
        -:  989:		{
        2:  990:			state->coins = state->coins + 2;
        -:  991:		}
        -:  992:
    #####:  993:		else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  994:		{
        -:  995:			//discard hand
    #####:  996:			while (numHandCards(state) > 0)
        -:  997:			{
    #####:  998:				discardCard(handPos, currentPlayer, state, 0);
        -:  999:			}
        -: 1000:
        -: 1001:			//draw 4
    #####: 1002:			for (i = 0; i < 4; i++)
        -: 1003:			{
    #####: 1004:				drawCard(currentPlayer, state);
        -: 1005:			}
        -: 1006:
        -: 1007:			//other players discard hand and redraw if hand size > 4
    #####: 1008:			for (i = 0; i < state->numPlayers; i++)
        -: 1009:			{
    #####: 1010:				if (i != currentPlayer)
        -: 1011:				{
    #####: 1012:					if (state->handCount[i] > 4)
        -: 1013:					{
        -: 1014:						//discard hand
    #####: 1015:						while (state->handCount[i] > 0)
        -: 1016:						{
    #####: 1017:							discardCard(handPos, i, state, 0);
        -: 1018:						}
        -: 1019:
        -: 1020:						//draw 4
    #####: 1021:						for (j = 0; j < 4; j++)
        -: 1022:						{
    #####: 1023:							drawCard(i, state);
        -: 1024:						}
        -: 1025:					}
        -: 1026:				}
        -: 1027:			}
        -: 1028:
        -: 1029:		}
        2: 1030:		return 0;
        -: 1031:
        -: 1032:	case steward:
       10: 1033:		if (choice1 == 1)
        -: 1034:		{
        -: 1035:			//+2 cards
    #####: 1036:			drawCard(currentPlayer, state);
    #####: 1037:			drawCard(currentPlayer, state);
        -: 1038:		}
       10: 1039:		else if (choice1 == 2)
        -: 1040:		{
        -: 1041:			//+2 coins
    #####: 1042:			state->coins = state->coins + 2;
        -: 1043:		}
        -: 1044:		else
        -: 1045:		{
        -: 1046:			//trash 2 cards in hand
       10: 1047:			discardCard(choice2, currentPlayer, state, 1);
       10: 1048:			discardCard(choice3, currentPlayer, state, 1);
        -: 1049:		}
        -: 1050:
        -: 1051:		//discard card from hand
       10: 1052:		discardCard(handPos, currentPlayer, state, 0);
       10: 1053:		return 0;
        -: 1054:
        -: 1055:	case tribute:
        1: 1056:		if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####: 1057:			if (state->deckCount[nextPlayer] > 0){
    #####: 1058:				tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1059:				state->deckCount[nextPlayer]--;
        -: 1060:			}
    #####: 1061:			else if (state->discardCount[nextPlayer] > 0){
    #####: 1062:				tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer] - 1];
    #####: 1063:				state->discardCount[nextPlayer]--;
        -: 1064:			}
        -: 1065:			else{
        -: 1066:				//No Card to Reveal
        -: 1067:				if (DEBUG){
        -: 1068:					printf("No cards to reveal\n");
        -: 1069:				}
        -: 1070:			}
        -: 1071:		}
        -: 1072:
        -: 1073:		else{
        1: 1074:			if (state->deckCount[nextPlayer] == 0){
    #####: 1075:				for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####: 1076:					state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1077:					state->deckCount[nextPlayer]++;
    #####: 1078:					state->discard[nextPlayer][i] = -1;
    #####: 1079:					state->discardCount[nextPlayer]--;
        -: 1080:				}
        -: 1081:
    #####: 1082:				shuffle(nextPlayer, state);//Shuffle the deck
        -: 1083:			}
        1: 1084:			tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
        1: 1085:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
        1: 1086:			state->deckCount[nextPlayer]--;
        1: 1087:			tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
        1: 1088:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
        1: 1089:			state->deckCount[nextPlayer]--;
        -: 1090:		}
        -: 1091:
        1: 1092:		if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
        1: 1093:			state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
        1: 1094:			state->playedCardCount++;
        1: 1095:			tributeRevealedCards[1] = -1;
        -: 1096:		}
        -: 1097:
        4: 1098:		for (i = 0; i <= 2; i++){
        3: 1099:			if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
    #####: 1100:				state->coins += 2;
        -: 1101:			}
        -: 1102:
        3: 1103:			else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
        1: 1104:				drawCard(currentPlayer, state);
        1: 1105:				drawCard(currentPlayer, state);
        -: 1106:			}
        -: 1107:			else{//Action Card
        2: 1108:				state->numActions = state->numActions + 2;
        -: 1109:			}
        -: 1110:		}
        -: 1111:
        1: 1112:		return 0;
        -: 1113:
        -: 1114:	case ambassador:
    #####: 1115:		j = 0;		//used to check if player has enough cards to discard
        -: 1116:
    #####: 1117:		if (choice2 > 2 || choice2 < 0)
        -: 1118:		{
    #####: 1119:			return -1;
        -: 1120:		}
        -: 1121:
    #####: 1122:		if (choice1 == handPos)
        -: 1123:		{
    #####: 1124:			return -1;
        -: 1125:		}
        -: 1126:
    #####: 1127:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1128:		{
    #####: 1129:			if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1130:			{
    #####: 1131:				j++;
        -: 1132:			}
        -: 1133:		}
    #####: 1134:		if (j < choice2)
        -: 1135:		{
    #####: 1136:			return -1;
        -: 1137:		}
        -: 1138:
        -: 1139:		if (DEBUG)
        -: 1140:			printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1141:
        -: 1142:		//increase supply count for choosen card by amount being discarded
    #####: 1143:		state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1144:
        -: 1145:		//each other player gains a copy of revealed card
    #####: 1146:		for (i = 0; i < state->numPlayers; i++)
        -: 1147:		{
    #####: 1148:			if (i != currentPlayer)
        -: 1149:			{
    #####: 1150:				gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1151:			}
        -: 1152:		}
        -: 1153:
        -: 1154:		//discard played card from hand
    #####: 1155:		discardCard(handPos, currentPlayer, state, 0);
        -: 1156:
        -: 1157:		//trash copies of cards returned to supply
    #####: 1158:		for (j = 0; j < choice2; j++)
        -: 1159:		{
    #####: 1160:			for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1161:			{
    #####: 1162:				if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1163:				{
    #####: 1164:					discardCard(i, currentPlayer, state, 1);
    #####: 1165:					break;
        -: 1166:				}
        -: 1167:			}
        -: 1168:		}
        -: 1169:
    #####: 1170:		return 0;
        -: 1171:
        -: 1172:	case cutpurse:
        -: 1173:
    #####: 1174:		updateCoins(currentPlayer, state, 2);
    #####: 1175:		for (i = 0; i < state->numPlayers; i++)
        -: 1176:		{
    #####: 1177:			if (i != currentPlayer)
        -: 1178:			{
    #####: 1179:				for (j = 0; j < state->handCount[i]; j++)
        -: 1180:				{
    #####: 1181:					if (state->hand[i][j] == copper)
        -: 1182:					{
    #####: 1183:						discardCard(j, i, state, 0);
    #####: 1184:						break;
        -: 1185:					}
    #####: 1186:					if (j == state->handCount[i])
        -: 1187:					{
    #####: 1188:						for (k = 0; k < state->handCount[i]; k++)
        -: 1189:						{
        -: 1190:							if (DEBUG)
        -: 1191:								printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1192:						}
    #####: 1193:						break;
        -: 1194:					}
        -: 1195:				}
        -: 1196:
        -: 1197:			}
        -: 1198:
        -: 1199:		}
        -: 1200:
        -: 1201:		//discard played card from hand
    #####: 1202:		discardCard(handPos, currentPlayer, state, 0);
        -: 1203:
    #####: 1204:		return 0;
        -: 1205:
        -: 1206:
        -: 1207:	case embargo:
        -: 1208:		//+2 Coins
       28: 1209:		state->coins = state->coins + 2;
        -: 1210:
        -: 1211:		//see if selected pile is in play
       28: 1212:		if (state->supplyCount[choice1] == -1)
        -: 1213:		{
       12: 1214:			return -1;
        -: 1215:		}
        -: 1216:
        -: 1217:		//add embargo token to selected supply pile
       16: 1218:		state->embargoTokens[choice1]++;
        -: 1219:
        -: 1220:		//trash card
       16: 1221:		discardCard(handPos, currentPlayer, state, 1);
       16: 1222:		return 0;
        -: 1223:
        -: 1224:	case outpost:
        -: 1225:		//set outpost flag
        1: 1226:		state->outpostPlayed++;
        -: 1227:
        -: 1228:		//discard card
        1: 1229:		discardCard(handPos, currentPlayer, state, 0);
        1: 1230:		return 0;
        -: 1231:
        -: 1232:	case salvager:
        -: 1233:		//+1 buy
        1: 1234:		state->numBuys++;
        -: 1235:
        1: 1236:		if (choice1)
        -: 1237:		{
        -: 1238:			//gain coins equal to trashed card
        1: 1239:			state->coins = state->coins + getCost(handCard(choice1, state));
        -: 1240:			//trash card
        1: 1241:			discardCard(choice1, currentPlayer, state, 1);
        -: 1242:		}
        -: 1243:
        -: 1244:		//discard card
        1: 1245:		discardCard(handPos, currentPlayer, state, 0);
        1: 1246:		return 0;
        -: 1247:
        -: 1248:	case sea_hag:
       20: 1249:		for (i = 0; i < state->numPlayers; i++){
       16: 1250:			if (i != currentPlayer){
       12: 1251:				state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
       12: 1252:				state->discardCount[i]++;
       12: 1253:				state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1254:			}
        -: 1255:		}
        4: 1256:		return 0;
        -: 1257:
        -: 1258:	case treasure_map:
        -: 1259:
    #####: 1260:		return playTreasureMap(state, currentPlayer, handPos);
        -: 1261:	}
    #####: 1262:	return -1;
        -: 1263:}
        -: 1264:
       76: 1265:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1266:{
        -: 1267:
        -: 1268:	//if card is not trashed, added to Played pile 
       76: 1269:	if (trashFlag < 1)
        -: 1270:	{
        -: 1271:		//add card to played pile
       39: 1272:		state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
       39: 1273:		state->playedCardCount++;
        -: 1274:	}
        -: 1275:
        -: 1276:	//set played card to -1
       76: 1277:	state->hand[currentPlayer][handPos] = -1;
        -: 1278:
        -: 1279:	//remove card from player's hand
       76: 1280:	if (handPos == (state->handCount[currentPlayer] - 1)) 	//last card in hand array is played
        -: 1281:	{
        -: 1282:		//reduce number of cards in hand
       14: 1283:		state->handCount[currentPlayer]--;
        -: 1284:	}
       62: 1285:	else if (state->handCount[currentPlayer] == 1) //only one card in hand
        -: 1286:	{
        -: 1287:		//reduce number of cards in hand
    #####: 1288:		state->handCount[currentPlayer]--;
        -: 1289:	}
        -: 1290:	else
        -: 1291:	{
        -: 1292:		//replace discarded card with last card in hand
       62: 1293:		state->hand[currentPlayer][handPos] = state->hand[currentPlayer][(state->handCount[currentPlayer] - 1)];
        -: 1294:		//set last card to -1
       62: 1295:		state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1296:		//reduce number of cards in hand
       62: 1297:		state->handCount[currentPlayer]--;
        -: 1298:	}
        -: 1299:
       76: 1300:	return 0;
        -: 1301:}
        -: 1302:
      268: 1303:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1304:{
        -: 1305:	//Note: supplyPos is enum of choosen card
        -: 1306:
        -: 1307:	//check if supply pile is empty (0) or card is not used in game (-1)
      268: 1308:	if (supplyCount(supplyPos, state) < 1)
        -: 1309:	{
        6: 1310:		return -1;
        -: 1311:	}
        -: 1312:
        -: 1313:	//added card for [whoseTurn] current player:
        -: 1314:	// toFlag = 0 : add to discard
        -: 1315:	// toFlag = 1 : add to deck
        -: 1316:	// toFlag = 2 : add to hand
        -: 1317:
      262: 1318:	if (toFlag == 1)
        -: 1319:	{
        2: 1320:		state->deck[player][state->deckCount[player]] = supplyPos;
        2: 1321:		state->deckCount[player]++;
        -: 1322:	}
      260: 1323:	else if (toFlag == 2)
        -: 1324:	{
    #####: 1325:		state->hand[player][state->handCount[player]] = supplyPos;
    #####: 1326:		state->handCount[player]++;
        -: 1327:	}
        -: 1328:	else
        -: 1329:	{
      260: 1330:		state->discard[player][state->discardCount[player]] = supplyPos;
      260: 1331:		state->discardCount[player]++;
        -: 1332:	}
        -: 1333:
        -: 1334:	//decrease number in supply pile
      262: 1335:	state->supplyCount[supplyPos]--;
        -: 1336:
      262: 1337:	return 0;
        -: 1338:}
        -: 1339:
      433: 1340:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1341:{
        -: 1342:	int i;
        -: 1343:
        -: 1344:	//reset coin count
      433: 1345:	state->coins = 0;
        -: 1346:
        -: 1347:	//add coins for each Treasure card in player's hand
     2549: 1348:	for (i = 0; i < state->handCount[player]; i++)
        -: 1349:	{
     2116: 1350:		if (state->hand[player][i] == copper)
        -: 1351:		{
      890: 1352:			state->coins += 1;
        -: 1353:		}
     1226: 1354:		else if (state->hand[player][i] == silver)
        -: 1355:		{
      158: 1356:			state->coins += 2;
        -: 1357:		}
     1068: 1358:		else if (state->hand[player][i] == gold)
        -: 1359:		{
        3: 1360:			state->coins += 3;
        -: 1361:		}
        -: 1362:	}
        -: 1363:
        -: 1364:	//add bonus
      433: 1365:	state->coins += bonus;
        -: 1366:
      433: 1367:	return 0;
        -: 1368:}
        -: 1369:
        -: 1370:
        -: 1371://end of dominion.c
File 'dominion.c'
No executable lines
Removing 'dominion.c.gcov'

File 'dominion.c'
Lines executed:71.81% of 557
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
     3709:    8:int compare(const void* a, const void* b) {
     3709:    9:	if (*(int*)a > *(int*)b)
     1336:   10:		return 1;
     2373:   11:	if (*(int*)a < *(int*)b)
     1099:   12:		return -1;
     1274:   13:	return 0;
        -:   14:}
        -:   15:
        4:   16:struct gameState* newGame() {
        4:   17:	struct gameState* g = malloc(sizeof(struct gameState));
        4:   18:	return g;
        -:   19:}
        -:   20:
       64:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:	int k8, int k9, int k10) {
       64:   23:	int* k = malloc(10 * sizeof(int));
       64:   24:	k[0] = k1;
       64:   25:	k[1] = k2;
       64:   26:	k[2] = k3;
       64:   27:	k[3] = k4;
       64:   28:	k[4] = k5;
       64:   29:	k[5] = k6;
       64:   30:	k[6] = k7;
       64:   31:	k[7] = k8;
       64:   32:	k[8] = k9;
       64:   33:	k[9] = k10;
       64:   34:	return k;
        -:   35:}
        -:   36:
       64:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		struct gameState *state) {
        -:   39:
        -:   40:	int i;
        -:   41:	int j;
        -:   42:	int it;
        -:   43:	//set up random number generator
       64:   44:	SelectStream(1);
       64:   45:	PutSeed((long)randomSeed);
        -:   46:
        -:   47:	//check number of players
       64:   48:	if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:	{
    #####:   50:		return -1;
        -:   51:	}
        -:   52:
        -:   53:	//set number of players
       64:   54:	state->numPlayers = numPlayers;
        -:   55:
        -:   56:	//check selected kingdom cards are different
      163:   57:	for (i = 0; i < 10; i++)
        -:   58:	{
     1469:   59:		for (j = 0; j < 10; j++)
        -:   60:		{
     1370:   61:			if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:			{
       62:   63:				return -1;
        -:   64:			}
        -:   65:		}
        -:   66:	}
        -:   67:
        -:   68:
        -:   69:	//initialize supply
        -:   70:	///////////////////////////////
        -:   71:
        -:   72:	//set number of Curse cards
        2:   73:	if (numPlayers == 2)
        -:   74:	{
    #####:   75:		state->supplyCount[curse] = 10;
        -:   76:	}
        2:   77:	else if (numPlayers == 3)
        -:   78:	{
    #####:   79:		state->supplyCount[curse] = 20;
        -:   80:	}
        -:   81:	else
        -:   82:	{
        2:   83:		state->supplyCount[curse] = 30;
        -:   84:	}
        -:   85:
        -:   86:	//set number of Victory cards
        2:   87:	if (numPlayers == 2)
        -:   88:	{
    #####:   89:		state->supplyCount[estate] = 8;
    #####:   90:		state->supplyCount[duchy] = 8;
    #####:   91:		state->supplyCount[province] = 8;
        -:   92:	}
        -:   93:	else
        -:   94:	{
        2:   95:		state->supplyCount[estate] = 12;
        2:   96:		state->supplyCount[duchy] = 12;
        2:   97:		state->supplyCount[province] = 12;
        -:   98:	}
        -:   99:
        -:  100:	//set number of Treasure cards
        2:  101:	state->supplyCount[copper] = 60 - (7 * numPlayers);
        2:  102:	state->supplyCount[silver] = 40;
        2:  103:	state->supplyCount[gold] = 30;
        -:  104:
        -:  105:	//set number of Kingdom cards
       42:  106:	for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:	{
      330:  108:		for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:		{
      310:  110:			if (kingdomCards[j] == i)
        -:  111:			{
        -:  112:				//check if card is a 'Victory' Kingdom card
       20:  113:				if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:				{
        4:  115:					if (numPlayers == 2){
    #####:  116:						state->supplyCount[i] = 8;
        -:  117:					}
        2:  118:					else{ state->supplyCount[i] = 12; }
        -:  119:				}
        -:  120:				else
        -:  121:				{
       18:  122:					state->supplyCount[i] = 10;
        -:  123:				}
       20:  124:				break;
        -:  125:			}
        -:  126:			else    //card is not in the set choosen for the game
        -:  127:			{
      290:  128:				state->supplyCount[i] = -1;
        -:  129:			}
        -:  130:		}
        -:  131:
        -:  132:	}
        -:  133:
        -:  134:	////////////////////////
        -:  135:	//supply intilization complete
        -:  136:
        -:  137:	//set player decks
       10:  138:	for (i = 0; i < numPlayers; i++)
        -:  139:	{
        8:  140:		state->deckCount[i] = 0;
       32:  141:		for (j = 0; j < 3; j++)
        -:  142:		{
       24:  143:			state->deck[i][j] = estate;
       24:  144:			state->deckCount[i]++;
        -:  145:		}
       64:  146:		for (j = 3; j < 10; j++)
        -:  147:		{
       56:  148:			state->deck[i][j] = copper;
       56:  149:			state->deckCount[i]++;
        -:  150:		}
        -:  151:	}
        -:  152:
        -:  153:	//shuffle player decks
       10:  154:	for (i = 0; i < numPlayers; i++)
        -:  155:	{
        8:  156:		if (shuffle(i, state) < 0)
        -:  157:		{
    #####:  158:			return -1;
        -:  159:		}
        -:  160:	}
        -:  161:
        -:  162:	//draw player hands
       10:  163:	for (i = 0; i < numPlayers; i++)
        -:  164:	{
        -:  165:		//initialize hand size to zero
        8:  166:		state->handCount[i] = 0;
        8:  167:		state->discardCount[i] = 0;
        -:  168:		//draw 5 cards
        -:  169:		// for (j = 0; j < 5; j++)
        -:  170:		//	{
        -:  171:		//	  drawCard(i, state);
        -:  172:		//	}
        -:  173:	}
        -:  174:
        -:  175:	//set embargo tokens to 0 for all supply piles
       56:  176:	for (i = 0; i <= treasure_map; i++)
        -:  177:	{
       54:  178:		state->embargoTokens[i] = 0;
        -:  179:	}
        -:  180:
        -:  181:	//initialize first player's turn
        2:  182:	state->outpostPlayed = 0;
        2:  183:	state->phase = 0;
        2:  184:	state->numActions = 1;
        2:  185:	state->numBuys = 1;
        2:  186:	state->playedCardCount = 0;
        2:  187:	state->whoseTurn = 0;
        2:  188:	state->handCount[state->whoseTurn] = 0;
        -:  189:	//int it; move to top
        -:  190:
        -:  191:	//Moved draw cards to here, only drawing at the start of a turn
       12:  192:	for (it = 0; it < 5; it++){
       10:  193:		drawCard(state->whoseTurn, state);
        -:  194:	}
        -:  195:
        2:  196:	updateCoins(state->whoseTurn, state, 0);
        -:  197:
        2:  198:	return 0;
        -:  199:}
        -:  200:
      111:  201:int shuffle(int player, struct gameState *state) {
        -:  202:
        -:  203:
        -:  204:	int newDeck[MAX_DECK];
      111:  205:	int newDeckPos = 0;
        -:  206:	int card;
        -:  207:	int i;
        -:  208:
      111:  209:	if (state->deckCount[player] < 1)
        1:  210:		return -1;
      110:  211:	qsort((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
        -:  212:	/* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
     1980:  214:	while (state->deckCount[player] > 0) {
     1760:  215:		card = floor(Random() * state->deckCount[player]);
     1760:  216:		newDeck[newDeckPos] = state->deck[player][card];
     1760:  217:		newDeckPos++;
     9353:  218:		for (i = card; i < state->deckCount[player] - 1; i++) {
     7593:  219:			state->deck[player][i] = state->deck[player][i + 1];
        -:  220:		}
     1760:  221:		state->deckCount[player]--;
        -:  222:	}
     1870:  223:	for (i = 0; i < newDeckPos; i++) {
     1760:  224:		state->deck[player][i] = newDeck[i];
     1760:  225:		state->deckCount[player]++;
        -:  226:	}
        -:  227:
      110:  228:	return 0;
        -:  229:}
        -:  230:
     1497:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state)
        -:  232:{
        -:  233:	int card;
     1497:  234:	int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:	//check if it is the right phase
     1497:  237:	if (state->phase != 0)
        -:  238:	{
      226:  239:		return -1;
        -:  240:	}
        -:  241:
        -:  242:	//check if player has enough actions
     1271:  243:	if (state->numActions < 1)
        -:  244:	{
       36:  245:		return -1;
        -:  246:	}
        -:  247:
        -:  248:	//get card played
     1235:  249:	card = handCard(handPos, state);
        -:  250:
        -:  251:	//check if selected card is an action
     1235:  252:	if (card < adventurer || card > treasure_map)
        -:  253:	{
     1119:  254:		return -1;
        -:  255:	}
        -:  256:
        -:  257:	//play card
      116:  258:	if (cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0)
        -:  259:	{
       35:  260:		return -1;
        -:  261:	}
        -:  262:
        -:  263:	//reduce number of actions
       81:  264:	state->numActions--;
        -:  265:
        -:  266:	//update coins (Treasure cards may be added with card draws)
       81:  267:	updateCoins(state->whoseTurn, state, coin_bonus);
        -:  268:
       81:  269:	return 0;
        -:  270:}
        -:  271:
     1468:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:	int who;
        -:  274:	if (DEBUG){
        -:  275:		printf("Entering buyCard...\n");
        -:  276:	}
        -:  277:
        -:  278:	// I don't know what to do about the phase thing.
        -:  279:
     1468:  280:	who = state->whoseTurn;
        -:  281:
     1468:  282:	if (state->numBuys < 1){
        -:  283:		if (DEBUG)
        -:  284:			printf("You do not have any buys left\n");
      216:  285:		return -1;
        -:  286:	}
     1252:  287:	else if (supplyCount(supplyPos, state) < 1){
        -:  288:		if (DEBUG)
        -:  289:			printf("There are not any of that type of card left\n");
      517:  290:		return -1;
        -:  291:	}
      735:  292:	else if (state->coins < getCost(supplyPos)){
        -:  293:		if (DEBUG)
        -:  294:			printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
      500:  295:		return -1;
        -:  296:	}
        -:  297:	else {
      235:  298:		state->phase = 1;
        -:  299:		//state->supplyCount[supplyPos]--;
      235:  300:		gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  301:
      235:  302:		state->coins = (state->coins) - (getCost(supplyPos));
      235:  303:		state->numBuys--;
        -:  304:		if (DEBUG)
        -:  305:			printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  306:	}
        -:  307:
        -:  308:	//state->discard[who][state->discardCount[who]] = supplyPos;
        -:  309:	//state->discardCount[who]++;
        -:  310:
      235:  311:	return 0;
        -:  312:}
        -:  313:
    #####:  314:int numHandCards(struct gameState *state) {
    #####:  315:	return state->handCount[whoseTurn(state)];
        -:  316:}
        -:  317:
     1237:  318:int handCard(int handPos, struct gameState *state) {
     1237:  319:	int currentPlayer = whoseTurn(state);
     1237:  320:	return state->hand[currentPlayer][handPos];
        -:  321:}
        -:  322:
     1518:  323:int supplyCount(int card, struct gameState *state) {
     1518:  324:	return state->supplyCount[card];
        -:  325:}
        -:  326:
    #####:  327:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  328:	int i;
    #####:  329:	int count = 0;
        -:  330:
    #####:  331:	for (i = 0; i < state->deckCount[player]; i++)
        -:  332:	{
    #####:  333:		if (state->deck[player][i] == card) count++;
        -:  334:	}
        -:  335:
    #####:  336:	for (i = 0; i < state->handCount[player]; i++)
        -:  337:	{
    #####:  338:		if (state->hand[player][i] == card) count++;
        -:  339:	}
        -:  340:
    #####:  341:	for (i = 0; i < state->discardCount[player]; i++)
        -:  342:	{
    #####:  343:		if (state->discard[player][i] == card) count++;
        -:  344:	}
        -:  345:
    #####:  346:	return count;
        -:  347:}
        -:  348:
     1653:  349:int whoseTurn(struct gameState *state) {
     1653:  350:	return state->whoseTurn;
        -:  351:}
        -:  352:
      300:  353:int endTurn(struct gameState *state) {
        -:  354:	int k;
        -:  355:	int i;
      300:  356:	int currentPlayer = whoseTurn(state);
        -:  357:
        -:  358:	//Discard hand
     1781:  359:	for (i = 0; i < state->handCount[currentPlayer]; i++){
     1481:  360:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
     1481:  361:		state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  362:	}
      300:  363:	state->handCount[currentPlayer] = 0;//Reset hand count
        -:  364:
        -:  365:	//Code for determining the player
      300:  366:	if (currentPlayer < (state->numPlayers - 1)){
      225:  367:		state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  368:	}
        -:  369:	else{
       75:  370:		state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  371:	}
        -:  372:
      300:  373:	state->outpostPlayed = 0;
      300:  374:	state->phase = 0;
      300:  375:	state->numActions = 1;
      300:  376:	state->coins = 0;
      300:  377:	state->numBuys = 1;
      300:  378:	state->playedCardCount = 0;
      300:  379:	state->handCount[state->whoseTurn] = 0;
        -:  380:
        -:  381:	//int k; move to top
        -:  382:	//Next player draws hand
     1800:  383:	for (k = 0; k < 5; k++){
     1500:  384:		drawCard(state->whoseTurn, state);//Draw a card
        -:  385:	}
        -:  386:
        -:  387:	//Update money
      300:  388:	updateCoins(state->whoseTurn, state, 0);
        -:  389:
      300:  390:	return 0;
        -:  391:}
        -:  392:
     4504:  393:int isGameOver(struct gameState *state) {
        -:  394:	int i;
        -:  395:	int j;
        -:  396:
        -:  397:	//if stack of Province cards is empty, the game ends
     4504:  398:	if (state->supplyCount[province] == 0)
        -:  399:	{
    #####:  400:		return 1;
        -:  401:	}
        -:  402:
        -:  403:	//if three supply pile are at 0, the game ends
     4504:  404:	j = 0;
   117104:  405:	for (i = 0; i < 25; i++)
        -:  406:	{
   112600:  407:		if (state->supplyCount[i] == 0)
        -:  408:		{
     3410:  409:			j++;
        -:  410:		}
        -:  411:	}
     4504:  412:	if (j >= 3)
        -:  413:	{
        2:  414:		return 1;
        -:  415:	}
        -:  416:
     4502:  417:	return 0;
        -:  418:}
        -:  419:
    #####:  420:int scoreFor(int player, struct gameState *state) {
        -:  421:
        -:  422:	int i;
    #####:  423:	int score = 0;
        -:  424:	//score from hand
    #####:  425:	for (i = 0; i < state->handCount[player]; i++)
        -:  426:	{
    #####:  427:		if (state->hand[player][i] == curse) { score = score - 1; };
    #####:  428:		if (state->hand[player][i] == estate) { score = score + 1; };
    #####:  429:		if (state->hand[player][i] == duchy) { score = score + 3; };
    #####:  430:		if (state->hand[player][i] == province) { score = score + 6; };
    #####:  431:		if (state->hand[player][i] == great_hall) { score = score + 1; };
    #####:  432:		if (state->hand[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  433:	}
        -:  434:
        -:  435:	//score from discard
    #####:  436:	for (i = 0; i < state->discardCount[player]; i++)
        -:  437:	{
    #####:  438:		if (state->discard[player][i] == curse) { score = score - 1; };
    #####:  439:		if (state->discard[player][i] == estate) { score = score + 1; };
    #####:  440:		if (state->discard[player][i] == duchy) { score = score + 3; };
    #####:  441:		if (state->discard[player][i] == province) { score = score + 6; };
    #####:  442:		if (state->discard[player][i] == great_hall) { score = score + 1; };
    #####:  443:		if (state->discard[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  444:	}
        -:  445:
        -:  446:	//score from deck
    #####:  447:	for (i = 0; i < state->discardCount[player]; i++)
        -:  448:	{
    #####:  449:		if (state->deck[player][i] == curse) { score = score - 1; };
    #####:  450:		if (state->deck[player][i] == estate) { score = score + 1; };
    #####:  451:		if (state->deck[player][i] == duchy) { score = score + 3; };
    #####:  452:		if (state->deck[player][i] == province) { score = score + 6; };
    #####:  453:		if (state->deck[player][i] == great_hall) { score = score + 1; };
    #####:  454:		if (state->deck[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  455:	}
        -:  456:
    #####:  457:	return score;
        -:  458:}
        -:  459:
    #####:  460:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  461:	int i;
        -:  462:	int j;
        -:  463:	int highScore;
        -:  464:	int currentPlayer;
        -:  465:
        -:  466:	//get score for each player
    #####:  467:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  468:	{
        -:  469:		//set unused player scores to -9999
    #####:  470:		if (i >= state->numPlayers)
        -:  471:		{
    #####:  472:			players[i] = -9999;
        -:  473:		}
        -:  474:		else
        -:  475:		{
    #####:  476:			players[i] = scoreFor(i, state);
        -:  477:		}
        -:  478:	}
        -:  479:
        -:  480:	//find highest score
    #####:  481:	j = 0;
    #####:  482:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  483:	{
    #####:  484:		if (players[i] > players[j])
        -:  485:		{
    #####:  486:			j = i;
        -:  487:		}
        -:  488:	}
    #####:  489:	highScore = players[j];
        -:  490:
        -:  491:	//add 1 to players who had less turns
    #####:  492:	currentPlayer = whoseTurn(state);
    #####:  493:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  494:	{
    #####:  495:		if (players[i] == highScore && i > currentPlayer)
        -:  496:		{
    #####:  497:			players[i]++;
        -:  498:		}
        -:  499:	}
        -:  500:
        -:  501:	//find new highest score
    #####:  502:	j = 0;
    #####:  503:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  504:	{
    #####:  505:		if (players[i] > players[j])
        -:  506:		{
    #####:  507:			j = i;
        -:  508:		}
        -:  509:	}
    #####:  510:	highScore = players[j];
        -:  511:
        -:  512:	//set winners in array to 1 and rest to 0
    #####:  513:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  514:	{
    #####:  515:		if (players[i] == highScore)
        -:  516:		{
    #####:  517:			players[i] = 1;
        -:  518:		}
        -:  519:		else
        -:  520:		{
    #####:  521:			players[i] = 0;
        -:  522:		}
        -:  523:	}
        -:  524:
    #####:  525:	return 0;
        -:  526:}
        -:  527:
     1565:  528:int drawCard(int player, struct gameState *state)
        -:  529:{
        -:  530:	int count;
        -:  531:	int deckCounter;
     1565:  532:	if (state->deckCount[player] <= 0){//Deck is empty
        -:  533:
        -:  534:		//Step 1 Shuffle the discard pile back into a deck
        -:  535:		int i;
        -:  536:		//Move discard to deck
     1782:  537:		for (i = 0; i < state->discardCount[player]; i++){
     1680:  538:			state->deck[player][i] = state->discard[player][i];
     1680:  539:			state->discard[player][i] = -1;
        -:  540:		}
        -:  541:
      102:  542:		state->deckCount[player] = state->discardCount[player];
      102:  543:		state->discardCount[player] = 0;//Reset discard
        -:  544:
        -:  545:		//Shufffle the deck
      102:  546:		shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  547:
        -:  548:		if (DEBUG){//Debug statements
        -:  549:			printf("Deck count now: %d\n", state->deckCount[player]);
        -:  550:		}
        -:  551:
      102:  552:		state->discardCount[player] = 0;
        -:  553:
        -:  554:		//Step 2 Draw Card
      102:  555:		count = state->handCount[player];//Get current player's hand count
        -:  556:
        -:  557:		if (DEBUG){//Debug statements
        -:  558:			printf("Current hand count: %d\n", count);
        -:  559:		}
        -:  560:
      102:  561:		deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  562:
      102:  563:		if (deckCounter == 0)
    #####:  564:			return -1;
        -:  565:
      102:  566:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
      102:  567:		state->deckCount[player]--;
      102:  568:		state->handCount[player]++;//Increment hand count
        -:  569:	}
        -:  570:
        -:  571:	else{
     1463:  572:		int count = state->handCount[player];//Get current hand count for player
        -:  573:		int deckCounter;
        -:  574:		if (DEBUG){//Debug statements
        -:  575:			printf("Current hand count: %d\n", count);
        -:  576:		}
        -:  577:
     1463:  578:		deckCounter = state->deckCount[player];//Create holder for the deck count
     1463:  579:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
     1463:  580:		state->deckCount[player]--;
     1463:  581:		state->handCount[player]++;//Increment hand count
        -:  582:	}
        -:  583:
     1565:  584:	return 0;
        -:  585:}
        -:  586:
      974:  587:int getCost(int cardNumber)
        -:  588:{
      974:  589:	switch (cardNumber)
        -:  590:	{
        -:  591:	case curse:
       85:  592:		return 0;
        -:  593:	case estate:
       47:  594:		return 2;
        -:  595:	case duchy:
       69:  596:		return 5;
        -:  597:	case province:
       37:  598:		return 8;
        -:  599:	case copper:
       82:  600:		return 0;
        -:  601:	case silver:
       55:  602:		return 3;
        -:  603:	case gold:
       39:  604:		return 6;
        -:  605:	case adventurer:
       32:  606:		return 6;
        -:  607:	case council_room:
       47:  608:		return 5;
        -:  609:	case feast:
       15:  610:		return 4;
        -:  611:	case gardens:
    #####:  612:		return 4;
        -:  613:	case mine:
       34:  614:		return 5;
        -:  615:	case remodel:
       15:  616:		return 4;
        -:  617:	case smithy:
    #####:  618:		return 4;
        -:  619:	case village:
       55:  620:		return 3;
        -:  621:	case baron:
       34:  622:		return 4;
        -:  623:	case great_hall:
       70:  624:		return 3;
        -:  625:	case minion:
    #####:  626:		return 5;
        -:  627:	case steward:
       20:  628:		return 3;
        -:  629:	case tribute:
       27:  630:		return 5;
        -:  631:	case ambassador:
       27:  632:		return 3;
        -:  633:	case cutpurse:
       38:  634:		return 4;
        -:  635:	case embargo:
       22:  636:		return 2;
        -:  637:	case outpost:
       15:  638:		return 5;
        -:  639:	case salvager:
       21:  640:		return 4;
        -:  641:	case sea_hag:
       50:  642:		return 4;
        -:  643:	case treasure_map:
       38:  644:		return 4;
        -:  645:	}
        -:  646:
    #####:  647:	return -1;
        -:  648:}
        -:  649:
        4:  650:void playAdventurer(struct gameState *state, int currentPlayer)
        -:  651:// Reveal cards from deck until 2 Treasure cards are found.  Put those Treasure cards in the hand and discard the rest.
        -:  652:{
        4:  653:	int drawntreasure = 0;
        -:  654:	int temphand[MAX_HAND];
        -:  655:	int cardDrawn;
        4:  656:	int z = 0; // this is the counter for the temp hand
        -:  657:
       24:  658:	while (drawntreasure < 2){
       16:  659:		if (state->deckCount[currentPlayer] < 1){//if the deck is empty we need to shuffle discard and add to deck
        1:  660:			shuffle(currentPlayer, state);
        -:  661:		}
       16:  662:		drawCard(currentPlayer, state);
       16:  663:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer] - 1];//top card of hand is most recently drawn card.
       16:  664:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
        8:  665:			drawntreasure++;
        -:  666:		else{
        8:  667:			temphand[z] = cardDrawn;
        8:  668:			state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
        8:  669:			z++;
        -:  670:		}
        -:  671:	}
       16:  672:	while (z - 1 >= 0){
        8:  673:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; // discard all cards in play that have been drawn
        8:  674:		z = z - 1;
        -:  675:	}
        4:  676:}
        -:  677:
        1:  678:int playRemodel(struct gameState *state, int currentPlayer, int choice1, int choice2, int handPos)
        -:  679://Trash a card in the hand, and gain a card costing up to $2 more than the trashed card
        -:  680:{
        -:  681:	int i;
        1:  682:	int j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  683:
        1:  684:	if ((getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2))
        -:  685:	{
    #####:  686:		return -1;
        -:  687:	}
        -:  688:
        1:  689:	gainCard(choice2, state, 0, currentPlayer);
        -:  690:
        -:  691:	//discard card from hand
        1:  692:	discardCard(handPos, currentPlayer, state, 0);
        -:  693:
        -:  694:	//discard trashed card
        5:  695:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  696:	{
        4:  697:		if (state->hand[currentPlayer][i] == j)
        -:  698:		{
    #####:  699:			discardCard(i, currentPlayer, state, 0);
    #####:  700:			break;
        -:  701:		}
        -:  702:	}
        -:  703:
        1:  704:	return 0;
        -:  705:}
        -:  706:
    #####:  707:void playSmithy(struct gameState *state, int currentPlayer, int handPos)
        -:  708:// Draw 3 cards
        -:  709:{
        -:  710:	int i;
    #####:  711:	for (i = 0; i < 3; i++)
        -:  712:	{
    #####:  713:		drawCard(currentPlayer, state);
        -:  714:	}
        -:  715:
        -:  716:	//discard card from hand
    #####:  717:	discardCard(handPos, currentPlayer, state, 0);
    #####:  718:}
        -:  719:
        7:  720:void playBaron(struct gameState *state, int currentPlayer, int choice1, int handPos)
        -:  721://Add a buy.  OPTION:  Discard an Estate card and gain $4.  Otherwise, gain an Estate card.
        -:  722:{
        7:  723:	state->numBuys++;//Increase buys by 1!
        7:  724:	if (choice1 > 0){//Boolean true or going to discard an estate
        7:  725:		int p = 0;//Iterator for hand!
        7:  726:		int card_not_discarded = 1;//Flag for discard set!
       51:  727:		while (card_not_discarded){
       37:  728:			if (state->hand[currentPlayer][p] == estate){ //Found an estate card!
        3:  729:				state->coins += 4;//Add 4 coins to the amount of coins
        3:  730:				state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
        3:  731:				state->discardCount[currentPlayer]++;
       12:  732:				for (; p < state->handCount[currentPlayer]; p++){
        9:  733:					state->hand[currentPlayer][p] = state->hand[currentPlayer][p + 1];
        -:  734:				}
        3:  735:				state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
        3:  736:				state->handCount[currentPlayer]--;
        3:  737:				card_not_discarded = 0;//Exit the loop
        -:  738:			}
       34:  739:			else if (p > state->handCount[currentPlayer]){
        -:  740:				if (DEBUG) {
        -:  741:					printf("No estate cards in your hand, invalid choice\n");
        -:  742:					printf("Must gain an estate if there are any\n");
        -:  743:				}
        4:  744:				if (supplyCount(estate, state) > 0){
        1:  745:					gainCard(estate, state, 1, currentPlayer);
        1:  746:					state->supplyCount[estate]--;//Decrement estates
        1:  747:					if (supplyCount(estate, state) == 0){
    #####:  748:						isGameOver(state);
        -:  749:					}
        -:  750:				}
        4:  751:				card_not_discarded = 0;//Exit the loop
        -:  752:			}
        -:  753:
        -:  754:			else{
       30:  755:				p++;//Next card
        -:  756:			}
        -:  757:		}
        -:  758:	}
        -:  759:
        -:  760:	else{
    #####:  761:		if (supplyCount(estate, state) > 0){
    #####:  762:			gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  763:			state->supplyCount[estate]--;//Decrement Estates
    #####:  764:			if (supplyCount(estate, state) == 0){
    #####:  765:				isGameOver(state);
        -:  766:			}
        -:  767:		}
        -:  768:	}
        7:  769:}
        -:  770:
        5:  771:int playTreasureMap(struct gameState *state, int currentPlayer, int handPos)
        -:  772://Trashing two treasure map cards from the hand = four gold on top of the deck.
        -:  773:{
        -:  774:	int i;
        -:  775:	int index;
        -:  776:
        -:  777:	//search hand for another treasure_map
       30:  778:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  779:	{
       25:  780:		if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -:  781:		{
    #####:  782:			index = i;
    #####:  783:			break;
        -:  784:		}
        -:  785:	}
        5:  786:	if (index > -1)
        -:  787:	{
        -:  788:		//trash both treasure cards
        5:  789:		discardCard(handPos, currentPlayer, state, 1);
        5:  790:		discardCard(index, currentPlayer, state, 1);
        -:  791:
        -:  792:		//gain 4 Gold cards
       25:  793:		for (i = 0; i < 4; i++)
        -:  794:		{
       20:  795:			gainCard(gold, state, 1, currentPlayer);
        -:  796:		}
        -:  797:
        -:  798:		//return success
        5:  799:		return 1;
        -:  800:	}
        -:  801:
        -:  802:	//no second treasure_map found in hand
    #####:  803:	return -1;
        -:  804:}
        -:  805:
      116:  806:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  807:{
        -:  808:	int i;
        -:  809:	int j;
        -:  810:	int k;
        -:  811:	//int x;  //Unused after while loop removed from feast.
      116:  812:	int currentPlayer = whoseTurn(state);
      116:  813:	int nextPlayer = currentPlayer + 1;
        -:  814:	int temphand[MAX_HAND];
        -:  815:
      116:  816:	int tributeRevealedCards[2] = { -1, -1 };
        -:  817:
      116:  818:	if (nextPlayer > (state->numPlayers - 1)){
       28:  819:		nextPlayer = 0;
        -:  820:	}
        -:  821:
        -:  822:	//uses switch to select card and perform actions
      116:  823:	switch (card)
        -:  824:	{
        -:  825:	case adventurer:
        -:  826:
        4:  827:		playAdventurer(state, currentPlayer);
        4:  828:		return 0;
        -:  829:
        -:  830:	case council_room:
        -:  831:		//+4 Cards
        5:  832:		for (i = 0; i < 4; i++)
        -:  833:		{
        4:  834:			drawCard(currentPlayer, state);
        -:  835:		}
        -:  836:
        -:  837:		//+1 Buy
        1:  838:		state->numBuys++;
        -:  839:
        -:  840:		//Each other player draws a card
        5:  841:		for (i = 0; i < state->numPlayers; i++)
        -:  842:		{
        4:  843:			if (i != currentPlayer)
        -:  844:			{
        3:  845:				drawCard(i, state);
        -:  846:			}
        -:  847:		}
        -:  848:
        -:  849:		//put played card in played card pile
        1:  850:		discardCard(handPos, currentPlayer, state, 0);
        -:  851:
        1:  852:		return 0;
        -:  853:
        -:  854:	case feast:
        -:  855:		//gain card with cost up to 5
        -:  856:		//Backup hand
        7:  857:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
        6:  858:			temphand[i] = state->hand[currentPlayer][i];//Backup card
        6:  859:			state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  860:		}
        -:  861:		//Backup hand
        -:  862:
        -:  863:		//Update Coins for Buy
        1:  864:		updateCoins(currentPlayer, state, 5);
        -:  865://		x = 1;//Condition to loop on
        -:  866://		while (x == 1) {//Buy one card
        1:  867:			if (supplyCount(choice1, state) <= 0){
        -:  868:				if (DEBUG)
        -:  869:					printf("None of that card left, sorry!\n");
        -:  870:
        -:  871:				if (DEBUG){
        -:  872:					printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  873:				}
        -:  874:			}
    #####:  875:			else if (state->coins < getCost(choice1)){
    #####:  876:				printf("That card is too expensive!\n");
        -:  877:
        -:  878:				if (DEBUG){
        -:  879:					printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  880:				}
        -:  881:			}
        -:  882:			else{
        -:  883:
        -:  884:				if (DEBUG){
        -:  885:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  886:				}
        -:  887:
    #####:  888:				gainCard(choice1, state, 0, currentPlayer);//Gain the card
        -:  889://				x = 0;//No more buying cards
        -:  890:
        -:  891:				if (DEBUG){
        -:  892:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  893:				}
        -:  894:
        -:  895:			}
        -:  896://		}
        -:  897:
        -:  898:		//Reset Hand
        7:  899:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
        6:  900:			state->hand[currentPlayer][i] = temphand[i];
        6:  901:			temphand[i] = -1;
        -:  902:		}
        -:  903:		//Reset Hand
        -:  904:
        1:  905:		return 0;
        -:  906:
        -:  907:	case gardens:
    #####:  908:		return -1;
        -:  909:
        -:  910:	case mine:
       13:  911:		j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  912:
       13:  913:		if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  914:		{
       13:  915:			return -1;
        -:  916:		}
        -:  917:
    #####:  918:		if (choice2 > treasure_map || choice2 < curse)
        -:  919:		{
    #####:  920:			return -1;
        -:  921:		}
        -:  922:
    #####:  923:		if ((getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2))
        -:  924:		{
    #####:  925:			return -1;
        -:  926:		}
        -:  927:
    #####:  928:		gainCard(choice2, state, 2, currentPlayer);
        -:  929:
        -:  930:		//discard card from hand
    #####:  931:		discardCard(handPos, currentPlayer, state, 0);
        -:  932:
        -:  933:		//discard trashed card
    #####:  934:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  935:		{
    #####:  936:			if (state->hand[currentPlayer][i] == j)
        -:  937:			{
    #####:  938:				discardCard(i, currentPlayer, state, 0);
    #####:  939:				break;
        -:  940:			}
        -:  941:		}
        -:  942:
    #####:  943:		return 0;
        -:  944:
        -:  945:	case remodel:
        -:  946:
        1:  947:		return playRemodel(state, currentPlayer, choice1, choice2, handPos);
        -:  948:
        -:  949:	case smithy:
        -:  950:
    #####:  951:		playSmithy(state, currentPlayer, handPos);
    #####:  952:		return 0;
        -:  953:
        -:  954:	case village:
        -:  955:		//+1 Card
        9:  956:		drawCard(currentPlayer, state);
        -:  957:
        -:  958:		//+2 Actions
        9:  959:		state->numActions = state->numActions + 2;
        -:  960:
        -:  961:		//discard played card from hand
        9:  962:		discardCard(handPos, currentPlayer, state, 0);
        9:  963:		return 0;
        -:  964:
        -:  965:	case baron:
        -:  966:
        7:  967:		playBaron(state, currentPlayer, choice1, handPos);
        7:  968:		return 0;
        -:  969:
        -:  970:	case great_hall:
        -:  971:		//+1 Card
       17:  972:		drawCard(currentPlayer, state);
        -:  973:
        -:  974:		//+1 Actions
       17:  975:		state->numActions++;
        -:  976:
        -:  977:		//discard card from hand
       17:  978:		discardCard(handPos, currentPlayer, state, 0);
       17:  979:		return 0;
        -:  980:
        -:  981:	case minion:
        -:  982:		//+1 action
    #####:  983:		state->numActions++;
        -:  984:
        -:  985:		//discard card from hand
    #####:  986:		discardCard(handPos, currentPlayer, state, 0);
        -:  987:
    #####:  988:		if (choice1)		//+2 coins
        -:  989:		{
    #####:  990:			state->coins = state->coins + 2;
        -:  991:		}
        -:  992:
    #####:  993:		else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  994:		{
        -:  995:			//discard hand
    #####:  996:			while (numHandCards(state) > 0)
        -:  997:			{
    #####:  998:				discardCard(handPos, currentPlayer, state, 0);
        -:  999:			}
        -: 1000:
        -: 1001:			//draw 4
    #####: 1002:			for (i = 0; i < 4; i++)
        -: 1003:			{
    #####: 1004:				drawCard(currentPlayer, state);
        -: 1005:			}
        -: 1006:
        -: 1007:			//other players discard hand and redraw if hand size > 4
    #####: 1008:			for (i = 0; i < state->numPlayers; i++)
        -: 1009:			{
    #####: 1010:				if (i != currentPlayer)
        -: 1011:				{
    #####: 1012:					if (state->handCount[i] > 4)
        -: 1013:					{
        -: 1014:						//discard hand
    #####: 1015:						while (state->handCount[i] > 0)
        -: 1016:						{
    #####: 1017:							discardCard(handPos, i, state, 0);
        -: 1018:						}
        -: 1019:
        -: 1020:						//draw 4
    #####: 1021:						for (j = 0; j < 4; j++)
        -: 1022:						{
    #####: 1023:							drawCard(i, state);
        -: 1024:						}
        -: 1025:					}
        -: 1026:				}
        -: 1027:			}
        -: 1028:
        -: 1029:		}
    #####: 1030:		return 0;
        -: 1031:
        -: 1032:	case steward:
        2: 1033:		if (choice1 == 1)
        -: 1034:		{
        -: 1035:			//+2 cards
    #####: 1036:			drawCard(currentPlayer, state);
    #####: 1037:			drawCard(currentPlayer, state);
        -: 1038:		}
        2: 1039:		else if (choice1 == 2)
        -: 1040:		{
        -: 1041:			//+2 coins
    #####: 1042:			state->coins = state->coins + 2;
        -: 1043:		}
        -: 1044:		else
        -: 1045:		{
        -: 1046:			//trash 2 cards in hand
        2: 1047:			discardCard(choice2, currentPlayer, state, 1);
        2: 1048:			discardCard(choice3, currentPlayer, state, 1);
        -: 1049:		}
        -: 1050:
        -: 1051:		//discard card from hand
        2: 1052:		discardCard(handPos, currentPlayer, state, 0);
        2: 1053:		return 0;
        -: 1054:
        -: 1055:	case tribute:
        8: 1056:		if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####: 1057:			if (state->deckCount[nextPlayer] > 0){
    #####: 1058:				tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1059:				state->deckCount[nextPlayer]--;
        -: 1060:			}
    #####: 1061:			else if (state->discardCount[nextPlayer] > 0){
    #####: 1062:				tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer] - 1];
    #####: 1063:				state->discardCount[nextPlayer]--;
        -: 1064:			}
        -: 1065:			else{
        -: 1066:				//No Card to Reveal
        -: 1067:				if (DEBUG){
        -: 1068:					printf("No cards to reveal\n");
        -: 1069:				}
        -: 1070:			}
        -: 1071:		}
        -: 1072:
        -: 1073:		else{
        8: 1074:			if (state->deckCount[nextPlayer] == 0){
    #####: 1075:				for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####: 1076:					state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1077:					state->deckCount[nextPlayer]++;
    #####: 1078:					state->discard[nextPlayer][i] = -1;
    #####: 1079:					state->discardCount[nextPlayer]--;
        -: 1080:				}
        -: 1081:
    #####: 1082:				shuffle(nextPlayer, state);//Shuffle the deck
        -: 1083:			}
        8: 1084:			tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
        8: 1085:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
        8: 1086:			state->deckCount[nextPlayer]--;
        8: 1087:			tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
        8: 1088:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
        8: 1089:			state->deckCount[nextPlayer]--;
        -: 1090:		}
        -: 1091:
        8: 1092:		if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
        3: 1093:			state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
        3: 1094:			state->playedCardCount++;
        3: 1095:			tributeRevealedCards[1] = -1;
        -: 1096:		}
        -: 1097:
       32: 1098:		for (i = 0; i <= 2; i++){
       24: 1099:			if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
       13: 1100:				state->coins += 2;
        -: 1101:			}
        -: 1102:
       11: 1103:			else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
        3: 1104:				drawCard(currentPlayer, state);
        3: 1105:				drawCard(currentPlayer, state);
        -: 1106:			}
        -: 1107:			else{//Action Card
        8: 1108:				state->numActions = state->numActions + 2;
        -: 1109:			}
        -: 1110:		}
        -: 1111:
        8: 1112:		return 0;
        -: 1113:
        -: 1114:	case ambassador:
       17: 1115:		j = 0;		//used to check if player has enough cards to discard
        -: 1116:
       17: 1117:		if (choice2 > 2 || choice2 < 0)
        -: 1118:		{
       15: 1119:			return -1;
        -: 1120:		}
        -: 1121:
        2: 1122:		if (choice1 == handPos)
        -: 1123:		{
    #####: 1124:			return -1;
        -: 1125:		}
        -: 1126:
       12: 1127:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1128:		{
       10: 1129:			if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1130:			{
        2: 1131:				j++;
        -: 1132:			}
        -: 1133:		}
        2: 1134:		if (j < choice2)
        -: 1135:		{
        1: 1136:			return -1;
        -: 1137:		}
        -: 1138:
        -: 1139:		if (DEBUG)
        -: 1140:			printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1141:
        -: 1142:		//increase supply count for choosen card by amount being discarded
        1: 1143:		state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1144:
        -: 1145:		//each other player gains a copy of revealed card
        5: 1146:		for (i = 0; i < state->numPlayers; i++)
        -: 1147:		{
        4: 1148:			if (i != currentPlayer)
        -: 1149:			{
        3: 1150:				gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1151:			}
        -: 1152:		}
        -: 1153:
        -: 1154:		//discard played card from hand
        1: 1155:		discardCard(handPos, currentPlayer, state, 0);
        -: 1156:
        -: 1157:		//trash copies of cards returned to supply
        1: 1158:		for (j = 0; j < choice2; j++)
        -: 1159:		{
    #####: 1160:			for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1161:			{
    #####: 1162:				if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1163:				{
    #####: 1164:					discardCard(i, currentPlayer, state, 1);
    #####: 1165:					break;
        -: 1166:				}
        -: 1167:			}
        -: 1168:		}
        -: 1169:
        1: 1170:		return 0;
        -: 1171:
        -: 1172:	case cutpurse:
        -: 1173:
        3: 1174:		updateCoins(currentPlayer, state, 2);
       15: 1175:		for (i = 0; i < state->numPlayers; i++)
        -: 1176:		{
       12: 1177:			if (i != currentPlayer)
        -: 1178:			{
        9: 1179:				for (j = 0; j < state->handCount[i]; j++)
        -: 1180:				{
    #####: 1181:					if (state->hand[i][j] == copper)
        -: 1182:					{
    #####: 1183:						discardCard(j, i, state, 0);
    #####: 1184:						break;
        -: 1185:					}
    #####: 1186:					if (j == state->handCount[i])
        -: 1187:					{
    #####: 1188:						for (k = 0; k < state->handCount[i]; k++)
        -: 1189:						{
        -: 1190:							if (DEBUG)
        -: 1191:								printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1192:						}
    #####: 1193:						break;
        -: 1194:					}
        -: 1195:				}
        -: 1196:
        -: 1197:			}
        -: 1198:
        -: 1199:		}
        -: 1200:
        -: 1201:		//discard played card from hand
        3: 1202:		discardCard(handPos, currentPlayer, state, 0);
        -: 1203:
        3: 1204:		return 0;
        -: 1205:
        -: 1206:
        -: 1207:	case embargo:
        -: 1208:		//+2 Coins
       14: 1209:		state->coins = state->coins + 2;
        -: 1210:
        -: 1211:		//see if selected pile is in play
       14: 1212:		if (state->supplyCount[choice1] == -1)
        -: 1213:		{
        6: 1214:			return -1;
        -: 1215:		}
        -: 1216:
        -: 1217:		//add embargo token to selected supply pile
        8: 1218:		state->embargoTokens[choice1]++;
        -: 1219:
        -: 1220:		//trash card
        8: 1221:		discardCard(handPos, currentPlayer, state, 1);
        8: 1222:		return 0;
        -: 1223:
        -: 1224:	case outpost:
        -: 1225:		//set outpost flag
    #####: 1226:		state->outpostPlayed++;
        -: 1227:
        -: 1228:		//discard card
    #####: 1229:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1230:		return 0;
        -: 1231:
        -: 1232:	case salvager:
        -: 1233:		//+1 buy
        2: 1234:		state->numBuys++;
        -: 1235:
        2: 1236:		if (choice1)
        -: 1237:		{
        -: 1238:			//gain coins equal to trashed card
        2: 1239:			state->coins = state->coins + getCost(handCard(choice1, state));
        -: 1240:			//trash card
        2: 1241:			discardCard(choice1, currentPlayer, state, 1);
        -: 1242:		}
        -: 1243:
        -: 1244:		//discard card
        2: 1245:		discardCard(handPos, currentPlayer, state, 0);
        2: 1246:		return 0;
        -: 1247:
        -: 1248:	case sea_hag:
       60: 1249:		for (i = 0; i < state->numPlayers; i++){
       48: 1250:			if (i != currentPlayer){
       36: 1251:				state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
       36: 1252:				state->discardCount[i]++;
       36: 1253:				state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1254:			}
        -: 1255:		}
       12: 1256:		return 0;
        -: 1257:
        -: 1258:	case treasure_map:
        -: 1259:
        5: 1260:		return playTreasureMap(state, currentPlayer, handPos);
        -: 1261:	}
    #####: 1262:	return -1;
        -: 1263:}
        -: 1264:
       60: 1265:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1266:{
        -: 1267:
        -: 1268:	//if card is not trashed, added to Played pile 
       60: 1269:	if (trashFlag < 1)
        -: 1270:	{
        -: 1271:		//add card to played pile
       36: 1272:		state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
       36: 1273:		state->playedCardCount++;
        -: 1274:	}
        -: 1275:
        -: 1276:	//set played card to -1
       60: 1277:	state->hand[currentPlayer][handPos] = -1;
        -: 1278:
        -: 1279:	//remove card from player's hand
       60: 1280:	if (handPos == (state->handCount[currentPlayer] - 1)) 	//last card in hand array is played
        -: 1281:	{
        -: 1282:		//reduce number of cards in hand
        5: 1283:		state->handCount[currentPlayer]--;
        -: 1284:	}
       55: 1285:	else if (state->handCount[currentPlayer] == 1) //only one card in hand
        -: 1286:	{
        -: 1287:		//reduce number of cards in hand
    #####: 1288:		state->handCount[currentPlayer]--;
        -: 1289:	}
        -: 1290:	else
        -: 1291:	{
        -: 1292:		//replace discarded card with last card in hand
       55: 1293:		state->hand[currentPlayer][handPos] = state->hand[currentPlayer][(state->handCount[currentPlayer] - 1)];
        -: 1294:		//set last card to -1
       55: 1295:		state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1296:		//reduce number of cards in hand
       55: 1297:		state->handCount[currentPlayer]--;
        -: 1298:	}
        -: 1299:
       60: 1300:	return 0;
        -: 1301:}
        -: 1302:
      260: 1303:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1304:{
        -: 1305:	//Note: supplyPos is enum of choosen card
        -: 1306:
        -: 1307:	//check if supply pile is empty (0) or card is not used in game (-1)
      260: 1308:	if (supplyCount(supplyPos, state) < 1)
        -: 1309:	{
        1: 1310:		return -1;
        -: 1311:	}
        -: 1312:
        -: 1313:	//added card for [whoseTurn] current player:
        -: 1314:	// toFlag = 0 : add to discard
        -: 1315:	// toFlag = 1 : add to deck
        -: 1316:	// toFlag = 2 : add to hand
        -: 1317:
      259: 1318:	if (toFlag == 1)
        -: 1319:	{
       21: 1320:		state->deck[player][state->deckCount[player]] = supplyPos;
       21: 1321:		state->deckCount[player]++;
        -: 1322:	}
      238: 1323:	else if (toFlag == 2)
        -: 1324:	{
    #####: 1325:		state->hand[player][state->handCount[player]] = supplyPos;
    #####: 1326:		state->handCount[player]++;
        -: 1327:	}
        -: 1328:	else
        -: 1329:	{
      238: 1330:		state->discard[player][state->discardCount[player]] = supplyPos;
      238: 1331:		state->discardCount[player]++;
        -: 1332:	}
        -: 1333:
        -: 1334:	//decrease number in supply pile
      259: 1335:	state->supplyCount[supplyPos]--;
        -: 1336:
      259: 1337:	return 0;
        -: 1338:}
        -: 1339:
      387: 1340:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1341:{
        -: 1342:	int i;
        -: 1343:
        -: 1344:	//reset coin count
      387: 1345:	state->coins = 0;
        -: 1346:
        -: 1347:	//add coins for each Treasure card in player's hand
     2303: 1348:	for (i = 0; i < state->handCount[player]; i++)
        -: 1349:	{
     1916: 1350:		if (state->hand[player][i] == copper)
        -: 1351:		{
      831: 1352:			state->coins += 1;
        -: 1353:		}
     1085: 1354:		else if (state->hand[player][i] == silver)
        -: 1355:		{
       36: 1356:			state->coins += 2;
        -: 1357:		}
     1049: 1358:		else if (state->hand[player][i] == gold)
        -: 1359:		{
      113: 1360:			state->coins += 3;
        -: 1361:		}
        -: 1362:	}
        -: 1363:
        -: 1364:	//add bonus
      387: 1365:	state->coins += bonus;
        -: 1366:
      387: 1367:	return 0;
        -: 1368:}
        -: 1369:
        -: 1370:
        -: 1371://end of dominion.c
File 'dominion.c'
Lines executed:69.30% of 557
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
     3928:    8:int compare(const void* a, const void* b) {
     3928:    9:	if (*(int*)a > *(int*)b)
     1361:   10:		return 1;
     2567:   11:	if (*(int*)a < *(int*)b)
     1301:   12:		return -1;
     1266:   13:	return 0;
        -:   14:}
        -:   15:
        4:   16:struct gameState* newGame() {
        4:   17:	struct gameState* g = malloc(sizeof(struct gameState));
        4:   18:	return g;
        -:   19:}
        -:   20:
        4:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:	int k8, int k9, int k10) {
        4:   23:	int* k = malloc(10 * sizeof(int));
        4:   24:	k[0] = k1;
        4:   25:	k[1] = k2;
        4:   26:	k[2] = k3;
        4:   27:	k[3] = k4;
        4:   28:	k[4] = k5;
        4:   29:	k[5] = k6;
        4:   30:	k[6] = k7;
        4:   31:	k[7] = k8;
        4:   32:	k[8] = k9;
        4:   33:	k[9] = k10;
        4:   34:	return k;
        -:   35:}
        -:   36:
        4:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		struct gameState *state) {
        -:   39:
        -:   40:	int i;
        -:   41:	int j;
        -:   42:	int it;
        -:   43:	//set up random number generator
        4:   44:	SelectStream(1);
        4:   45:	PutSeed((long)randomSeed);
        -:   46:
        -:   47:	//check number of players
        4:   48:	if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:	{
    #####:   50:		return -1;
        -:   51:	}
        -:   52:
        -:   53:	//set number of players
        4:   54:	state->numPlayers = numPlayers;
        -:   55:
        -:   56:	//check selected kingdom cards are different
       25:   57:	for (i = 0; i < 10; i++)
        -:   58:	{
      242:   59:		for (j = 0; j < 10; j++)
        -:   60:		{
      221:   61:			if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:			{
        2:   63:				return -1;
        -:   64:			}
        -:   65:		}
        -:   66:	}
        -:   67:
        -:   68:
        -:   69:	//initialize supply
        -:   70:	///////////////////////////////
        -:   71:
        -:   72:	//set number of Curse cards
        2:   73:	if (numPlayers == 2)
        -:   74:	{
        1:   75:		state->supplyCount[curse] = 10;
        -:   76:	}
        1:   77:	else if (numPlayers == 3)
        -:   78:	{
    #####:   79:		state->supplyCount[curse] = 20;
        -:   80:	}
        -:   81:	else
        -:   82:	{
        1:   83:		state->supplyCount[curse] = 30;
        -:   84:	}
        -:   85:
        -:   86:	//set number of Victory cards
        2:   87:	if (numPlayers == 2)
        -:   88:	{
        1:   89:		state->supplyCount[estate] = 8;
        1:   90:		state->supplyCount[duchy] = 8;
        1:   91:		state->supplyCount[province] = 8;
        -:   92:	}
        -:   93:	else
        -:   94:	{
        1:   95:		state->supplyCount[estate] = 12;
        1:   96:		state->supplyCount[duchy] = 12;
        1:   97:		state->supplyCount[province] = 12;
        -:   98:	}
        -:   99:
        -:  100:	//set number of Treasure cards
        2:  101:	state->supplyCount[copper] = 60 - (7 * numPlayers);
        2:  102:	state->supplyCount[silver] = 40;
        2:  103:	state->supplyCount[gold] = 30;
        -:  104:
        -:  105:	//set number of Kingdom cards
       42:  106:	for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:	{
      330:  108:		for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:		{
      310:  110:			if (kingdomCards[j] == i)
        -:  111:			{
        -:  112:				//check if card is a 'Victory' Kingdom card
       20:  113:				if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:				{
        2:  115:					if (numPlayers == 2){
    #####:  116:						state->supplyCount[i] = 8;
        -:  117:					}
        1:  118:					else{ state->supplyCount[i] = 12; }
        -:  119:				}
        -:  120:				else
        -:  121:				{
       19:  122:					state->supplyCount[i] = 10;
        -:  123:				}
       20:  124:				break;
        -:  125:			}
        -:  126:			else    //card is not in the set choosen for the game
        -:  127:			{
      290:  128:				state->supplyCount[i] = -1;
        -:  129:			}
        -:  130:		}
        -:  131:
        -:  132:	}
        -:  133:
        -:  134:	////////////////////////
        -:  135:	//supply intilization complete
        -:  136:
        -:  137:	//set player decks
        8:  138:	for (i = 0; i < numPlayers; i++)
        -:  139:	{
        6:  140:		state->deckCount[i] = 0;
       24:  141:		for (j = 0; j < 3; j++)
        -:  142:		{
       18:  143:			state->deck[i][j] = estate;
       18:  144:			state->deckCount[i]++;
        -:  145:		}
       48:  146:		for (j = 3; j < 10; j++)
        -:  147:		{
       42:  148:			state->deck[i][j] = copper;
       42:  149:			state->deckCount[i]++;
        -:  150:		}
        -:  151:	}
        -:  152:
        -:  153:	//shuffle player decks
        8:  154:	for (i = 0; i < numPlayers; i++)
        -:  155:	{
        6:  156:		if (shuffle(i, state) < 0)
        -:  157:		{
    #####:  158:			return -1;
        -:  159:		}
        -:  160:	}
        -:  161:
        -:  162:	//draw player hands
        8:  163:	for (i = 0; i < numPlayers; i++)
        -:  164:	{
        -:  165:		//initialize hand size to zero
        6:  166:		state->handCount[i] = 0;
        6:  167:		state->discardCount[i] = 0;
        -:  168:		//draw 5 cards
        -:  169:		// for (j = 0; j < 5; j++)
        -:  170:		//	{
        -:  171:		//	  drawCard(i, state);
        -:  172:		//	}
        -:  173:	}
        -:  174:
        -:  175:	//set embargo tokens to 0 for all supply piles
       56:  176:	for (i = 0; i <= treasure_map; i++)
        -:  177:	{
       54:  178:		state->embargoTokens[i] = 0;
        -:  179:	}
        -:  180:
        -:  181:	//initialize first player's turn
        2:  182:	state->outpostPlayed = 0;
        2:  183:	state->phase = 0;
        2:  184:	state->numActions = 1;
        2:  185:	state->numBuys = 1;
        2:  186:	state->playedCardCount = 0;
        2:  187:	state->whoseTurn = 0;
        2:  188:	state->handCount[state->whoseTurn] = 0;
        -:  189:	//int it; move to top
        -:  190:
        -:  191:	//Moved draw cards to here, only drawing at the start of a turn
       12:  192:	for (it = 0; it < 5; it++){
       10:  193:		drawCard(state->whoseTurn, state);
        -:  194:	}
        -:  195:
        2:  196:	updateCoins(state->whoseTurn, state, 0);
        -:  197:
        2:  198:	return 0;
        -:  199:}
        -:  200:
       72:  201:int shuffle(int player, struct gameState *state) {
        -:  202:
        -:  203:
        -:  204:	int newDeck[MAX_DECK];
       72:  205:	int newDeckPos = 0;
        -:  206:	int card;
        -:  207:	int i;
        -:  208:
       72:  209:	if (state->deckCount[player] < 1)
    #####:  210:		return -1;
       72:  211:	qsort((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
        -:  212:	/* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
     1732:  214:	while (state->deckCount[player] > 0) {
     1588:  215:		card = floor(Random() * state->deckCount[player]);
     1588:  216:		newDeck[newDeckPos] = state->deck[player][card];
     1588:  217:		newDeckPos++;
    11829:  218:		for (i = card; i < state->deckCount[player] - 1; i++) {
    10241:  219:			state->deck[player][i] = state->deck[player][i + 1];
        -:  220:		}
     1588:  221:		state->deckCount[player]--;
        -:  222:	}
     1660:  223:	for (i = 0; i < newDeckPos; i++) {
     1588:  224:		state->deck[player][i] = newDeck[i];
     1588:  225:		state->deckCount[player]++;
        -:  226:	}
        -:  227:
       72:  228:	return 0;
        -:  229:}
        -:  230:
     1167:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state)
        -:  232:{
        -:  233:	int card;
     1167:  234:	int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:	//check if it is the right phase
     1167:  237:	if (state->phase != 0)
        -:  238:	{
      213:  239:		return -1;
        -:  240:	}
        -:  241:
        -:  242:	//check if player has enough actions
      954:  243:	if (state->numActions < 1)
        -:  244:	{
       57:  245:		return -1;
        -:  246:	}
        -:  247:
        -:  248:	//get card played
      897:  249:	card = handCard(handPos, state);
        -:  250:
        -:  251:	//check if selected card is an action
      897:  252:	if (card < adventurer || card > treasure_map)
        -:  253:	{
      810:  254:		return -1;
        -:  255:	}
        -:  256:
        -:  257:	//play card
       87:  258:	if (cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0)
        -:  259:	{
       17:  260:		return -1;
        -:  261:	}
        -:  262:
        -:  263:	//reduce number of actions
       70:  264:	state->numActions--;
        -:  265:
        -:  266:	//update coins (Treasure cards may be added with card draws)
       70:  267:	updateCoins(state->whoseTurn, state, coin_bonus);
        -:  268:
       70:  269:	return 0;
        -:  270:}
        -:  271:
     1199:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:	int who;
        -:  274:	if (DEBUG){
        -:  275:		printf("Entering buyCard...\n");
        -:  276:	}
        -:  277:
        -:  278:	// I don't know what to do about the phase thing.
        -:  279:
     1199:  280:	who = state->whoseTurn;
        -:  281:
     1199:  282:	if (state->numBuys < 1){
        -:  283:		if (DEBUG)
        -:  284:			printf("You do not have any buys left\n");
      229:  285:		return -1;
        -:  286:	}
      970:  287:	else if (supplyCount(supplyPos, state) < 1){
        -:  288:		if (DEBUG)
        -:  289:			printf("There are not any of that type of card left\n");
      403:  290:		return -1;
        -:  291:	}
      567:  292:	else if (state->coins < getCost(supplyPos)){
        -:  293:		if (DEBUG)
        -:  294:			printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
      332:  295:		return -1;
        -:  296:	}
        -:  297:	else {
      235:  298:		state->phase = 1;
        -:  299:		//state->supplyCount[supplyPos]--;
      235:  300:		gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  301:
      235:  302:		state->coins = (state->coins) - (getCost(supplyPos));
      235:  303:		state->numBuys--;
        -:  304:		if (DEBUG)
        -:  305:			printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  306:	}
        -:  307:
        -:  308:	//state->discard[who][state->discardCount[who]] = supplyPos;
        -:  309:	//state->discardCount[who]++;
        -:  310:
      235:  311:	return 0;
        -:  312:}
        -:  313:
    #####:  314:int numHandCards(struct gameState *state) {
    #####:  315:	return state->handCount[whoseTurn(state)];
        -:  316:}
        -:  317:
      898:  318:int handCard(int handPos, struct gameState *state) {
      898:  319:	int currentPlayer = whoseTurn(state);
      898:  320:	return state->hand[currentPlayer][handPos];
        -:  321:}
        -:  322:
     1263:  323:int supplyCount(int card, struct gameState *state) {
     1263:  324:	return state->supplyCount[card];
        -:  325:}
        -:  326:
    #####:  327:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  328:	int i;
    #####:  329:	int count = 0;
        -:  330:
    #####:  331:	for (i = 0; i < state->deckCount[player]; i++)
        -:  332:	{
    #####:  333:		if (state->deck[player][i] == card) count++;
        -:  334:	}
        -:  335:
    #####:  336:	for (i = 0; i < state->handCount[player]; i++)
        -:  337:	{
    #####:  338:		if (state->hand[player][i] == card) count++;
        -:  339:	}
        -:  340:
    #####:  341:	for (i = 0; i < state->discardCount[player]; i++)
        -:  342:	{
    #####:  343:		if (state->discard[player][i] == card) count++;
        -:  344:	}
        -:  345:
    #####:  346:	return count;
        -:  347:}
        -:  348:
     1271:  349:int whoseTurn(struct gameState *state) {
     1271:  350:	return state->whoseTurn;
        -:  351:}
        -:  352:
      286:  353:int endTurn(struct gameState *state) {
        -:  354:	int k;
        -:  355:	int i;
      286:  356:	int currentPlayer = whoseTurn(state);
        -:  357:
        -:  358:	//Discard hand
     1686:  359:	for (i = 0; i < state->handCount[currentPlayer]; i++){
     1400:  360:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
     1400:  361:		state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  362:	}
      286:  363:	state->handCount[currentPlayer] = 0;//Reset hand count
        -:  364:
        -:  365:	//Code for determining the player
      286:  366:	if (currentPlayer < (state->numPlayers - 1)){
      188:  367:		state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  368:	}
        -:  369:	else{
       98:  370:		state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  371:	}
        -:  372:
      286:  373:	state->outpostPlayed = 0;
      286:  374:	state->phase = 0;
      286:  375:	state->numActions = 1;
      286:  376:	state->coins = 0;
      286:  377:	state->numBuys = 1;
      286:  378:	state->playedCardCount = 0;
      286:  379:	state->handCount[state->whoseTurn] = 0;
        -:  380:
        -:  381:	//int k; move to top
        -:  382:	//Next player draws hand
     1716:  383:	for (k = 0; k < 5; k++){
     1430:  384:		drawCard(state->whoseTurn, state);//Draw a card
        -:  385:	}
        -:  386:
        -:  387:	//Update money
      286:  388:	updateCoins(state->whoseTurn, state, 0);
        -:  389:
      286:  390:	return 0;
        -:  391:}
        -:  392:
     3547:  393:int isGameOver(struct gameState *state) {
        -:  394:	int i;
        -:  395:	int j;
        -:  396:
        -:  397:	//if stack of Province cards is empty, the game ends
     3547:  398:	if (state->supplyCount[province] == 0)
        -:  399:	{
    #####:  400:		return 1;
        -:  401:	}
        -:  402:
        -:  403:	//if three supply pile are at 0, the game ends
     3547:  404:	j = 0;
    92222:  405:	for (i = 0; i < 25; i++)
        -:  406:	{
    88675:  407:		if (state->supplyCount[i] == 0)
        -:  408:		{
     1927:  409:			j++;
        -:  410:		}
        -:  411:	}
     3547:  412:	if (j >= 3)
        -:  413:	{
        2:  414:		return 1;
        -:  415:	}
        -:  416:
     3545:  417:	return 0;
        -:  418:}
        -:  419:
    #####:  420:int scoreFor(int player, struct gameState *state) {
        -:  421:
        -:  422:	int i;
    #####:  423:	int score = 0;
        -:  424:	//score from hand
    #####:  425:	for (i = 0; i < state->handCount[player]; i++)
        -:  426:	{
    #####:  427:		if (state->hand[player][i] == curse) { score = score - 1; };
    #####:  428:		if (state->hand[player][i] == estate) { score = score + 1; };
    #####:  429:		if (state->hand[player][i] == duchy) { score = score + 3; };
    #####:  430:		if (state->hand[player][i] == province) { score = score + 6; };
    #####:  431:		if (state->hand[player][i] == great_hall) { score = score + 1; };
    #####:  432:		if (state->hand[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  433:	}
        -:  434:
        -:  435:	//score from discard
    #####:  436:	for (i = 0; i < state->discardCount[player]; i++)
        -:  437:	{
    #####:  438:		if (state->discard[player][i] == curse) { score = score - 1; };
    #####:  439:		if (state->discard[player][i] == estate) { score = score + 1; };
    #####:  440:		if (state->discard[player][i] == duchy) { score = score + 3; };
    #####:  441:		if (state->discard[player][i] == province) { score = score + 6; };
    #####:  442:		if (state->discard[player][i] == great_hall) { score = score + 1; };
    #####:  443:		if (state->discard[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  444:	}
        -:  445:
        -:  446:	//score from deck
    #####:  447:	for (i = 0; i < state->discardCount[player]; i++)
        -:  448:	{
    #####:  449:		if (state->deck[player][i] == curse) { score = score - 1; };
    #####:  450:		if (state->deck[player][i] == estate) { score = score + 1; };
    #####:  451:		if (state->deck[player][i] == duchy) { score = score + 3; };
    #####:  452:		if (state->deck[player][i] == province) { score = score + 6; };
    #####:  453:		if (state->deck[player][i] == great_hall) { score = score + 1; };
    #####:  454:		if (state->deck[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  455:	}
        -:  456:
    #####:  457:	return score;
        -:  458:}
        -:  459:
    #####:  460:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  461:	int i;
        -:  462:	int j;
        -:  463:	int highScore;
        -:  464:	int currentPlayer;
        -:  465:
        -:  466:	//get score for each player
    #####:  467:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  468:	{
        -:  469:		//set unused player scores to -9999
    #####:  470:		if (i >= state->numPlayers)
        -:  471:		{
    #####:  472:			players[i] = -9999;
        -:  473:		}
        -:  474:		else
        -:  475:		{
    #####:  476:			players[i] = scoreFor(i, state);
        -:  477:		}
        -:  478:	}
        -:  479:
        -:  480:	//find highest score
    #####:  481:	j = 0;
    #####:  482:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  483:	{
    #####:  484:		if (players[i] > players[j])
        -:  485:		{
    #####:  486:			j = i;
        -:  487:		}
        -:  488:	}
    #####:  489:	highScore = players[j];
        -:  490:
        -:  491:	//add 1 to players who had less turns
    #####:  492:	currentPlayer = whoseTurn(state);
    #####:  493:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  494:	{
    #####:  495:		if (players[i] == highScore && i > currentPlayer)
        -:  496:		{
    #####:  497:			players[i]++;
        -:  498:		}
        -:  499:	}
        -:  500:
        -:  501:	//find new highest score
    #####:  502:	j = 0;
    #####:  503:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  504:	{
    #####:  505:		if (players[i] > players[j])
        -:  506:		{
    #####:  507:			j = i;
        -:  508:		}
        -:  509:	}
    #####:  510:	highScore = players[j];
        -:  511:
        -:  512:	//set winners in array to 1 and rest to 0
    #####:  513:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  514:	{
    #####:  515:		if (players[i] == highScore)
        -:  516:		{
    #####:  517:			players[i] = 1;
        -:  518:		}
        -:  519:		else
        -:  520:		{
    #####:  521:			players[i] = 0;
        -:  522:		}
        -:  523:	}
        -:  524:
    #####:  525:	return 0;
        -:  526:}
        -:  527:
     1482:  528:int drawCard(int player, struct gameState *state)
        -:  529:{
        -:  530:	int count;
        -:  531:	int deckCounter;
     1482:  532:	if (state->deckCount[player] <= 0){//Deck is empty
        -:  533:
        -:  534:		//Step 1 Shuffle the discard pile back into a deck
        -:  535:		int i;
        -:  536:		//Move discard to deck
     1594:  537:		for (i = 0; i < state->discardCount[player]; i++){
     1528:  538:			state->deck[player][i] = state->discard[player][i];
     1528:  539:			state->discard[player][i] = -1;
        -:  540:		}
        -:  541:
       66:  542:		state->deckCount[player] = state->discardCount[player];
       66:  543:		state->discardCount[player] = 0;//Reset discard
        -:  544:
        -:  545:		//Shufffle the deck
       66:  546:		shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  547:
        -:  548:		if (DEBUG){//Debug statements
        -:  549:			printf("Deck count now: %d\n", state->deckCount[player]);
        -:  550:		}
        -:  551:
       66:  552:		state->discardCount[player] = 0;
        -:  553:
        -:  554:		//Step 2 Draw Card
       66:  555:		count = state->handCount[player];//Get current player's hand count
        -:  556:
        -:  557:		if (DEBUG){//Debug statements
        -:  558:			printf("Current hand count: %d\n", count);
        -:  559:		}
        -:  560:
       66:  561:		deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  562:
       66:  563:		if (deckCounter == 0)
    #####:  564:			return -1;
        -:  565:
       66:  566:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
       66:  567:		state->deckCount[player]--;
       66:  568:		state->handCount[player]++;//Increment hand count
        -:  569:	}
        -:  570:
        -:  571:	else{
     1416:  572:		int count = state->handCount[player];//Get current hand count for player
        -:  573:		int deckCounter;
        -:  574:		if (DEBUG){//Debug statements
        -:  575:			printf("Current hand count: %d\n", count);
        -:  576:		}
        -:  577:
     1416:  578:		deckCounter = state->deckCount[player];//Create holder for the deck count
     1416:  579:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
     1416:  580:		state->deckCount[player]--;
     1416:  581:		state->handCount[player]++;//Increment hand count
        -:  582:	}
        -:  583:
     1482:  584:	return 0;
        -:  585:}
        -:  586:
      811:  587:int getCost(int cardNumber)
        -:  588:{
      811:  589:	switch (cardNumber)
        -:  590:	{
        -:  591:	case curse:
       77:  592:		return 0;
        -:  593:	case estate:
       33:  594:		return 2;
        -:  595:	case duchy:
       38:  596:		return 5;
        -:  597:	case province:
       40:  598:		return 8;
        -:  599:	case copper:
       82:  600:		return 0;
        -:  601:	case silver:
       59:  602:		return 3;
        -:  603:	case gold:
       29:  604:		return 6;
        -:  605:	case adventurer:
       26:  606:		return 6;
        -:  607:	case council_room:
    #####:  608:		return 5;
        -:  609:	case feast:
        1:  610:		return 4;
        -:  611:	case gardens:
    #####:  612:		return 4;
        -:  613:	case mine:
       41:  614:		return 5;
        -:  615:	case remodel:
       33:  616:		return 4;
        -:  617:	case smithy:
       48:  618:		return 4;
        -:  619:	case village:
       30:  620:		return 3;
        -:  621:	case baron:
       48:  622:		return 4;
        -:  623:	case great_hall:
       39:  624:		return 3;
        -:  625:	case minion:
       19:  626:		return 5;
        -:  627:	case steward:
       27:  628:		return 3;
        -:  629:	case tribute:
       19:  630:		return 5;
        -:  631:	case ambassador:
       11:  632:		return 3;
        -:  633:	case cutpurse:
       22:  634:		return 4;
        -:  635:	case embargo:
    #####:  636:		return 2;
        -:  637:	case outpost:
       18:  638:		return 5;
        -:  639:	case salvager:
       11:  640:		return 4;
        -:  641:	case sea_hag:
       12:  642:		return 4;
        -:  643:	case treasure_map:
       48:  644:		return 4;
        -:  645:	}
        -:  646:
    #####:  647:	return -1;
        -:  648:}
        -:  649:
        2:  650:void playAdventurer(struct gameState *state, int currentPlayer)
        -:  651:// Reveal cards from deck until 2 Treasure cards are found.  Put those Treasure cards in the hand and discard the rest.
        -:  652:{
        2:  653:	int drawntreasure = 0;
        -:  654:	int temphand[MAX_HAND];
        -:  655:	int cardDrawn;
        2:  656:	int z = 0; // this is the counter for the temp hand
        -:  657:
       10:  658:	while (drawntreasure < 2){
        6:  659:		if (state->deckCount[currentPlayer] < 1){//if the deck is empty we need to shuffle discard and add to deck
    #####:  660:			shuffle(currentPlayer, state);
        -:  661:		}
        6:  662:		drawCard(currentPlayer, state);
        6:  663:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer] - 1];//top card of hand is most recently drawn card.
        6:  664:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
        4:  665:			drawntreasure++;
        -:  666:		else{
        2:  667:			temphand[z] = cardDrawn;
        2:  668:			state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
        2:  669:			z++;
        -:  670:		}
        -:  671:	}
        6:  672:	while (z - 1 >= 0){
        2:  673:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; // discard all cards in play that have been drawn
        2:  674:		z = z - 1;
        -:  675:	}
        2:  676:}
        -:  677:
        4:  678:int playRemodel(struct gameState *state, int currentPlayer, int choice1, int choice2, int handPos)
        -:  679://Trash a card in the hand, and gain a card costing up to $2 more than the trashed card
        -:  680:{
        -:  681:	int i;
        4:  682:	int j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  683:
        4:  684:	if ((getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2))
        -:  685:	{
        1:  686:		return -1;
        -:  687:	}
        -:  688:
        3:  689:	gainCard(choice2, state, 0, currentPlayer);
        -:  690:
        -:  691:	//discard card from hand
        3:  692:	discardCard(handPos, currentPlayer, state, 0);
        -:  693:
        -:  694:	//discard trashed card
       11:  695:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  696:	{
        9:  697:		if (state->hand[currentPlayer][i] == j)
        -:  698:		{
        1:  699:			discardCard(i, currentPlayer, state, 0);
        1:  700:			break;
        -:  701:		}
        -:  702:	}
        -:  703:
        3:  704:	return 0;
        -:  705:}
        -:  706:
        6:  707:void playSmithy(struct gameState *state, int currentPlayer, int handPos)
        -:  708:// Draw 3 cards
        -:  709:{
        -:  710:	int i;
       24:  711:	for (i = 0; i < 3; i++)
        -:  712:	{
       18:  713:		drawCard(currentPlayer, state);
        -:  714:	}
        -:  715:
        -:  716:	//discard card from hand
        6:  717:	discardCard(handPos, currentPlayer, state, 0);
        6:  718:}
        -:  719:
       20:  720:void playBaron(struct gameState *state, int currentPlayer, int choice1, int handPos)
        -:  721://Add a buy.  OPTION:  Discard an Estate card and gain $4.  Otherwise, gain an Estate card.
        -:  722:{
       20:  723:	state->numBuys++;//Increase buys by 1!
       20:  724:	if (choice1 > 0){//Boolean true or going to discard an estate
       20:  725:		int p = 0;//Iterator for hand!
       20:  726:		int card_not_discarded = 1;//Flag for discard set!
      129:  727:		while (card_not_discarded){
       89:  728:			if (state->hand[currentPlayer][p] == estate){ //Found an estate card!
       11:  729:				state->coins += 4;//Add 4 coins to the amount of coins
       11:  730:				state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
       11:  731:				state->discardCount[currentPlayer]++;
       51:  732:				for (; p < state->handCount[currentPlayer]; p++){
       40:  733:					state->hand[currentPlayer][p] = state->hand[currentPlayer][p + 1];
        -:  734:				}
       11:  735:				state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
       11:  736:				state->handCount[currentPlayer]--;
       11:  737:				card_not_discarded = 0;//Exit the loop
        -:  738:			}
       78:  739:			else if (p > state->handCount[currentPlayer]){
        -:  740:				if (DEBUG) {
        -:  741:					printf("No estate cards in your hand, invalid choice\n");
        -:  742:					printf("Must gain an estate if there are any\n");
        -:  743:				}
        9:  744:				if (supplyCount(estate, state) > 0){
        3:  745:					gainCard(estate, state, 1, currentPlayer);
        3:  746:					state->supplyCount[estate]--;//Decrement estates
        3:  747:					if (supplyCount(estate, state) == 0){
    #####:  748:						isGameOver(state);
        -:  749:					}
        -:  750:				}
        9:  751:				card_not_discarded = 0;//Exit the loop
        -:  752:			}
        -:  753:
        -:  754:			else{
       69:  755:				p++;//Next card
        -:  756:			}
        -:  757:		}
        -:  758:	}
        -:  759:
        -:  760:	else{
    #####:  761:		if (supplyCount(estate, state) > 0){
    #####:  762:			gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  763:			state->supplyCount[estate]--;//Decrement Estates
    #####:  764:			if (supplyCount(estate, state) == 0){
    #####:  765:				isGameOver(state);
        -:  766:			}
        -:  767:		}
        -:  768:	}
       20:  769:}
        -:  770:
       10:  771:int playTreasureMap(struct gameState *state, int currentPlayer, int handPos)
        -:  772://Trashing two treasure map cards from the hand = four gold on top of the deck.
        -:  773:{
        -:  774:	int i;
        -:  775:	int index;
        -:  776:
        -:  777:	//search hand for another treasure_map
       60:  778:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  779:	{
       50:  780:		if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -:  781:		{
    #####:  782:			index = i;
    #####:  783:			break;
        -:  784:		}
        -:  785:	}
       10:  786:	if (index > -1)
        -:  787:	{
        -:  788:		//trash both treasure cards
       10:  789:		discardCard(handPos, currentPlayer, state, 1);
       10:  790:		discardCard(index, currentPlayer, state, 1);
        -:  791:
        -:  792:		//gain 4 Gold cards
       50:  793:		for (i = 0; i < 4; i++)
        -:  794:		{
       40:  795:			gainCard(gold, state, 1, currentPlayer);
        -:  796:		}
        -:  797:
        -:  798:		//return success
       10:  799:		return 1;
        -:  800:	}
        -:  801:
        -:  802:	//no second treasure_map found in hand
    #####:  803:	return -1;
        -:  804:}
        -:  805:
       87:  806:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  807:{
        -:  808:	int i;
        -:  809:	int j;
        -:  810:	int k;
        -:  811:	//int x;  //Unused after while loop removed from feast.
       87:  812:	int currentPlayer = whoseTurn(state);
       87:  813:	int nextPlayer = currentPlayer + 1;
        -:  814:	int temphand[MAX_HAND];
        -:  815:
       87:  816:	int tributeRevealedCards[2] = { -1, -1 };
        -:  817:
       87:  818:	if (nextPlayer > (state->numPlayers - 1)){
       47:  819:		nextPlayer = 0;
        -:  820:	}
        -:  821:
        -:  822:	//uses switch to select card and perform actions
       87:  823:	switch (card)
        -:  824:	{
        -:  825:	case adventurer:
        -:  826:
        2:  827:		playAdventurer(state, currentPlayer);
        2:  828:		return 0;
        -:  829:
        -:  830:	case council_room:
        -:  831:		//+4 Cards
    #####:  832:		for (i = 0; i < 4; i++)
        -:  833:		{
    #####:  834:			drawCard(currentPlayer, state);
        -:  835:		}
        -:  836:
        -:  837:		//+1 Buy
    #####:  838:		state->numBuys++;
        -:  839:
        -:  840:		//Each other player draws a card
    #####:  841:		for (i = 0; i < state->numPlayers; i++)
        -:  842:		{
    #####:  843:			if (i != currentPlayer)
        -:  844:			{
    #####:  845:				drawCard(i, state);
        -:  846:			}
        -:  847:		}
        -:  848:
        -:  849:		//put played card in played card pile
    #####:  850:		discardCard(handPos, currentPlayer, state, 0);
        -:  851:
    #####:  852:		return 0;
        -:  853:
        -:  854:	case feast:
        -:  855:		//gain card with cost up to 5
        -:  856:		//Backup hand
    #####:  857:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  858:			temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  859:			state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  860:		}
        -:  861:		//Backup hand
        -:  862:
        -:  863:		//Update Coins for Buy
    #####:  864:		updateCoins(currentPlayer, state, 5);
        -:  865://		x = 1;//Condition to loop on
        -:  866://		while (x == 1) {//Buy one card
    #####:  867:			if (supplyCount(choice1, state) <= 0){
        -:  868:				if (DEBUG)
        -:  869:					printf("None of that card left, sorry!\n");
        -:  870:
        -:  871:				if (DEBUG){
        -:  872:					printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  873:				}
        -:  874:			}
    #####:  875:			else if (state->coins < getCost(choice1)){
    #####:  876:				printf("That card is too expensive!\n");
        -:  877:
        -:  878:				if (DEBUG){
        -:  879:					printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  880:				}
        -:  881:			}
        -:  882:			else{
        -:  883:
        -:  884:				if (DEBUG){
        -:  885:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  886:				}
        -:  887:
    #####:  888:				gainCard(choice1, state, 0, currentPlayer);//Gain the card
        -:  889://				x = 0;//No more buying cards
        -:  890:
        -:  891:				if (DEBUG){
        -:  892:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  893:				}
        -:  894:
        -:  895:			}
        -:  896://		}
        -:  897:
        -:  898:		//Reset Hand
    #####:  899:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  900:			state->hand[currentPlayer][i] = temphand[i];
    #####:  901:			temphand[i] = -1;
        -:  902:		}
        -:  903:		//Reset Hand
        -:  904:
    #####:  905:		return 0;
        -:  906:
        -:  907:	case gardens:
    #####:  908:		return -1;
        -:  909:
        -:  910:	case mine:
        6:  911:		j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  912:
        6:  913:		if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  914:		{
        6:  915:			return -1;
        -:  916:		}
        -:  917:
    #####:  918:		if (choice2 > treasure_map || choice2 < curse)
        -:  919:		{
    #####:  920:			return -1;
        -:  921:		}
        -:  922:
    #####:  923:		if ((getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2))
        -:  924:		{
    #####:  925:			return -1;
        -:  926:		}
        -:  927:
    #####:  928:		gainCard(choice2, state, 2, currentPlayer);
        -:  929:
        -:  930:		//discard card from hand
    #####:  931:		discardCard(handPos, currentPlayer, state, 0);
        -:  932:
        -:  933:		//discard trashed card
    #####:  934:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  935:		{
    #####:  936:			if (state->hand[currentPlayer][i] == j)
        -:  937:			{
    #####:  938:				discardCard(i, currentPlayer, state, 0);
    #####:  939:				break;
        -:  940:			}
        -:  941:		}
        -:  942:
    #####:  943:		return 0;
        -:  944:
        -:  945:	case remodel:
        -:  946:
        4:  947:		return playRemodel(state, currentPlayer, choice1, choice2, handPos);
        -:  948:
        -:  949:	case smithy:
        -:  950:
        6:  951:		playSmithy(state, currentPlayer, handPos);
        6:  952:		return 0;
        -:  953:
        -:  954:	case village:
        -:  955:		//+1 Card
        3:  956:		drawCard(currentPlayer, state);
        -:  957:
        -:  958:		//+2 Actions
        3:  959:		state->numActions = state->numActions + 2;
        -:  960:
        -:  961:		//discard played card from hand
        3:  962:		discardCard(handPos, currentPlayer, state, 0);
        3:  963:		return 0;
        -:  964:
        -:  965:	case baron:
        -:  966:
       20:  967:		playBaron(state, currentPlayer, choice1, handPos);
       20:  968:		return 0;
        -:  969:
        -:  970:	case great_hall:
        -:  971:		//+1 Card
        7:  972:		drawCard(currentPlayer, state);
        -:  973:
        -:  974:		//+1 Actions
        7:  975:		state->numActions++;
        -:  976:
        -:  977:		//discard card from hand
        7:  978:		discardCard(handPos, currentPlayer, state, 0);
        7:  979:		return 0;
        -:  980:
        -:  981:	case minion:
        -:  982:		//+1 action
        1:  983:		state->numActions++;
        -:  984:
        -:  985:		//discard card from hand
        1:  986:		discardCard(handPos, currentPlayer, state, 0);
        -:  987:
        1:  988:		if (choice1)		//+2 coins
        -:  989:		{
        1:  990:			state->coins = state->coins + 2;
        -:  991:		}
        -:  992:
    #####:  993:		else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  994:		{
        -:  995:			//discard hand
    #####:  996:			while (numHandCards(state) > 0)
        -:  997:			{
    #####:  998:				discardCard(handPos, currentPlayer, state, 0);
        -:  999:			}
        -: 1000:
        -: 1001:			//draw 4
    #####: 1002:			for (i = 0; i < 4; i++)
        -: 1003:			{
    #####: 1004:				drawCard(currentPlayer, state);
        -: 1005:			}
        -: 1006:
        -: 1007:			//other players discard hand and redraw if hand size > 4
    #####: 1008:			for (i = 0; i < state->numPlayers; i++)
        -: 1009:			{
    #####: 1010:				if (i != currentPlayer)
        -: 1011:				{
    #####: 1012:					if (state->handCount[i] > 4)
        -: 1013:					{
        -: 1014:						//discard hand
    #####: 1015:						while (state->handCount[i] > 0)
        -: 1016:						{
    #####: 1017:							discardCard(handPos, i, state, 0);
        -: 1018:						}
        -: 1019:
        -: 1020:						//draw 4
    #####: 1021:						for (j = 0; j < 4; j++)
        -: 1022:						{
    #####: 1023:							drawCard(i, state);
        -: 1024:						}
        -: 1025:					}
        -: 1026:				}
        -: 1027:			}
        -: 1028:
        -: 1029:		}
        1: 1030:		return 0;
        -: 1031:
        -: 1032:	case steward:
        4: 1033:		if (choice1 == 1)
        -: 1034:		{
        -: 1035:			//+2 cards
    #####: 1036:			drawCard(currentPlayer, state);
    #####: 1037:			drawCard(currentPlayer, state);
        -: 1038:		}
        4: 1039:		else if (choice1 == 2)
        -: 1040:		{
        -: 1041:			//+2 coins
    #####: 1042:			state->coins = state->coins + 2;
        -: 1043:		}
        -: 1044:		else
        -: 1045:		{
        -: 1046:			//trash 2 cards in hand
        4: 1047:			discardCard(choice2, currentPlayer, state, 1);
        4: 1048:			discardCard(choice3, currentPlayer, state, 1);
        -: 1049:		}
        -: 1050:
        -: 1051:		//discard card from hand
        4: 1052:		discardCard(handPos, currentPlayer, state, 0);
        4: 1053:		return 0;
        -: 1054:
        -: 1055:	case tribute:
        7: 1056:		if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####: 1057:			if (state->deckCount[nextPlayer] > 0){
    #####: 1058:				tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1059:				state->deckCount[nextPlayer]--;
        -: 1060:			}
    #####: 1061:			else if (state->discardCount[nextPlayer] > 0){
    #####: 1062:				tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer] - 1];
    #####: 1063:				state->discardCount[nextPlayer]--;
        -: 1064:			}
        -: 1065:			else{
        -: 1066:				//No Card to Reveal
        -: 1067:				if (DEBUG){
        -: 1068:					printf("No cards to reveal\n");
        -: 1069:				}
        -: 1070:			}
        -: 1071:		}
        -: 1072:
        -: 1073:		else{
        7: 1074:			if (state->deckCount[nextPlayer] == 0){
    #####: 1075:				for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####: 1076:					state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1077:					state->deckCount[nextPlayer]++;
    #####: 1078:					state->discard[nextPlayer][i] = -1;
    #####: 1079:					state->discardCount[nextPlayer]--;
        -: 1080:				}
        -: 1081:
    #####: 1082:				shuffle(nextPlayer, state);//Shuffle the deck
        -: 1083:			}
        7: 1084:			tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
        7: 1085:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
        7: 1086:			state->deckCount[nextPlayer]--;
        7: 1087:			tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
        7: 1088:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
        7: 1089:			state->deckCount[nextPlayer]--;
        -: 1090:		}
        -: 1091:
        7: 1092:		if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
        3: 1093:			state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
        3: 1094:			state->playedCardCount++;
        3: 1095:			tributeRevealedCards[1] = -1;
        -: 1096:		}
        -: 1097:
       28: 1098:		for (i = 0; i <= 2; i++){
       21: 1099:			if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
        6: 1100:				state->coins += 2;
        -: 1101:			}
        -: 1102:
       15: 1103:			else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
        4: 1104:				drawCard(currentPlayer, state);
        4: 1105:				drawCard(currentPlayer, state);
        -: 1106:			}
        -: 1107:			else{//Action Card
       11: 1108:				state->numActions = state->numActions + 2;
        -: 1109:			}
        -: 1110:		}
        -: 1111:
        7: 1112:		return 0;
        -: 1113:
        -: 1114:	case ambassador:
       10: 1115:		j = 0;		//used to check if player has enough cards to discard
        -: 1116:
       10: 1117:		if (choice2 > 2 || choice2 < 0)
        -: 1118:		{
        8: 1119:			return -1;
        -: 1120:		}
        -: 1121:
        2: 1122:		if (choice1 == handPos)
        -: 1123:		{
    #####: 1124:			return -1;
        -: 1125:		}
        -: 1126:
       12: 1127:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1128:		{
       10: 1129:			if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1130:			{
    #####: 1131:				j++;
        -: 1132:			}
        -: 1133:		}
        2: 1134:		if (j < choice2)
        -: 1135:		{
        2: 1136:			return -1;
        -: 1137:		}
        -: 1138:
        -: 1139:		if (DEBUG)
        -: 1140:			printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1141:
        -: 1142:		//increase supply count for choosen card by amount being discarded
    #####: 1143:		state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1144:
        -: 1145:		//each other player gains a copy of revealed card
    #####: 1146:		for (i = 0; i < state->numPlayers; i++)
        -: 1147:		{
    #####: 1148:			if (i != currentPlayer)
        -: 1149:			{
    #####: 1150:				gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1151:			}
        -: 1152:		}
        -: 1153:
        -: 1154:		//discard played card from hand
    #####: 1155:		discardCard(handPos, currentPlayer, state, 0);
        -: 1156:
        -: 1157:		//trash copies of cards returned to supply
    #####: 1158:		for (j = 0; j < choice2; j++)
        -: 1159:		{
    #####: 1160:			for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1161:			{
    #####: 1162:				if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1163:				{
    #####: 1164:					discardCard(i, currentPlayer, state, 1);
    #####: 1165:					break;
        -: 1166:				}
        -: 1167:			}
        -: 1168:		}
        -: 1169:
    #####: 1170:		return 0;
        -: 1171:
        -: 1172:	case cutpurse:
        -: 1173:
        4: 1174:		updateCoins(currentPlayer, state, 2);
       12: 1175:		for (i = 0; i < state->numPlayers; i++)
        -: 1176:		{
        8: 1177:			if (i != currentPlayer)
        -: 1178:			{
        4: 1179:				for (j = 0; j < state->handCount[i]; j++)
        -: 1180:				{
    #####: 1181:					if (state->hand[i][j] == copper)
        -: 1182:					{
    #####: 1183:						discardCard(j, i, state, 0);
    #####: 1184:						break;
        -: 1185:					}
    #####: 1186:					if (j == state->handCount[i])
        -: 1187:					{
    #####: 1188:						for (k = 0; k < state->handCount[i]; k++)
        -: 1189:						{
        -: 1190:							if (DEBUG)
        -: 1191:								printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1192:						}
    #####: 1193:						break;
        -: 1194:					}
        -: 1195:				}
        -: 1196:
        -: 1197:			}
        -: 1198:
        -: 1199:		}
        -: 1200:
        -: 1201:		//discard played card from hand
        4: 1202:		discardCard(handPos, currentPlayer, state, 0);
        -: 1203:
        4: 1204:		return 0;
        -: 1205:
        -: 1206:
        -: 1207:	case embargo:
        -: 1208:		//+2 Coins
    #####: 1209:		state->coins = state->coins + 2;
        -: 1210:
        -: 1211:		//see if selected pile is in play
    #####: 1212:		if (state->supplyCount[choice1] == -1)
        -: 1213:		{
    #####: 1214:			return -1;
        -: 1215:		}
        -: 1216:
        -: 1217:		//add embargo token to selected supply pile
    #####: 1218:		state->embargoTokens[choice1]++;
        -: 1219:
        -: 1220:		//trash card
    #####: 1221:		discardCard(handPos, currentPlayer, state, 1);
    #####: 1222:		return 0;
        -: 1223:
        -: 1224:	case outpost:
        -: 1225:		//set outpost flag
    #####: 1226:		state->outpostPlayed++;
        -: 1227:
        -: 1228:		//discard card
    #####: 1229:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1230:		return 0;
        -: 1231:
        -: 1232:	case salvager:
        -: 1233:		//+1 buy
        1: 1234:		state->numBuys++;
        -: 1235:
        1: 1236:		if (choice1)
        -: 1237:		{
        -: 1238:			//gain coins equal to trashed card
        1: 1239:			state->coins = state->coins + getCost(handCard(choice1, state));
        -: 1240:			//trash card
        1: 1241:			discardCard(choice1, currentPlayer, state, 1);
        -: 1242:		}
        -: 1243:
        -: 1244:		//discard card
        1: 1245:		discardCard(handPos, currentPlayer, state, 0);
        1: 1246:		return 0;
        -: 1247:
        -: 1248:	case sea_hag:
        6: 1249:		for (i = 0; i < state->numPlayers; i++){
        4: 1250:			if (i != currentPlayer){
        2: 1251:				state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
        2: 1252:				state->discardCount[i]++;
        2: 1253:				state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1254:			}
        -: 1255:		}
        2: 1256:		return 0;
        -: 1257:
        -: 1258:	case treasure_map:
        -: 1259:
       10: 1260:		return playTreasureMap(state, currentPlayer, handPos);
        -: 1261:	}
    #####: 1262:	return -1;
        -: 1263:}
        -: 1264:
       59: 1265:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1266:{
        -: 1267:
        -: 1268:	//if card is not trashed, added to Played pile 
       59: 1269:	if (trashFlag < 1)
        -: 1270:	{
        -: 1271:		//add card to played pile
       30: 1272:		state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
       30: 1273:		state->playedCardCount++;
        -: 1274:	}
        -: 1275:
        -: 1276:	//set played card to -1
       59: 1277:	state->hand[currentPlayer][handPos] = -1;
        -: 1278:
        -: 1279:	//remove card from player's hand
       59: 1280:	if (handPos == (state->handCount[currentPlayer] - 1)) 	//last card in hand array is played
        -: 1281:	{
        -: 1282:		//reduce number of cards in hand
        8: 1283:		state->handCount[currentPlayer]--;
        -: 1284:	}
       51: 1285:	else if (state->handCount[currentPlayer] == 1) //only one card in hand
        -: 1286:	{
        -: 1287:		//reduce number of cards in hand
    #####: 1288:		state->handCount[currentPlayer]--;
        -: 1289:	}
        -: 1290:	else
        -: 1291:	{
        -: 1292:		//replace discarded card with last card in hand
       51: 1293:		state->hand[currentPlayer][handPos] = state->hand[currentPlayer][(state->handCount[currentPlayer] - 1)];
        -: 1294:		//set last card to -1
       51: 1295:		state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1296:		//reduce number of cards in hand
       51: 1297:		state->handCount[currentPlayer]--;
        -: 1298:	}
        -: 1299:
       59: 1300:	return 0;
        -: 1301:}
        -: 1302:
      281: 1303:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1304:{
        -: 1305:	//Note: supplyPos is enum of choosen card
        -: 1306:
        -: 1307:	//check if supply pile is empty (0) or card is not used in game (-1)
      281: 1308:	if (supplyCount(supplyPos, state) < 1)
        -: 1309:	{
        2: 1310:		return -1;
        -: 1311:	}
        -: 1312:
        -: 1313:	//added card for [whoseTurn] current player:
        -: 1314:	// toFlag = 0 : add to discard
        -: 1315:	// toFlag = 1 : add to deck
        -: 1316:	// toFlag = 2 : add to hand
        -: 1317:
      279: 1318:	if (toFlag == 1)
        -: 1319:	{
       43: 1320:		state->deck[player][state->deckCount[player]] = supplyPos;
       43: 1321:		state->deckCount[player]++;
        -: 1322:	}
      236: 1323:	else if (toFlag == 2)
        -: 1324:	{
    #####: 1325:		state->hand[player][state->handCount[player]] = supplyPos;
    #####: 1326:		state->handCount[player]++;
        -: 1327:	}
        -: 1328:	else
        -: 1329:	{
      236: 1330:		state->discard[player][state->discardCount[player]] = supplyPos;
      236: 1331:		state->discardCount[player]++;
        -: 1332:	}
        -: 1333:
        -: 1334:	//decrease number in supply pile
      279: 1335:	state->supplyCount[supplyPos]--;
        -: 1336:
      279: 1337:	return 0;
        -: 1338:}
        -: 1339:
      362: 1340:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1341:{
        -: 1342:	int i;
        -: 1343:
        -: 1344:	//reset coin count
      362: 1345:	state->coins = 0;
        -: 1346:
        -: 1347:	//add coins for each Treasure card in player's hand
     2144: 1348:	for (i = 0; i < state->handCount[player]; i++)
        -: 1349:	{
     1782: 1350:		if (state->hand[player][i] == copper)
        -: 1351:		{
      667: 1352:			state->coins += 1;
        -: 1353:		}
     1115: 1354:		else if (state->hand[player][i] == silver)
        -: 1355:		{
       90: 1356:			state->coins += 2;
        -: 1357:		}
     1025: 1358:		else if (state->hand[player][i] == gold)
        -: 1359:		{
      217: 1360:			state->coins += 3;
        -: 1361:		}
        -: 1362:	}
        -: 1363:
        -: 1364:	//add bonus
      362: 1365:	state->coins += bonus;
        -: 1366:
      362: 1367:	return 0;
        -: 1368:}
        -: 1369:
        -: 1370:
        -: 1371://end of dominion.c
File 'dominion.c'
Lines executed:54.22% of 557
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
     2099:    8:int compare(const void* a, const void* b) {
     2099:    9:	if (*(int*)a > *(int*)b)
      632:   10:		return 1;
     1467:   11:	if (*(int*)a < *(int*)b)
      666:   12:		return -1;
      801:   13:	return 0;
        -:   14:}
        -:   15:
        4:   16:struct gameState* newGame() {
        4:   17:	struct gameState* g = malloc(sizeof(struct gameState));
        4:   18:	return g;
        -:   19:}
        -:   20:
       38:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:	int k8, int k9, int k10) {
       38:   23:	int* k = malloc(10 * sizeof(int));
       38:   24:	k[0] = k1;
       38:   25:	k[1] = k2;
       38:   26:	k[2] = k3;
       38:   27:	k[3] = k4;
       38:   28:	k[4] = k5;
       38:   29:	k[5] = k6;
       38:   30:	k[6] = k7;
       38:   31:	k[7] = k8;
       38:   32:	k[8] = k9;
       38:   33:	k[9] = k10;
       38:   34:	return k;
        -:   35:}
        -:   36:
       38:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		struct gameState *state) {
        -:   39:
        -:   40:	int i;
        -:   41:	int j;
        -:   42:	int it;
        -:   43:	//set up random number generator
       38:   44:	SelectStream(1);
       38:   45:	PutSeed((long)randomSeed);
        -:   46:
        -:   47:	//check number of players
       38:   48:	if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:	{
    #####:   50:		return -1;
        -:   51:	}
        -:   52:
        -:   53:	//set number of players
       38:   54:	state->numPlayers = numPlayers;
        -:   55:
        -:   56:	//check selected kingdom cards are different
      113:   57:	for (i = 0; i < 10; i++)
        -:   58:	{
     1061:   59:		for (j = 0; j < 10; j++)
        -:   60:		{
      986:   61:			if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:			{
       36:   63:				return -1;
        -:   64:			}
        -:   65:		}
        -:   66:	}
        -:   67:
        -:   68:
        -:   69:	//initialize supply
        -:   70:	///////////////////////////////
        -:   71:
        -:   72:	//set number of Curse cards
        2:   73:	if (numPlayers == 2)
        -:   74:	{
        1:   75:		state->supplyCount[curse] = 10;
        -:   76:	}
        1:   77:	else if (numPlayers == 3)
        -:   78:	{
        1:   79:		state->supplyCount[curse] = 20;
        -:   80:	}
        -:   81:	else
        -:   82:	{
    #####:   83:		state->supplyCount[curse] = 30;
        -:   84:	}
        -:   85:
        -:   86:	//set number of Victory cards
        2:   87:	if (numPlayers == 2)
        -:   88:	{
        1:   89:		state->supplyCount[estate] = 8;
        1:   90:		state->supplyCount[duchy] = 8;
        1:   91:		state->supplyCount[province] = 8;
        -:   92:	}
        -:   93:	else
        -:   94:	{
        1:   95:		state->supplyCount[estate] = 12;
        1:   96:		state->supplyCount[duchy] = 12;
        1:   97:		state->supplyCount[province] = 12;
        -:   98:	}
        -:   99:
        -:  100:	//set number of Treasure cards
        2:  101:	state->supplyCount[copper] = 60 - (7 * numPlayers);
        2:  102:	state->supplyCount[silver] = 40;
        2:  103:	state->supplyCount[gold] = 30;
        -:  104:
        -:  105:	//set number of Kingdom cards
       42:  106:	for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:	{
      330:  108:		for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:		{
      310:  110:			if (kingdomCards[j] == i)
        -:  111:			{
        -:  112:				//check if card is a 'Victory' Kingdom card
       20:  113:				if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:				{
        6:  115:					if (numPlayers == 2){
        2:  116:						state->supplyCount[i] = 8;
        -:  117:					}
        1:  118:					else{ state->supplyCount[i] = 12; }
        -:  119:				}
        -:  120:				else
        -:  121:				{
       17:  122:					state->supplyCount[i] = 10;
        -:  123:				}
       20:  124:				break;
        -:  125:			}
        -:  126:			else    //card is not in the set choosen for the game
        -:  127:			{
      290:  128:				state->supplyCount[i] = -1;
        -:  129:			}
        -:  130:		}
        -:  131:
        -:  132:	}
        -:  133:
        -:  134:	////////////////////////
        -:  135:	//supply intilization complete
        -:  136:
        -:  137:	//set player decks
        7:  138:	for (i = 0; i < numPlayers; i++)
        -:  139:	{
        5:  140:		state->deckCount[i] = 0;
       20:  141:		for (j = 0; j < 3; j++)
        -:  142:		{
       15:  143:			state->deck[i][j] = estate;
       15:  144:			state->deckCount[i]++;
        -:  145:		}
       40:  146:		for (j = 3; j < 10; j++)
        -:  147:		{
       35:  148:			state->deck[i][j] = copper;
       35:  149:			state->deckCount[i]++;
        -:  150:		}
        -:  151:	}
        -:  152:
        -:  153:	//shuffle player decks
        7:  154:	for (i = 0; i < numPlayers; i++)
        -:  155:	{
        5:  156:		if (shuffle(i, state) < 0)
        -:  157:		{
    #####:  158:			return -1;
        -:  159:		}
        -:  160:	}
        -:  161:
        -:  162:	//draw player hands
        7:  163:	for (i = 0; i < numPlayers; i++)
        -:  164:	{
        -:  165:		//initialize hand size to zero
        5:  166:		state->handCount[i] = 0;
        5:  167:		state->discardCount[i] = 0;
        -:  168:		//draw 5 cards
        -:  169:		// for (j = 0; j < 5; j++)
        -:  170:		//	{
        -:  171:		//	  drawCard(i, state);
        -:  172:		//	}
        -:  173:	}
        -:  174:
        -:  175:	//set embargo tokens to 0 for all supply piles
       56:  176:	for (i = 0; i <= treasure_map; i++)
        -:  177:	{
       54:  178:		state->embargoTokens[i] = 0;
        -:  179:	}
        -:  180:
        -:  181:	//initialize first player's turn
        2:  182:	state->outpostPlayed = 0;
        2:  183:	state->phase = 0;
        2:  184:	state->numActions = 1;
        2:  185:	state->numBuys = 1;
        2:  186:	state->playedCardCount = 0;
        2:  187:	state->whoseTurn = 0;
        2:  188:	state->handCount[state->whoseTurn] = 0;
        -:  189:	//int it; move to top
        -:  190:
        -:  191:	//Moved draw cards to here, only drawing at the start of a turn
       12:  192:	for (it = 0; it < 5; it++){
       10:  193:		drawCard(state->whoseTurn, state);
        -:  194:	}
        -:  195:
        2:  196:	updateCoins(state->whoseTurn, state, 0);
        -:  197:
        2:  198:	return 0;
        -:  199:}
        -:  200:
       61:  201:int shuffle(int player, struct gameState *state) {
        -:  202:
        -:  203:
        -:  204:	int newDeck[MAX_DECK];
       61:  205:	int newDeckPos = 0;
        -:  206:	int card;
        -:  207:	int i;
        -:  208:
       61:  209:	if (state->deckCount[player] < 1)
    #####:  210:		return -1;
       61:  211:	qsort((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
        -:  212:	/* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
     1145:  214:	while (state->deckCount[player] > 0) {
     1023:  215:		card = floor(Random() * state->deckCount[player]);
     1023:  216:		newDeck[newDeckPos] = state->deck[player][card];
     1023:  217:		newDeckPos++;
     5603:  218:		for (i = card; i < state->deckCount[player] - 1; i++) {
     4580:  219:			state->deck[player][i] = state->deck[player][i + 1];
        -:  220:		}
     1023:  221:		state->deckCount[player]--;
        -:  222:	}
     1084:  223:	for (i = 0; i < newDeckPos; i++) {
     1023:  224:		state->deck[player][i] = newDeck[i];
     1023:  225:		state->deckCount[player]++;
        -:  226:	}
        -:  227:
       61:  228:	return 0;
        -:  229:}
        -:  230:
     1005:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state)
        -:  232:{
        -:  233:	int card;
     1005:  234:	int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:	//check if it is the right phase
     1005:  237:	if (state->phase != 0)
        -:  238:	{
      178:  239:		return -1;
        -:  240:	}
        -:  241:
        -:  242:	//check if player has enough actions
      827:  243:	if (state->numActions < 1)
        -:  244:	{
        8:  245:		return -1;
        -:  246:	}
        -:  247:
        -:  248:	//get card played
      819:  249:	card = handCard(handPos, state);
        -:  250:
        -:  251:	//check if selected card is an action
      819:  252:	if (card < adventurer || card > treasure_map)
        -:  253:	{
      704:  254:		return -1;
        -:  255:	}
        -:  256:
        -:  257:	//play card
      115:  258:	if (cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0)
        -:  259:	{
       74:  260:		return -1;
        -:  261:	}
        -:  262:
        -:  263:	//reduce number of actions
       41:  264:	state->numActions--;
        -:  265:
        -:  266:	//update coins (Treasure cards may be added with card draws)
       41:  267:	updateCoins(state->whoseTurn, state, coin_bonus);
        -:  268:
       41:  269:	return 0;
        -:  270:}
        -:  271:
      956:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:	int who;
        -:  274:	if (DEBUG){
        -:  275:		printf("Entering buyCard...\n");
        -:  276:	}
        -:  277:
        -:  278:	// I don't know what to do about the phase thing.
        -:  279:
      956:  280:	who = state->whoseTurn;
        -:  281:
      956:  282:	if (state->numBuys < 1){
        -:  283:		if (DEBUG)
        -:  284:			printf("You do not have any buys left\n");
      153:  285:		return -1;
        -:  286:	}
      803:  287:	else if (supplyCount(supplyPos, state) < 1){
        -:  288:		if (DEBUG)
        -:  289:			printf("There are not any of that type of card left\n");
      329:  290:		return -1;
        -:  291:	}
      474:  292:	else if (state->coins < getCost(supplyPos)){
        -:  293:		if (DEBUG)
        -:  294:			printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
      330:  295:		return -1;
        -:  296:	}
        -:  297:	else {
      144:  298:		state->phase = 1;
        -:  299:		//state->supplyCount[supplyPos]--;
      144:  300:		gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  301:
      144:  302:		state->coins = (state->coins) - (getCost(supplyPos));
      144:  303:		state->numBuys--;
        -:  304:		if (DEBUG)
        -:  305:			printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  306:	}
        -:  307:
        -:  308:	//state->discard[who][state->discardCount[who]] = supplyPos;
        -:  309:	//state->discardCount[who]++;
        -:  310:
      144:  311:	return 0;
        -:  312:}
        -:  313:
    #####:  314:int numHandCards(struct gameState *state) {
    #####:  315:	return state->handCount[whoseTurn(state)];
        -:  316:}
        -:  317:
      819:  318:int handCard(int handPos, struct gameState *state) {
      819:  319:	int currentPlayer = whoseTurn(state);
      819:  320:	return state->hand[currentPlayer][handPos];
        -:  321:}
        -:  322:
      955:  323:int supplyCount(int card, struct gameState *state) {
      955:  324:	return state->supplyCount[card];
        -:  325:}
        -:  326:
    #####:  327:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  328:	int i;
    #####:  329:	int count = 0;
        -:  330:
    #####:  331:	for (i = 0; i < state->deckCount[player]; i++)
        -:  332:	{
    #####:  333:		if (state->deck[player][i] == card) count++;
        -:  334:	}
        -:  335:
    #####:  336:	for (i = 0; i < state->handCount[player]; i++)
        -:  337:	{
    #####:  338:		if (state->hand[player][i] == card) count++;
        -:  339:	}
        -:  340:
    #####:  341:	for (i = 0; i < state->discardCount[player]; i++)
        -:  342:	{
    #####:  343:		if (state->discard[player][i] == card) count++;
        -:  344:	}
        -:  345:
    #####:  346:	return count;
        -:  347:}
        -:  348:
     1112:  349:int whoseTurn(struct gameState *state) {
     1112:  350:	return state->whoseTurn;
        -:  351:}
        -:  352:
      178:  353:int endTurn(struct gameState *state) {
        -:  354:	int k;
        -:  355:	int i;
      178:  356:	int currentPlayer = whoseTurn(state);
        -:  357:
        -:  358:	//Discard hand
     1040:  359:	for (i = 0; i < state->handCount[currentPlayer]; i++){
      862:  360:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
      862:  361:		state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  362:	}
      178:  363:	state->handCount[currentPlayer] = 0;//Reset hand count
        -:  364:
        -:  365:	//Code for determining the player
      178:  366:	if (currentPlayer < (state->numPlayers - 1)){
      107:  367:		state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  368:	}
        -:  369:	else{
       71:  370:		state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  371:	}
        -:  372:
      178:  373:	state->outpostPlayed = 0;
      178:  374:	state->phase = 0;
      178:  375:	state->numActions = 1;
      178:  376:	state->coins = 0;
      178:  377:	state->numBuys = 1;
      178:  378:	state->playedCardCount = 0;
      178:  379:	state->handCount[state->whoseTurn] = 0;
        -:  380:
        -:  381:	//int k; move to top
        -:  382:	//Next player draws hand
     1068:  383:	for (k = 0; k < 5; k++){
      890:  384:		drawCard(state->whoseTurn, state);//Draw a card
        -:  385:	}
        -:  386:
        -:  387:	//Update money
      178:  388:	updateCoins(state->whoseTurn, state, 0);
        -:  389:
      178:  390:	return 0;
        -:  391:}
        -:  392:
     2915:  393:int isGameOver(struct gameState *state) {
        -:  394:	int i;
        -:  395:	int j;
        -:  396:
        -:  397:	//if stack of Province cards is empty, the game ends
     2915:  398:	if (state->supplyCount[province] == 0)
        -:  399:	{
    #####:  400:		return 1;
        -:  401:	}
        -:  402:
        -:  403:	//if three supply pile are at 0, the game ends
     2915:  404:	j = 0;
    75790:  405:	for (i = 0; i < 25; i++)
        -:  406:	{
    72875:  407:		if (state->supplyCount[i] == 0)
        -:  408:		{
     2155:  409:			j++;
        -:  410:		}
        -:  411:	}
     2915:  412:	if (j >= 3)
        -:  413:	{
        2:  414:		return 1;
        -:  415:	}
        -:  416:
     2913:  417:	return 0;
        -:  418:}
        -:  419:
    #####:  420:int scoreFor(int player, struct gameState *state) {
        -:  421:
        -:  422:	int i;
    #####:  423:	int score = 0;
        -:  424:	//score from hand
    #####:  425:	for (i = 0; i < state->handCount[player]; i++)
        -:  426:	{
    #####:  427:		if (state->hand[player][i] == curse) { score = score - 1; };
    #####:  428:		if (state->hand[player][i] == estate) { score = score + 1; };
    #####:  429:		if (state->hand[player][i] == duchy) { score = score + 3; };
    #####:  430:		if (state->hand[player][i] == province) { score = score + 6; };
    #####:  431:		if (state->hand[player][i] == great_hall) { score = score + 1; };
    #####:  432:		if (state->hand[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  433:	}
        -:  434:
        -:  435:	//score from discard
    #####:  436:	for (i = 0; i < state->discardCount[player]; i++)
        -:  437:	{
    #####:  438:		if (state->discard[player][i] == curse) { score = score - 1; };
    #####:  439:		if (state->discard[player][i] == estate) { score = score + 1; };
    #####:  440:		if (state->discard[player][i] == duchy) { score = score + 3; };
    #####:  441:		if (state->discard[player][i] == province) { score = score + 6; };
    #####:  442:		if (state->discard[player][i] == great_hall) { score = score + 1; };
    #####:  443:		if (state->discard[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  444:	}
        -:  445:
        -:  446:	//score from deck
    #####:  447:	for (i = 0; i < state->discardCount[player]; i++)
        -:  448:	{
    #####:  449:		if (state->deck[player][i] == curse) { score = score - 1; };
    #####:  450:		if (state->deck[player][i] == estate) { score = score + 1; };
    #####:  451:		if (state->deck[player][i] == duchy) { score = score + 3; };
    #####:  452:		if (state->deck[player][i] == province) { score = score + 6; };
    #####:  453:		if (state->deck[player][i] == great_hall) { score = score + 1; };
    #####:  454:		if (state->deck[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  455:	}
        -:  456:
    #####:  457:	return score;
        -:  458:}
        -:  459:
    #####:  460:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  461:	int i;
        -:  462:	int j;
        -:  463:	int highScore;
        -:  464:	int currentPlayer;
        -:  465:
        -:  466:	//get score for each player
    #####:  467:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  468:	{
        -:  469:		//set unused player scores to -9999
    #####:  470:		if (i >= state->numPlayers)
        -:  471:		{
    #####:  472:			players[i] = -9999;
        -:  473:		}
        -:  474:		else
        -:  475:		{
    #####:  476:			players[i] = scoreFor(i, state);
        -:  477:		}
        -:  478:	}
        -:  479:
        -:  480:	//find highest score
    #####:  481:	j = 0;
    #####:  482:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  483:	{
    #####:  484:		if (players[i] > players[j])
        -:  485:		{
    #####:  486:			j = i;
        -:  487:		}
        -:  488:	}
    #####:  489:	highScore = players[j];
        -:  490:
        -:  491:	//add 1 to players who had less turns
    #####:  492:	currentPlayer = whoseTurn(state);
    #####:  493:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  494:	{
    #####:  495:		if (players[i] == highScore && i > currentPlayer)
        -:  496:		{
    #####:  497:			players[i]++;
        -:  498:		}
        -:  499:	}
        -:  500:
        -:  501:	//find new highest score
    #####:  502:	j = 0;
    #####:  503:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  504:	{
    #####:  505:		if (players[i] > players[j])
        -:  506:		{
    #####:  507:			j = i;
        -:  508:		}
        -:  509:	}
    #####:  510:	highScore = players[j];
        -:  511:
        -:  512:	//set winners in array to 1 and rest to 0
    #####:  513:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  514:	{
    #####:  515:		if (players[i] == highScore)
        -:  516:		{
    #####:  517:			players[i] = 1;
        -:  518:		}
        -:  519:		else
        -:  520:		{
    #####:  521:			players[i] = 0;
        -:  522:		}
        -:  523:	}
        -:  524:
    #####:  525:	return 0;
        -:  526:}
        -:  527:
      913:  528:int drawCard(int player, struct gameState *state)
        -:  529:{
        -:  530:	int count;
        -:  531:	int deckCounter;
      913:  532:	if (state->deckCount[player] <= 0){//Deck is empty
        -:  533:
        -:  534:		//Step 1 Shuffle the discard pile back into a deck
        -:  535:		int i;
        -:  536:		//Move discard to deck
     1029:  537:		for (i = 0; i < state->discardCount[player]; i++){
      973:  538:			state->deck[player][i] = state->discard[player][i];
      973:  539:			state->discard[player][i] = -1;
        -:  540:		}
        -:  541:
       56:  542:		state->deckCount[player] = state->discardCount[player];
       56:  543:		state->discardCount[player] = 0;//Reset discard
        -:  544:
        -:  545:		//Shufffle the deck
       56:  546:		shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  547:
        -:  548:		if (DEBUG){//Debug statements
        -:  549:			printf("Deck count now: %d\n", state->deckCount[player]);
        -:  550:		}
        -:  551:
       56:  552:		state->discardCount[player] = 0;
        -:  553:
        -:  554:		//Step 2 Draw Card
       56:  555:		count = state->handCount[player];//Get current player's hand count
        -:  556:
        -:  557:		if (DEBUG){//Debug statements
        -:  558:			printf("Current hand count: %d\n", count);
        -:  559:		}
        -:  560:
       56:  561:		deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  562:
       56:  563:		if (deckCounter == 0)
    #####:  564:			return -1;
        -:  565:
       56:  566:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
       56:  567:		state->deckCount[player]--;
       56:  568:		state->handCount[player]++;//Increment hand count
        -:  569:	}
        -:  570:
        -:  571:	else{
      857:  572:		int count = state->handCount[player];//Get current hand count for player
        -:  573:		int deckCounter;
        -:  574:		if (DEBUG){//Debug statements
        -:  575:			printf("Current hand count: %d\n", count);
        -:  576:		}
        -:  577:
      857:  578:		deckCounter = state->deckCount[player];//Create holder for the deck count
      857:  579:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
      857:  580:		state->deckCount[player]--;
      857:  581:		state->handCount[player]++;//Increment hand count
        -:  582:	}
        -:  583:
      913:  584:	return 0;
        -:  585:}
        -:  586:
      619:  587:int getCost(int cardNumber)
        -:  588:{
      619:  589:	switch (cardNumber)
        -:  590:	{
        -:  591:	case curse:
       48:  592:		return 0;
        -:  593:	case estate:
       48:  594:		return 2;
        -:  595:	case duchy:
       22:  596:		return 5;
        -:  597:	case province:
       22:  598:		return 8;
        -:  599:	case copper:
       62:  600:		return 0;
        -:  601:	case silver:
       37:  602:		return 3;
        -:  603:	case gold:
       21:  604:		return 6;
        -:  605:	case adventurer:
       23:  606:		return 6;
        -:  607:	case council_room:
       15:  608:		return 5;
        -:  609:	case feast:
       33:  610:		return 4;
        -:  611:	case gardens:
       17:  612:		return 4;
        -:  613:	case mine:
       10:  614:		return 5;
        -:  615:	case remodel:
    #####:  616:		return 4;
        -:  617:	case smithy:
    #####:  618:		return 4;
        -:  619:	case village:
       33:  620:		return 3;
        -:  621:	case baron:
       12:  622:		return 4;
        -:  623:	case great_hall:
       31:  624:		return 3;
        -:  625:	case minion:
       19:  626:		return 5;
        -:  627:	case steward:
       18:  628:		return 3;
        -:  629:	case tribute:
       12:  630:		return 5;
        -:  631:	case ambassador:
       47:  632:		return 3;
        -:  633:	case cutpurse:
       19:  634:		return 4;
        -:  635:	case embargo:
       40:  636:		return 2;
        -:  637:	case outpost:
    #####:  638:		return 5;
        -:  639:	case salvager:
    #####:  640:		return 4;
        -:  641:	case sea_hag:
       16:  642:		return 4;
        -:  643:	case treasure_map:
       14:  644:		return 4;
        -:  645:	}
        -:  646:
    #####:  647:	return -1;
        -:  648:}
        -:  649:
    #####:  650:void playAdventurer(struct gameState *state, int currentPlayer)
        -:  651:// Reveal cards from deck until 2 Treasure cards are found.  Put those Treasure cards in the hand and discard the rest.
        -:  652:{
    #####:  653:	int drawntreasure = 0;
        -:  654:	int temphand[MAX_HAND];
        -:  655:	int cardDrawn;
    #####:  656:	int z = 0; // this is the counter for the temp hand
        -:  657:
    #####:  658:	while (drawntreasure < 2){
    #####:  659:		if (state->deckCount[currentPlayer] < 1){//if the deck is empty we need to shuffle discard and add to deck
    #####:  660:			shuffle(currentPlayer, state);
        -:  661:		}
    #####:  662:		drawCard(currentPlayer, state);
    #####:  663:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer] - 1];//top card of hand is most recently drawn card.
    #####:  664:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
    #####:  665:			drawntreasure++;
        -:  666:		else{
    #####:  667:			temphand[z] = cardDrawn;
    #####:  668:			state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####:  669:			z++;
        -:  670:		}
        -:  671:	}
    #####:  672:	while (z - 1 >= 0){
    #####:  673:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; // discard all cards in play that have been drawn
    #####:  674:		z = z - 1;
        -:  675:	}
    #####:  676:}
        -:  677:
    #####:  678:int playRemodel(struct gameState *state, int currentPlayer, int choice1, int choice2, int handPos)
        -:  679://Trash a card in the hand, and gain a card costing up to $2 more than the trashed card
        -:  680:{
        -:  681:	int i;
    #####:  682:	int j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  683:
    #####:  684:	if ((getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2))
        -:  685:	{
    #####:  686:		return -1;
        -:  687:	}
        -:  688:
    #####:  689:	gainCard(choice2, state, 0, currentPlayer);
        -:  690:
        -:  691:	//discard card from hand
    #####:  692:	discardCard(handPos, currentPlayer, state, 0);
        -:  693:
        -:  694:	//discard trashed card
    #####:  695:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  696:	{
    #####:  697:		if (state->hand[currentPlayer][i] == j)
        -:  698:		{
    #####:  699:			discardCard(i, currentPlayer, state, 0);
    #####:  700:			break;
        -:  701:		}
        -:  702:	}
        -:  703:
    #####:  704:	return 0;
        -:  705:}
        -:  706:
    #####:  707:void playSmithy(struct gameState *state, int currentPlayer, int handPos)
        -:  708:// Draw 3 cards
        -:  709:{
        -:  710:	int i;
    #####:  711:	for (i = 0; i < 3; i++)
        -:  712:	{
    #####:  713:		drawCard(currentPlayer, state);
        -:  714:	}
        -:  715:
        -:  716:	//discard card from hand
    #####:  717:	discardCard(handPos, currentPlayer, state, 0);
    #####:  718:}
        -:  719:
    #####:  720:void playBaron(struct gameState *state, int currentPlayer, int choice1, int handPos)
        -:  721://Add a buy.  OPTION:  Discard an Estate card and gain $4.  Otherwise, gain an Estate card.
        -:  722:{
    #####:  723:	state->numBuys++;//Increase buys by 1!
    #####:  724:	if (choice1 > 0){//Boolean true or going to discard an estate
    #####:  725:		int p = 0;//Iterator for hand!
    #####:  726:		int card_not_discarded = 1;//Flag for discard set!
    #####:  727:		while (card_not_discarded){
    #####:  728:			if (state->hand[currentPlayer][p] == estate){ //Found an estate card!
    #####:  729:				state->coins += 4;//Add 4 coins to the amount of coins
    #####:  730:				state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  731:				state->discardCount[currentPlayer]++;
    #####:  732:				for (; p < state->handCount[currentPlayer]; p++){
    #####:  733:					state->hand[currentPlayer][p] = state->hand[currentPlayer][p + 1];
        -:  734:				}
    #####:  735:				state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  736:				state->handCount[currentPlayer]--;
    #####:  737:				card_not_discarded = 0;//Exit the loop
        -:  738:			}
    #####:  739:			else if (p > state->handCount[currentPlayer]){
        -:  740:				if (DEBUG) {
        -:  741:					printf("No estate cards in your hand, invalid choice\n");
        -:  742:					printf("Must gain an estate if there are any\n");
        -:  743:				}
    #####:  744:				if (supplyCount(estate, state) > 0){
    #####:  745:					gainCard(estate, state, 1, currentPlayer);
    #####:  746:					state->supplyCount[estate]--;//Decrement estates
    #####:  747:					if (supplyCount(estate, state) == 0){
    #####:  748:						isGameOver(state);
        -:  749:					}
        -:  750:				}
    #####:  751:				card_not_discarded = 0;//Exit the loop
        -:  752:			}
        -:  753:
        -:  754:			else{
    #####:  755:				p++;//Next card
        -:  756:			}
        -:  757:		}
        -:  758:	}
        -:  759:
        -:  760:	else{
    #####:  761:		if (supplyCount(estate, state) > 0){
    #####:  762:			gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  763:			state->supplyCount[estate]--;//Decrement Estates
    #####:  764:			if (supplyCount(estate, state) == 0){
    #####:  765:				isGameOver(state);
        -:  766:			}
        -:  767:		}
        -:  768:	}
    #####:  769:}
        -:  770:
    #####:  771:int playTreasureMap(struct gameState *state, int currentPlayer, int handPos)
        -:  772://Trashing two treasure map cards from the hand = four gold on top of the deck.
        -:  773:{
        -:  774:	int i;
        -:  775:	int index;
        -:  776:
        -:  777:	//search hand for another treasure_map
    #####:  778:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  779:	{
    #####:  780:		if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -:  781:		{
    #####:  782:			index = i;
    #####:  783:			break;
        -:  784:		}
        -:  785:	}
    #####:  786:	if (index > -1)
        -:  787:	{
        -:  788:		//trash both treasure cards
    #####:  789:		discardCard(handPos, currentPlayer, state, 1);
    #####:  790:		discardCard(index, currentPlayer, state, 1);
        -:  791:
        -:  792:		//gain 4 Gold cards
    #####:  793:		for (i = 0; i < 4; i++)
        -:  794:		{
    #####:  795:			gainCard(gold, state, 1, currentPlayer);
        -:  796:		}
        -:  797:
        -:  798:		//return success
    #####:  799:		return 1;
        -:  800:	}
        -:  801:
        -:  802:	//no second treasure_map found in hand
    #####:  803:	return -1;
        -:  804:}
        -:  805:
      115:  806:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  807:{
        -:  808:	int i;
        -:  809:	int j;
        -:  810:	int k;
        -:  811:	//int x;  //Unused after while loop removed from feast.
      115:  812:	int currentPlayer = whoseTurn(state);
      115:  813:	int nextPlayer = currentPlayer + 1;
        -:  814:	int temphand[MAX_HAND];
        -:  815:
      115:  816:	int tributeRevealedCards[2] = { -1, -1 };
        -:  817:
      115:  818:	if (nextPlayer > (state->numPlayers - 1)){
       39:  819:		nextPlayer = 0;
        -:  820:	}
        -:  821:
        -:  822:	//uses switch to select card and perform actions
      115:  823:	switch (card)
        -:  824:	{
        -:  825:	case adventurer:
        -:  826:
    #####:  827:		playAdventurer(state, currentPlayer);
    #####:  828:		return 0;
        -:  829:
        -:  830:	case council_room:
        -:  831:		//+4 Cards
    #####:  832:		for (i = 0; i < 4; i++)
        -:  833:		{
    #####:  834:			drawCard(currentPlayer, state);
        -:  835:		}
        -:  836:
        -:  837:		//+1 Buy
    #####:  838:		state->numBuys++;
        -:  839:
        -:  840:		//Each other player draws a card
    #####:  841:		for (i = 0; i < state->numPlayers; i++)
        -:  842:		{
    #####:  843:			if (i != currentPlayer)
        -:  844:			{
    #####:  845:				drawCard(i, state);
        -:  846:			}
        -:  847:		}
        -:  848:
        -:  849:		//put played card in played card pile
    #####:  850:		discardCard(handPos, currentPlayer, state, 0);
        -:  851:
    #####:  852:		return 0;
        -:  853:
        -:  854:	case feast:
        -:  855:		//gain card with cost up to 5
        -:  856:		//Backup hand
        7:  857:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
        6:  858:			temphand[i] = state->hand[currentPlayer][i];//Backup card
        6:  859:			state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  860:		}
        -:  861:		//Backup hand
        -:  862:
        -:  863:		//Update Coins for Buy
        1:  864:		updateCoins(currentPlayer, state, 5);
        -:  865://		x = 1;//Condition to loop on
        -:  866://		while (x == 1) {//Buy one card
        1:  867:			if (supplyCount(choice1, state) <= 0){
        -:  868:				if (DEBUG)
        -:  869:					printf("None of that card left, sorry!\n");
        -:  870:
        -:  871:				if (DEBUG){
        -:  872:					printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  873:				}
        -:  874:			}
        1:  875:			else if (state->coins < getCost(choice1)){
    #####:  876:				printf("That card is too expensive!\n");
        -:  877:
        -:  878:				if (DEBUG){
        -:  879:					printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  880:				}
        -:  881:			}
        -:  882:			else{
        -:  883:
        -:  884:				if (DEBUG){
        -:  885:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  886:				}
        -:  887:
        1:  888:				gainCard(choice1, state, 0, currentPlayer);//Gain the card
        -:  889://				x = 0;//No more buying cards
        -:  890:
        -:  891:				if (DEBUG){
        -:  892:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  893:				}
        -:  894:
        -:  895:			}
        -:  896://		}
        -:  897:
        -:  898:		//Reset Hand
        7:  899:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
        6:  900:			state->hand[currentPlayer][i] = temphand[i];
        6:  901:			temphand[i] = -1;
        -:  902:		}
        -:  903:		//Reset Hand
        -:  904:
        1:  905:		return 0;
        -:  906:
        -:  907:	case gardens:
        8:  908:		return -1;
        -:  909:
        -:  910:	case mine:
    #####:  911:		j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  912:
    #####:  913:		if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  914:		{
    #####:  915:			return -1;
        -:  916:		}
        -:  917:
    #####:  918:		if (choice2 > treasure_map || choice2 < curse)
        -:  919:		{
    #####:  920:			return -1;
        -:  921:		}
        -:  922:
    #####:  923:		if ((getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2))
        -:  924:		{
    #####:  925:			return -1;
        -:  926:		}
        -:  927:
    #####:  928:		gainCard(choice2, state, 2, currentPlayer);
        -:  929:
        -:  930:		//discard card from hand
    #####:  931:		discardCard(handPos, currentPlayer, state, 0);
        -:  932:
        -:  933:		//discard trashed card
    #####:  934:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  935:		{
    #####:  936:			if (state->hand[currentPlayer][i] == j)
        -:  937:			{
    #####:  938:				discardCard(i, currentPlayer, state, 0);
    #####:  939:				break;
        -:  940:			}
        -:  941:		}
        -:  942:
    #####:  943:		return 0;
        -:  944:
        -:  945:	case remodel:
        -:  946:
    #####:  947:		return playRemodel(state, currentPlayer, choice1, choice2, handPos);
        -:  948:
        -:  949:	case smithy:
        -:  950:
    #####:  951:		playSmithy(state, currentPlayer, handPos);
    #####:  952:		return 0;
        -:  953:
        -:  954:	case village:
        -:  955:		//+1 Card
        6:  956:		drawCard(currentPlayer, state);
        -:  957:
        -:  958:		//+2 Actions
        6:  959:		state->numActions = state->numActions + 2;
        -:  960:
        -:  961:		//discard played card from hand
        6:  962:		discardCard(handPos, currentPlayer, state, 0);
        6:  963:		return 0;
        -:  964:
        -:  965:	case baron:
        -:  966:
    #####:  967:		playBaron(state, currentPlayer, choice1, handPos);
    #####:  968:		return 0;
        -:  969:
        -:  970:	case great_hall:
        -:  971:		//+1 Card
        7:  972:		drawCard(currentPlayer, state);
        -:  973:
        -:  974:		//+1 Actions
        7:  975:		state->numActions++;
        -:  976:
        -:  977:		//discard card from hand
        7:  978:		discardCard(handPos, currentPlayer, state, 0);
        7:  979:		return 0;
        -:  980:
        -:  981:	case minion:
        -:  982:		//+1 action
    #####:  983:		state->numActions++;
        -:  984:
        -:  985:		//discard card from hand
    #####:  986:		discardCard(handPos, currentPlayer, state, 0);
        -:  987:
    #####:  988:		if (choice1)		//+2 coins
        -:  989:		{
    #####:  990:			state->coins = state->coins + 2;
        -:  991:		}
        -:  992:
    #####:  993:		else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  994:		{
        -:  995:			//discard hand
    #####:  996:			while (numHandCards(state) > 0)
        -:  997:			{
    #####:  998:				discardCard(handPos, currentPlayer, state, 0);
        -:  999:			}
        -: 1000:
        -: 1001:			//draw 4
    #####: 1002:			for (i = 0; i < 4; i++)
        -: 1003:			{
    #####: 1004:				drawCard(currentPlayer, state);
        -: 1005:			}
        -: 1006:
        -: 1007:			//other players discard hand and redraw if hand size > 4
    #####: 1008:			for (i = 0; i < state->numPlayers; i++)
        -: 1009:			{
    #####: 1010:				if (i != currentPlayer)
        -: 1011:				{
    #####: 1012:					if (state->handCount[i] > 4)
        -: 1013:					{
        -: 1014:						//discard hand
    #####: 1015:						while (state->handCount[i] > 0)
        -: 1016:						{
    #####: 1017:							discardCard(handPos, i, state, 0);
        -: 1018:						}
        -: 1019:
        -: 1020:						//draw 4
    #####: 1021:						for (j = 0; j < 4; j++)
        -: 1022:						{
    #####: 1023:							drawCard(i, state);
        -: 1024:						}
        -: 1025:					}
        -: 1026:				}
        -: 1027:			}
        -: 1028:
        -: 1029:		}
    #####: 1030:		return 0;
        -: 1031:
        -: 1032:	case steward:
        3: 1033:		if (choice1 == 1)
        -: 1034:		{
        -: 1035:			//+2 cards
    #####: 1036:			drawCard(currentPlayer, state);
    #####: 1037:			drawCard(currentPlayer, state);
        -: 1038:		}
        3: 1039:		else if (choice1 == 2)
        -: 1040:		{
        -: 1041:			//+2 coins
    #####: 1042:			state->coins = state->coins + 2;
        -: 1043:		}
        -: 1044:		else
        -: 1045:		{
        -: 1046:			//trash 2 cards in hand
        3: 1047:			discardCard(choice2, currentPlayer, state, 1);
        3: 1048:			discardCard(choice3, currentPlayer, state, 1);
        -: 1049:		}
        -: 1050:
        -: 1051:		//discard card from hand
        3: 1052:		discardCard(handPos, currentPlayer, state, 0);
        3: 1053:		return 0;
        -: 1054:
        -: 1055:	case tribute:
    #####: 1056:		if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####: 1057:			if (state->deckCount[nextPlayer] > 0){
    #####: 1058:				tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1059:				state->deckCount[nextPlayer]--;
        -: 1060:			}
    #####: 1061:			else if (state->discardCount[nextPlayer] > 0){
    #####: 1062:				tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer] - 1];
    #####: 1063:				state->discardCount[nextPlayer]--;
        -: 1064:			}
        -: 1065:			else{
        -: 1066:				//No Card to Reveal
        -: 1067:				if (DEBUG){
        -: 1068:					printf("No cards to reveal\n");
        -: 1069:				}
        -: 1070:			}
        -: 1071:		}
        -: 1072:
        -: 1073:		else{
    #####: 1074:			if (state->deckCount[nextPlayer] == 0){
    #####: 1075:				for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####: 1076:					state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1077:					state->deckCount[nextPlayer]++;
    #####: 1078:					state->discard[nextPlayer][i] = -1;
    #####: 1079:					state->discardCount[nextPlayer]--;
        -: 1080:				}
        -: 1081:
    #####: 1082:				shuffle(nextPlayer, state);//Shuffle the deck
        -: 1083:			}
    #####: 1084:			tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1085:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1086:			state->deckCount[nextPlayer]--;
    #####: 1087:			tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1088:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1089:			state->deckCount[nextPlayer]--;
        -: 1090:		}
        -: 1091:
    #####: 1092:		if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
    #####: 1093:			state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1094:			state->playedCardCount++;
    #####: 1095:			tributeRevealedCards[1] = -1;
        -: 1096:		}
        -: 1097:
    #####: 1098:		for (i = 0; i <= 2; i++){
    #####: 1099:			if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
    #####: 1100:				state->coins += 2;
        -: 1101:			}
        -: 1102:
    #####: 1103:			else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
    #####: 1104:				drawCard(currentPlayer, state);
    #####: 1105:				drawCard(currentPlayer, state);
        -: 1106:			}
        -: 1107:			else{//Action Card
    #####: 1108:				state->numActions = state->numActions + 2;
        -: 1109:			}
        -: 1110:		}
        -: 1111:
    #####: 1112:		return 0;
        -: 1113:
        -: 1114:	case ambassador:
       60: 1115:		j = 0;		//used to check if player has enough cards to discard
        -: 1116:
       60: 1117:		if (choice2 > 2 || choice2 < 0)
        -: 1118:		{
       54: 1119:			return -1;
        -: 1120:		}
        -: 1121:
        6: 1122:		if (choice1 == handPos)
        -: 1123:		{
    #####: 1124:			return -1;
        -: 1125:		}
        -: 1126:
       36: 1127:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1128:		{
       30: 1129:			if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1130:			{
        3: 1131:				j++;
        -: 1132:			}
        -: 1133:		}
        6: 1134:		if (j < choice2)
        -: 1135:		{
        3: 1136:			return -1;
        -: 1137:		}
        -: 1138:
        -: 1139:		if (DEBUG)
        -: 1140:			printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1141:
        -: 1142:		//increase supply count for choosen card by amount being discarded
        3: 1143:		state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1144:
        -: 1145:		//each other player gains a copy of revealed card
       12: 1146:		for (i = 0; i < state->numPlayers; i++)
        -: 1147:		{
        9: 1148:			if (i != currentPlayer)
        -: 1149:			{
        6: 1150:				gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1151:			}
        -: 1152:		}
        -: 1153:
        -: 1154:		//discard played card from hand
        3: 1155:		discardCard(handPos, currentPlayer, state, 0);
        -: 1156:
        -: 1157:		//trash copies of cards returned to supply
        3: 1158:		for (j = 0; j < choice2; j++)
        -: 1159:		{
    #####: 1160:			for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1161:			{
    #####: 1162:				if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1163:				{
    #####: 1164:					discardCard(i, currentPlayer, state, 1);
    #####: 1165:					break;
        -: 1166:				}
        -: 1167:			}
        -: 1168:		}
        -: 1169:
        3: 1170:		return 0;
        -: 1171:
        -: 1172:	case cutpurse:
        -: 1173:
        1: 1174:		updateCoins(currentPlayer, state, 2);
        3: 1175:		for (i = 0; i < state->numPlayers; i++)
        -: 1176:		{
        2: 1177:			if (i != currentPlayer)
        -: 1178:			{
        1: 1179:				for (j = 0; j < state->handCount[i]; j++)
        -: 1180:				{
    #####: 1181:					if (state->hand[i][j] == copper)
        -: 1182:					{
    #####: 1183:						discardCard(j, i, state, 0);
    #####: 1184:						break;
        -: 1185:					}
    #####: 1186:					if (j == state->handCount[i])
        -: 1187:					{
    #####: 1188:						for (k = 0; k < state->handCount[i]; k++)
        -: 1189:						{
        -: 1190:							if (DEBUG)
        -: 1191:								printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1192:						}
    #####: 1193:						break;
        -: 1194:					}
        -: 1195:				}
        -: 1196:
        -: 1197:			}
        -: 1198:
        -: 1199:		}
        -: 1200:
        -: 1201:		//discard played card from hand
        1: 1202:		discardCard(handPos, currentPlayer, state, 0);
        -: 1203:
        1: 1204:		return 0;
        -: 1205:
        -: 1206:
        -: 1207:	case embargo:
        -: 1208:		//+2 Coins
       24: 1209:		state->coins = state->coins + 2;
        -: 1210:
        -: 1211:		//see if selected pile is in play
       24: 1212:		if (state->supplyCount[choice1] == -1)
        -: 1213:		{
        9: 1214:			return -1;
        -: 1215:		}
        -: 1216:
        -: 1217:		//add embargo token to selected supply pile
       15: 1218:		state->embargoTokens[choice1]++;
        -: 1219:
        -: 1220:		//trash card
       15: 1221:		discardCard(handPos, currentPlayer, state, 1);
       15: 1222:		return 0;
        -: 1223:
        -: 1224:	case outpost:
        -: 1225:		//set outpost flag
    #####: 1226:		state->outpostPlayed++;
        -: 1227:
        -: 1228:		//discard card
    #####: 1229:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1230:		return 0;
        -: 1231:
        -: 1232:	case salvager:
        -: 1233:		//+1 buy
    #####: 1234:		state->numBuys++;
        -: 1235:
    #####: 1236:		if (choice1)
        -: 1237:		{
        -: 1238:			//gain coins equal to trashed card
    #####: 1239:			state->coins = state->coins + getCost(handCard(choice1, state));
        -: 1240:			//trash card
    #####: 1241:			discardCard(choice1, currentPlayer, state, 1);
        -: 1242:		}
        -: 1243:
        -: 1244:		//discard card
    #####: 1245:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1246:		return 0;
        -: 1247:
        -: 1248:	case sea_hag:
       20: 1249:		for (i = 0; i < state->numPlayers; i++){
       15: 1250:			if (i != currentPlayer){
       10: 1251:				state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
       10: 1252:				state->discardCount[i]++;
       10: 1253:				state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1254:			}
        -: 1255:		}
        5: 1256:		return 0;
        -: 1257:
        -: 1258:	case treasure_map:
        -: 1259:
    #####: 1260:		return playTreasureMap(state, currentPlayer, handPos);
        -: 1261:	}
    #####: 1262:	return -1;
        -: 1263:}
        -: 1264:
       41: 1265:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1266:{
        -: 1267:
        -: 1268:	//if card is not trashed, added to Played pile 
       41: 1269:	if (trashFlag < 1)
        -: 1270:	{
        -: 1271:		//add card to played pile
       20: 1272:		state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
       20: 1273:		state->playedCardCount++;
        -: 1274:	}
        -: 1275:
        -: 1276:	//set played card to -1
       41: 1277:	state->hand[currentPlayer][handPos] = -1;
        -: 1278:
        -: 1279:	//remove card from player's hand
       41: 1280:	if (handPos == (state->handCount[currentPlayer] - 1)) 	//last card in hand array is played
        -: 1281:	{
        -: 1282:		//reduce number of cards in hand
        3: 1283:		state->handCount[currentPlayer]--;
        -: 1284:	}
       38: 1285:	else if (state->handCount[currentPlayer] == 1) //only one card in hand
        -: 1286:	{
        -: 1287:		//reduce number of cards in hand
    #####: 1288:		state->handCount[currentPlayer]--;
        -: 1289:	}
        -: 1290:	else
        -: 1291:	{
        -: 1292:		//replace discarded card with last card in hand
       38: 1293:		state->hand[currentPlayer][handPos] = state->hand[currentPlayer][(state->handCount[currentPlayer] - 1)];
        -: 1294:		//set last card to -1
       38: 1295:		state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1296:		//reduce number of cards in hand
       38: 1297:		state->handCount[currentPlayer]--;
        -: 1298:	}
        -: 1299:
       41: 1300:	return 0;
        -: 1301:}
        -: 1302:
      151: 1303:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1304:{
        -: 1305:	//Note: supplyPos is enum of choosen card
        -: 1306:
        -: 1307:	//check if supply pile is empty (0) or card is not used in game (-1)
      151: 1308:	if (supplyCount(supplyPos, state) < 1)
        -: 1309:	{
    #####: 1310:		return -1;
        -: 1311:	}
        -: 1312:
        -: 1313:	//added card for [whoseTurn] current player:
        -: 1314:	// toFlag = 0 : add to discard
        -: 1315:	// toFlag = 1 : add to deck
        -: 1316:	// toFlag = 2 : add to hand
        -: 1317:
      151: 1318:	if (toFlag == 1)
        -: 1319:	{
    #####: 1320:		state->deck[player][state->deckCount[player]] = supplyPos;
    #####: 1321:		state->deckCount[player]++;
        -: 1322:	}
      151: 1323:	else if (toFlag == 2)
        -: 1324:	{
    #####: 1325:		state->hand[player][state->handCount[player]] = supplyPos;
    #####: 1326:		state->handCount[player]++;
        -: 1327:	}
        -: 1328:	else
        -: 1329:	{
      151: 1330:		state->discard[player][state->discardCount[player]] = supplyPos;
      151: 1331:		state->discardCount[player]++;
        -: 1332:	}
        -: 1333:
        -: 1334:	//decrease number in supply pile
      151: 1335:	state->supplyCount[supplyPos]--;
        -: 1336:
      151: 1337:	return 0;
        -: 1338:}
        -: 1339:
      223: 1340:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1341:{
        -: 1342:	int i;
        -: 1343:
        -: 1344:	//reset coin count
      223: 1345:	state->coins = 0;
        -: 1346:
        -: 1347:	//add coins for each Treasure card in player's hand
     1307: 1348:	for (i = 0; i < state->handCount[player]; i++)
        -: 1349:	{
     1084: 1350:		if (state->hand[player][i] == copper)
        -: 1351:		{
      493: 1352:			state->coins += 1;
        -: 1353:		}
      591: 1354:		else if (state->hand[player][i] == silver)
        -: 1355:		{
       19: 1356:			state->coins += 2;
        -: 1357:		}
      572: 1358:		else if (state->hand[player][i] == gold)
        -: 1359:		{
    #####: 1360:			state->coins += 3;
        -: 1361:		}
        -: 1362:	}
        -: 1363:
        -: 1364:	//add bonus
      223: 1365:	state->coins += bonus;
        -: 1366:
      223: 1367:	return 0;
        -: 1368:}
        -: 1369:
        -: 1370:
        -: 1371://end of dominion.c
File 'dominion.c'
Lines executed:65.17% of 557
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
     3774:    8:int compare(const void* a, const void* b) {
     3774:    9:	if (*(int*)a > *(int*)b)
     1241:   10:		return 1;
     2533:   11:	if (*(int*)a < *(int*)b)
     1187:   12:		return -1;
     1346:   13:	return 0;
        -:   14:}
        -:   15:
        4:   16:struct gameState* newGame() {
        4:   17:	struct gameState* g = malloc(sizeof(struct gameState));
        4:   18:	return g;
        -:   19:}
        -:   20:
        2:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:	int k8, int k9, int k10) {
        2:   23:	int* k = malloc(10 * sizeof(int));
        2:   24:	k[0] = k1;
        2:   25:	k[1] = k2;
        2:   26:	k[2] = k3;
        2:   27:	k[3] = k4;
        2:   28:	k[4] = k5;
        2:   29:	k[5] = k6;
        2:   30:	k[6] = k7;
        2:   31:	k[7] = k8;
        2:   32:	k[8] = k9;
        2:   33:	k[9] = k10;
        2:   34:	return k;
        -:   35:}
        -:   36:
        2:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		struct gameState *state) {
        -:   39:
        -:   40:	int i;
        -:   41:	int j;
        -:   42:	int it;
        -:   43:	//set up random number generator
        2:   44:	SelectStream(1);
        2:   45:	PutSeed((long)randomSeed);
        -:   46:
        -:   47:	//check number of players
        2:   48:	if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:	{
    #####:   50:		return -1;
        -:   51:	}
        -:   52:
        -:   53:	//set number of players
        2:   54:	state->numPlayers = numPlayers;
        -:   55:
        -:   56:	//check selected kingdom cards are different
       22:   57:	for (i = 0; i < 10; i++)
        -:   58:	{
      220:   59:		for (j = 0; j < 10; j++)
        -:   60:		{
      200:   61:			if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:			{
    #####:   63:				return -1;
        -:   64:			}
        -:   65:		}
        -:   66:	}
        -:   67:
        -:   68:
        -:   69:	//initialize supply
        -:   70:	///////////////////////////////
        -:   71:
        -:   72:	//set number of Curse cards
        2:   73:	if (numPlayers == 2)
        -:   74:	{
    #####:   75:		state->supplyCount[curse] = 10;
        -:   76:	}
        2:   77:	else if (numPlayers == 3)
        -:   78:	{
    #####:   79:		state->supplyCount[curse] = 20;
        -:   80:	}
        -:   81:	else
        -:   82:	{
        2:   83:		state->supplyCount[curse] = 30;
        -:   84:	}
        -:   85:
        -:   86:	//set number of Victory cards
        2:   87:	if (numPlayers == 2)
        -:   88:	{
    #####:   89:		state->supplyCount[estate] = 8;
    #####:   90:		state->supplyCount[duchy] = 8;
    #####:   91:		state->supplyCount[province] = 8;
        -:   92:	}
        -:   93:	else
        -:   94:	{
        2:   95:		state->supplyCount[estate] = 12;
        2:   96:		state->supplyCount[duchy] = 12;
        2:   97:		state->supplyCount[province] = 12;
        -:   98:	}
        -:   99:
        -:  100:	//set number of Treasure cards
        2:  101:	state->supplyCount[copper] = 60 - (7 * numPlayers);
        2:  102:	state->supplyCount[silver] = 40;
        2:  103:	state->supplyCount[gold] = 30;
        -:  104:
        -:  105:	//set number of Kingdom cards
       42:  106:	for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:	{
      330:  108:		for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:		{
      310:  110:			if (kingdomCards[j] == i)
        -:  111:			{
        -:  112:				//check if card is a 'Victory' Kingdom card
       20:  113:				if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:				{
        2:  115:					if (numPlayers == 2){
    #####:  116:						state->supplyCount[i] = 8;
        -:  117:					}
        1:  118:					else{ state->supplyCount[i] = 12; }
        -:  119:				}
        -:  120:				else
        -:  121:				{
       19:  122:					state->supplyCount[i] = 10;
        -:  123:				}
       20:  124:				break;
        -:  125:			}
        -:  126:			else    //card is not in the set choosen for the game
        -:  127:			{
      290:  128:				state->supplyCount[i] = -1;
        -:  129:			}
        -:  130:		}
        -:  131:
        -:  132:	}
        -:  133:
        -:  134:	////////////////////////
        -:  135:	//supply intilization complete
        -:  136:
        -:  137:	//set player decks
       10:  138:	for (i = 0; i < numPlayers; i++)
        -:  139:	{
        8:  140:		state->deckCount[i] = 0;
       32:  141:		for (j = 0; j < 3; j++)
        -:  142:		{
       24:  143:			state->deck[i][j] = estate;
       24:  144:			state->deckCount[i]++;
        -:  145:		}
       64:  146:		for (j = 3; j < 10; j++)
        -:  147:		{
       56:  148:			state->deck[i][j] = copper;
       56:  149:			state->deckCount[i]++;
        -:  150:		}
        -:  151:	}
        -:  152:
        -:  153:	//shuffle player decks
       10:  154:	for (i = 0; i < numPlayers; i++)
        -:  155:	{
        8:  156:		if (shuffle(i, state) < 0)
        -:  157:		{
    #####:  158:			return -1;
        -:  159:		}
        -:  160:	}
        -:  161:
        -:  162:	//draw player hands
       10:  163:	for (i = 0; i < numPlayers; i++)
        -:  164:	{
        -:  165:		//initialize hand size to zero
        8:  166:		state->handCount[i] = 0;
        8:  167:		state->discardCount[i] = 0;
        -:  168:		//draw 5 cards
        -:  169:		// for (j = 0; j < 5; j++)
        -:  170:		//	{
        -:  171:		//	  drawCard(i, state);
        -:  172:		//	}
        -:  173:	}
        -:  174:
        -:  175:	//set embargo tokens to 0 for all supply piles
       56:  176:	for (i = 0; i <= treasure_map; i++)
        -:  177:	{
       54:  178:		state->embargoTokens[i] = 0;
        -:  179:	}
        -:  180:
        -:  181:	//initialize first player's turn
        2:  182:	state->outpostPlayed = 0;
        2:  183:	state->phase = 0;
        2:  184:	state->numActions = 1;
        2:  185:	state->numBuys = 1;
        2:  186:	state->playedCardCount = 0;
        2:  187:	state->whoseTurn = 0;
        2:  188:	state->handCount[state->whoseTurn] = 0;
        -:  189:	//int it; move to top
        -:  190:
        -:  191:	//Moved draw cards to here, only drawing at the start of a turn
       12:  192:	for (it = 0; it < 5; it++){
       10:  193:		drawCard(state->whoseTurn, state);
        -:  194:	}
        -:  195:
        2:  196:	updateCoins(state->whoseTurn, state, 0);
        -:  197:
        2:  198:	return 0;
        -:  199:}
        -:  200:
      100:  201:int shuffle(int player, struct gameState *state) {
        -:  202:
        -:  203:
        -:  204:	int newDeck[MAX_DECK];
      100:  205:	int newDeckPos = 0;
        -:  206:	int card;
        -:  207:	int i;
        -:  208:
      100:  209:	if (state->deckCount[player] < 1)
    #####:  210:		return -1;
      100:  211:	qsort((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
        -:  212:	/* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
     1964:  214:	while (state->deckCount[player] > 0) {
     1764:  215:		card = floor(Random() * state->deckCount[player]);
     1764:  216:		newDeck[newDeckPos] = state->deck[player][card];
     1764:  217:		newDeckPos++;
    10227:  218:		for (i = card; i < state->deckCount[player] - 1; i++) {
     8463:  219:			state->deck[player][i] = state->deck[player][i + 1];
        -:  220:		}
     1764:  221:		state->deckCount[player]--;
        -:  222:	}
     1864:  223:	for (i = 0; i < newDeckPos; i++) {
     1764:  224:		state->deck[player][i] = newDeck[i];
     1764:  225:		state->deckCount[player]++;
        -:  226:	}
        -:  227:
      100:  228:	return 0;
        -:  229:}
        -:  230:
     1336:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state)
        -:  232:{
        -:  233:	int card;
     1336:  234:	int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:	//check if it is the right phase
     1336:  237:	if (state->phase != 0)
        -:  238:	{
      239:  239:		return -1;
        -:  240:	}
        -:  241:
        -:  242:	//check if player has enough actions
     1097:  243:	if (state->numActions < 1)
        -:  244:	{
       46:  245:		return -1;
        -:  246:	}
        -:  247:
        -:  248:	//get card played
     1051:  249:	card = handCard(handPos, state);
        -:  250:
        -:  251:	//check if selected card is an action
     1051:  252:	if (card < adventurer || card > treasure_map)
        -:  253:	{
      965:  254:		return -1;
        -:  255:	}
        -:  256:
        -:  257:	//play card
       86:  258:	if (cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0)
        -:  259:	{
        7:  260:		return -1;
        -:  261:	}
        -:  262:
        -:  263:	//reduce number of actions
       79:  264:	state->numActions--;
        -:  265:
        -:  266:	//update coins (Treasure cards may be added with card draws)
       79:  267:	updateCoins(state->whoseTurn, state, coin_bonus);
        -:  268:
       79:  269:	return 0;
        -:  270:}
        -:  271:
     1345:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:	int who;
        -:  274:	if (DEBUG){
        -:  275:		printf("Entering buyCard...\n");
        -:  276:	}
        -:  277:
        -:  278:	// I don't know what to do about the phase thing.
        -:  279:
     1345:  280:	who = state->whoseTurn;
        -:  281:
     1345:  282:	if (state->numBuys < 1){
        -:  283:		if (DEBUG)
        -:  284:			printf("You do not have any buys left\n");
      228:  285:		return -1;
        -:  286:	}
     1117:  287:	else if (supplyCount(supplyPos, state) < 1){
        -:  288:		if (DEBUG)
        -:  289:			printf("There are not any of that type of card left\n");
      422:  290:		return -1;
        -:  291:	}
      695:  292:	else if (state->coins < getCost(supplyPos)){
        -:  293:		if (DEBUG)
        -:  294:			printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
      443:  295:		return -1;
        -:  296:	}
        -:  297:	else {
      252:  298:		state->phase = 1;
        -:  299:		//state->supplyCount[supplyPos]--;
      252:  300:		gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  301:
      252:  302:		state->coins = (state->coins) - (getCost(supplyPos));
      252:  303:		state->numBuys--;
        -:  304:		if (DEBUG)
        -:  305:			printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  306:	}
        -:  307:
        -:  308:	//state->discard[who][state->discardCount[who]] = supplyPos;
        -:  309:	//state->discardCount[who]++;
        -:  310:
      252:  311:	return 0;
        -:  312:}
        -:  313:
    #####:  314:int numHandCards(struct gameState *state) {
    #####:  315:	return state->handCount[whoseTurn(state)];
        -:  316:}
        -:  317:
     1057:  318:int handCard(int handPos, struct gameState *state) {
     1057:  319:	int currentPlayer = whoseTurn(state);
     1057:  320:	return state->hand[currentPlayer][handPos];
        -:  321:}
        -:  322:
     1419:  323:int supplyCount(int card, struct gameState *state) {
     1419:  324:	return state->supplyCount[card];
        -:  325:}
        -:  326:
    #####:  327:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  328:	int i;
    #####:  329:	int count = 0;
        -:  330:
    #####:  331:	for (i = 0; i < state->deckCount[player]; i++)
        -:  332:	{
    #####:  333:		if (state->deck[player][i] == card) count++;
        -:  334:	}
        -:  335:
    #####:  336:	for (i = 0; i < state->handCount[player]; i++)
        -:  337:	{
    #####:  338:		if (state->hand[player][i] == card) count++;
        -:  339:	}
        -:  340:
    #####:  341:	for (i = 0; i < state->discardCount[player]; i++)
        -:  342:	{
    #####:  343:		if (state->discard[player][i] == card) count++;
        -:  344:	}
        -:  345:
    #####:  346:	return count;
        -:  347:}
        -:  348:
     1452:  349:int whoseTurn(struct gameState *state) {
     1452:  350:	return state->whoseTurn;
        -:  351:}
        -:  352:
      309:  353:int endTurn(struct gameState *state) {
        -:  354:	int k;
        -:  355:	int i;
      309:  356:	int currentPlayer = whoseTurn(state);
        -:  357:
        -:  358:	//Discard hand
     1806:  359:	for (i = 0; i < state->handCount[currentPlayer]; i++){
     1497:  360:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
     1497:  361:		state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  362:	}
      309:  363:	state->handCount[currentPlayer] = 0;//Reset hand count
        -:  364:
        -:  365:	//Code for determining the player
      309:  366:	if (currentPlayer < (state->numPlayers - 1)){
      232:  367:		state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  368:	}
        -:  369:	else{
       77:  370:		state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  371:	}
        -:  372:
      309:  373:	state->outpostPlayed = 0;
      309:  374:	state->phase = 0;
      309:  375:	state->numActions = 1;
      309:  376:	state->coins = 0;
      309:  377:	state->numBuys = 1;
      309:  378:	state->playedCardCount = 0;
      309:  379:	state->handCount[state->whoseTurn] = 0;
        -:  380:
        -:  381:	//int k; move to top
        -:  382:	//Next player draws hand
     1854:  383:	for (k = 0; k < 5; k++){
     1545:  384:		drawCard(state->whoseTurn, state);//Draw a card
        -:  385:	}
        -:  386:
        -:  387:	//Update money
      309:  388:	updateCoins(state->whoseTurn, state, 0);
        -:  389:
      309:  390:	return 0;
        -:  391:}
        -:  392:
     4060:  393:int isGameOver(struct gameState *state) {
        -:  394:	int i;
        -:  395:	int j;
        -:  396:
        -:  397:	//if stack of Province cards is empty, the game ends
     4060:  398:	if (state->supplyCount[province] == 0)
        -:  399:	{
    #####:  400:		return 1;
        -:  401:	}
        -:  402:
        -:  403:	//if three supply pile are at 0, the game ends
     4060:  404:	j = 0;
   105560:  405:	for (i = 0; i < 25; i++)
        -:  406:	{
   101500:  407:		if (state->supplyCount[i] == 0)
        -:  408:		{
     2585:  409:			j++;
        -:  410:		}
        -:  411:	}
     4060:  412:	if (j >= 3)
        -:  413:	{
        2:  414:		return 1;
        -:  415:	}
        -:  416:
     4058:  417:	return 0;
        -:  418:}
        -:  419:
    #####:  420:int scoreFor(int player, struct gameState *state) {
        -:  421:
        -:  422:	int i;
    #####:  423:	int score = 0;
        -:  424:	//score from hand
    #####:  425:	for (i = 0; i < state->handCount[player]; i++)
        -:  426:	{
    #####:  427:		if (state->hand[player][i] == curse) { score = score - 1; };
    #####:  428:		if (state->hand[player][i] == estate) { score = score + 1; };
    #####:  429:		if (state->hand[player][i] == duchy) { score = score + 3; };
    #####:  430:		if (state->hand[player][i] == province) { score = score + 6; };
    #####:  431:		if (state->hand[player][i] == great_hall) { score = score + 1; };
    #####:  432:		if (state->hand[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  433:	}
        -:  434:
        -:  435:	//score from discard
    #####:  436:	for (i = 0; i < state->discardCount[player]; i++)
        -:  437:	{
    #####:  438:		if (state->discard[player][i] == curse) { score = score - 1; };
    #####:  439:		if (state->discard[player][i] == estate) { score = score + 1; };
    #####:  440:		if (state->discard[player][i] == duchy) { score = score + 3; };
    #####:  441:		if (state->discard[player][i] == province) { score = score + 6; };
    #####:  442:		if (state->discard[player][i] == great_hall) { score = score + 1; };
    #####:  443:		if (state->discard[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  444:	}
        -:  445:
        -:  446:	//score from deck
    #####:  447:	for (i = 0; i < state->discardCount[player]; i++)
        -:  448:	{
    #####:  449:		if (state->deck[player][i] == curse) { score = score - 1; };
    #####:  450:		if (state->deck[player][i] == estate) { score = score + 1; };
    #####:  451:		if (state->deck[player][i] == duchy) { score = score + 3; };
    #####:  452:		if (state->deck[player][i] == province) { score = score + 6; };
    #####:  453:		if (state->deck[player][i] == great_hall) { score = score + 1; };
    #####:  454:		if (state->deck[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  455:	}
        -:  456:
    #####:  457:	return score;
        -:  458:}
        -:  459:
    #####:  460:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  461:	int i;
        -:  462:	int j;
        -:  463:	int highScore;
        -:  464:	int currentPlayer;
        -:  465:
        -:  466:	//get score for each player
    #####:  467:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  468:	{
        -:  469:		//set unused player scores to -9999
    #####:  470:		if (i >= state->numPlayers)
        -:  471:		{
    #####:  472:			players[i] = -9999;
        -:  473:		}
        -:  474:		else
        -:  475:		{
    #####:  476:			players[i] = scoreFor(i, state);
        -:  477:		}
        -:  478:	}
        -:  479:
        -:  480:	//find highest score
    #####:  481:	j = 0;
    #####:  482:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  483:	{
    #####:  484:		if (players[i] > players[j])
        -:  485:		{
    #####:  486:			j = i;
        -:  487:		}
        -:  488:	}
    #####:  489:	highScore = players[j];
        -:  490:
        -:  491:	//add 1 to players who had less turns
    #####:  492:	currentPlayer = whoseTurn(state);
    #####:  493:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  494:	{
    #####:  495:		if (players[i] == highScore && i > currentPlayer)
        -:  496:		{
    #####:  497:			players[i]++;
        -:  498:		}
        -:  499:	}
        -:  500:
        -:  501:	//find new highest score
    #####:  502:	j = 0;
    #####:  503:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  504:	{
    #####:  505:		if (players[i] > players[j])
        -:  506:		{
    #####:  507:			j = i;
        -:  508:		}
        -:  509:	}
    #####:  510:	highScore = players[j];
        -:  511:
        -:  512:	//set winners in array to 1 and rest to 0
    #####:  513:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  514:	{
    #####:  515:		if (players[i] == highScore)
        -:  516:		{
    #####:  517:			players[i] = 1;
        -:  518:		}
        -:  519:		else
        -:  520:		{
    #####:  521:			players[i] = 0;
        -:  522:		}
        -:  523:	}
        -:  524:
    #####:  525:	return 0;
        -:  526:}
        -:  527:
     1588:  528:int drawCard(int player, struct gameState *state)
        -:  529:{
        -:  530:	int count;
        -:  531:	int deckCounter;
     1588:  532:	if (state->deckCount[player] <= 0){//Deck is empty
        -:  533:
        -:  534:		//Step 1 Shuffle the discard pile back into a deck
        -:  535:		int i;
        -:  536:		//Move discard to deck
     1776:  537:		for (i = 0; i < state->discardCount[player]; i++){
     1684:  538:			state->deck[player][i] = state->discard[player][i];
     1684:  539:			state->discard[player][i] = -1;
        -:  540:		}
        -:  541:
       92:  542:		state->deckCount[player] = state->discardCount[player];
       92:  543:		state->discardCount[player] = 0;//Reset discard
        -:  544:
        -:  545:		//Shufffle the deck
       92:  546:		shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  547:
        -:  548:		if (DEBUG){//Debug statements
        -:  549:			printf("Deck count now: %d\n", state->deckCount[player]);
        -:  550:		}
        -:  551:
       92:  552:		state->discardCount[player] = 0;
        -:  553:
        -:  554:		//Step 2 Draw Card
       92:  555:		count = state->handCount[player];//Get current player's hand count
        -:  556:
        -:  557:		if (DEBUG){//Debug statements
        -:  558:			printf("Current hand count: %d\n", count);
        -:  559:		}
        -:  560:
       92:  561:		deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  562:
       92:  563:		if (deckCounter == 0)
    #####:  564:			return -1;
        -:  565:
       92:  566:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
       92:  567:		state->deckCount[player]--;
       92:  568:		state->handCount[player]++;//Increment hand count
        -:  569:	}
        -:  570:
        -:  571:	else{
     1496:  572:		int count = state->handCount[player];//Get current hand count for player
        -:  573:		int deckCounter;
        -:  574:		if (DEBUG){//Debug statements
        -:  575:			printf("Current hand count: %d\n", count);
        -:  576:		}
        -:  577:
     1496:  578:		deckCounter = state->deckCount[player];//Create holder for the deck count
     1496:  579:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
     1496:  580:		state->deckCount[player]--;
     1496:  581:		state->handCount[player]++;//Increment hand count
        -:  582:	}
        -:  583:
     1588:  584:	return 0;
        -:  585:}
        -:  586:
      964:  587:int getCost(int cardNumber)
        -:  588:{
      964:  589:	switch (cardNumber)
        -:  590:	{
        -:  591:	case curse:
      103:  592:		return 0;
        -:  593:	case estate:
       48:  594:		return 2;
        -:  595:	case duchy:
       44:  596:		return 5;
        -:  597:	case province:
       43:  598:		return 8;
        -:  599:	case copper:
      106:  600:		return 0;
        -:  601:	case silver:
       69:  602:		return 3;
        -:  603:	case gold:
       43:  604:		return 6;
        -:  605:	case adventurer:
       24:  606:		return 6;
        -:  607:	case council_room:
       21:  608:		return 5;
        -:  609:	case feast:
       32:  610:		return 4;
        -:  611:	case gardens:
        1:  612:		return 4;
        -:  613:	case mine:
       46:  614:		return 5;
        -:  615:	case remodel:
       17:  616:		return 4;
        -:  617:	case smithy:
       24:  618:		return 4;
        -:  619:	case village:
       56:  620:		return 3;
        -:  621:	case baron:
       59:  622:		return 4;
        -:  623:	case great_hall:
       31:  624:		return 3;
        -:  625:	case minion:
       17:  626:		return 5;
        -:  627:	case steward:
       25:  628:		return 3;
        -:  629:	case tribute:
    #####:  630:		return 5;
        -:  631:	case ambassador:
    #####:  632:		return 3;
        -:  633:	case cutpurse:
       25:  634:		return 4;
        -:  635:	case embargo:
       25:  636:		return 2;
        -:  637:	case outpost:
    #####:  638:		return 5;
        -:  639:	case salvager:
       62:  640:		return 4;
        -:  641:	case sea_hag:
       14:  642:		return 4;
        -:  643:	case treasure_map:
       29:  644:		return 4;
        -:  645:	}
        -:  646:
    #####:  647:	return -1;
        -:  648:}
        -:  649:
        2:  650:void playAdventurer(struct gameState *state, int currentPlayer)
        -:  651:// Reveal cards from deck until 2 Treasure cards are found.  Put those Treasure cards in the hand and discard the rest.
        -:  652:{
        2:  653:	int drawntreasure = 0;
        -:  654:	int temphand[MAX_HAND];
        -:  655:	int cardDrawn;
        2:  656:	int z = 0; // this is the counter for the temp hand
        -:  657:
        8:  658:	while (drawntreasure < 2){
        4:  659:		if (state->deckCount[currentPlayer] < 1){//if the deck is empty we need to shuffle discard and add to deck
    #####:  660:			shuffle(currentPlayer, state);
        -:  661:		}
        4:  662:		drawCard(currentPlayer, state);
        4:  663:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer] - 1];//top card of hand is most recently drawn card.
        4:  664:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
        4:  665:			drawntreasure++;
        -:  666:		else{
    #####:  667:			temphand[z] = cardDrawn;
    #####:  668:			state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####:  669:			z++;
        -:  670:		}
        -:  671:	}
        4:  672:	while (z - 1 >= 0){
    #####:  673:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; // discard all cards in play that have been drawn
    #####:  674:		z = z - 1;
        -:  675:	}
        2:  676:}
        -:  677:
        2:  678:int playRemodel(struct gameState *state, int currentPlayer, int choice1, int choice2, int handPos)
        -:  679://Trash a card in the hand, and gain a card costing up to $2 more than the trashed card
        -:  680:{
        -:  681:	int i;
        2:  682:	int j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  683:
        2:  684:	if ((getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2))
        -:  685:	{
    #####:  686:		return -1;
        -:  687:	}
        -:  688:
        2:  689:	gainCard(choice2, state, 0, currentPlayer);
        -:  690:
        -:  691:	//discard card from hand
        2:  692:	discardCard(handPos, currentPlayer, state, 0);
        -:  693:
        -:  694:	//discard trashed card
       10:  695:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  696:	{
        8:  697:		if (state->hand[currentPlayer][i] == j)
        -:  698:		{
    #####:  699:			discardCard(i, currentPlayer, state, 0);
    #####:  700:			break;
        -:  701:		}
        -:  702:	}
        -:  703:
        2:  704:	return 0;
        -:  705:}
        -:  706:
        2:  707:void playSmithy(struct gameState *state, int currentPlayer, int handPos)
        -:  708:// Draw 3 cards
        -:  709:{
        -:  710:	int i;
        8:  711:	for (i = 0; i < 3; i++)
        -:  712:	{
        6:  713:		drawCard(currentPlayer, state);
        -:  714:	}
        -:  715:
        -:  716:	//discard card from hand
        2:  717:	discardCard(handPos, currentPlayer, state, 0);
        2:  718:}
        -:  719:
       16:  720:void playBaron(struct gameState *state, int currentPlayer, int choice1, int handPos)
        -:  721://Add a buy.  OPTION:  Discard an Estate card and gain $4.  Otherwise, gain an Estate card.
        -:  722:{
       16:  723:	state->numBuys++;//Increase buys by 1!
       16:  724:	if (choice1 > 0){//Boolean true or going to discard an estate
       16:  725:		int p = 0;//Iterator for hand!
       16:  726:		int card_not_discarded = 1;//Flag for discard set!
       95:  727:		while (card_not_discarded){
       63:  728:			if (state->hand[currentPlayer][p] == estate){ //Found an estate card!
       12:  729:				state->coins += 4;//Add 4 coins to the amount of coins
       12:  730:				state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
       12:  731:				state->discardCount[currentPlayer]++;
       49:  732:				for (; p < state->handCount[currentPlayer]; p++){
       37:  733:					state->hand[currentPlayer][p] = state->hand[currentPlayer][p + 1];
        -:  734:				}
       12:  735:				state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
       12:  736:				state->handCount[currentPlayer]--;
       12:  737:				card_not_discarded = 0;//Exit the loop
        -:  738:			}
       51:  739:			else if (p > state->handCount[currentPlayer]){
        -:  740:				if (DEBUG) {
        -:  741:					printf("No estate cards in your hand, invalid choice\n");
        -:  742:					printf("Must gain an estate if there are any\n");
        -:  743:				}
        4:  744:				if (supplyCount(estate, state) > 0){
        1:  745:					gainCard(estate, state, 1, currentPlayer);
        1:  746:					state->supplyCount[estate]--;//Decrement estates
        1:  747:					if (supplyCount(estate, state) == 0){
    #####:  748:						isGameOver(state);
        -:  749:					}
        -:  750:				}
        4:  751:				card_not_discarded = 0;//Exit the loop
        -:  752:			}
        -:  753:
        -:  754:			else{
       47:  755:				p++;//Next card
        -:  756:			}
        -:  757:		}
        -:  758:	}
        -:  759:
        -:  760:	else{
    #####:  761:		if (supplyCount(estate, state) > 0){
    #####:  762:			gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  763:			state->supplyCount[estate]--;//Decrement Estates
    #####:  764:			if (supplyCount(estate, state) == 0){
    #####:  765:				isGameOver(state);
        -:  766:			}
        -:  767:		}
        -:  768:	}
       16:  769:}
        -:  770:
        6:  771:int playTreasureMap(struct gameState *state, int currentPlayer, int handPos)
        -:  772://Trashing two treasure map cards from the hand = four gold on top of the deck.
        -:  773:{
        -:  774:	int i;
        -:  775:	int index;
        -:  776:
        -:  777:	//search hand for another treasure_map
       36:  778:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  779:	{
       30:  780:		if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -:  781:		{
    #####:  782:			index = i;
    #####:  783:			break;
        -:  784:		}
        -:  785:	}
        6:  786:	if (index > -1)
        -:  787:	{
        -:  788:		//trash both treasure cards
        6:  789:		discardCard(handPos, currentPlayer, state, 1);
        6:  790:		discardCard(index, currentPlayer, state, 1);
        -:  791:
        -:  792:		//gain 4 Gold cards
       30:  793:		for (i = 0; i < 4; i++)
        -:  794:		{
       24:  795:			gainCard(gold, state, 1, currentPlayer);
        -:  796:		}
        -:  797:
        -:  798:		//return success
        6:  799:		return 1;
        -:  800:	}
        -:  801:
        -:  802:	//no second treasure_map found in hand
    #####:  803:	return -1;
        -:  804:}
        -:  805:
       86:  806:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  807:{
        -:  808:	int i;
        -:  809:	int j;
        -:  810:	int k;
        -:  811:	//int x;  //Unused after while loop removed from feast.
       86:  812:	int currentPlayer = whoseTurn(state);
       86:  813:	int nextPlayer = currentPlayer + 1;
        -:  814:	int temphand[MAX_HAND];
        -:  815:
       86:  816:	int tributeRevealedCards[2] = { -1, -1 };
        -:  817:
       86:  818:	if (nextPlayer > (state->numPlayers - 1)){
       18:  819:		nextPlayer = 0;
        -:  820:	}
        -:  821:
        -:  822:	//uses switch to select card and perform actions
       86:  823:	switch (card)
        -:  824:	{
        -:  825:	case adventurer:
        -:  826:
        2:  827:		playAdventurer(state, currentPlayer);
        2:  828:		return 0;
        -:  829:
        -:  830:	case council_room:
        -:  831:		//+4 Cards
        5:  832:		for (i = 0; i < 4; i++)
        -:  833:		{
        4:  834:			drawCard(currentPlayer, state);
        -:  835:		}
        -:  836:
        -:  837:		//+1 Buy
        1:  838:		state->numBuys++;
        -:  839:
        -:  840:		//Each other player draws a card
        5:  841:		for (i = 0; i < state->numPlayers; i++)
        -:  842:		{
        4:  843:			if (i != currentPlayer)
        -:  844:			{
        3:  845:				drawCard(i, state);
        -:  846:			}
        -:  847:		}
        -:  848:
        -:  849:		//put played card in played card pile
        1:  850:		discardCard(handPos, currentPlayer, state, 0);
        -:  851:
        1:  852:		return 0;
        -:  853:
        -:  854:	case feast:
        -:  855:		//gain card with cost up to 5
        -:  856:		//Backup hand
       84:  857:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
       72:  858:			temphand[i] = state->hand[currentPlayer][i];//Backup card
       72:  859:			state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  860:		}
        -:  861:		//Backup hand
        -:  862:
        -:  863:		//Update Coins for Buy
       12:  864:		updateCoins(currentPlayer, state, 5);
        -:  865://		x = 1;//Condition to loop on
        -:  866://		while (x == 1) {//Buy one card
       12:  867:			if (supplyCount(choice1, state) <= 0){
        -:  868:				if (DEBUG)
        -:  869:					printf("None of that card left, sorry!\n");
        -:  870:
        -:  871:				if (DEBUG){
        -:  872:					printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  873:				}
        -:  874:			}
        7:  875:			else if (state->coins < getCost(choice1)){
        1:  876:				printf("That card is too expensive!\n");
        -:  877:
        -:  878:				if (DEBUG){
        -:  879:					printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  880:				}
        -:  881:			}
        -:  882:			else{
        -:  883:
        -:  884:				if (DEBUG){
        -:  885:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  886:				}
        -:  887:
        6:  888:				gainCard(choice1, state, 0, currentPlayer);//Gain the card
        -:  889://				x = 0;//No more buying cards
        -:  890:
        -:  891:				if (DEBUG){
        -:  892:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  893:				}
        -:  894:
        -:  895:			}
        -:  896://		}
        -:  897:
        -:  898:		//Reset Hand
       84:  899:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
       72:  900:			state->hand[currentPlayer][i] = temphand[i];
       72:  901:			temphand[i] = -1;
        -:  902:		}
        -:  903:		//Reset Hand
        -:  904:
       12:  905:		return 0;
        -:  906:
        -:  907:	case gardens:
    #####:  908:		return -1;
        -:  909:
        -:  910:	case mine:
    #####:  911:		j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  912:
    #####:  913:		if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  914:		{
    #####:  915:			return -1;
        -:  916:		}
        -:  917:
    #####:  918:		if (choice2 > treasure_map || choice2 < curse)
        -:  919:		{
    #####:  920:			return -1;
        -:  921:		}
        -:  922:
    #####:  923:		if ((getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2))
        -:  924:		{
    #####:  925:			return -1;
        -:  926:		}
        -:  927:
    #####:  928:		gainCard(choice2, state, 2, currentPlayer);
        -:  929:
        -:  930:		//discard card from hand
    #####:  931:		discardCard(handPos, currentPlayer, state, 0);
        -:  932:
        -:  933:		//discard trashed card
    #####:  934:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  935:		{
    #####:  936:			if (state->hand[currentPlayer][i] == j)
        -:  937:			{
    #####:  938:				discardCard(i, currentPlayer, state, 0);
    #####:  939:				break;
        -:  940:			}
        -:  941:		}
        -:  942:
    #####:  943:		return 0;
        -:  944:
        -:  945:	case remodel:
        -:  946:
        2:  947:		return playRemodel(state, currentPlayer, choice1, choice2, handPos);
        -:  948:
        -:  949:	case smithy:
        -:  950:
        2:  951:		playSmithy(state, currentPlayer, handPos);
        2:  952:		return 0;
        -:  953:
        -:  954:	case village:
        -:  955:		//+1 Card
       11:  956:		drawCard(currentPlayer, state);
        -:  957:
        -:  958:		//+2 Actions
       11:  959:		state->numActions = state->numActions + 2;
        -:  960:
        -:  961:		//discard played card from hand
       11:  962:		discardCard(handPos, currentPlayer, state, 0);
       11:  963:		return 0;
        -:  964:
        -:  965:	case baron:
        -:  966:
       16:  967:		playBaron(state, currentPlayer, choice1, handPos);
       16:  968:		return 0;
        -:  969:
        -:  970:	case great_hall:
        -:  971:		//+1 Card
        5:  972:		drawCard(currentPlayer, state);
        -:  973:
        -:  974:		//+1 Actions
        5:  975:		state->numActions++;
        -:  976:
        -:  977:		//discard card from hand
        5:  978:		discardCard(handPos, currentPlayer, state, 0);
        5:  979:		return 0;
        -:  980:
        -:  981:	case minion:
        -:  982:		//+1 action
        1:  983:		state->numActions++;
        -:  984:
        -:  985:		//discard card from hand
        1:  986:		discardCard(handPos, currentPlayer, state, 0);
        -:  987:
        1:  988:		if (choice1)		//+2 coins
        -:  989:		{
        1:  990:			state->coins = state->coins + 2;
        -:  991:		}
        -:  992:
    #####:  993:		else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  994:		{
        -:  995:			//discard hand
    #####:  996:			while (numHandCards(state) > 0)
        -:  997:			{
    #####:  998:				discardCard(handPos, currentPlayer, state, 0);
        -:  999:			}
        -: 1000:
        -: 1001:			//draw 4
    #####: 1002:			for (i = 0; i < 4; i++)
        -: 1003:			{
    #####: 1004:				drawCard(currentPlayer, state);
        -: 1005:			}
        -: 1006:
        -: 1007:			//other players discard hand and redraw if hand size > 4
    #####: 1008:			for (i = 0; i < state->numPlayers; i++)
        -: 1009:			{
    #####: 1010:				if (i != currentPlayer)
        -: 1011:				{
    #####: 1012:					if (state->handCount[i] > 4)
        -: 1013:					{
        -: 1014:						//discard hand
    #####: 1015:						while (state->handCount[i] > 0)
        -: 1016:						{
    #####: 1017:							discardCard(handPos, i, state, 0);
        -: 1018:						}
        -: 1019:
        -: 1020:						//draw 4
    #####: 1021:						for (j = 0; j < 4; j++)
        -: 1022:						{
    #####: 1023:							drawCard(i, state);
        -: 1024:						}
        -: 1025:					}
        -: 1026:				}
        -: 1027:			}
        -: 1028:
        -: 1029:		}
        1: 1030:		return 0;
        -: 1031:
        -: 1032:	case steward:
        5: 1033:		if (choice1 == 1)
        -: 1034:		{
        -: 1035:			//+2 cards
    #####: 1036:			drawCard(currentPlayer, state);
    #####: 1037:			drawCard(currentPlayer, state);
        -: 1038:		}
        5: 1039:		else if (choice1 == 2)
        -: 1040:		{
        -: 1041:			//+2 coins
        1: 1042:			state->coins = state->coins + 2;
        -: 1043:		}
        -: 1044:		else
        -: 1045:		{
        -: 1046:			//trash 2 cards in hand
        4: 1047:			discardCard(choice2, currentPlayer, state, 1);
        4: 1048:			discardCard(choice3, currentPlayer, state, 1);
        -: 1049:		}
        -: 1050:
        -: 1051:		//discard card from hand
        5: 1052:		discardCard(handPos, currentPlayer, state, 0);
        5: 1053:		return 0;
        -: 1054:
        -: 1055:	case tribute:
    #####: 1056:		if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####: 1057:			if (state->deckCount[nextPlayer] > 0){
    #####: 1058:				tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1059:				state->deckCount[nextPlayer]--;
        -: 1060:			}
    #####: 1061:			else if (state->discardCount[nextPlayer] > 0){
    #####: 1062:				tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer] - 1];
    #####: 1063:				state->discardCount[nextPlayer]--;
        -: 1064:			}
        -: 1065:			else{
        -: 1066:				//No Card to Reveal
        -: 1067:				if (DEBUG){
        -: 1068:					printf("No cards to reveal\n");
        -: 1069:				}
        -: 1070:			}
        -: 1071:		}
        -: 1072:
        -: 1073:		else{
    #####: 1074:			if (state->deckCount[nextPlayer] == 0){
    #####: 1075:				for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####: 1076:					state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1077:					state->deckCount[nextPlayer]++;
    #####: 1078:					state->discard[nextPlayer][i] = -1;
    #####: 1079:					state->discardCount[nextPlayer]--;
        -: 1080:				}
        -: 1081:
    #####: 1082:				shuffle(nextPlayer, state);//Shuffle the deck
        -: 1083:			}
    #####: 1084:			tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1085:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1086:			state->deckCount[nextPlayer]--;
    #####: 1087:			tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1088:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1089:			state->deckCount[nextPlayer]--;
        -: 1090:		}
        -: 1091:
    #####: 1092:		if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
    #####: 1093:			state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1094:			state->playedCardCount++;
    #####: 1095:			tributeRevealedCards[1] = -1;
        -: 1096:		}
        -: 1097:
    #####: 1098:		for (i = 0; i <= 2; i++){
    #####: 1099:			if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
    #####: 1100:				state->coins += 2;
        -: 1101:			}
        -: 1102:
    #####: 1103:			else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
    #####: 1104:				drawCard(currentPlayer, state);
    #####: 1105:				drawCard(currentPlayer, state);
        -: 1106:			}
        -: 1107:			else{//Action Card
    #####: 1108:				state->numActions = state->numActions + 2;
        -: 1109:			}
        -: 1110:		}
        -: 1111:
    #####: 1112:		return 0;
        -: 1113:
        -: 1114:	case ambassador:
    #####: 1115:		j = 0;		//used to check if player has enough cards to discard
        -: 1116:
    #####: 1117:		if (choice2 > 2 || choice2 < 0)
        -: 1118:		{
    #####: 1119:			return -1;
        -: 1120:		}
        -: 1121:
    #####: 1122:		if (choice1 == handPos)
        -: 1123:		{
    #####: 1124:			return -1;
        -: 1125:		}
        -: 1126:
    #####: 1127:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1128:		{
    #####: 1129:			if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1130:			{
    #####: 1131:				j++;
        -: 1132:			}
        -: 1133:		}
    #####: 1134:		if (j < choice2)
        -: 1135:		{
    #####: 1136:			return -1;
        -: 1137:		}
        -: 1138:
        -: 1139:		if (DEBUG)
        -: 1140:			printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1141:
        -: 1142:		//increase supply count for choosen card by amount being discarded
    #####: 1143:		state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1144:
        -: 1145:		//each other player gains a copy of revealed card
    #####: 1146:		for (i = 0; i < state->numPlayers; i++)
        -: 1147:		{
    #####: 1148:			if (i != currentPlayer)
        -: 1149:			{
    #####: 1150:				gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1151:			}
        -: 1152:		}
        -: 1153:
        -: 1154:		//discard played card from hand
    #####: 1155:		discardCard(handPos, currentPlayer, state, 0);
        -: 1156:
        -: 1157:		//trash copies of cards returned to supply
    #####: 1158:		for (j = 0; j < choice2; j++)
        -: 1159:		{
    #####: 1160:			for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1161:			{
    #####: 1162:				if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1163:				{
    #####: 1164:					discardCard(i, currentPlayer, state, 1);
    #####: 1165:					break;
        -: 1166:				}
        -: 1167:			}
        -: 1168:		}
        -: 1169:
    #####: 1170:		return 0;
        -: 1171:
        -: 1172:	case cutpurse:
        -: 1173:
    #####: 1174:		updateCoins(currentPlayer, state, 2);
    #####: 1175:		for (i = 0; i < state->numPlayers; i++)
        -: 1176:		{
    #####: 1177:			if (i != currentPlayer)
        -: 1178:			{
    #####: 1179:				for (j = 0; j < state->handCount[i]; j++)
        -: 1180:				{
    #####: 1181:					if (state->hand[i][j] == copper)
        -: 1182:					{
    #####: 1183:						discardCard(j, i, state, 0);
    #####: 1184:						break;
        -: 1185:					}
    #####: 1186:					if (j == state->handCount[i])
        -: 1187:					{
    #####: 1188:						for (k = 0; k < state->handCount[i]; k++)
        -: 1189:						{
        -: 1190:							if (DEBUG)
        -: 1191:								printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1192:						}
    #####: 1193:						break;
        -: 1194:					}
        -: 1195:				}
        -: 1196:
        -: 1197:			}
        -: 1198:
        -: 1199:		}
        -: 1200:
        -: 1201:		//discard played card from hand
    #####: 1202:		discardCard(handPos, currentPlayer, state, 0);
        -: 1203:
    #####: 1204:		return 0;
        -: 1205:
        -: 1206:
        -: 1207:	case embargo:
        -: 1208:		//+2 Coins
       10: 1209:		state->coins = state->coins + 2;
        -: 1210:
        -: 1211:		//see if selected pile is in play
       10: 1212:		if (state->supplyCount[choice1] == -1)
        -: 1213:		{
        7: 1214:			return -1;
        -: 1215:		}
        -: 1216:
        -: 1217:		//add embargo token to selected supply pile
        3: 1218:		state->embargoTokens[choice1]++;
        -: 1219:
        -: 1220:		//trash card
        3: 1221:		discardCard(handPos, currentPlayer, state, 1);
        3: 1222:		return 0;
        -: 1223:
        -: 1224:	case outpost:
        -: 1225:		//set outpost flag
    #####: 1226:		state->outpostPlayed++;
        -: 1227:
        -: 1228:		//discard card
    #####: 1229:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1230:		return 0;
        -: 1231:
        -: 1232:	case salvager:
        -: 1233:		//+1 buy
        6: 1234:		state->numBuys++;
        -: 1235:
        6: 1236:		if (choice1)
        -: 1237:		{
        -: 1238:			//gain coins equal to trashed card
        6: 1239:			state->coins = state->coins + getCost(handCard(choice1, state));
        -: 1240:			//trash card
        6: 1241:			discardCard(choice1, currentPlayer, state, 1);
        -: 1242:		}
        -: 1243:
        -: 1244:		//discard card
        6: 1245:		discardCard(handPos, currentPlayer, state, 0);
        6: 1246:		return 0;
        -: 1247:
        -: 1248:	case sea_hag:
       35: 1249:		for (i = 0; i < state->numPlayers; i++){
       28: 1250:			if (i != currentPlayer){
       21: 1251:				state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
       21: 1252:				state->discardCount[i]++;
       21: 1253:				state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1254:			}
        -: 1255:		}
        7: 1256:		return 0;
        -: 1257:
        -: 1258:	case treasure_map:
        -: 1259:
        6: 1260:		return playTreasureMap(state, currentPlayer, handPos);
        -: 1261:	}
    #####: 1262:	return -1;
        -: 1263:}
        -: 1264:
       62: 1265:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1266:{
        -: 1267:
        -: 1268:	//if card is not trashed, added to Played pile 
       62: 1269:	if (trashFlag < 1)
        -: 1270:	{
        -: 1271:		//add card to played pile
       33: 1272:		state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
       33: 1273:		state->playedCardCount++;
        -: 1274:	}
        -: 1275:
        -: 1276:	//set played card to -1
       62: 1277:	state->hand[currentPlayer][handPos] = -1;
        -: 1278:
        -: 1279:	//remove card from player's hand
       62: 1280:	if (handPos == (state->handCount[currentPlayer] - 1)) 	//last card in hand array is played
        -: 1281:	{
        -: 1282:		//reduce number of cards in hand
        5: 1283:		state->handCount[currentPlayer]--;
        -: 1284:	}
       57: 1285:	else if (state->handCount[currentPlayer] == 1) //only one card in hand
        -: 1286:	{
        -: 1287:		//reduce number of cards in hand
    #####: 1288:		state->handCount[currentPlayer]--;
        -: 1289:	}
        -: 1290:	else
        -: 1291:	{
        -: 1292:		//replace discarded card with last card in hand
       57: 1293:		state->hand[currentPlayer][handPos] = state->hand[currentPlayer][(state->handCount[currentPlayer] - 1)];
        -: 1294:		//set last card to -1
       57: 1295:		state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1296:		//reduce number of cards in hand
       57: 1297:		state->handCount[currentPlayer]--;
        -: 1298:	}
        -: 1299:
       62: 1300:	return 0;
        -: 1301:}
        -: 1302:
      285: 1303:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1304:{
        -: 1305:	//Note: supplyPos is enum of choosen card
        -: 1306:
        -: 1307:	//check if supply pile is empty (0) or card is not used in game (-1)
      285: 1308:	if (supplyCount(supplyPos, state) < 1)
        -: 1309:	{
        1: 1310:		return -1;
        -: 1311:	}
        -: 1312:
        -: 1313:	//added card for [whoseTurn] current player:
        -: 1314:	// toFlag = 0 : add to discard
        -: 1315:	// toFlag = 1 : add to deck
        -: 1316:	// toFlag = 2 : add to hand
        -: 1317:
      284: 1318:	if (toFlag == 1)
        -: 1319:	{
       25: 1320:		state->deck[player][state->deckCount[player]] = supplyPos;
       25: 1321:		state->deckCount[player]++;
        -: 1322:	}
      259: 1323:	else if (toFlag == 2)
        -: 1324:	{
    #####: 1325:		state->hand[player][state->handCount[player]] = supplyPos;
    #####: 1326:		state->handCount[player]++;
        -: 1327:	}
        -: 1328:	else
        -: 1329:	{
      259: 1330:		state->discard[player][state->discardCount[player]] = supplyPos;
      259: 1331:		state->discardCount[player]++;
        -: 1332:	}
        -: 1333:
        -: 1334:	//decrease number in supply pile
      284: 1335:	state->supplyCount[supplyPos]--;
        -: 1336:
      284: 1337:	return 0;
        -: 1338:}
        -: 1339:
      402: 1340:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1341:{
        -: 1342:	int i;
        -: 1343:
        -: 1344:	//reset coin count
      402: 1345:	state->coins = 0;
        -: 1346:
        -: 1347:	//add coins for each Treasure card in player's hand
     2363: 1348:	for (i = 0; i < state->handCount[player]; i++)
        -: 1349:	{
     1961: 1350:		if (state->hand[player][i] == copper)
        -: 1351:		{
      807: 1352:			state->coins += 1;
        -: 1353:		}
     1154: 1354:		else if (state->hand[player][i] == silver)
        -: 1355:		{
      121: 1356:			state->coins += 2;
        -: 1357:		}
     1033: 1358:		else if (state->hand[player][i] == gold)
        -: 1359:		{
       69: 1360:			state->coins += 3;
        -: 1361:		}
        -: 1362:	}
        -: 1363:
        -: 1364:	//add bonus
      402: 1365:	state->coins += bonus;
        -: 1366:
      402: 1367:	return 0;
        -: 1368:}
        -: 1369:
        -: 1370:
        -: 1371://end of dominion.c
File 'dominion.c'
Lines executed:60.32% of 557
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
     3307:    8:int compare(const void* a, const void* b) {
     3307:    9:	if (*(int*)a > *(int*)b)
     1001:   10:		return 1;
     2306:   11:	if (*(int*)a < *(int*)b)
     1106:   12:		return -1;
     1200:   13:	return 0;
        -:   14:}
        -:   15:
        4:   16:struct gameState* newGame() {
        4:   17:	struct gameState* g = malloc(sizeof(struct gameState));
        4:   18:	return g;
        -:   19:}
        -:   20:
       20:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:	int k8, int k9, int k10) {
       20:   23:	int* k = malloc(10 * sizeof(int));
       20:   24:	k[0] = k1;
       20:   25:	k[1] = k2;
       20:   26:	k[2] = k3;
       20:   27:	k[3] = k4;
       20:   28:	k[4] = k5;
       20:   29:	k[5] = k6;
       20:   30:	k[6] = k7;
       20:   31:	k[7] = k8;
       20:   32:	k[8] = k9;
       20:   33:	k[9] = k10;
       20:   34:	return k;
        -:   35:}
        -:   36:
       20:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		struct gameState *state) {
        -:   39:
        -:   40:	int i;
        -:   41:	int j;
        -:   42:	int it;
        -:   43:	//set up random number generator
       20:   44:	SelectStream(1);
       20:   45:	PutSeed((long)randomSeed);
        -:   46:
        -:   47:	//check number of players
       20:   48:	if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:	{
    #####:   50:		return -1;
        -:   51:	}
        -:   52:
        -:   53:	//set number of players
       20:   54:	state->numPlayers = numPlayers;
        -:   55:
        -:   56:	//check selected kingdom cards are different
       59:   57:	for (i = 0; i < 10; i++)
        -:   58:	{
      521:   59:		for (j = 0; j < 10; j++)
        -:   60:		{
      482:   61:			if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:			{
       18:   63:				return -1;
        -:   64:			}
        -:   65:		}
        -:   66:	}
        -:   67:
        -:   68:
        -:   69:	//initialize supply
        -:   70:	///////////////////////////////
        -:   71:
        -:   72:	//set number of Curse cards
        2:   73:	if (numPlayers == 2)
        -:   74:	{
    #####:   75:		state->supplyCount[curse] = 10;
        -:   76:	}
        2:   77:	else if (numPlayers == 3)
        -:   78:	{
        1:   79:		state->supplyCount[curse] = 20;
        -:   80:	}
        -:   81:	else
        -:   82:	{
        1:   83:		state->supplyCount[curse] = 30;
        -:   84:	}
        -:   85:
        -:   86:	//set number of Victory cards
        2:   87:	if (numPlayers == 2)
        -:   88:	{
    #####:   89:		state->supplyCount[estate] = 8;
    #####:   90:		state->supplyCount[duchy] = 8;
    #####:   91:		state->supplyCount[province] = 8;
        -:   92:	}
        -:   93:	else
        -:   94:	{
        2:   95:		state->supplyCount[estate] = 12;
        2:   96:		state->supplyCount[duchy] = 12;
        2:   97:		state->supplyCount[province] = 12;
        -:   98:	}
        -:   99:
        -:  100:	//set number of Treasure cards
        2:  101:	state->supplyCount[copper] = 60 - (7 * numPlayers);
        2:  102:	state->supplyCount[silver] = 40;
        2:  103:	state->supplyCount[gold] = 30;
        -:  104:
        -:  105:	//set number of Kingdom cards
       42:  106:	for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:	{
      330:  108:		for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:		{
      310:  110:			if (kingdomCards[j] == i)
        -:  111:			{
        -:  112:				//check if card is a 'Victory' Kingdom card
       20:  113:				if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:				{
        6:  115:					if (numPlayers == 2){
    #####:  116:						state->supplyCount[i] = 8;
        -:  117:					}
        3:  118:					else{ state->supplyCount[i] = 12; }
        -:  119:				}
        -:  120:				else
        -:  121:				{
       17:  122:					state->supplyCount[i] = 10;
        -:  123:				}
       20:  124:				break;
        -:  125:			}
        -:  126:			else    //card is not in the set choosen for the game
        -:  127:			{
      290:  128:				state->supplyCount[i] = -1;
        -:  129:			}
        -:  130:		}
        -:  131:
        -:  132:	}
        -:  133:
        -:  134:	////////////////////////
        -:  135:	//supply intilization complete
        -:  136:
        -:  137:	//set player decks
        9:  138:	for (i = 0; i < numPlayers; i++)
        -:  139:	{
        7:  140:		state->deckCount[i] = 0;
       28:  141:		for (j = 0; j < 3; j++)
        -:  142:		{
       21:  143:			state->deck[i][j] = estate;
       21:  144:			state->deckCount[i]++;
        -:  145:		}
       56:  146:		for (j = 3; j < 10; j++)
        -:  147:		{
       49:  148:			state->deck[i][j] = copper;
       49:  149:			state->deckCount[i]++;
        -:  150:		}
        -:  151:	}
        -:  152:
        -:  153:	//shuffle player decks
        9:  154:	for (i = 0; i < numPlayers; i++)
        -:  155:	{
        7:  156:		if (shuffle(i, state) < 0)
        -:  157:		{
    #####:  158:			return -1;
        -:  159:		}
        -:  160:	}
        -:  161:
        -:  162:	//draw player hands
        9:  163:	for (i = 0; i < numPlayers; i++)
        -:  164:	{
        -:  165:		//initialize hand size to zero
        7:  166:		state->handCount[i] = 0;
        7:  167:		state->discardCount[i] = 0;
        -:  168:		//draw 5 cards
        -:  169:		// for (j = 0; j < 5; j++)
        -:  170:		//	{
        -:  171:		//	  drawCard(i, state);
        -:  172:		//	}
        -:  173:	}
        -:  174:
        -:  175:	//set embargo tokens to 0 for all supply piles
       56:  176:	for (i = 0; i <= treasure_map; i++)
        -:  177:	{
       54:  178:		state->embargoTokens[i] = 0;
        -:  179:	}
        -:  180:
        -:  181:	//initialize first player's turn
        2:  182:	state->outpostPlayed = 0;
        2:  183:	state->phase = 0;
        2:  184:	state->numActions = 1;
        2:  185:	state->numBuys = 1;
        2:  186:	state->playedCardCount = 0;
        2:  187:	state->whoseTurn = 0;
        2:  188:	state->handCount[state->whoseTurn] = 0;
        -:  189:	//int it; move to top
        -:  190:
        -:  191:	//Moved draw cards to here, only drawing at the start of a turn
       12:  192:	for (it = 0; it < 5; it++){
       10:  193:		drawCard(state->whoseTurn, state);
        -:  194:	}
        -:  195:
        2:  196:	updateCoins(state->whoseTurn, state, 0);
        -:  197:
        2:  198:	return 0;
        -:  199:}
        -:  200:
       76:  201:int shuffle(int player, struct gameState *state) {
        -:  202:
        -:  203:
        -:  204:	int newDeck[MAX_DECK];
       76:  205:	int newDeckPos = 0;
        -:  206:	int card;
        -:  207:	int i;
        -:  208:
       76:  209:	if (state->deckCount[player] < 1)
    #####:  210:		return -1;
       76:  211:	qsort((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
        -:  212:	/* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
     1631:  214:	while (state->deckCount[player] > 0) {
     1479:  215:		card = floor(Random() * state->deckCount[player]);
     1479:  216:		newDeck[newDeckPos] = state->deck[player][card];
     1479:  217:		newDeckPos++;
    10059:  218:		for (i = card; i < state->deckCount[player] - 1; i++) {
     8580:  219:			state->deck[player][i] = state->deck[player][i + 1];
        -:  220:		}
     1479:  221:		state->deckCount[player]--;
        -:  222:	}
     1555:  223:	for (i = 0; i < newDeckPos; i++) {
     1479:  224:		state->deck[player][i] = newDeck[i];
     1479:  225:		state->deckCount[player]++;
        -:  226:	}
        -:  227:
       76:  228:	return 0;
        -:  229:}
        -:  230:
     2042:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state)
        -:  232:{
        -:  233:	int card;
     2042:  234:	int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:	//check if it is the right phase
     2042:  237:	if (state->phase != 0)
        -:  238:	{
      225:  239:		return -1;
        -:  240:	}
        -:  241:
        -:  242:	//check if player has enough actions
     1817:  243:	if (state->numActions < 1)
        -:  244:	{
       26:  245:		return -1;
        -:  246:	}
        -:  247:
        -:  248:	//get card played
     1791:  249:	card = handCard(handPos, state);
        -:  250:
        -:  251:	//check if selected card is an action
     1791:  252:	if (card < adventurer || card > treasure_map)
        -:  253:	{
     1622:  254:		return -1;
        -:  255:	}
        -:  256:
        -:  257:	//play card
      169:  258:	if (cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0)
        -:  259:	{
      120:  260:		return -1;
        -:  261:	}
        -:  262:
        -:  263:	//reduce number of actions
       49:  264:	state->numActions--;
        -:  265:
        -:  266:	//update coins (Treasure cards may be added with card draws)
       49:  267:	updateCoins(state->whoseTurn, state, coin_bonus);
        -:  268:
       49:  269:	return 0;
        -:  270:}
        -:  271:
     1899:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:	int who;
        -:  274:	if (DEBUG){
        -:  275:		printf("Entering buyCard...\n");
        -:  276:	}
        -:  277:
        -:  278:	// I don't know what to do about the phase thing.
        -:  279:
     1899:  280:	who = state->whoseTurn;
        -:  281:
     1899:  282:	if (state->numBuys < 1){
        -:  283:		if (DEBUG)
        -:  284:			printf("You do not have any buys left\n");
      236:  285:		return -1;
        -:  286:	}
     1663:  287:	else if (supplyCount(supplyPos, state) < 1){
        -:  288:		if (DEBUG)
        -:  289:			printf("There are not any of that type of card left\n");
      648:  290:		return -1;
        -:  291:	}
     1015:  292:	else if (state->coins < getCost(supplyPos)){
        -:  293:		if (DEBUG)
        -:  294:			printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
      789:  295:		return -1;
        -:  296:	}
        -:  297:	else {
      226:  298:		state->phase = 1;
        -:  299:		//state->supplyCount[supplyPos]--;
      226:  300:		gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  301:
      226:  302:		state->coins = (state->coins) - (getCost(supplyPos));
      226:  303:		state->numBuys--;
        -:  304:		if (DEBUG)
        -:  305:			printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  306:	}
        -:  307:
        -:  308:	//state->discard[who][state->discardCount[who]] = supplyPos;
        -:  309:	//state->discardCount[who]++;
        -:  310:
      226:  311:	return 0;
        -:  312:}
        -:  313:
    #####:  314:int numHandCards(struct gameState *state) {
    #####:  315:	return state->handCount[whoseTurn(state)];
        -:  316:}
        -:  317:
     1796:  318:int handCard(int handPos, struct gameState *state) {
     1796:  319:	int currentPlayer = whoseTurn(state);
     1796:  320:	return state->hand[currentPlayer][handPos];
        -:  321:}
        -:  322:
     1917:  323:int supplyCount(int card, struct gameState *state) {
     1917:  324:	return state->supplyCount[card];
        -:  325:}
        -:  326:
    #####:  327:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  328:	int i;
    #####:  329:	int count = 0;
        -:  330:
    #####:  331:	for (i = 0; i < state->deckCount[player]; i++)
        -:  332:	{
    #####:  333:		if (state->deck[player][i] == card) count++;
        -:  334:	}
        -:  335:
    #####:  336:	for (i = 0; i < state->handCount[player]; i++)
        -:  337:	{
    #####:  338:		if (state->hand[player][i] == card) count++;
        -:  339:	}
        -:  340:
    #####:  341:	for (i = 0; i < state->discardCount[player]; i++)
        -:  342:	{
    #####:  343:		if (state->discard[player][i] == card) count++;
        -:  344:	}
        -:  345:
    #####:  346:	return count;
        -:  347:}
        -:  348:
     2235:  349:int whoseTurn(struct gameState *state) {
     2235:  350:	return state->whoseTurn;
        -:  351:}
        -:  352:
      270:  353:int endTurn(struct gameState *state) {
        -:  354:	int k;
        -:  355:	int i;
      270:  356:	int currentPlayer = whoseTurn(state);
        -:  357:
        -:  358:	//Discard hand
     1577:  359:	for (i = 0; i < state->handCount[currentPlayer]; i++){
     1307:  360:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
     1307:  361:		state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  362:	}
      270:  363:	state->handCount[currentPlayer] = 0;//Reset hand count
        -:  364:
        -:  365:	//Code for determining the player
      270:  366:	if (currentPlayer < (state->numPlayers - 1)){
      190:  367:		state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  368:	}
        -:  369:	else{
       80:  370:		state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  371:	}
        -:  372:
      270:  373:	state->outpostPlayed = 0;
      270:  374:	state->phase = 0;
      270:  375:	state->numActions = 1;
      270:  376:	state->coins = 0;
      270:  377:	state->numBuys = 1;
      270:  378:	state->playedCardCount = 0;
      270:  379:	state->handCount[state->whoseTurn] = 0;
        -:  380:
        -:  381:	//int k; move to top
        -:  382:	//Next player draws hand
     1620:  383:	for (k = 0; k < 5; k++){
     1350:  384:		drawCard(state->whoseTurn, state);//Draw a card
        -:  385:	}
        -:  386:
        -:  387:	//Update money
      270:  388:	updateCoins(state->whoseTurn, state, 0);
        -:  389:
      270:  390:	return 0;
        -:  391:}
        -:  392:
     6020:  393:int isGameOver(struct gameState *state) {
        -:  394:	int i;
        -:  395:	int j;
        -:  396:
        -:  397:	//if stack of Province cards is empty, the game ends
     6020:  398:	if (state->supplyCount[province] == 0)
        -:  399:	{
    #####:  400:		return 1;
        -:  401:	}
        -:  402:
        -:  403:	//if three supply pile are at 0, the game ends
     6020:  404:	j = 0;
   156520:  405:	for (i = 0; i < 25; i++)
        -:  406:	{
   150500:  407:		if (state->supplyCount[i] == 0)
        -:  408:		{
     5692:  409:			j++;
        -:  410:		}
        -:  411:	}
     6020:  412:	if (j >= 3)
        -:  413:	{
        2:  414:		return 1;
        -:  415:	}
        -:  416:
     6018:  417:	return 0;
        -:  418:}
        -:  419:
    #####:  420:int scoreFor(int player, struct gameState *state) {
        -:  421:
        -:  422:	int i;
    #####:  423:	int score = 0;
        -:  424:	//score from hand
    #####:  425:	for (i = 0; i < state->handCount[player]; i++)
        -:  426:	{
    #####:  427:		if (state->hand[player][i] == curse) { score = score - 1; };
    #####:  428:		if (state->hand[player][i] == estate) { score = score + 1; };
    #####:  429:		if (state->hand[player][i] == duchy) { score = score + 3; };
    #####:  430:		if (state->hand[player][i] == province) { score = score + 6; };
    #####:  431:		if (state->hand[player][i] == great_hall) { score = score + 1; };
    #####:  432:		if (state->hand[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  433:	}
        -:  434:
        -:  435:	//score from discard
    #####:  436:	for (i = 0; i < state->discardCount[player]; i++)
        -:  437:	{
    #####:  438:		if (state->discard[player][i] == curse) { score = score - 1; };
    #####:  439:		if (state->discard[player][i] == estate) { score = score + 1; };
    #####:  440:		if (state->discard[player][i] == duchy) { score = score + 3; };
    #####:  441:		if (state->discard[player][i] == province) { score = score + 6; };
    #####:  442:		if (state->discard[player][i] == great_hall) { score = score + 1; };
    #####:  443:		if (state->discard[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  444:	}
        -:  445:
        -:  446:	//score from deck
    #####:  447:	for (i = 0; i < state->discardCount[player]; i++)
        -:  448:	{
    #####:  449:		if (state->deck[player][i] == curse) { score = score - 1; };
    #####:  450:		if (state->deck[player][i] == estate) { score = score + 1; };
    #####:  451:		if (state->deck[player][i] == duchy) { score = score + 3; };
    #####:  452:		if (state->deck[player][i] == province) { score = score + 6; };
    #####:  453:		if (state->deck[player][i] == great_hall) { score = score + 1; };
    #####:  454:		if (state->deck[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  455:	}
        -:  456:
    #####:  457:	return score;
        -:  458:}
        -:  459:
    #####:  460:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  461:	int i;
        -:  462:	int j;
        -:  463:	int highScore;
        -:  464:	int currentPlayer;
        -:  465:
        -:  466:	//get score for each player
    #####:  467:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  468:	{
        -:  469:		//set unused player scores to -9999
    #####:  470:		if (i >= state->numPlayers)
        -:  471:		{
    #####:  472:			players[i] = -9999;
        -:  473:		}
        -:  474:		else
        -:  475:		{
    #####:  476:			players[i] = scoreFor(i, state);
        -:  477:		}
        -:  478:	}
        -:  479:
        -:  480:	//find highest score
    #####:  481:	j = 0;
    #####:  482:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  483:	{
    #####:  484:		if (players[i] > players[j])
        -:  485:		{
    #####:  486:			j = i;
        -:  487:		}
        -:  488:	}
    #####:  489:	highScore = players[j];
        -:  490:
        -:  491:	//add 1 to players who had less turns
    #####:  492:	currentPlayer = whoseTurn(state);
    #####:  493:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  494:	{
    #####:  495:		if (players[i] == highScore && i > currentPlayer)
        -:  496:		{
    #####:  497:			players[i]++;
        -:  498:		}
        -:  499:	}
        -:  500:
        -:  501:	//find new highest score
    #####:  502:	j = 0;
    #####:  503:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  504:	{
    #####:  505:		if (players[i] > players[j])
        -:  506:		{
    #####:  507:			j = i;
        -:  508:		}
        -:  509:	}
    #####:  510:	highScore = players[j];
        -:  511:
        -:  512:	//set winners in array to 1 and rest to 0
    #####:  513:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  514:	{
    #####:  515:		if (players[i] == highScore)
        -:  516:		{
    #####:  517:			players[i] = 1;
        -:  518:		}
        -:  519:		else
        -:  520:		{
    #####:  521:			players[i] = 0;
        -:  522:		}
        -:  523:	}
        -:  524:
    #####:  525:	return 0;
        -:  526:}
        -:  527:
     1382:  528:int drawCard(int player, struct gameState *state)
        -:  529:{
        -:  530:	int count;
        -:  531:	int deckCounter;
     1382:  532:	if (state->deckCount[player] <= 0){//Deck is empty
        -:  533:
        -:  534:		//Step 1 Shuffle the discard pile back into a deck
        -:  535:		int i;
        -:  536:		//Move discard to deck
     1478:  537:		for (i = 0; i < state->discardCount[player]; i++){
     1409:  538:			state->deck[player][i] = state->discard[player][i];
     1409:  539:			state->discard[player][i] = -1;
        -:  540:		}
        -:  541:
       69:  542:		state->deckCount[player] = state->discardCount[player];
       69:  543:		state->discardCount[player] = 0;//Reset discard
        -:  544:
        -:  545:		//Shufffle the deck
       69:  546:		shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  547:
        -:  548:		if (DEBUG){//Debug statements
        -:  549:			printf("Deck count now: %d\n", state->deckCount[player]);
        -:  550:		}
        -:  551:
       69:  552:		state->discardCount[player] = 0;
        -:  553:
        -:  554:		//Step 2 Draw Card
       69:  555:		count = state->handCount[player];//Get current player's hand count
        -:  556:
        -:  557:		if (DEBUG){//Debug statements
        -:  558:			printf("Current hand count: %d\n", count);
        -:  559:		}
        -:  560:
       69:  561:		deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  562:
       69:  563:		if (deckCounter == 0)
    #####:  564:			return -1;
        -:  565:
       69:  566:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
       69:  567:		state->deckCount[player]--;
       69:  568:		state->handCount[player]++;//Increment hand count
        -:  569:	}
        -:  570:
        -:  571:	else{
     1313:  572:		int count = state->handCount[player];//Get current hand count for player
        -:  573:		int deckCounter;
        -:  574:		if (DEBUG){//Debug statements
        -:  575:			printf("Current hand count: %d\n", count);
        -:  576:		}
        -:  577:
     1313:  578:		deckCounter = state->deckCount[player];//Create holder for the deck count
     1313:  579:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
     1313:  580:		state->deckCount[player]--;
     1313:  581:		state->handCount[player]++;//Increment hand count
        -:  582:	}
        -:  583:
     1382:  584:	return 0;
        -:  585:}
        -:  586:
     1255:  587:int getCost(int cardNumber)
        -:  588:{
     1255:  589:	switch (cardNumber)
        -:  590:	{
        -:  591:	case curse:
       85:  592:		return 0;
        -:  593:	case estate:
       49:  594:		return 2;
        -:  595:	case duchy:
       84:  596:		return 5;
        -:  597:	case province:
       52:  598:		return 8;
        -:  599:	case copper:
      112:  600:		return 0;
        -:  601:	case silver:
       81:  602:		return 3;
        -:  603:	case gold:
       71:  604:		return 6;
        -:  605:	case adventurer:
       68:  606:		return 6;
        -:  607:	case council_room:
       15:  608:		return 5;
        -:  609:	case feast:
       49:  610:		return 4;
        -:  611:	case gardens:
       89:  612:		return 4;
        -:  613:	case mine:
       65:  614:		return 5;
        -:  615:	case remodel:
    #####:  616:		return 4;
        -:  617:	case smithy:
       60:  618:		return 4;
        -:  619:	case village:
       26:  620:		return 3;
        -:  621:	case baron:
    #####:  622:		return 4;
        -:  623:	case great_hall:
       33:  624:		return 3;
        -:  625:	case minion:
       68:  626:		return 5;
        -:  627:	case steward:
       45:  628:		return 3;
        -:  629:	case tribute:
        1:  630:		return 5;
        -:  631:	case ambassador:
       28:  632:		return 3;
        -:  633:	case cutpurse:
    #####:  634:		return 4;
        -:  635:	case embargo:
    #####:  636:		return 2;
        -:  637:	case outpost:
       23:  638:		return 5;
        -:  639:	case salvager:
       43:  640:		return 4;
        -:  641:	case sea_hag:
       48:  642:		return 4;
        -:  643:	case treasure_map:
       60:  644:		return 4;
        -:  645:	}
        -:  646:
    #####:  647:	return -1;
        -:  648:}
        -:  649:
    #####:  650:void playAdventurer(struct gameState *state, int currentPlayer)
        -:  651:// Reveal cards from deck until 2 Treasure cards are found.  Put those Treasure cards in the hand and discard the rest.
        -:  652:{
    #####:  653:	int drawntreasure = 0;
        -:  654:	int temphand[MAX_HAND];
        -:  655:	int cardDrawn;
    #####:  656:	int z = 0; // this is the counter for the temp hand
        -:  657:
    #####:  658:	while (drawntreasure < 2){
    #####:  659:		if (state->deckCount[currentPlayer] < 1){//if the deck is empty we need to shuffle discard and add to deck
    #####:  660:			shuffle(currentPlayer, state);
        -:  661:		}
    #####:  662:		drawCard(currentPlayer, state);
    #####:  663:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer] - 1];//top card of hand is most recently drawn card.
    #####:  664:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
    #####:  665:			drawntreasure++;
        -:  666:		else{
    #####:  667:			temphand[z] = cardDrawn;
    #####:  668:			state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####:  669:			z++;
        -:  670:		}
        -:  671:	}
    #####:  672:	while (z - 1 >= 0){
    #####:  673:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; // discard all cards in play that have been drawn
    #####:  674:		z = z - 1;
        -:  675:	}
    #####:  676:}
        -:  677:
    #####:  678:int playRemodel(struct gameState *state, int currentPlayer, int choice1, int choice2, int handPos)
        -:  679://Trash a card in the hand, and gain a card costing up to $2 more than the trashed card
        -:  680:{
        -:  681:	int i;
    #####:  682:	int j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  683:
    #####:  684:	if ((getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2))
        -:  685:	{
    #####:  686:		return -1;
        -:  687:	}
        -:  688:
    #####:  689:	gainCard(choice2, state, 0, currentPlayer);
        -:  690:
        -:  691:	//discard card from hand
    #####:  692:	discardCard(handPos, currentPlayer, state, 0);
        -:  693:
        -:  694:	//discard trashed card
    #####:  695:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  696:	{
    #####:  697:		if (state->hand[currentPlayer][i] == j)
        -:  698:		{
    #####:  699:			discardCard(i, currentPlayer, state, 0);
    #####:  700:			break;
        -:  701:		}
        -:  702:	}
        -:  703:
    #####:  704:	return 0;
        -:  705:}
        -:  706:
        2:  707:void playSmithy(struct gameState *state, int currentPlayer, int handPos)
        -:  708:// Draw 3 cards
        -:  709:{
        -:  710:	int i;
        8:  711:	for (i = 0; i < 3; i++)
        -:  712:	{
        6:  713:		drawCard(currentPlayer, state);
        -:  714:	}
        -:  715:
        -:  716:	//discard card from hand
        2:  717:	discardCard(handPos, currentPlayer, state, 0);
        2:  718:}
        -:  719:
    #####:  720:void playBaron(struct gameState *state, int currentPlayer, int choice1, int handPos)
        -:  721://Add a buy.  OPTION:  Discard an Estate card and gain $4.  Otherwise, gain an Estate card.
        -:  722:{
    #####:  723:	state->numBuys++;//Increase buys by 1!
    #####:  724:	if (choice1 > 0){//Boolean true or going to discard an estate
    #####:  725:		int p = 0;//Iterator for hand!
    #####:  726:		int card_not_discarded = 1;//Flag for discard set!
    #####:  727:		while (card_not_discarded){
    #####:  728:			if (state->hand[currentPlayer][p] == estate){ //Found an estate card!
    #####:  729:				state->coins += 4;//Add 4 coins to the amount of coins
    #####:  730:				state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  731:				state->discardCount[currentPlayer]++;
    #####:  732:				for (; p < state->handCount[currentPlayer]; p++){
    #####:  733:					state->hand[currentPlayer][p] = state->hand[currentPlayer][p + 1];
        -:  734:				}
    #####:  735:				state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  736:				state->handCount[currentPlayer]--;
    #####:  737:				card_not_discarded = 0;//Exit the loop
        -:  738:			}
    #####:  739:			else if (p > state->handCount[currentPlayer]){
        -:  740:				if (DEBUG) {
        -:  741:					printf("No estate cards in your hand, invalid choice\n");
        -:  742:					printf("Must gain an estate if there are any\n");
        -:  743:				}
    #####:  744:				if (supplyCount(estate, state) > 0){
    #####:  745:					gainCard(estate, state, 1, currentPlayer);
    #####:  746:					state->supplyCount[estate]--;//Decrement estates
    #####:  747:					if (supplyCount(estate, state) == 0){
    #####:  748:						isGameOver(state);
        -:  749:					}
        -:  750:				}
    #####:  751:				card_not_discarded = 0;//Exit the loop
        -:  752:			}
        -:  753:
        -:  754:			else{
    #####:  755:				p++;//Next card
        -:  756:			}
        -:  757:		}
        -:  758:	}
        -:  759:
        -:  760:	else{
    #####:  761:		if (supplyCount(estate, state) > 0){
    #####:  762:			gainCard(estate, state, 0, currentPlayer);//Gain an estate
    #####:  763:			state->supplyCount[estate]--;//Decrement Estates
    #####:  764:			if (supplyCount(estate, state) == 0){
    #####:  765:				isGameOver(state);
        -:  766:			}
        -:  767:		}
        -:  768:	}
    #####:  769:}
        -:  770:
        4:  771:int playTreasureMap(struct gameState *state, int currentPlayer, int handPos)
        -:  772://Trashing two treasure map cards from the hand = four gold on top of the deck.
        -:  773:{
        -:  774:	int i;
        -:  775:	int index;
        -:  776:
        -:  777:	//search hand for another treasure_map
       23:  778:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  779:	{
       20:  780:		if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -:  781:		{
        1:  782:			index = i;
        1:  783:			break;
        -:  784:		}
        -:  785:	}
        4:  786:	if (index > -1)
        -:  787:	{
        -:  788:		//trash both treasure cards
        4:  789:		discardCard(handPos, currentPlayer, state, 1);
        4:  790:		discardCard(index, currentPlayer, state, 1);
        -:  791:
        -:  792:		//gain 4 Gold cards
       20:  793:		for (i = 0; i < 4; i++)
        -:  794:		{
       16:  795:			gainCard(gold, state, 1, currentPlayer);
        -:  796:		}
        -:  797:
        -:  798:		//return success
        4:  799:		return 1;
        -:  800:	}
        -:  801:
        -:  802:	//no second treasure_map found in hand
    #####:  803:	return -1;
        -:  804:}
        -:  805:
      169:  806:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  807:{
        -:  808:	int i;
        -:  809:	int j;
        -:  810:	int k;
        -:  811:	//int x;  //Unused after while loop removed from feast.
      169:  812:	int currentPlayer = whoseTurn(state);
      169:  813:	int nextPlayer = currentPlayer + 1;
        -:  814:	int temphand[MAX_HAND];
        -:  815:
      169:  816:	int tributeRevealedCards[2] = { -1, -1 };
        -:  817:
      169:  818:	if (nextPlayer > (state->numPlayers - 1)){
       53:  819:		nextPlayer = 0;
        -:  820:	}
        -:  821:
        -:  822:	//uses switch to select card and perform actions
      169:  823:	switch (card)
        -:  824:	{
        -:  825:	case adventurer:
        -:  826:
    #####:  827:		playAdventurer(state, currentPlayer);
    #####:  828:		return 0;
        -:  829:
        -:  830:	case council_room:
        -:  831:		//+4 Cards
    #####:  832:		for (i = 0; i < 4; i++)
        -:  833:		{
    #####:  834:			drawCard(currentPlayer, state);
        -:  835:		}
        -:  836:
        -:  837:		//+1 Buy
    #####:  838:		state->numBuys++;
        -:  839:
        -:  840:		//Each other player draws a card
    #####:  841:		for (i = 0; i < state->numPlayers; i++)
        -:  842:		{
    #####:  843:			if (i != currentPlayer)
        -:  844:			{
    #####:  845:				drawCard(i, state);
        -:  846:			}
        -:  847:		}
        -:  848:
        -:  849:		//put played card in played card pile
    #####:  850:		discardCard(handPos, currentPlayer, state, 0);
        -:  851:
    #####:  852:		return 0;
        -:  853:
        -:  854:	case feast:
        -:  855:		//gain card with cost up to 5
        -:  856:		//Backup hand
       35:  857:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
       30:  858:			temphand[i] = state->hand[currentPlayer][i];//Backup card
       30:  859:			state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  860:		}
        -:  861:		//Backup hand
        -:  862:
        -:  863:		//Update Coins for Buy
        5:  864:		updateCoins(currentPlayer, state, 5);
        -:  865://		x = 1;//Condition to loop on
        -:  866://		while (x == 1) {//Buy one card
        5:  867:			if (supplyCount(choice1, state) <= 0){
        -:  868:				if (DEBUG)
        -:  869:					printf("None of that card left, sorry!\n");
        -:  870:
        -:  871:				if (DEBUG){
        -:  872:					printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  873:				}
        -:  874:			}
        1:  875:			else if (state->coins < getCost(choice1)){
    #####:  876:				printf("That card is too expensive!\n");
        -:  877:
        -:  878:				if (DEBUG){
        -:  879:					printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  880:				}
        -:  881:			}
        -:  882:			else{
        -:  883:
        -:  884:				if (DEBUG){
        -:  885:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  886:				}
        -:  887:
        1:  888:				gainCard(choice1, state, 0, currentPlayer);//Gain the card
        -:  889://				x = 0;//No more buying cards
        -:  890:
        -:  891:				if (DEBUG){
        -:  892:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  893:				}
        -:  894:
        -:  895:			}
        -:  896://		}
        -:  897:
        -:  898:		//Reset Hand
       35:  899:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
       30:  900:			state->hand[currentPlayer][i] = temphand[i];
       30:  901:			temphand[i] = -1;
        -:  902:		}
        -:  903:		//Reset Hand
        -:  904:
        5:  905:		return 0;
        -:  906:
        -:  907:	case gardens:
       88:  908:		return -1;
        -:  909:
        -:  910:	case mine:
       15:  911:		j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  912:
       15:  913:		if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  914:		{
       11:  915:			return -1;
        -:  916:		}
        -:  917:
        4:  918:		if (choice2 > treasure_map || choice2 < curse)
        -:  919:		{
    #####:  920:			return -1;
        -:  921:		}
        -:  922:
        4:  923:		if ((getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2))
        -:  924:		{
        1:  925:			return -1;
        -:  926:		}
        -:  927:
        3:  928:		gainCard(choice2, state, 2, currentPlayer);
        -:  929:
        -:  930:		//discard card from hand
        3:  931:		discardCard(handPos, currentPlayer, state, 0);
        -:  932:
        -:  933:		//discard trashed card
        6:  934:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  935:		{
        6:  936:			if (state->hand[currentPlayer][i] == j)
        -:  937:			{
        3:  938:				discardCard(i, currentPlayer, state, 0);
        3:  939:				break;
        -:  940:			}
        -:  941:		}
        -:  942:
        3:  943:		return 0;
        -:  944:
        -:  945:	case remodel:
        -:  946:
    #####:  947:		return playRemodel(state, currentPlayer, choice1, choice2, handPos);
        -:  948:
        -:  949:	case smithy:
        -:  950:
        2:  951:		playSmithy(state, currentPlayer, handPos);
        2:  952:		return 0;
        -:  953:
        -:  954:	case village:
        -:  955:		//+1 Card
        8:  956:		drawCard(currentPlayer, state);
        -:  957:
        -:  958:		//+2 Actions
        8:  959:		state->numActions = state->numActions + 2;
        -:  960:
        -:  961:		//discard played card from hand
        8:  962:		discardCard(handPos, currentPlayer, state, 0);
        8:  963:		return 0;
        -:  964:
        -:  965:	case baron:
        -:  966:
    #####:  967:		playBaron(state, currentPlayer, choice1, handPos);
    #####:  968:		return 0;
        -:  969:
        -:  970:	case great_hall:
        -:  971:		//+1 Card
        8:  972:		drawCard(currentPlayer, state);
        -:  973:
        -:  974:		//+1 Actions
        8:  975:		state->numActions++;
        -:  976:
        -:  977:		//discard card from hand
        8:  978:		discardCard(handPos, currentPlayer, state, 0);
        8:  979:		return 0;
        -:  980:
        -:  981:	case minion:
        -:  982:		//+1 action
        4:  983:		state->numActions++;
        -:  984:
        -:  985:		//discard card from hand
        4:  986:		discardCard(handPos, currentPlayer, state, 0);
        -:  987:
        4:  988:		if (choice1)		//+2 coins
        -:  989:		{
        4:  990:			state->coins = state->coins + 2;
        -:  991:		}
        -:  992:
    #####:  993:		else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  994:		{
        -:  995:			//discard hand
    #####:  996:			while (numHandCards(state) > 0)
        -:  997:			{
    #####:  998:				discardCard(handPos, currentPlayer, state, 0);
        -:  999:			}
        -: 1000:
        -: 1001:			//draw 4
    #####: 1002:			for (i = 0; i < 4; i++)
        -: 1003:			{
    #####: 1004:				drawCard(currentPlayer, state);
        -: 1005:			}
        -: 1006:
        -: 1007:			//other players discard hand and redraw if hand size > 4
    #####: 1008:			for (i = 0; i < state->numPlayers; i++)
        -: 1009:			{
    #####: 1010:				if (i != currentPlayer)
        -: 1011:				{
    #####: 1012:					if (state->handCount[i] > 4)
        -: 1013:					{
        -: 1014:						//discard hand
    #####: 1015:						while (state->handCount[i] > 0)
        -: 1016:						{
    #####: 1017:							discardCard(handPos, i, state, 0);
        -: 1018:						}
        -: 1019:
        -: 1020:						//draw 4
    #####: 1021:						for (j = 0; j < 4; j++)
        -: 1022:						{
    #####: 1023:							drawCard(i, state);
        -: 1024:						}
        -: 1025:					}
        -: 1026:				}
        -: 1027:			}
        -: 1028:
        -: 1029:		}
        4: 1030:		return 0;
        -: 1031:
        -: 1032:	case steward:
        7: 1033:		if (choice1 == 1)
        -: 1034:		{
        -: 1035:			//+2 cards
    #####: 1036:			drawCard(currentPlayer, state);
    #####: 1037:			drawCard(currentPlayer, state);
        -: 1038:		}
        7: 1039:		else if (choice1 == 2)
        -: 1040:		{
        -: 1041:			//+2 coins
        1: 1042:			state->coins = state->coins + 2;
        -: 1043:		}
        -: 1044:		else
        -: 1045:		{
        -: 1046:			//trash 2 cards in hand
        6: 1047:			discardCard(choice2, currentPlayer, state, 1);
        6: 1048:			discardCard(choice3, currentPlayer, state, 1);
        -: 1049:		}
        -: 1050:
        -: 1051:		//discard card from hand
        7: 1052:		discardCard(handPos, currentPlayer, state, 0);
        7: 1053:		return 0;
        -: 1054:
        -: 1055:	case tribute:
    #####: 1056:		if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####: 1057:			if (state->deckCount[nextPlayer] > 0){
    #####: 1058:				tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1059:				state->deckCount[nextPlayer]--;
        -: 1060:			}
    #####: 1061:			else if (state->discardCount[nextPlayer] > 0){
    #####: 1062:				tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer] - 1];
    #####: 1063:				state->discardCount[nextPlayer]--;
        -: 1064:			}
        -: 1065:			else{
        -: 1066:				//No Card to Reveal
        -: 1067:				if (DEBUG){
        -: 1068:					printf("No cards to reveal\n");
        -: 1069:				}
        -: 1070:			}
        -: 1071:		}
        -: 1072:
        -: 1073:		else{
    #####: 1074:			if (state->deckCount[nextPlayer] == 0){
    #####: 1075:				for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####: 1076:					state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1077:					state->deckCount[nextPlayer]++;
    #####: 1078:					state->discard[nextPlayer][i] = -1;
    #####: 1079:					state->discardCount[nextPlayer]--;
        -: 1080:				}
        -: 1081:
    #####: 1082:				shuffle(nextPlayer, state);//Shuffle the deck
        -: 1083:			}
    #####: 1084:			tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1085:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1086:			state->deckCount[nextPlayer]--;
    #####: 1087:			tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1088:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1089:			state->deckCount[nextPlayer]--;
        -: 1090:		}
        -: 1091:
    #####: 1092:		if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
    #####: 1093:			state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1094:			state->playedCardCount++;
    #####: 1095:			tributeRevealedCards[1] = -1;
        -: 1096:		}
        -: 1097:
    #####: 1098:		for (i = 0; i <= 2; i++){
    #####: 1099:			if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
    #####: 1100:				state->coins += 2;
        -: 1101:			}
        -: 1102:
    #####: 1103:			else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
    #####: 1104:				drawCard(currentPlayer, state);
    #####: 1105:				drawCard(currentPlayer, state);
        -: 1106:			}
        -: 1107:			else{//Action Card
    #####: 1108:				state->numActions = state->numActions + 2;
        -: 1109:			}
        -: 1110:		}
        -: 1111:
    #####: 1112:		return 0;
        -: 1113:
        -: 1114:	case ambassador:
       21: 1115:		j = 0;		//used to check if player has enough cards to discard
        -: 1116:
       21: 1117:		if (choice2 > 2 || choice2 < 0)
        -: 1118:		{
       19: 1119:			return -1;
        -: 1120:		}
        -: 1121:
        2: 1122:		if (choice1 == handPos)
        -: 1123:		{
    #####: 1124:			return -1;
        -: 1125:		}
        -: 1126:
       12: 1127:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1128:		{
       10: 1129:			if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1130:			{
        1: 1131:				j++;
        -: 1132:			}
        -: 1133:		}
        2: 1134:		if (j < choice2)
        -: 1135:		{
        1: 1136:			return -1;
        -: 1137:		}
        -: 1138:
        -: 1139:		if (DEBUG)
        -: 1140:			printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1141:
        -: 1142:		//increase supply count for choosen card by amount being discarded
        1: 1143:		state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1144:
        -: 1145:		//each other player gains a copy of revealed card
        5: 1146:		for (i = 0; i < state->numPlayers; i++)
        -: 1147:		{
        4: 1148:			if (i != currentPlayer)
        -: 1149:			{
        3: 1150:				gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1151:			}
        -: 1152:		}
        -: 1153:
        -: 1154:		//discard played card from hand
        1: 1155:		discardCard(handPos, currentPlayer, state, 0);
        -: 1156:
        -: 1157:		//trash copies of cards returned to supply
        1: 1158:		for (j = 0; j < choice2; j++)
        -: 1159:		{
    #####: 1160:			for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1161:			{
    #####: 1162:				if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1163:				{
    #####: 1164:					discardCard(i, currentPlayer, state, 1);
    #####: 1165:					break;
        -: 1166:				}
        -: 1167:			}
        -: 1168:		}
        -: 1169:
        1: 1170:		return 0;
        -: 1171:
        -: 1172:	case cutpurse:
        -: 1173:
    #####: 1174:		updateCoins(currentPlayer, state, 2);
    #####: 1175:		for (i = 0; i < state->numPlayers; i++)
        -: 1176:		{
    #####: 1177:			if (i != currentPlayer)
        -: 1178:			{
    #####: 1179:				for (j = 0; j < state->handCount[i]; j++)
        -: 1180:				{
    #####: 1181:					if (state->hand[i][j] == copper)
        -: 1182:					{
    #####: 1183:						discardCard(j, i, state, 0);
    #####: 1184:						break;
        -: 1185:					}
    #####: 1186:					if (j == state->handCount[i])
        -: 1187:					{
    #####: 1188:						for (k = 0; k < state->handCount[i]; k++)
        -: 1189:						{
        -: 1190:							if (DEBUG)
        -: 1191:								printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1192:						}
    #####: 1193:						break;
        -: 1194:					}
        -: 1195:				}
        -: 1196:
        -: 1197:			}
        -: 1198:
        -: 1199:		}
        -: 1200:
        -: 1201:		//discard played card from hand
    #####: 1202:		discardCard(handPos, currentPlayer, state, 0);
        -: 1203:
    #####: 1204:		return 0;
        -: 1205:
        -: 1206:
        -: 1207:	case embargo:
        -: 1208:		//+2 Coins
    #####: 1209:		state->coins = state->coins + 2;
        -: 1210:
        -: 1211:		//see if selected pile is in play
    #####: 1212:		if (state->supplyCount[choice1] == -1)
        -: 1213:		{
    #####: 1214:			return -1;
        -: 1215:		}
        -: 1216:
        -: 1217:		//add embargo token to selected supply pile
    #####: 1218:		state->embargoTokens[choice1]++;
        -: 1219:
        -: 1220:		//trash card
    #####: 1221:		discardCard(handPos, currentPlayer, state, 1);
    #####: 1222:		return 0;
        -: 1223:
        -: 1224:	case outpost:
        -: 1225:		//set outpost flag
    #####: 1226:		state->outpostPlayed++;
        -: 1227:
        -: 1228:		//discard card
    #####: 1229:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1230:		return 0;
        -: 1231:
        -: 1232:	case salvager:
        -: 1233:		//+1 buy
        6: 1234:		state->numBuys++;
        -: 1235:
        6: 1236:		if (choice1)
        -: 1237:		{
        -: 1238:			//gain coins equal to trashed card
        5: 1239:			state->coins = state->coins + getCost(handCard(choice1, state));
        -: 1240:			//trash card
        5: 1241:			discardCard(choice1, currentPlayer, state, 1);
        -: 1242:		}
        -: 1243:
        -: 1244:		//discard card
        6: 1245:		discardCard(handPos, currentPlayer, state, 0);
        6: 1246:		return 0;
        -: 1247:
        -: 1248:	case sea_hag:
        4: 1249:		for (i = 0; i < state->numPlayers; i++){
        3: 1250:			if (i != currentPlayer){
        2: 1251:				state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
        2: 1252:				state->discardCount[i]++;
        2: 1253:				state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1254:			}
        -: 1255:		}
        1: 1256:		return 0;
        -: 1257:
        -: 1258:	case treasure_map:
        -: 1259:
        4: 1260:		return playTreasureMap(state, currentPlayer, handPos);
        -: 1261:	}
    #####: 1262:	return -1;
        -: 1263:}
        -: 1264:
       67: 1265:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1266:{
        -: 1267:
        -: 1268:	//if card is not trashed, added to Played pile 
       67: 1269:	if (trashFlag < 1)
        -: 1270:	{
        -: 1271:		//add card to played pile
       42: 1272:		state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
       42: 1273:		state->playedCardCount++;
        -: 1274:	}
        -: 1275:
        -: 1276:	//set played card to -1
       67: 1277:	state->hand[currentPlayer][handPos] = -1;
        -: 1278:
        -: 1279:	//remove card from player's hand
       67: 1280:	if (handPos == (state->handCount[currentPlayer] - 1)) 	//last card in hand array is played
        -: 1281:	{
        -: 1282:		//reduce number of cards in hand
        4: 1283:		state->handCount[currentPlayer]--;
        -: 1284:	}
       63: 1285:	else if (state->handCount[currentPlayer] == 1) //only one card in hand
        -: 1286:	{
        -: 1287:		//reduce number of cards in hand
    #####: 1288:		state->handCount[currentPlayer]--;
        -: 1289:	}
        -: 1290:	else
        -: 1291:	{
        -: 1292:		//replace discarded card with last card in hand
       63: 1293:		state->hand[currentPlayer][handPos] = state->hand[currentPlayer][(state->handCount[currentPlayer] - 1)];
        -: 1294:		//set last card to -1
       63: 1295:		state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1296:		//reduce number of cards in hand
       63: 1297:		state->handCount[currentPlayer]--;
        -: 1298:	}
        -: 1299:
       67: 1300:	return 0;
        -: 1301:}
        -: 1302:
      249: 1303:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1304:{
        -: 1305:	//Note: supplyPos is enum of choosen card
        -: 1306:
        -: 1307:	//check if supply pile is empty (0) or card is not used in game (-1)
      249: 1308:	if (supplyCount(supplyPos, state) < 1)
        -: 1309:	{
        1: 1310:		return -1;
        -: 1311:	}
        -: 1312:
        -: 1313:	//added card for [whoseTurn] current player:
        -: 1314:	// toFlag = 0 : add to discard
        -: 1315:	// toFlag = 1 : add to deck
        -: 1316:	// toFlag = 2 : add to hand
        -: 1317:
      248: 1318:	if (toFlag == 1)
        -: 1319:	{
       16: 1320:		state->deck[player][state->deckCount[player]] = supplyPos;
       16: 1321:		state->deckCount[player]++;
        -: 1322:	}
      232: 1323:	else if (toFlag == 2)
        -: 1324:	{
        2: 1325:		state->hand[player][state->handCount[player]] = supplyPos;
        2: 1326:		state->handCount[player]++;
        -: 1327:	}
        -: 1328:	else
        -: 1329:	{
      230: 1330:		state->discard[player][state->discardCount[player]] = supplyPos;
      230: 1331:		state->discardCount[player]++;
        -: 1332:	}
        -: 1333:
        -: 1334:	//decrease number in supply pile
      248: 1335:	state->supplyCount[supplyPos]--;
        -: 1336:
      248: 1337:	return 0;
        -: 1338:}
        -: 1339:
      326: 1340:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1341:{
        -: 1342:	int i;
        -: 1343:
        -: 1344:	//reset coin count
      326: 1345:	state->coins = 0;
        -: 1346:
        -: 1347:	//add coins for each Treasure card in player's hand
     1912: 1348:	for (i = 0; i < state->handCount[player]; i++)
        -: 1349:	{
     1586: 1350:		if (state->hand[player][i] == copper)
        -: 1351:		{
      656: 1352:			state->coins += 1;
        -: 1353:		}
      930: 1354:		else if (state->hand[player][i] == silver)
        -: 1355:		{
       89: 1356:			state->coins += 2;
        -: 1357:		}
      841: 1358:		else if (state->hand[player][i] == gold)
        -: 1359:		{
       73: 1360:			state->coins += 3;
        -: 1361:		}
        -: 1362:	}
        -: 1363:
        -: 1364:	//add bonus
      326: 1365:	state->coins += bonus;
        -: 1366:
      326: 1367:	return 0;
        -: 1368:}
        -: 1369:
        -: 1370:
        -: 1371://end of dominion.c
File 'dominion.c'
Lines executed:57.45% of 557
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
     2609:    8:int compare(const void* a, const void* b) {
     2609:    9:	if (*(int*)a > *(int*)b)
      866:   10:		return 1;
     1743:   11:	if (*(int*)a < *(int*)b)
      710:   12:		return -1;
     1033:   13:	return 0;
        -:   14:}
        -:   15:
        4:   16:struct gameState* newGame() {
        4:   17:	struct gameState* g = malloc(sizeof(struct gameState));
        4:   18:	return g;
        -:   19:}
        -:   20:
       26:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:	int k8, int k9, int k10) {
       26:   23:	int* k = malloc(10 * sizeof(int));
       26:   24:	k[0] = k1;
       26:   25:	k[1] = k2;
       26:   26:	k[2] = k3;
       26:   27:	k[3] = k4;
       26:   28:	k[4] = k5;
       26:   29:	k[5] = k6;
       26:   30:	k[6] = k7;
       26:   31:	k[7] = k8;
       26:   32:	k[8] = k9;
       26:   33:	k[9] = k10;
       26:   34:	return k;
        -:   35:}
        -:   36:
       26:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		struct gameState *state) {
        -:   39:
        -:   40:	int i;
        -:   41:	int j;
        -:   42:	int it;
        -:   43:	//set up random number generator
       26:   44:	SelectStream(1);
       26:   45:	PutSeed((long)randomSeed);
        -:   46:
        -:   47:	//check number of players
       26:   48:	if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:	{
    #####:   50:		return -1;
        -:   51:	}
        -:   52:
        -:   53:	//set number of players
       26:   54:	state->numPlayers = numPlayers;
        -:   55:
        -:   56:	//check selected kingdom cards are different
       73:   57:	for (i = 0; i < 10; i++)
        -:   58:	{
      663:   59:		for (j = 0; j < 10; j++)
        -:   60:		{
      616:   61:			if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:			{
       24:   63:				return -1;
        -:   64:			}
        -:   65:		}
        -:   66:	}
        -:   67:
        -:   68:
        -:   69:	//initialize supply
        -:   70:	///////////////////////////////
        -:   71:
        -:   72:	//set number of Curse cards
        2:   73:	if (numPlayers == 2)
        -:   74:	{
    #####:   75:		state->supplyCount[curse] = 10;
        -:   76:	}
        2:   77:	else if (numPlayers == 3)
        -:   78:	{
        2:   79:		state->supplyCount[curse] = 20;
        -:   80:	}
        -:   81:	else
        -:   82:	{
    #####:   83:		state->supplyCount[curse] = 30;
        -:   84:	}
        -:   85:
        -:   86:	//set number of Victory cards
        2:   87:	if (numPlayers == 2)
        -:   88:	{
    #####:   89:		state->supplyCount[estate] = 8;
    #####:   90:		state->supplyCount[duchy] = 8;
    #####:   91:		state->supplyCount[province] = 8;
        -:   92:	}
        -:   93:	else
        -:   94:	{
        2:   95:		state->supplyCount[estate] = 12;
        2:   96:		state->supplyCount[duchy] = 12;
        2:   97:		state->supplyCount[province] = 12;
        -:   98:	}
        -:   99:
        -:  100:	//set number of Treasure cards
        2:  101:	state->supplyCount[copper] = 60 - (7 * numPlayers);
        2:  102:	state->supplyCount[silver] = 40;
        2:  103:	state->supplyCount[gold] = 30;
        -:  104:
        -:  105:	//set number of Kingdom cards
       42:  106:	for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:	{
      330:  108:		for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:		{
      310:  110:			if (kingdomCards[j] == i)
        -:  111:			{
        -:  112:				//check if card is a 'Victory' Kingdom card
       20:  113:				if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:				{
        2:  115:					if (numPlayers == 2){
    #####:  116:						state->supplyCount[i] = 8;
        -:  117:					}
        1:  118:					else{ state->supplyCount[i] = 12; }
        -:  119:				}
        -:  120:				else
        -:  121:				{
       19:  122:					state->supplyCount[i] = 10;
        -:  123:				}
       20:  124:				break;
        -:  125:			}
        -:  126:			else    //card is not in the set choosen for the game
        -:  127:			{
      290:  128:				state->supplyCount[i] = -1;
        -:  129:			}
        -:  130:		}
        -:  131:
        -:  132:	}
        -:  133:
        -:  134:	////////////////////////
        -:  135:	//supply intilization complete
        -:  136:
        -:  137:	//set player decks
        8:  138:	for (i = 0; i < numPlayers; i++)
        -:  139:	{
        6:  140:		state->deckCount[i] = 0;
       24:  141:		for (j = 0; j < 3; j++)
        -:  142:		{
       18:  143:			state->deck[i][j] = estate;
       18:  144:			state->deckCount[i]++;
        -:  145:		}
       48:  146:		for (j = 3; j < 10; j++)
        -:  147:		{
       42:  148:			state->deck[i][j] = copper;
       42:  149:			state->deckCount[i]++;
        -:  150:		}
        -:  151:	}
        -:  152:
        -:  153:	//shuffle player decks
        8:  154:	for (i = 0; i < numPlayers; i++)
        -:  155:	{
        6:  156:		if (shuffle(i, state) < 0)
        -:  157:		{
    #####:  158:			return -1;
        -:  159:		}
        -:  160:	}
        -:  161:
        -:  162:	//draw player hands
        8:  163:	for (i = 0; i < numPlayers; i++)
        -:  164:	{
        -:  165:		//initialize hand size to zero
        6:  166:		state->handCount[i] = 0;
        6:  167:		state->discardCount[i] = 0;
        -:  168:		//draw 5 cards
        -:  169:		// for (j = 0; j < 5; j++)
        -:  170:		//	{
        -:  171:		//	  drawCard(i, state);
        -:  172:		//	}
        -:  173:	}
        -:  174:
        -:  175:	//set embargo tokens to 0 for all supply piles
       56:  176:	for (i = 0; i <= treasure_map; i++)
        -:  177:	{
       54:  178:		state->embargoTokens[i] = 0;
        -:  179:	}
        -:  180:
        -:  181:	//initialize first player's turn
        2:  182:	state->outpostPlayed = 0;
        2:  183:	state->phase = 0;
        2:  184:	state->numActions = 1;
        2:  185:	state->numBuys = 1;
        2:  186:	state->playedCardCount = 0;
        2:  187:	state->whoseTurn = 0;
        2:  188:	state->handCount[state->whoseTurn] = 0;
        -:  189:	//int it; move to top
        -:  190:
        -:  191:	//Moved draw cards to here, only drawing at the start of a turn
       12:  192:	for (it = 0; it < 5; it++){
       10:  193:		drawCard(state->whoseTurn, state);
        -:  194:	}
        -:  195:
        2:  196:	updateCoins(state->whoseTurn, state, 0);
        -:  197:
        2:  198:	return 0;
        -:  199:}
        -:  200:
       76:  201:int shuffle(int player, struct gameState *state) {
        -:  202:
        -:  203:
        -:  204:	int newDeck[MAX_DECK];
       76:  205:	int newDeckPos = 0;
        -:  206:	int card;
        -:  207:	int i;
        -:  208:
       76:  209:	if (state->deckCount[player] < 1)
    #####:  210:		return -1;
       76:  211:	qsort((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
        -:  212:	/* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
     1416:  214:	while (state->deckCount[player] > 0) {
     1264:  215:		card = floor(Random() * state->deckCount[player]);
     1264:  216:		newDeck[newDeckPos] = state->deck[player][card];
     1264:  217:		newDeckPos++;
     6937:  218:		for (i = card; i < state->deckCount[player] - 1; i++) {
     5673:  219:			state->deck[player][i] = state->deck[player][i + 1];
        -:  220:		}
     1264:  221:		state->deckCount[player]--;
        -:  222:	}
     1340:  223:	for (i = 0; i < newDeckPos; i++) {
     1264:  224:		state->deck[player][i] = newDeck[i];
     1264:  225:		state->deckCount[player]++;
        -:  226:	}
        -:  227:
       76:  228:	return 0;
        -:  229:}
        -:  230:
     1224:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state)
        -:  232:{
        -:  233:	int card;
     1224:  234:	int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:	//check if it is the right phase
     1224:  237:	if (state->phase != 0)
        -:  238:	{
      151:  239:		return -1;
        -:  240:	}
        -:  241:
        -:  242:	//check if player has enough actions
     1073:  243:	if (state->numActions < 1)
        -:  244:	{
       39:  245:		return -1;
        -:  246:	}
        -:  247:
        -:  248:	//get card played
     1034:  249:	card = handCard(handPos, state);
        -:  250:
        -:  251:	//check if selected card is an action
     1034:  252:	if (card < adventurer || card > treasure_map)
        -:  253:	{
      926:  254:		return -1;
        -:  255:	}
        -:  256:
        -:  257:	//play card
      108:  258:	if (cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0)
        -:  259:	{
       57:  260:		return -1;
        -:  261:	}
        -:  262:
        -:  263:	//reduce number of actions
       51:  264:	state->numActions--;
        -:  265:
        -:  266:	//update coins (Treasure cards may be added with card draws)
       51:  267:	updateCoins(state->whoseTurn, state, coin_bonus);
        -:  268:
       51:  269:	return 0;
        -:  270:}
        -:  271:
     1192:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:	int who;
        -:  274:	if (DEBUG){
        -:  275:		printf("Entering buyCard...\n");
        -:  276:	}
        -:  277:
        -:  278:	// I don't know what to do about the phase thing.
        -:  279:
     1192:  280:	who = state->whoseTurn;
        -:  281:
     1192:  282:	if (state->numBuys < 1){
        -:  283:		if (DEBUG)
        -:  284:			printf("You do not have any buys left\n");
      142:  285:		return -1;
        -:  286:	}
     1050:  287:	else if (supplyCount(supplyPos, state) < 1){
        -:  288:		if (DEBUG)
        -:  289:			printf("There are not any of that type of card left\n");
      426:  290:		return -1;
        -:  291:	}
      624:  292:	else if (state->coins < getCost(supplyPos)){
        -:  293:		if (DEBUG)
        -:  294:			printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
      443:  295:		return -1;
        -:  296:	}
        -:  297:	else {
      181:  298:		state->phase = 1;
        -:  299:		//state->supplyCount[supplyPos]--;
      181:  300:		gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  301:
      181:  302:		state->coins = (state->coins) - (getCost(supplyPos));
      181:  303:		state->numBuys--;
        -:  304:		if (DEBUG)
        -:  305:			printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  306:	}
        -:  307:
        -:  308:	//state->discard[who][state->discardCount[who]] = supplyPos;
        -:  309:	//state->discardCount[who]++;
        -:  310:
      181:  311:	return 0;
        -:  312:}
        -:  313:
    #####:  314:int numHandCards(struct gameState *state) {
    #####:  315:	return state->handCount[whoseTurn(state)];
        -:  316:}
        -:  317:
     1034:  318:int handCard(int handPos, struct gameState *state) {
     1034:  319:	int currentPlayer = whoseTurn(state);
     1034:  320:	return state->hand[currentPlayer][handPos];
        -:  321:}
        -:  322:
     1245:  323:int supplyCount(int card, struct gameState *state) {
     1245:  324:	return state->supplyCount[card];
        -:  325:}
        -:  326:
    #####:  327:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  328:	int i;
    #####:  329:	int count = 0;
        -:  330:
    #####:  331:	for (i = 0; i < state->deckCount[player]; i++)
        -:  332:	{
    #####:  333:		if (state->deck[player][i] == card) count++;
        -:  334:	}
        -:  335:
    #####:  336:	for (i = 0; i < state->handCount[player]; i++)
        -:  337:	{
    #####:  338:		if (state->hand[player][i] == card) count++;
        -:  339:	}
        -:  340:
    #####:  341:	for (i = 0; i < state->discardCount[player]; i++)
        -:  342:	{
    #####:  343:		if (state->discard[player][i] == card) count++;
        -:  344:	}
        -:  345:
    #####:  346:	return count;
        -:  347:}
        -:  348:
     1367:  349:int whoseTurn(struct gameState *state) {
     1367:  350:	return state->whoseTurn;
        -:  351:}
        -:  352:
      225:  353:int endTurn(struct gameState *state) {
        -:  354:	int k;
        -:  355:	int i;
      225:  356:	int currentPlayer = whoseTurn(state);
        -:  357:
        -:  358:	//Discard hand
     1317:  359:	for (i = 0; i < state->handCount[currentPlayer]; i++){
     1092:  360:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
     1092:  361:		state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  362:	}
      225:  363:	state->handCount[currentPlayer] = 0;//Reset hand count
        -:  364:
        -:  365:	//Code for determining the player
      225:  366:	if (currentPlayer < (state->numPlayers - 1)){
      151:  367:		state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  368:	}
        -:  369:	else{
       74:  370:		state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  371:	}
        -:  372:
      225:  373:	state->outpostPlayed = 0;
      225:  374:	state->phase = 0;
      225:  375:	state->numActions = 1;
      225:  376:	state->coins = 0;
      225:  377:	state->numBuys = 1;
      225:  378:	state->playedCardCount = 0;
      225:  379:	state->handCount[state->whoseTurn] = 0;
        -:  380:
        -:  381:	//int k; move to top
        -:  382:	//Next player draws hand
     1350:  383:	for (k = 0; k < 5; k++){
     1125:  384:		drawCard(state->whoseTurn, state);//Draw a card
        -:  385:	}
        -:  386:
        -:  387:	//Update money
      225:  388:	updateCoins(state->whoseTurn, state, 0);
        -:  389:
      225:  390:	return 0;
        -:  391:}
        -:  392:
     3642:  393:int isGameOver(struct gameState *state) {
        -:  394:	int i;
        -:  395:	int j;
        -:  396:
        -:  397:	//if stack of Province cards is empty, the game ends
     3642:  398:	if (state->supplyCount[province] == 0)
        -:  399:	{
    #####:  400:		return 1;
        -:  401:	}
        -:  402:
        -:  403:	//if three supply pile are at 0, the game ends
     3642:  404:	j = 0;
    94692:  405:	for (i = 0; i < 25; i++)
        -:  406:	{
    91050:  407:		if (state->supplyCount[i] == 0)
        -:  408:		{
     3668:  409:			j++;
        -:  410:		}
        -:  411:	}
     3642:  412:	if (j >= 3)
        -:  413:	{
        2:  414:		return 1;
        -:  415:	}
        -:  416:
     3640:  417:	return 0;
        -:  418:}
        -:  419:
    #####:  420:int scoreFor(int player, struct gameState *state) {
        -:  421:
        -:  422:	int i;
    #####:  423:	int score = 0;
        -:  424:	//score from hand
    #####:  425:	for (i = 0; i < state->handCount[player]; i++)
        -:  426:	{
    #####:  427:		if (state->hand[player][i] == curse) { score = score - 1; };
    #####:  428:		if (state->hand[player][i] == estate) { score = score + 1; };
    #####:  429:		if (state->hand[player][i] == duchy) { score = score + 3; };
    #####:  430:		if (state->hand[player][i] == province) { score = score + 6; };
    #####:  431:		if (state->hand[player][i] == great_hall) { score = score + 1; };
    #####:  432:		if (state->hand[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  433:	}
        -:  434:
        -:  435:	//score from discard
    #####:  436:	for (i = 0; i < state->discardCount[player]; i++)
        -:  437:	{
    #####:  438:		if (state->discard[player][i] == curse) { score = score - 1; };
    #####:  439:		if (state->discard[player][i] == estate) { score = score + 1; };
    #####:  440:		if (state->discard[player][i] == duchy) { score = score + 3; };
    #####:  441:		if (state->discard[player][i] == province) { score = score + 6; };
    #####:  442:		if (state->discard[player][i] == great_hall) { score = score + 1; };
    #####:  443:		if (state->discard[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  444:	}
        -:  445:
        -:  446:	//score from deck
    #####:  447:	for (i = 0; i < state->discardCount[player]; i++)
        -:  448:	{
    #####:  449:		if (state->deck[player][i] == curse) { score = score - 1; };
    #####:  450:		if (state->deck[player][i] == estate) { score = score + 1; };
    #####:  451:		if (state->deck[player][i] == duchy) { score = score + 3; };
    #####:  452:		if (state->deck[player][i] == province) { score = score + 6; };
    #####:  453:		if (state->deck[player][i] == great_hall) { score = score + 1; };
    #####:  454:		if (state->deck[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  455:	}
        -:  456:
    #####:  457:	return score;
        -:  458:}
        -:  459:
    #####:  460:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  461:	int i;
        -:  462:	int j;
        -:  463:	int highScore;
        -:  464:	int currentPlayer;
        -:  465:
        -:  466:	//get score for each player
    #####:  467:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  468:	{
        -:  469:		//set unused player scores to -9999
    #####:  470:		if (i >= state->numPlayers)
        -:  471:		{
    #####:  472:			players[i] = -9999;
        -:  473:		}
        -:  474:		else
        -:  475:		{
    #####:  476:			players[i] = scoreFor(i, state);
        -:  477:		}
        -:  478:	}
        -:  479:
        -:  480:	//find highest score
    #####:  481:	j = 0;
    #####:  482:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  483:	{
    #####:  484:		if (players[i] > players[j])
        -:  485:		{
    #####:  486:			j = i;
        -:  487:		}
        -:  488:	}
    #####:  489:	highScore = players[j];
        -:  490:
        -:  491:	//add 1 to players who had less turns
    #####:  492:	currentPlayer = whoseTurn(state);
    #####:  493:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  494:	{
    #####:  495:		if (players[i] == highScore && i > currentPlayer)
        -:  496:		{
    #####:  497:			players[i]++;
        -:  498:		}
        -:  499:	}
        -:  500:
        -:  501:	//find new highest score
    #####:  502:	j = 0;
    #####:  503:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  504:	{
    #####:  505:		if (players[i] > players[j])
        -:  506:		{
    #####:  507:			j = i;
        -:  508:		}
        -:  509:	}
    #####:  510:	highScore = players[j];
        -:  511:
        -:  512:	//set winners in array to 1 and rest to 0
    #####:  513:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  514:	{
    #####:  515:		if (players[i] == highScore)
        -:  516:		{
    #####:  517:			players[i] = 1;
        -:  518:		}
        -:  519:		else
        -:  520:		{
    #####:  521:			players[i] = 0;
        -:  522:		}
        -:  523:	}
        -:  524:
    #####:  525:	return 0;
        -:  526:}
        -:  527:
     1142:  528:int drawCard(int player, struct gameState *state)
        -:  529:{
        -:  530:	int count;
        -:  531:	int deckCounter;
     1142:  532:	if (state->deckCount[player] <= 0){//Deck is empty
        -:  533:
        -:  534:		//Step 1 Shuffle the discard pile back into a deck
        -:  535:		int i;
        -:  536:		//Move discard to deck
     1274:  537:		for (i = 0; i < state->discardCount[player]; i++){
     1204:  538:			state->deck[player][i] = state->discard[player][i];
     1204:  539:			state->discard[player][i] = -1;
        -:  540:		}
        -:  541:
       70:  542:		state->deckCount[player] = state->discardCount[player];
       70:  543:		state->discardCount[player] = 0;//Reset discard
        -:  544:
        -:  545:		//Shufffle the deck
       70:  546:		shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  547:
        -:  548:		if (DEBUG){//Debug statements
        -:  549:			printf("Deck count now: %d\n", state->deckCount[player]);
        -:  550:		}
        -:  551:
       70:  552:		state->discardCount[player] = 0;
        -:  553:
        -:  554:		//Step 2 Draw Card
       70:  555:		count = state->handCount[player];//Get current player's hand count
        -:  556:
        -:  557:		if (DEBUG){//Debug statements
        -:  558:			printf("Current hand count: %d\n", count);
        -:  559:		}
        -:  560:
       70:  561:		deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  562:
       70:  563:		if (deckCounter == 0)
    #####:  564:			return -1;
        -:  565:
       70:  566:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
       70:  567:		state->deckCount[player]--;
       70:  568:		state->handCount[player]++;//Increment hand count
        -:  569:	}
        -:  570:
        -:  571:	else{
     1072:  572:		int count = state->handCount[player];//Get current hand count for player
        -:  573:		int deckCounter;
        -:  574:		if (DEBUG){//Debug statements
        -:  575:			printf("Current hand count: %d\n", count);
        -:  576:		}
        -:  577:
     1072:  578:		deckCounter = state->deckCount[player];//Create holder for the deck count
     1072:  579:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
     1072:  580:		state->deckCount[player]--;
     1072:  581:		state->handCount[player]++;//Increment hand count
        -:  582:	}
        -:  583:
     1142:  584:	return 0;
        -:  585:}
        -:  586:
      815:  587:int getCost(int cardNumber)
        -:  588:{
      815:  589:	switch (cardNumber)
        -:  590:	{
        -:  591:	case curse:
       75:  592:		return 0;
        -:  593:	case estate:
       46:  594:		return 2;
        -:  595:	case duchy:
       32:  596:		return 5;
        -:  597:	case province:
       38:  598:		return 8;
        -:  599:	case copper:
       99:  600:		return 0;
        -:  601:	case silver:
       47:  602:		return 3;
        -:  603:	case gold:
       50:  604:		return 6;
        -:  605:	case adventurer:
       23:  606:		return 6;
        -:  607:	case council_room:
       25:  608:		return 5;
        -:  609:	case feast:
       34:  610:		return 4;
        -:  611:	case gardens:
       19:  612:		return 4;
        -:  613:	case mine:
       15:  614:		return 5;
        -:  615:	case remodel:
       56:  616:		return 4;
        -:  617:	case smithy:
    #####:  618:		return 4;
        -:  619:	case village:
       20:  620:		return 3;
        -:  621:	case baron:
       44:  622:		return 4;
        -:  623:	case great_hall:
    #####:  624:		return 3;
        -:  625:	case minion:
    #####:  626:		return 5;
        -:  627:	case steward:
       18:  628:		return 3;
        -:  629:	case tribute:
    #####:  630:		return 5;
        -:  631:	case ambassador:
       47:  632:		return 3;
        -:  633:	case cutpurse:
       28:  634:		return 4;
        -:  635:	case embargo:
       21:  636:		return 2;
        -:  637:	case outpost:
       15:  638:		return 5;
        -:  639:	case salvager:
       18:  640:		return 4;
        -:  641:	case sea_hag:
       45:  642:		return 4;
        -:  643:	case treasure_map:
    #####:  644:		return 4;
        -:  645:	}
        -:  646:
    #####:  647:	return -1;
        -:  648:}
        -:  649:
    #####:  650:void playAdventurer(struct gameState *state, int currentPlayer)
        -:  651:// Reveal cards from deck until 2 Treasure cards are found.  Put those Treasure cards in the hand and discard the rest.
        -:  652:{
    #####:  653:	int drawntreasure = 0;
        -:  654:	int temphand[MAX_HAND];
        -:  655:	int cardDrawn;
    #####:  656:	int z = 0; // this is the counter for the temp hand
        -:  657:
    #####:  658:	while (drawntreasure < 2){
    #####:  659:		if (state->deckCount[currentPlayer] < 1){//if the deck is empty we need to shuffle discard and add to deck
    #####:  660:			shuffle(currentPlayer, state);
        -:  661:		}
    #####:  662:		drawCard(currentPlayer, state);
    #####:  663:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer] - 1];//top card of hand is most recently drawn card.
    #####:  664:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
    #####:  665:			drawntreasure++;
        -:  666:		else{
    #####:  667:			temphand[z] = cardDrawn;
    #####:  668:			state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####:  669:			z++;
        -:  670:		}
        -:  671:	}
    #####:  672:	while (z - 1 >= 0){
    #####:  673:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; // discard all cards in play that have been drawn
    #####:  674:		z = z - 1;
        -:  675:	}
    #####:  676:}
        -:  677:
        5:  678:int playRemodel(struct gameState *state, int currentPlayer, int choice1, int choice2, int handPos)
        -:  679://Trash a card in the hand, and gain a card costing up to $2 more than the trashed card
        -:  680:{
        -:  681:	int i;
        5:  682:	int j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  683:
        5:  684:	if ((getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2))
        -:  685:	{
        1:  686:		return -1;
        -:  687:	}
        -:  688:
        4:  689:	gainCard(choice2, state, 0, currentPlayer);
        -:  690:
        -:  691:	//discard card from hand
        4:  692:	discardCard(handPos, currentPlayer, state, 0);
        -:  693:
        -:  694:	//discard trashed card
       12:  695:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  696:	{
       10:  697:		if (state->hand[currentPlayer][i] == j)
        -:  698:		{
        2:  699:			discardCard(i, currentPlayer, state, 0);
        2:  700:			break;
        -:  701:		}
        -:  702:	}
        -:  703:
        4:  704:	return 0;
        -:  705:}
        -:  706:
    #####:  707:void playSmithy(struct gameState *state, int currentPlayer, int handPos)
        -:  708:// Draw 3 cards
        -:  709:{
        -:  710:	int i;
    #####:  711:	for (i = 0; i < 3; i++)
        -:  712:	{
    #####:  713:		drawCard(currentPlayer, state);
        -:  714:	}
        -:  715:
        -:  716:	//discard card from hand
    #####:  717:	discardCard(handPos, currentPlayer, state, 0);
    #####:  718:}
        -:  719:
       13:  720:void playBaron(struct gameState *state, int currentPlayer, int choice1, int handPos)
        -:  721://Add a buy.  OPTION:  Discard an Estate card and gain $4.  Otherwise, gain an Estate card.
        -:  722:{
       13:  723:	state->numBuys++;//Increase buys by 1!
       13:  724:	if (choice1 > 0){//Boolean true or going to discard an estate
       10:  725:		int p = 0;//Iterator for hand!
       10:  726:		int card_not_discarded = 1;//Flag for discard set!
       53:  727:		while (card_not_discarded){
       33:  728:			if (state->hand[currentPlayer][p] == estate){ //Found an estate card!
        9:  729:				state->coins += 4;//Add 4 coins to the amount of coins
        9:  730:				state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
        9:  731:				state->discardCount[currentPlayer]++;
       37:  732:				for (; p < state->handCount[currentPlayer]; p++){
       28:  733:					state->hand[currentPlayer][p] = state->hand[currentPlayer][p + 1];
        -:  734:				}
        9:  735:				state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
        9:  736:				state->handCount[currentPlayer]--;
        9:  737:				card_not_discarded = 0;//Exit the loop
        -:  738:			}
       24:  739:			else if (p > state->handCount[currentPlayer]){
        -:  740:				if (DEBUG) {
        -:  741:					printf("No estate cards in your hand, invalid choice\n");
        -:  742:					printf("Must gain an estate if there are any\n");
        -:  743:				}
        1:  744:				if (supplyCount(estate, state) > 0){
    #####:  745:					gainCard(estate, state, 1, currentPlayer);
    #####:  746:					state->supplyCount[estate]--;//Decrement estates
    #####:  747:					if (supplyCount(estate, state) == 0){
    #####:  748:						isGameOver(state);
        -:  749:					}
        -:  750:				}
        1:  751:				card_not_discarded = 0;//Exit the loop
        -:  752:			}
        -:  753:
        -:  754:			else{
       23:  755:				p++;//Next card
        -:  756:			}
        -:  757:		}
        -:  758:	}
        -:  759:
        -:  760:	else{
        3:  761:		if (supplyCount(estate, state) > 0){
        1:  762:			gainCard(estate, state, 0, currentPlayer);//Gain an estate
        1:  763:			state->supplyCount[estate]--;//Decrement Estates
        1:  764:			if (supplyCount(estate, state) == 0){
    #####:  765:				isGameOver(state);
        -:  766:			}
        -:  767:		}
        -:  768:	}
       13:  769:}
        -:  770:
    #####:  771:int playTreasureMap(struct gameState *state, int currentPlayer, int handPos)
        -:  772://Trashing two treasure map cards from the hand = four gold on top of the deck.
        -:  773:{
        -:  774:	int i;
        -:  775:	int index;
        -:  776:
        -:  777:	//search hand for another treasure_map
    #####:  778:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  779:	{
    #####:  780:		if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -:  781:		{
    #####:  782:			index = i;
    #####:  783:			break;
        -:  784:		}
        -:  785:	}
    #####:  786:	if (index > -1)
        -:  787:	{
        -:  788:		//trash both treasure cards
    #####:  789:		discardCard(handPos, currentPlayer, state, 1);
    #####:  790:		discardCard(index, currentPlayer, state, 1);
        -:  791:
        -:  792:		//gain 4 Gold cards
    #####:  793:		for (i = 0; i < 4; i++)
        -:  794:		{
    #####:  795:			gainCard(gold, state, 1, currentPlayer);
        -:  796:		}
        -:  797:
        -:  798:		//return success
    #####:  799:		return 1;
        -:  800:	}
        -:  801:
        -:  802:	//no second treasure_map found in hand
    #####:  803:	return -1;
        -:  804:}
        -:  805:
      108:  806:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  807:{
        -:  808:	int i;
        -:  809:	int j;
        -:  810:	int k;
        -:  811:	//int x;  //Unused after while loop removed from feast.
      108:  812:	int currentPlayer = whoseTurn(state);
      108:  813:	int nextPlayer = currentPlayer + 1;
        -:  814:	int temphand[MAX_HAND];
        -:  815:
      108:  816:	int tributeRevealedCards[2] = { -1, -1 };
        -:  817:
      108:  818:	if (nextPlayer > (state->numPlayers - 1)){
       44:  819:		nextPlayer = 0;
        -:  820:	}
        -:  821:
        -:  822:	//uses switch to select card and perform actions
      108:  823:	switch (card)
        -:  824:	{
        -:  825:	case adventurer:
        -:  826:
    #####:  827:		playAdventurer(state, currentPlayer);
    #####:  828:		return 0;
        -:  829:
        -:  830:	case council_room:
        -:  831:		//+4 Cards
    #####:  832:		for (i = 0; i < 4; i++)
        -:  833:		{
    #####:  834:			drawCard(currentPlayer, state);
        -:  835:		}
        -:  836:
        -:  837:		//+1 Buy
    #####:  838:		state->numBuys++;
        -:  839:
        -:  840:		//Each other player draws a card
    #####:  841:		for (i = 0; i < state->numPlayers; i++)
        -:  842:		{
    #####:  843:			if (i != currentPlayer)
        -:  844:			{
    #####:  845:				drawCard(i, state);
        -:  846:			}
        -:  847:		}
        -:  848:
        -:  849:		//put played card in played card pile
    #####:  850:		discardCard(handPos, currentPlayer, state, 0);
        -:  851:
    #####:  852:		return 0;
        -:  853:
        -:  854:	case feast:
        -:  855:		//gain card with cost up to 5
        -:  856:		//Backup hand
    #####:  857:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  858:			temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  859:			state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  860:		}
        -:  861:		//Backup hand
        -:  862:
        -:  863:		//Update Coins for Buy
    #####:  864:		updateCoins(currentPlayer, state, 5);
        -:  865://		x = 1;//Condition to loop on
        -:  866://		while (x == 1) {//Buy one card
    #####:  867:			if (supplyCount(choice1, state) <= 0){
        -:  868:				if (DEBUG)
        -:  869:					printf("None of that card left, sorry!\n");
        -:  870:
        -:  871:				if (DEBUG){
        -:  872:					printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  873:				}
        -:  874:			}
    #####:  875:			else if (state->coins < getCost(choice1)){
    #####:  876:				printf("That card is too expensive!\n");
        -:  877:
        -:  878:				if (DEBUG){
        -:  879:					printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  880:				}
        -:  881:			}
        -:  882:			else{
        -:  883:
        -:  884:				if (DEBUG){
        -:  885:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  886:				}
        -:  887:
    #####:  888:				gainCard(choice1, state, 0, currentPlayer);//Gain the card
        -:  889://				x = 0;//No more buying cards
        -:  890:
        -:  891:				if (DEBUG){
        -:  892:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  893:				}
        -:  894:
        -:  895:			}
        -:  896://		}
        -:  897:
        -:  898:		//Reset Hand
    #####:  899:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
    #####:  900:			state->hand[currentPlayer][i] = temphand[i];
    #####:  901:			temphand[i] = -1;
        -:  902:		}
        -:  903:		//Reset Hand
        -:  904:
    #####:  905:		return 0;
        -:  906:
        -:  907:	case gardens:
        4:  908:		return -1;
        -:  909:
        -:  910:	case mine:
    #####:  911:		j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  912:
    #####:  913:		if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  914:		{
    #####:  915:			return -1;
        -:  916:		}
        -:  917:
    #####:  918:		if (choice2 > treasure_map || choice2 < curse)
        -:  919:		{
    #####:  920:			return -1;
        -:  921:		}
        -:  922:
    #####:  923:		if ((getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2))
        -:  924:		{
    #####:  925:			return -1;
        -:  926:		}
        -:  927:
    #####:  928:		gainCard(choice2, state, 2, currentPlayer);
        -:  929:
        -:  930:		//discard card from hand
    #####:  931:		discardCard(handPos, currentPlayer, state, 0);
        -:  932:
        -:  933:		//discard trashed card
    #####:  934:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  935:		{
    #####:  936:			if (state->hand[currentPlayer][i] == j)
        -:  937:			{
    #####:  938:				discardCard(i, currentPlayer, state, 0);
    #####:  939:				break;
        -:  940:			}
        -:  941:		}
        -:  942:
    #####:  943:		return 0;
        -:  944:
        -:  945:	case remodel:
        -:  946:
        5:  947:		return playRemodel(state, currentPlayer, choice1, choice2, handPos);
        -:  948:
        -:  949:	case smithy:
        -:  950:
    #####:  951:		playSmithy(state, currentPlayer, handPos);
    #####:  952:		return 0;
        -:  953:
        -:  954:	case village:
        -:  955:		//+1 Card
        5:  956:		drawCard(currentPlayer, state);
        -:  957:
        -:  958:		//+2 Actions
        5:  959:		state->numActions = state->numActions + 2;
        -:  960:
        -:  961:		//discard played card from hand
        5:  962:		discardCard(handPos, currentPlayer, state, 0);
        5:  963:		return 0;
        -:  964:
        -:  965:	case baron:
        -:  966:
       13:  967:		playBaron(state, currentPlayer, choice1, handPos);
       13:  968:		return 0;
        -:  969:
        -:  970:	case great_hall:
        -:  971:		//+1 Card
    #####:  972:		drawCard(currentPlayer, state);
        -:  973:
        -:  974:		//+1 Actions
    #####:  975:		state->numActions++;
        -:  976:
        -:  977:		//discard card from hand
    #####:  978:		discardCard(handPos, currentPlayer, state, 0);
    #####:  979:		return 0;
        -:  980:
        -:  981:	case minion:
        -:  982:		//+1 action
    #####:  983:		state->numActions++;
        -:  984:
        -:  985:		//discard card from hand
    #####:  986:		discardCard(handPos, currentPlayer, state, 0);
        -:  987:
    #####:  988:		if (choice1)		//+2 coins
        -:  989:		{
    #####:  990:			state->coins = state->coins + 2;
        -:  991:		}
        -:  992:
    #####:  993:		else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  994:		{
        -:  995:			//discard hand
    #####:  996:			while (numHandCards(state) > 0)
        -:  997:			{
    #####:  998:				discardCard(handPos, currentPlayer, state, 0);
        -:  999:			}
        -: 1000:
        -: 1001:			//draw 4
    #####: 1002:			for (i = 0; i < 4; i++)
        -: 1003:			{
    #####: 1004:				drawCard(currentPlayer, state);
        -: 1005:			}
        -: 1006:
        -: 1007:			//other players discard hand and redraw if hand size > 4
    #####: 1008:			for (i = 0; i < state->numPlayers; i++)
        -: 1009:			{
    #####: 1010:				if (i != currentPlayer)
        -: 1011:				{
    #####: 1012:					if (state->handCount[i] > 4)
        -: 1013:					{
        -: 1014:						//discard hand
    #####: 1015:						while (state->handCount[i] > 0)
        -: 1016:						{
    #####: 1017:							discardCard(handPos, i, state, 0);
        -: 1018:						}
        -: 1019:
        -: 1020:						//draw 4
    #####: 1021:						for (j = 0; j < 4; j++)
        -: 1022:						{
    #####: 1023:							drawCard(i, state);
        -: 1024:						}
        -: 1025:					}
        -: 1026:				}
        -: 1027:			}
        -: 1028:
        -: 1029:		}
    #####: 1030:		return 0;
        -: 1031:
        -: 1032:	case steward:
        3: 1033:		if (choice1 == 1)
        -: 1034:		{
        -: 1035:			//+2 cards
        1: 1036:			drawCard(currentPlayer, state);
        1: 1037:			drawCard(currentPlayer, state);
        -: 1038:		}
        2: 1039:		else if (choice1 == 2)
        -: 1040:		{
        -: 1041:			//+2 coins
    #####: 1042:			state->coins = state->coins + 2;
        -: 1043:		}
        -: 1044:		else
        -: 1045:		{
        -: 1046:			//trash 2 cards in hand
        2: 1047:			discardCard(choice2, currentPlayer, state, 1);
        2: 1048:			discardCard(choice3, currentPlayer, state, 1);
        -: 1049:		}
        -: 1050:
        -: 1051:		//discard card from hand
        3: 1052:		discardCard(handPos, currentPlayer, state, 0);
        3: 1053:		return 0;
        -: 1054:
        -: 1055:	case tribute:
    #####: 1056:		if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####: 1057:			if (state->deckCount[nextPlayer] > 0){
    #####: 1058:				tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1059:				state->deckCount[nextPlayer]--;
        -: 1060:			}
    #####: 1061:			else if (state->discardCount[nextPlayer] > 0){
    #####: 1062:				tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer] - 1];
    #####: 1063:				state->discardCount[nextPlayer]--;
        -: 1064:			}
        -: 1065:			else{
        -: 1066:				//No Card to Reveal
        -: 1067:				if (DEBUG){
        -: 1068:					printf("No cards to reveal\n");
        -: 1069:				}
        -: 1070:			}
        -: 1071:		}
        -: 1072:
        -: 1073:		else{
    #####: 1074:			if (state->deckCount[nextPlayer] == 0){
    #####: 1075:				for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####: 1076:					state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1077:					state->deckCount[nextPlayer]++;
    #####: 1078:					state->discard[nextPlayer][i] = -1;
    #####: 1079:					state->discardCount[nextPlayer]--;
        -: 1080:				}
        -: 1081:
    #####: 1082:				shuffle(nextPlayer, state);//Shuffle the deck
        -: 1083:			}
    #####: 1084:			tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1085:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1086:			state->deckCount[nextPlayer]--;
    #####: 1087:			tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1088:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1089:			state->deckCount[nextPlayer]--;
        -: 1090:		}
        -: 1091:
    #####: 1092:		if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
    #####: 1093:			state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1094:			state->playedCardCount++;
    #####: 1095:			tributeRevealedCards[1] = -1;
        -: 1096:		}
        -: 1097:
    #####: 1098:		for (i = 0; i <= 2; i++){
    #####: 1099:			if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
    #####: 1100:				state->coins += 2;
        -: 1101:			}
        -: 1102:
    #####: 1103:			else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
    #####: 1104:				drawCard(currentPlayer, state);
    #####: 1105:				drawCard(currentPlayer, state);
        -: 1106:			}
        -: 1107:			else{//Action Card
    #####: 1108:				state->numActions = state->numActions + 2;
        -: 1109:			}
        -: 1110:		}
        -: 1111:
    #####: 1112:		return 0;
        -: 1113:
        -: 1114:	case ambassador:
       50: 1115:		j = 0;		//used to check if player has enough cards to discard
        -: 1116:
       50: 1117:		if (choice2 > 2 || choice2 < 0)
        -: 1118:		{
       43: 1119:			return -1;
        -: 1120:		}
        -: 1121:
        7: 1122:		if (choice1 == handPos)
        -: 1123:		{
    #####: 1124:			return -1;
        -: 1125:		}
        -: 1126:
       42: 1127:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1128:		{
       35: 1129:			if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1130:			{
        5: 1131:				j++;
        -: 1132:			}
        -: 1133:		}
        7: 1134:		if (j < choice2)
        -: 1135:		{
        5: 1136:			return -1;
        -: 1137:		}
        -: 1138:
        -: 1139:		if (DEBUG)
        -: 1140:			printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1141:
        -: 1142:		//increase supply count for choosen card by amount being discarded
        2: 1143:		state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1144:
        -: 1145:		//each other player gains a copy of revealed card
        8: 1146:		for (i = 0; i < state->numPlayers; i++)
        -: 1147:		{
        6: 1148:			if (i != currentPlayer)
        -: 1149:			{
        4: 1150:				gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1151:			}
        -: 1152:		}
        -: 1153:
        -: 1154:		//discard played card from hand
        2: 1155:		discardCard(handPos, currentPlayer, state, 0);
        -: 1156:
        -: 1157:		//trash copies of cards returned to supply
        2: 1158:		for (j = 0; j < choice2; j++)
        -: 1159:		{
    #####: 1160:			for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1161:			{
    #####: 1162:				if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1163:				{
    #####: 1164:					discardCard(i, currentPlayer, state, 1);
    #####: 1165:					break;
        -: 1166:				}
        -: 1167:			}
        -: 1168:		}
        -: 1169:
        2: 1170:		return 0;
        -: 1171:
        -: 1172:	case cutpurse:
        -: 1173:
        3: 1174:		updateCoins(currentPlayer, state, 2);
       12: 1175:		for (i = 0; i < state->numPlayers; i++)
        -: 1176:		{
        9: 1177:			if (i != currentPlayer)
        -: 1178:			{
        6: 1179:				for (j = 0; j < state->handCount[i]; j++)
        -: 1180:				{
    #####: 1181:					if (state->hand[i][j] == copper)
        -: 1182:					{
    #####: 1183:						discardCard(j, i, state, 0);
    #####: 1184:						break;
        -: 1185:					}
    #####: 1186:					if (j == state->handCount[i])
        -: 1187:					{
    #####: 1188:						for (k = 0; k < state->handCount[i]; k++)
        -: 1189:						{
        -: 1190:							if (DEBUG)
        -: 1191:								printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1192:						}
    #####: 1193:						break;
        -: 1194:					}
        -: 1195:				}
        -: 1196:
        -: 1197:			}
        -: 1198:
        -: 1199:		}
        -: 1200:
        -: 1201:		//discard played card from hand
        3: 1202:		discardCard(handPos, currentPlayer, state, 0);
        -: 1203:
        3: 1204:		return 0;
        -: 1205:
        -: 1206:
        -: 1207:	case embargo:
        -: 1208:		//+2 Coins
       13: 1209:		state->coins = state->coins + 2;
        -: 1210:
        -: 1211:		//see if selected pile is in play
       13: 1212:		if (state->supplyCount[choice1] == -1)
        -: 1213:		{
        4: 1214:			return -1;
        -: 1215:		}
        -: 1216:
        -: 1217:		//add embargo token to selected supply pile
        9: 1218:		state->embargoTokens[choice1]++;
        -: 1219:
        -: 1220:		//trash card
        9: 1221:		discardCard(handPos, currentPlayer, state, 1);
        9: 1222:		return 0;
        -: 1223:
        -: 1224:	case outpost:
        -: 1225:		//set outpost flag
    #####: 1226:		state->outpostPlayed++;
        -: 1227:
        -: 1228:		//discard card
    #####: 1229:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1230:		return 0;
        -: 1231:
        -: 1232:	case salvager:
        -: 1233:		//+1 buy
    #####: 1234:		state->numBuys++;
        -: 1235:
    #####: 1236:		if (choice1)
        -: 1237:		{
        -: 1238:			//gain coins equal to trashed card
    #####: 1239:			state->coins = state->coins + getCost(handCard(choice1, state));
        -: 1240:			//trash card
    #####: 1241:			discardCard(choice1, currentPlayer, state, 1);
        -: 1242:		}
        -: 1243:
        -: 1244:		//discard card
    #####: 1245:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1246:		return 0;
        -: 1247:
        -: 1248:	case sea_hag:
       48: 1249:		for (i = 0; i < state->numPlayers; i++){
       36: 1250:			if (i != currentPlayer){
       24: 1251:				state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
       24: 1252:				state->discardCount[i]++;
       24: 1253:				state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1254:			}
        -: 1255:		}
       12: 1256:		return 0;
        -: 1257:
        -: 1258:	case treasure_map:
        -: 1259:
    #####: 1260:		return playTreasureMap(state, currentPlayer, handPos);
        -: 1261:	}
    #####: 1262:	return -1;
        -: 1263:}
        -: 1264:
       32: 1265:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1266:{
        -: 1267:
        -: 1268:	//if card is not trashed, added to Played pile 
       32: 1269:	if (trashFlag < 1)
        -: 1270:	{
        -: 1271:		//add card to played pile
       19: 1272:		state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
       19: 1273:		state->playedCardCount++;
        -: 1274:	}
        -: 1275:
        -: 1276:	//set played card to -1
       32: 1277:	state->hand[currentPlayer][handPos] = -1;
        -: 1278:
        -: 1279:	//remove card from player's hand
       32: 1280:	if (handPos == (state->handCount[currentPlayer] - 1)) 	//last card in hand array is played
        -: 1281:	{
        -: 1282:		//reduce number of cards in hand
    #####: 1283:		state->handCount[currentPlayer]--;
        -: 1284:	}
       32: 1285:	else if (state->handCount[currentPlayer] == 1) //only one card in hand
        -: 1286:	{
        -: 1287:		//reduce number of cards in hand
    #####: 1288:		state->handCount[currentPlayer]--;
        -: 1289:	}
        -: 1290:	else
        -: 1291:	{
        -: 1292:		//replace discarded card with last card in hand
       32: 1293:		state->hand[currentPlayer][handPos] = state->hand[currentPlayer][(state->handCount[currentPlayer] - 1)];
        -: 1294:		//set last card to -1
       32: 1295:		state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1296:		//reduce number of cards in hand
       32: 1297:		state->handCount[currentPlayer]--;
        -: 1298:	}
        -: 1299:
       32: 1300:	return 0;
        -: 1301:}
        -: 1302:
      190: 1303:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1304:{
        -: 1305:	//Note: supplyPos is enum of choosen card
        -: 1306:
        -: 1307:	//check if supply pile is empty (0) or card is not used in game (-1)
      190: 1308:	if (supplyCount(supplyPos, state) < 1)
        -: 1309:	{
    #####: 1310:		return -1;
        -: 1311:	}
        -: 1312:
        -: 1313:	//added card for [whoseTurn] current player:
        -: 1314:	// toFlag = 0 : add to discard
        -: 1315:	// toFlag = 1 : add to deck
        -: 1316:	// toFlag = 2 : add to hand
        -: 1317:
      190: 1318:	if (toFlag == 1)
        -: 1319:	{
    #####: 1320:		state->deck[player][state->deckCount[player]] = supplyPos;
    #####: 1321:		state->deckCount[player]++;
        -: 1322:	}
      190: 1323:	else if (toFlag == 2)
        -: 1324:	{
    #####: 1325:		state->hand[player][state->handCount[player]] = supplyPos;
    #####: 1326:		state->handCount[player]++;
        -: 1327:	}
        -: 1328:	else
        -: 1329:	{
      190: 1330:		state->discard[player][state->discardCount[player]] = supplyPos;
      190: 1331:		state->discardCount[player]++;
        -: 1332:	}
        -: 1333:
        -: 1334:	//decrease number in supply pile
      190: 1335:	state->supplyCount[supplyPos]--;
        -: 1336:
      190: 1337:	return 0;
        -: 1338:}
        -: 1339:
      281: 1340:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1341:{
        -: 1342:	int i;
        -: 1343:
        -: 1344:	//reset coin count
      281: 1345:	state->coins = 0;
        -: 1346:
        -: 1347:	//add coins for each Treasure card in player's hand
     1652: 1348:	for (i = 0; i < state->handCount[player]; i++)
        -: 1349:	{
     1371: 1350:		if (state->hand[player][i] == copper)
        -: 1351:		{
      643: 1352:			state->coins += 1;
        -: 1353:		}
      728: 1354:		else if (state->hand[player][i] == silver)
        -: 1355:		{
       44: 1356:			state->coins += 2;
        -: 1357:		}
      684: 1358:		else if (state->hand[player][i] == gold)
        -: 1359:		{
    #####: 1360:			state->coins += 3;
        -: 1361:		}
        -: 1362:	}
        -: 1363:
        -: 1364:	//add bonus
      281: 1365:	state->coins += bonus;
        -: 1366:
      281: 1367:	return 0;
        -: 1368:}
        -: 1369:
        -: 1370:
        -: 1371://end of dominion.c
File 'dominion.c'
Lines executed:61.04% of 557
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
     2933:    8:int compare(const void* a, const void* b) {
     2933:    9:	if (*(int*)a > *(int*)b)
      976:   10:		return 1;
     1957:   11:	if (*(int*)a < *(int*)b)
      849:   12:		return -1;
     1108:   13:	return 0;
        -:   14:}
        -:   15:
        4:   16:struct gameState* newGame() {
        4:   17:	struct gameState* g = malloc(sizeof(struct gameState));
        4:   18:	return g;
        -:   19:}
        -:   20:
       25:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:	int k8, int k9, int k10) {
       25:   23:	int* k = malloc(10 * sizeof(int));
       25:   24:	k[0] = k1;
       25:   25:	k[1] = k2;
       25:   26:	k[2] = k3;
       25:   27:	k[3] = k4;
       25:   28:	k[4] = k5;
       25:   29:	k[5] = k6;
       25:   30:	k[6] = k7;
       25:   31:	k[7] = k8;
       25:   32:	k[8] = k9;
       25:   33:	k[9] = k10;
       25:   34:	return k;
        -:   35:}
        -:   36:
       25:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		struct gameState *state) {
        -:   39:
        -:   40:	int i;
        -:   41:	int j;
        -:   42:	int it;
        -:   43:	//set up random number generator
       25:   44:	SelectStream(1);
       25:   45:	PutSeed((long)randomSeed);
        -:   46:
        -:   47:	//check number of players
       25:   48:	if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   49:	{
    #####:   50:		return -1;
        -:   51:	}
        -:   52:
        -:   53:	//set number of players
       25:   54:	state->numPlayers = numPlayers;
        -:   55:
        -:   56:	//check selected kingdom cards are different
       61:   57:	for (i = 0; i < 10; i++)
        -:   58:	{
      537:   59:		for (j = 0; j < 10; j++)
        -:   60:		{
      501:   61:			if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   62:			{
       23:   63:				return -1;
        -:   64:			}
        -:   65:		}
        -:   66:	}
        -:   67:
        -:   68:
        -:   69:	//initialize supply
        -:   70:	///////////////////////////////
        -:   71:
        -:   72:	//set number of Curse cards
        2:   73:	if (numPlayers == 2)
        -:   74:	{
    #####:   75:		state->supplyCount[curse] = 10;
        -:   76:	}
        2:   77:	else if (numPlayers == 3)
        -:   78:	{
        1:   79:		state->supplyCount[curse] = 20;
        -:   80:	}
        -:   81:	else
        -:   82:	{
        1:   83:		state->supplyCount[curse] = 30;
        -:   84:	}
        -:   85:
        -:   86:	//set number of Victory cards
        2:   87:	if (numPlayers == 2)
        -:   88:	{
    #####:   89:		state->supplyCount[estate] = 8;
    #####:   90:		state->supplyCount[duchy] = 8;
    #####:   91:		state->supplyCount[province] = 8;
        -:   92:	}
        -:   93:	else
        -:   94:	{
        2:   95:		state->supplyCount[estate] = 12;
        2:   96:		state->supplyCount[duchy] = 12;
        2:   97:		state->supplyCount[province] = 12;
        -:   98:	}
        -:   99:
        -:  100:	//set number of Treasure cards
        2:  101:	state->supplyCount[copper] = 60 - (7 * numPlayers);
        2:  102:	state->supplyCount[silver] = 40;
        2:  103:	state->supplyCount[gold] = 30;
        -:  104:
        -:  105:	//set number of Kingdom cards
       42:  106:	for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
        -:  107:	{
      330:  108:		for (j = 0; j < 10; j++)           		//loop chosen cards
        -:  109:		{
      310:  110:			if (kingdomCards[j] == i)
        -:  111:			{
        -:  112:				//check if card is a 'Victory' Kingdom card
       20:  113:				if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  114:				{
        6:  115:					if (numPlayers == 2){
    #####:  116:						state->supplyCount[i] = 8;
        -:  117:					}
        3:  118:					else{ state->supplyCount[i] = 12; }
        -:  119:				}
        -:  120:				else
        -:  121:				{
       17:  122:					state->supplyCount[i] = 10;
        -:  123:				}
       20:  124:				break;
        -:  125:			}
        -:  126:			else    //card is not in the set choosen for the game
        -:  127:			{
      290:  128:				state->supplyCount[i] = -1;
        -:  129:			}
        -:  130:		}
        -:  131:
        -:  132:	}
        -:  133:
        -:  134:	////////////////////////
        -:  135:	//supply intilization complete
        -:  136:
        -:  137:	//set player decks
        9:  138:	for (i = 0; i < numPlayers; i++)
        -:  139:	{
        7:  140:		state->deckCount[i] = 0;
       28:  141:		for (j = 0; j < 3; j++)
        -:  142:		{
       21:  143:			state->deck[i][j] = estate;
       21:  144:			state->deckCount[i]++;
        -:  145:		}
       56:  146:		for (j = 3; j < 10; j++)
        -:  147:		{
       49:  148:			state->deck[i][j] = copper;
       49:  149:			state->deckCount[i]++;
        -:  150:		}
        -:  151:	}
        -:  152:
        -:  153:	//shuffle player decks
        9:  154:	for (i = 0; i < numPlayers; i++)
        -:  155:	{
        7:  156:		if (shuffle(i, state) < 0)
        -:  157:		{
    #####:  158:			return -1;
        -:  159:		}
        -:  160:	}
        -:  161:
        -:  162:	//draw player hands
        9:  163:	for (i = 0; i < numPlayers; i++)
        -:  164:	{
        -:  165:		//initialize hand size to zero
        7:  166:		state->handCount[i] = 0;
        7:  167:		state->discardCount[i] = 0;
        -:  168:		//draw 5 cards
        -:  169:		// for (j = 0; j < 5; j++)
        -:  170:		//	{
        -:  171:		//	  drawCard(i, state);
        -:  172:		//	}
        -:  173:	}
        -:  174:
        -:  175:	//set embargo tokens to 0 for all supply piles
       56:  176:	for (i = 0; i <= treasure_map; i++)
        -:  177:	{
       54:  178:		state->embargoTokens[i] = 0;
        -:  179:	}
        -:  180:
        -:  181:	//initialize first player's turn
        2:  182:	state->outpostPlayed = 0;
        2:  183:	state->phase = 0;
        2:  184:	state->numActions = 1;
        2:  185:	state->numBuys = 1;
        2:  186:	state->playedCardCount = 0;
        2:  187:	state->whoseTurn = 0;
        2:  188:	state->handCount[state->whoseTurn] = 0;
        -:  189:	//int it; move to top
        -:  190:
        -:  191:	//Moved draw cards to here, only drawing at the start of a turn
       12:  192:	for (it = 0; it < 5; it++){
       10:  193:		drawCard(state->whoseTurn, state);
        -:  194:	}
        -:  195:
        2:  196:	updateCoins(state->whoseTurn, state, 0);
        -:  197:
        2:  198:	return 0;
        -:  199:}
        -:  200:
       89:  201:int shuffle(int player, struct gameState *state) {
        -:  202:
        -:  203:
        -:  204:	int newDeck[MAX_DECK];
       89:  205:	int newDeckPos = 0;
        -:  206:	int card;
        -:  207:	int i;
        -:  208:
       89:  209:	if (state->deckCount[player] < 1)
    #####:  210:		return -1;
       89:  211:	qsort((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
        -:  212:	/* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
     1552:  214:	while (state->deckCount[player] > 0) {
     1374:  215:		card = floor(Random() * state->deckCount[player]);
     1374:  216:		newDeck[newDeckPos] = state->deck[player][card];
     1374:  217:		newDeckPos++;
     7298:  218:		for (i = card; i < state->deckCount[player] - 1; i++) {
     5924:  219:			state->deck[player][i] = state->deck[player][i + 1];
        -:  220:		}
     1374:  221:		state->deckCount[player]--;
        -:  222:	}
     1463:  223:	for (i = 0; i < newDeckPos; i++) {
     1374:  224:		state->deck[player][i] = newDeck[i];
     1374:  225:		state->deckCount[player]++;
        -:  226:	}
        -:  227:
       89:  228:	return 0;
        -:  229:}
        -:  230:
     1175:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state)
        -:  232:{
        -:  233:	int card;
     1175:  234:	int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:	//check if it is the right phase
     1175:  237:	if (state->phase != 0)
        -:  238:	{
      223:  239:		return -1;
        -:  240:	}
        -:  241:
        -:  242:	//check if player has enough actions
      952:  243:	if (state->numActions < 1)
        -:  244:	{
       40:  245:		return -1;
        -:  246:	}
        -:  247:
        -:  248:	//get card played
      912:  249:	card = handCard(handPos, state);
        -:  250:
        -:  251:	//check if selected card is an action
      912:  252:	if (card < adventurer || card > treasure_map)
        -:  253:	{
      835:  254:		return -1;
        -:  255:	}
        -:  256:
        -:  257:	//play card
       77:  258:	if (cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0)
        -:  259:	{
       15:  260:		return -1;
        -:  261:	}
        -:  262:
        -:  263:	//reduce number of actions
       62:  264:	state->numActions--;
        -:  265:
        -:  266:	//update coins (Treasure cards may be added with card draws)
       62:  267:	updateCoins(state->whoseTurn, state, coin_bonus);
        -:  268:
       62:  269:	return 0;
        -:  270:}
        -:  271:
     1199:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:	int who;
        -:  274:	if (DEBUG){
        -:  275:		printf("Entering buyCard...\n");
        -:  276:	}
        -:  277:
        -:  278:	// I don't know what to do about the phase thing.
        -:  279:
     1199:  280:	who = state->whoseTurn;
        -:  281:
     1199:  282:	if (state->numBuys < 1){
        -:  283:		if (DEBUG)
        -:  284:			printf("You do not have any buys left\n");
      217:  285:		return -1;
        -:  286:	}
      982:  287:	else if (supplyCount(supplyPos, state) < 1){
        -:  288:		if (DEBUG)
        -:  289:			printf("There are not any of that type of card left\n");
      402:  290:		return -1;
        -:  291:	}
      580:  292:	else if (state->coins < getCost(supplyPos)){
        -:  293:		if (DEBUG)
        -:  294:			printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
      384:  295:		return -1;
        -:  296:	}
        -:  297:	else {
      196:  298:		state->phase = 1;
        -:  299:		//state->supplyCount[supplyPos]--;
      196:  300:		gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
        -:  301:
      196:  302:		state->coins = (state->coins) - (getCost(supplyPos));
      196:  303:		state->numBuys--;
        -:  304:		if (DEBUG)
        -:  305:			printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  306:	}
        -:  307:
        -:  308:	//state->discard[who][state->discardCount[who]] = supplyPos;
        -:  309:	//state->discardCount[who]++;
        -:  310:
      196:  311:	return 0;
        -:  312:}
        -:  313:
    #####:  314:int numHandCards(struct gameState *state) {
    #####:  315:	return state->handCount[whoseTurn(state)];
        -:  316:}
        -:  317:
      914:  318:int handCard(int handPos, struct gameState *state) {
      914:  319:	int currentPlayer = whoseTurn(state);
      914:  320:	return state->hand[currentPlayer][handPos];
        -:  321:}
        -:  322:
     1188:  323:int supplyCount(int card, struct gameState *state) {
     1188:  324:	return state->supplyCount[card];
        -:  325:}
        -:  326:
    #####:  327:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  328:	int i;
    #####:  329:	int count = 0;
        -:  330:
    #####:  331:	for (i = 0; i < state->deckCount[player]; i++)
        -:  332:	{
    #####:  333:		if (state->deck[player][i] == card) count++;
        -:  334:	}
        -:  335:
    #####:  336:	for (i = 0; i < state->handCount[player]; i++)
        -:  337:	{
    #####:  338:		if (state->hand[player][i] == card) count++;
        -:  339:	}
        -:  340:
    #####:  341:	for (i = 0; i < state->discardCount[player]; i++)
        -:  342:	{
    #####:  343:		if (state->discard[player][i] == card) count++;
        -:  344:	}
        -:  345:
    #####:  346:	return count;
        -:  347:}
        -:  348:
     1240:  349:int whoseTurn(struct gameState *state) {
     1240:  350:	return state->whoseTurn;
        -:  351:}
        -:  352:
      249:  353:int endTurn(struct gameState *state) {
        -:  354:	int k;
        -:  355:	int i;
      249:  356:	int currentPlayer = whoseTurn(state);
        -:  357:
        -:  358:	//Discard hand
     1462:  359:	for (i = 0; i < state->handCount[currentPlayer]; i++){
     1213:  360:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
     1213:  361:		state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  362:	}
      249:  363:	state->handCount[currentPlayer] = 0;//Reset hand count
        -:  364:
        -:  365:	//Code for determining the player
      249:  366:	if (currentPlayer < (state->numPlayers - 1)){
      177:  367:		state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  368:	}
        -:  369:	else{
       72:  370:		state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  371:	}
        -:  372:
      249:  373:	state->outpostPlayed = 0;
      249:  374:	state->phase = 0;
      249:  375:	state->numActions = 1;
      249:  376:	state->coins = 0;
      249:  377:	state->numBuys = 1;
      249:  378:	state->playedCardCount = 0;
      249:  379:	state->handCount[state->whoseTurn] = 0;
        -:  380:
        -:  381:	//int k; move to top
        -:  382:	//Next player draws hand
     1494:  383:	for (k = 0; k < 5; k++){
     1245:  384:		drawCard(state->whoseTurn, state);//Draw a card
        -:  385:	}
        -:  386:
        -:  387:	//Update money
      249:  388:	updateCoins(state->whoseTurn, state, 0);
        -:  389:
      249:  390:	return 0;
        -:  391:}
        -:  392:
     3469:  393:int isGameOver(struct gameState *state) {
        -:  394:	int i;
        -:  395:	int j;
        -:  396:
        -:  397:	//if stack of Province cards is empty, the game ends
     3469:  398:	if (state->supplyCount[province] == 0)
        -:  399:	{
    #####:  400:		return 1;
        -:  401:	}
        -:  402:
        -:  403:	//if three supply pile are at 0, the game ends
     3469:  404:	j = 0;
    90194:  405:	for (i = 0; i < 25; i++)
        -:  406:	{
    86725:  407:		if (state->supplyCount[i] == 0)
        -:  408:		{
     2010:  409:			j++;
        -:  410:		}
        -:  411:	}
     3469:  412:	if (j >= 3)
        -:  413:	{
        2:  414:		return 1;
        -:  415:	}
        -:  416:
     3467:  417:	return 0;
        -:  418:}
        -:  419:
    #####:  420:int scoreFor(int player, struct gameState *state) {
        -:  421:
        -:  422:	int i;
    #####:  423:	int score = 0;
        -:  424:	//score from hand
    #####:  425:	for (i = 0; i < state->handCount[player]; i++)
        -:  426:	{
    #####:  427:		if (state->hand[player][i] == curse) { score = score - 1; };
    #####:  428:		if (state->hand[player][i] == estate) { score = score + 1; };
    #####:  429:		if (state->hand[player][i] == duchy) { score = score + 3; };
    #####:  430:		if (state->hand[player][i] == province) { score = score + 6; };
    #####:  431:		if (state->hand[player][i] == great_hall) { score = score + 1; };
    #####:  432:		if (state->hand[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  433:	}
        -:  434:
        -:  435:	//score from discard
    #####:  436:	for (i = 0; i < state->discardCount[player]; i++)
        -:  437:	{
    #####:  438:		if (state->discard[player][i] == curse) { score = score - 1; };
    #####:  439:		if (state->discard[player][i] == estate) { score = score + 1; };
    #####:  440:		if (state->discard[player][i] == duchy) { score = score + 3; };
    #####:  441:		if (state->discard[player][i] == province) { score = score + 6; };
    #####:  442:		if (state->discard[player][i] == great_hall) { score = score + 1; };
    #####:  443:		if (state->discard[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  444:	}
        -:  445:
        -:  446:	//score from deck
    #####:  447:	for (i = 0; i < state->discardCount[player]; i++)
        -:  448:	{
    #####:  449:		if (state->deck[player][i] == curse) { score = score - 1; };
    #####:  450:		if (state->deck[player][i] == estate) { score = score + 1; };
    #####:  451:		if (state->deck[player][i] == duchy) { score = score + 3; };
    #####:  452:		if (state->deck[player][i] == province) { score = score + 6; };
    #####:  453:		if (state->deck[player][i] == great_hall) { score = score + 1; };
    #####:  454:		if (state->deck[player][i] == gardens) { score = score + (fullDeckCount(player, 0, state) / 10); };
        -:  455:	}
        -:  456:
    #####:  457:	return score;
        -:  458:}
        -:  459:
    #####:  460:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  461:	int i;
        -:  462:	int j;
        -:  463:	int highScore;
        -:  464:	int currentPlayer;
        -:  465:
        -:  466:	//get score for each player
    #####:  467:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  468:	{
        -:  469:		//set unused player scores to -9999
    #####:  470:		if (i >= state->numPlayers)
        -:  471:		{
    #####:  472:			players[i] = -9999;
        -:  473:		}
        -:  474:		else
        -:  475:		{
    #####:  476:			players[i] = scoreFor(i, state);
        -:  477:		}
        -:  478:	}
        -:  479:
        -:  480:	//find highest score
    #####:  481:	j = 0;
    #####:  482:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  483:	{
    #####:  484:		if (players[i] > players[j])
        -:  485:		{
    #####:  486:			j = i;
        -:  487:		}
        -:  488:	}
    #####:  489:	highScore = players[j];
        -:  490:
        -:  491:	//add 1 to players who had less turns
    #####:  492:	currentPlayer = whoseTurn(state);
    #####:  493:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  494:	{
    #####:  495:		if (players[i] == highScore && i > currentPlayer)
        -:  496:		{
    #####:  497:			players[i]++;
        -:  498:		}
        -:  499:	}
        -:  500:
        -:  501:	//find new highest score
    #####:  502:	j = 0;
    #####:  503:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  504:	{
    #####:  505:		if (players[i] > players[j])
        -:  506:		{
    #####:  507:			j = i;
        -:  508:		}
        -:  509:	}
    #####:  510:	highScore = players[j];
        -:  511:
        -:  512:	//set winners in array to 1 and rest to 0
    #####:  513:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  514:	{
    #####:  515:		if (players[i] == highScore)
        -:  516:		{
    #####:  517:			players[i] = 1;
        -:  518:		}
        -:  519:		else
        -:  520:		{
    #####:  521:			players[i] = 0;
        -:  522:		}
        -:  523:	}
        -:  524:
    #####:  525:	return 0;
        -:  526:}
        -:  527:
     1298:  528:int drawCard(int player, struct gameState *state)
        -:  529:{
        -:  530:	int count;
        -:  531:	int deckCounter;
     1298:  532:	if (state->deckCount[player] <= 0){//Deck is empty
        -:  533:
        -:  534:		//Step 1 Shuffle the discard pile back into a deck
        -:  535:		int i;
        -:  536:		//Move discard to deck
     1386:  537:		for (i = 0; i < state->discardCount[player]; i++){
     1304:  538:			state->deck[player][i] = state->discard[player][i];
     1304:  539:			state->discard[player][i] = -1;
        -:  540:		}
        -:  541:
       82:  542:		state->deckCount[player] = state->discardCount[player];
       82:  543:		state->discardCount[player] = 0;//Reset discard
        -:  544:
        -:  545:		//Shufffle the deck
       82:  546:		shuffle(player, state);//Shuffle the deck up and make it so that we can draw
        -:  547:
        -:  548:		if (DEBUG){//Debug statements
        -:  549:			printf("Deck count now: %d\n", state->deckCount[player]);
        -:  550:		}
        -:  551:
       82:  552:		state->discardCount[player] = 0;
        -:  553:
        -:  554:		//Step 2 Draw Card
       82:  555:		count = state->handCount[player];//Get current player's hand count
        -:  556:
        -:  557:		if (DEBUG){//Debug statements
        -:  558:			printf("Current hand count: %d\n", count);
        -:  559:		}
        -:  560:
       82:  561:		deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  562:
       82:  563:		if (deckCounter == 0)
    #####:  564:			return -1;
        -:  565:
       82:  566:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
       82:  567:		state->deckCount[player]--;
       82:  568:		state->handCount[player]++;//Increment hand count
        -:  569:	}
        -:  570:
        -:  571:	else{
     1216:  572:		int count = state->handCount[player];//Get current hand count for player
        -:  573:		int deckCounter;
        -:  574:		if (DEBUG){//Debug statements
        -:  575:			printf("Current hand count: %d\n", count);
        -:  576:		}
        -:  577:
     1216:  578:		deckCounter = state->deckCount[player];//Create holder for the deck count
     1216:  579:		state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
     1216:  580:		state->deckCount[player]--;
     1216:  581:		state->handCount[player]++;//Increment hand count
        -:  582:	}
        -:  583:
     1298:  584:	return 0;
        -:  585:}
        -:  586:
      781:  587:int getCost(int cardNumber)
        -:  588:{
      781:  589:	switch (cardNumber)
        -:  590:	{
        -:  591:	case curse:
       73:  592:		return 0;
        -:  593:	case estate:
       47:  594:		return 2;
        -:  595:	case duchy:
       41:  596:		return 5;
        -:  597:	case province:
       23:  598:		return 8;
        -:  599:	case copper:
       72:  600:		return 0;
        -:  601:	case silver:
       52:  602:		return 3;
        -:  603:	case gold:
       35:  604:		return 6;
        -:  605:	case adventurer:
       46:  606:		return 6;
        -:  607:	case council_room:
    #####:  608:		return 5;
        -:  609:	case feast:
       17:  610:		return 4;
        -:  611:	case gardens:
       19:  612:		return 4;
        -:  613:	case mine:
       39:  614:		return 5;
        -:  615:	case remodel:
       20:  616:		return 4;
        -:  617:	case smithy:
       27:  618:		return 4;
        -:  619:	case village:
    #####:  620:		return 3;
        -:  621:	case baron:
       18:  622:		return 4;
        -:  623:	case great_hall:
       51:  624:		return 3;
        -:  625:	case minion:
       40:  626:		return 5;
        -:  627:	case steward:
       32:  628:		return 3;
        -:  629:	case tribute:
    #####:  630:		return 5;
        -:  631:	case ambassador:
    #####:  632:		return 3;
        -:  633:	case cutpurse:
       25:  634:		return 4;
        -:  635:	case embargo:
       45:  636:		return 2;
        -:  637:	case outpost:
       23:  638:		return 5;
        -:  639:	case salvager:
       19:  640:		return 4;
        -:  641:	case sea_hag:
       17:  642:		return 4;
        -:  643:	case treasure_map:
    #####:  644:		return 4;
        -:  645:	}
        -:  646:
    #####:  647:	return -1;
        -:  648:}
        -:  649:
        3:  650:void playAdventurer(struct gameState *state, int currentPlayer)
        -:  651:// Reveal cards from deck until 2 Treasure cards are found.  Put those Treasure cards in the hand and discard the rest.
        -:  652:{
        3:  653:	int drawntreasure = 0;
        -:  654:	int temphand[MAX_HAND];
        -:  655:	int cardDrawn;
        3:  656:	int z = 0; // this is the counter for the temp hand
        -:  657:
       20:  658:	while (drawntreasure < 2){
       14:  659:		if (state->deckCount[currentPlayer] < 1){//if the deck is empty we need to shuffle discard and add to deck
    #####:  660:			shuffle(currentPlayer, state);
        -:  661:		}
       14:  662:		drawCard(currentPlayer, state);
       14:  663:		cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer] - 1];//top card of hand is most recently drawn card.
       14:  664:		if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
        6:  665:			drawntreasure++;
        -:  666:		else{
        8:  667:			temphand[z] = cardDrawn;
        8:  668:			state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
        8:  669:			z++;
        -:  670:		}
        -:  671:	}
       14:  672:	while (z - 1 >= 0){
        8:  673:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] = temphand[z - 1]; // discard all cards in play that have been drawn
        8:  674:		z = z - 1;
        -:  675:	}
        3:  676:}
        -:  677:
        1:  678:int playRemodel(struct gameState *state, int currentPlayer, int choice1, int choice2, int handPos)
        -:  679://Trash a card in the hand, and gain a card costing up to $2 more than the trashed card
        -:  680:{
        -:  681:	int i;
        1:  682:	int j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  683:
        1:  684:	if ((getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2))
        -:  685:	{
    #####:  686:		return -1;
        -:  687:	}
        -:  688:
        1:  689:	gainCard(choice2, state, 0, currentPlayer);
        -:  690:
        -:  691:	//discard card from hand
        1:  692:	discardCard(handPos, currentPlayer, state, 0);
        -:  693:
        -:  694:	//discard trashed card
        5:  695:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  696:	{
        4:  697:		if (state->hand[currentPlayer][i] == j)
        -:  698:		{
    #####:  699:			discardCard(i, currentPlayer, state, 0);
    #####:  700:			break;
        -:  701:		}
        -:  702:	}
        -:  703:
        1:  704:	return 0;
        -:  705:}
        -:  706:
        4:  707:void playSmithy(struct gameState *state, int currentPlayer, int handPos)
        -:  708:// Draw 3 cards
        -:  709:{
        -:  710:	int i;
       16:  711:	for (i = 0; i < 3; i++)
        -:  712:	{
       12:  713:		drawCard(currentPlayer, state);
        -:  714:	}
        -:  715:
        -:  716:	//discard card from hand
        4:  717:	discardCard(handPos, currentPlayer, state, 0);
        4:  718:}
        -:  719:
        4:  720:void playBaron(struct gameState *state, int currentPlayer, int choice1, int handPos)
        -:  721://Add a buy.  OPTION:  Discard an Estate card and gain $4.  Otherwise, gain an Estate card.
        -:  722:{
        4:  723:	state->numBuys++;//Increase buys by 1!
        4:  724:	if (choice1 > 0){//Boolean true or going to discard an estate
        3:  725:		int p = 0;//Iterator for hand!
        3:  726:		int card_not_discarded = 1;//Flag for discard set!
       12:  727:		while (card_not_discarded){
        6:  728:			if (state->hand[currentPlayer][p] == estate){ //Found an estate card!
        3:  729:				state->coins += 4;//Add 4 coins to the amount of coins
        3:  730:				state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
        3:  731:				state->discardCount[currentPlayer]++;
       15:  732:				for (; p < state->handCount[currentPlayer]; p++){
       12:  733:					state->hand[currentPlayer][p] = state->hand[currentPlayer][p + 1];
        -:  734:				}
        3:  735:				state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
        3:  736:				state->handCount[currentPlayer]--;
        3:  737:				card_not_discarded = 0;//Exit the loop
        -:  738:			}
        3:  739:			else if (p > state->handCount[currentPlayer]){
        -:  740:				if (DEBUG) {
        -:  741:					printf("No estate cards in your hand, invalid choice\n");
        -:  742:					printf("Must gain an estate if there are any\n");
        -:  743:				}
    #####:  744:				if (supplyCount(estate, state) > 0){
    #####:  745:					gainCard(estate, state, 1, currentPlayer);
    #####:  746:					state->supplyCount[estate]--;//Decrement estates
    #####:  747:					if (supplyCount(estate, state) == 0){
    #####:  748:						isGameOver(state);
        -:  749:					}
        -:  750:				}
    #####:  751:				card_not_discarded = 0;//Exit the loop
        -:  752:			}
        -:  753:
        -:  754:			else{
        3:  755:				p++;//Next card
        -:  756:			}
        -:  757:		}
        -:  758:	}
        -:  759:
        -:  760:	else{
        1:  761:		if (supplyCount(estate, state) > 0){
        1:  762:			gainCard(estate, state, 0, currentPlayer);//Gain an estate
        1:  763:			state->supplyCount[estate]--;//Decrement Estates
        1:  764:			if (supplyCount(estate, state) == 0){
    #####:  765:				isGameOver(state);
        -:  766:			}
        -:  767:		}
        -:  768:	}
        4:  769:}
        -:  770:
    #####:  771:int playTreasureMap(struct gameState *state, int currentPlayer, int handPos)
        -:  772://Trashing two treasure map cards from the hand = four gold on top of the deck.
        -:  773:{
        -:  774:	int i;
        -:  775:	int index;
        -:  776:
        -:  777:	//search hand for another treasure_map
    #####:  778:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  779:	{
    #####:  780:		if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -:  781:		{
    #####:  782:			index = i;
    #####:  783:			break;
        -:  784:		}
        -:  785:	}
    #####:  786:	if (index > -1)
        -:  787:	{
        -:  788:		//trash both treasure cards
    #####:  789:		discardCard(handPos, currentPlayer, state, 1);
    #####:  790:		discardCard(index, currentPlayer, state, 1);
        -:  791:
        -:  792:		//gain 4 Gold cards
    #####:  793:		for (i = 0; i < 4; i++)
        -:  794:		{
    #####:  795:			gainCard(gold, state, 1, currentPlayer);
        -:  796:		}
        -:  797:
        -:  798:		//return success
    #####:  799:		return 1;
        -:  800:	}
        -:  801:
        -:  802:	//no second treasure_map found in hand
    #####:  803:	return -1;
        -:  804:}
        -:  805:
       77:  806:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  807:{
        -:  808:	int i;
        -:  809:	int j;
        -:  810:	int k;
        -:  811:	//int x;  //Unused after while loop removed from feast.
       77:  812:	int currentPlayer = whoseTurn(state);
       77:  813:	int nextPlayer = currentPlayer + 1;
        -:  814:	int temphand[MAX_HAND];
        -:  815:
       77:  816:	int tributeRevealedCards[2] = { -1, -1 };
        -:  817:
       77:  818:	if (nextPlayer > (state->numPlayers - 1)){
       16:  819:		nextPlayer = 0;
        -:  820:	}
        -:  821:
        -:  822:	//uses switch to select card and perform actions
       77:  823:	switch (card)
        -:  824:	{
        -:  825:	case adventurer:
        -:  826:
        3:  827:		playAdventurer(state, currentPlayer);
        3:  828:		return 0;
        -:  829:
        -:  830:	case council_room:
        -:  831:		//+4 Cards
    #####:  832:		for (i = 0; i < 4; i++)
        -:  833:		{
    #####:  834:			drawCard(currentPlayer, state);
        -:  835:		}
        -:  836:
        -:  837:		//+1 Buy
    #####:  838:		state->numBuys++;
        -:  839:
        -:  840:		//Each other player draws a card
    #####:  841:		for (i = 0; i < state->numPlayers; i++)
        -:  842:		{
    #####:  843:			if (i != currentPlayer)
        -:  844:			{
    #####:  845:				drawCard(i, state);
        -:  846:			}
        -:  847:		}
        -:  848:
        -:  849:		//put played card in played card pile
    #####:  850:		discardCard(handPos, currentPlayer, state, 0);
        -:  851:
    #####:  852:		return 0;
        -:  853:
        -:  854:	case feast:
        -:  855:		//gain card with cost up to 5
        -:  856:		//Backup hand
       35:  857:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
       30:  858:			temphand[i] = state->hand[currentPlayer][i];//Backup card
       30:  859:			state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  860:		}
        -:  861:		//Backup hand
        -:  862:
        -:  863:		//Update Coins for Buy
        5:  864:		updateCoins(currentPlayer, state, 5);
        -:  865://		x = 1;//Condition to loop on
        -:  866://		while (x == 1) {//Buy one card
        5:  867:			if (supplyCount(choice1, state) <= 0){
        -:  868:				if (DEBUG)
        -:  869:					printf("None of that card left, sorry!\n");
        -:  870:
        -:  871:				if (DEBUG){
        -:  872:					printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  873:				}
        -:  874:			}
        1:  875:			else if (state->coins < getCost(choice1)){
    #####:  876:				printf("That card is too expensive!\n");
        -:  877:
        -:  878:				if (DEBUG){
        -:  879:					printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  880:				}
        -:  881:			}
        -:  882:			else{
        -:  883:
        -:  884:				if (DEBUG){
        -:  885:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  886:				}
        -:  887:
        1:  888:				gainCard(choice1, state, 0, currentPlayer);//Gain the card
        -:  889://				x = 0;//No more buying cards
        -:  890:
        -:  891:				if (DEBUG){
        -:  892:					printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  893:				}
        -:  894:
        -:  895:			}
        -:  896://		}
        -:  897:
        -:  898:		//Reset Hand
       35:  899:		for (i = 0; i <= state->handCount[currentPlayer]; i++){
       30:  900:			state->hand[currentPlayer][i] = temphand[i];
       30:  901:			temphand[i] = -1;
        -:  902:		}
        -:  903:		//Reset Hand
        -:  904:
        5:  905:		return 0;
        -:  906:
        -:  907:	case gardens:
        9:  908:		return -1;
        -:  909:
        -:  910:	case mine:
    #####:  911:		j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  912:
    #####:  913:		if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
        -:  914:		{
    #####:  915:			return -1;
        -:  916:		}
        -:  917:
    #####:  918:		if (choice2 > treasure_map || choice2 < curse)
        -:  919:		{
    #####:  920:			return -1;
        -:  921:		}
        -:  922:
    #####:  923:		if ((getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2))
        -:  924:		{
    #####:  925:			return -1;
        -:  926:		}
        -:  927:
    #####:  928:		gainCard(choice2, state, 2, currentPlayer);
        -:  929:
        -:  930:		//discard card from hand
    #####:  931:		discardCard(handPos, currentPlayer, state, 0);
        -:  932:
        -:  933:		//discard trashed card
    #####:  934:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  935:		{
    #####:  936:			if (state->hand[currentPlayer][i] == j)
        -:  937:			{
    #####:  938:				discardCard(i, currentPlayer, state, 0);
    #####:  939:				break;
        -:  940:			}
        -:  941:		}
        -:  942:
    #####:  943:		return 0;
        -:  944:
        -:  945:	case remodel:
        -:  946:
        1:  947:		return playRemodel(state, currentPlayer, choice1, choice2, handPos);
        -:  948:
        -:  949:	case smithy:
        -:  950:
        4:  951:		playSmithy(state, currentPlayer, handPos);
        4:  952:		return 0;
        -:  953:
        -:  954:	case village:
        -:  955:		//+1 Card
    #####:  956:		drawCard(currentPlayer, state);
        -:  957:
        -:  958:		//+2 Actions
    #####:  959:		state->numActions = state->numActions + 2;
        -:  960:
        -:  961:		//discard played card from hand
    #####:  962:		discardCard(handPos, currentPlayer, state, 0);
    #####:  963:		return 0;
        -:  964:
        -:  965:	case baron:
        -:  966:
        4:  967:		playBaron(state, currentPlayer, choice1, handPos);
        4:  968:		return 0;
        -:  969:
        -:  970:	case great_hall:
        -:  971:		//+1 Card
       17:  972:		drawCard(currentPlayer, state);
        -:  973:
        -:  974:		//+1 Actions
       17:  975:		state->numActions++;
        -:  976:
        -:  977:		//discard card from hand
       17:  978:		discardCard(handPos, currentPlayer, state, 0);
       17:  979:		return 0;
        -:  980:
        -:  981:	case minion:
        -:  982:		//+1 action
        2:  983:		state->numActions++;
        -:  984:
        -:  985:		//discard card from hand
        2:  986:		discardCard(handPos, currentPlayer, state, 0);
        -:  987:
        2:  988:		if (choice1)		//+2 coins
        -:  989:		{
        2:  990:			state->coins = state->coins + 2;
        -:  991:		}
        -:  992:
    #####:  993:		else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
        -:  994:		{
        -:  995:			//discard hand
    #####:  996:			while (numHandCards(state) > 0)
        -:  997:			{
    #####:  998:				discardCard(handPos, currentPlayer, state, 0);
        -:  999:			}
        -: 1000:
        -: 1001:			//draw 4
    #####: 1002:			for (i = 0; i < 4; i++)
        -: 1003:			{
    #####: 1004:				drawCard(currentPlayer, state);
        -: 1005:			}
        -: 1006:
        -: 1007:			//other players discard hand and redraw if hand size > 4
    #####: 1008:			for (i = 0; i < state->numPlayers; i++)
        -: 1009:			{
    #####: 1010:				if (i != currentPlayer)
        -: 1011:				{
    #####: 1012:					if (state->handCount[i] > 4)
        -: 1013:					{
        -: 1014:						//discard hand
    #####: 1015:						while (state->handCount[i] > 0)
        -: 1016:						{
    #####: 1017:							discardCard(handPos, i, state, 0);
        -: 1018:						}
        -: 1019:
        -: 1020:						//draw 4
    #####: 1021:						for (j = 0; j < 4; j++)
        -: 1022:						{
    #####: 1023:							drawCard(i, state);
        -: 1024:						}
        -: 1025:					}
        -: 1026:				}
        -: 1027:			}
        -: 1028:
        -: 1029:		}
        2: 1030:		return 0;
        -: 1031:
        -: 1032:	case steward:
        6: 1033:		if (choice1 == 1)
        -: 1034:		{
        -: 1035:			//+2 cards
    #####: 1036:			drawCard(currentPlayer, state);
    #####: 1037:			drawCard(currentPlayer, state);
        -: 1038:		}
        6: 1039:		else if (choice1 == 2)
        -: 1040:		{
        -: 1041:			//+2 coins
    #####: 1042:			state->coins = state->coins + 2;
        -: 1043:		}
        -: 1044:		else
        -: 1045:		{
        -: 1046:			//trash 2 cards in hand
        6: 1047:			discardCard(choice2, currentPlayer, state, 1);
        6: 1048:			discardCard(choice3, currentPlayer, state, 1);
        -: 1049:		}
        -: 1050:
        -: 1051:		//discard card from hand
        6: 1052:		discardCard(handPos, currentPlayer, state, 0);
        6: 1053:		return 0;
        -: 1054:
        -: 1055:	case tribute:
    #####: 1056:		if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
    #####: 1057:			if (state->deckCount[nextPlayer] > 0){
    #####: 1058:				tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1059:				state->deckCount[nextPlayer]--;
        -: 1060:			}
    #####: 1061:			else if (state->discardCount[nextPlayer] > 0){
    #####: 1062:				tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer] - 1];
    #####: 1063:				state->discardCount[nextPlayer]--;
        -: 1064:			}
        -: 1065:			else{
        -: 1066:				//No Card to Reveal
        -: 1067:				if (DEBUG){
        -: 1068:					printf("No cards to reveal\n");
        -: 1069:				}
        -: 1070:			}
        -: 1071:		}
        -: 1072:
        -: 1073:		else{
    #####: 1074:			if (state->deckCount[nextPlayer] == 0){
    #####: 1075:				for (i = 0; i < state->discardCount[nextPlayer]; i++){
    #####: 1076:					state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1077:					state->deckCount[nextPlayer]++;
    #####: 1078:					state->discard[nextPlayer][i] = -1;
    #####: 1079:					state->discardCount[nextPlayer]--;
        -: 1080:				}
        -: 1081:
    #####: 1082:				shuffle(nextPlayer, state);//Shuffle the deck
        -: 1083:			}
    #####: 1084:			tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1085:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1086:			state->deckCount[nextPlayer]--;
    #####: 1087:			tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1088:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1089:			state->deckCount[nextPlayer]--;
        -: 1090:		}
        -: 1091:
    #####: 1092:		if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
    #####: 1093:			state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1094:			state->playedCardCount++;
    #####: 1095:			tributeRevealedCards[1] = -1;
        -: 1096:		}
        -: 1097:
    #####: 1098:		for (i = 0; i <= 2; i++){
    #####: 1099:			if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
    #####: 1100:				state->coins += 2;
        -: 1101:			}
        -: 1102:
    #####: 1103:			else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
    #####: 1104:				drawCard(currentPlayer, state);
    #####: 1105:				drawCard(currentPlayer, state);
        -: 1106:			}
        -: 1107:			else{//Action Card
    #####: 1108:				state->numActions = state->numActions + 2;
        -: 1109:			}
        -: 1110:		}
        -: 1111:
    #####: 1112:		return 0;
        -: 1113:
        -: 1114:	case ambassador:
    #####: 1115:		j = 0;		//used to check if player has enough cards to discard
        -: 1116:
    #####: 1117:		if (choice2 > 2 || choice2 < 0)
        -: 1118:		{
    #####: 1119:			return -1;
        -: 1120:		}
        -: 1121:
    #####: 1122:		if (choice1 == handPos)
        -: 1123:		{
    #####: 1124:			return -1;
        -: 1125:		}
        -: 1126:
    #####: 1127:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1128:		{
    #####: 1129:			if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1130:			{
    #####: 1131:				j++;
        -: 1132:			}
        -: 1133:		}
    #####: 1134:		if (j < choice2)
        -: 1135:		{
    #####: 1136:			return -1;
        -: 1137:		}
        -: 1138:
        -: 1139:		if (DEBUG)
        -: 1140:			printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1141:
        -: 1142:		//increase supply count for choosen card by amount being discarded
    #####: 1143:		state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1144:
        -: 1145:		//each other player gains a copy of revealed card
    #####: 1146:		for (i = 0; i < state->numPlayers; i++)
        -: 1147:		{
    #####: 1148:			if (i != currentPlayer)
        -: 1149:			{
    #####: 1150:				gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1151:			}
        -: 1152:		}
        -: 1153:
        -: 1154:		//discard played card from hand
    #####: 1155:		discardCard(handPos, currentPlayer, state, 0);
        -: 1156:
        -: 1157:		//trash copies of cards returned to supply
    #####: 1158:		for (j = 0; j < choice2; j++)
        -: 1159:		{
    #####: 1160:			for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1161:			{
    #####: 1162:				if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1163:				{
    #####: 1164:					discardCard(i, currentPlayer, state, 1);
    #####: 1165:					break;
        -: 1166:				}
        -: 1167:			}
        -: 1168:		}
        -: 1169:
    #####: 1170:		return 0;
        -: 1171:
        -: 1172:	case cutpurse:
        -: 1173:
        5: 1174:		updateCoins(currentPlayer, state, 2);
       20: 1175:		for (i = 0; i < state->numPlayers; i++)
        -: 1176:		{
       15: 1177:			if (i != currentPlayer)
        -: 1178:			{
       10: 1179:				for (j = 0; j < state->handCount[i]; j++)
        -: 1180:				{
    #####: 1181:					if (state->hand[i][j] == copper)
        -: 1182:					{
    #####: 1183:						discardCard(j, i, state, 0);
    #####: 1184:						break;
        -: 1185:					}
    #####: 1186:					if (j == state->handCount[i])
        -: 1187:					{
    #####: 1188:						for (k = 0; k < state->handCount[i]; k++)
        -: 1189:						{
        -: 1190:							if (DEBUG)
        -: 1191:								printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1192:						}
    #####: 1193:						break;
        -: 1194:					}
        -: 1195:				}
        -: 1196:
        -: 1197:			}
        -: 1198:
        -: 1199:		}
        -: 1200:
        -: 1201:		//discard played card from hand
        5: 1202:		discardCard(handPos, currentPlayer, state, 0);
        -: 1203:
        5: 1204:		return 0;
        -: 1205:
        -: 1206:
        -: 1207:	case embargo:
        -: 1208:		//+2 Coins
       19: 1209:		state->coins = state->coins + 2;
        -: 1210:
        -: 1211:		//see if selected pile is in play
       19: 1212:		if (state->supplyCount[choice1] == -1)
        -: 1213:		{
        6: 1214:			return -1;
        -: 1215:		}
        -: 1216:
        -: 1217:		//add embargo token to selected supply pile
       13: 1218:		state->embargoTokens[choice1]++;
        -: 1219:
        -: 1220:		//trash card
       13: 1221:		discardCard(handPos, currentPlayer, state, 1);
       13: 1222:		return 0;
        -: 1223:
        -: 1224:	case outpost:
        -: 1225:		//set outpost flag
    #####: 1226:		state->outpostPlayed++;
        -: 1227:
        -: 1228:		//discard card
    #####: 1229:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1230:		return 0;
        -: 1231:
        -: 1232:	case salvager:
        -: 1233:		//+1 buy
        2: 1234:		state->numBuys++;
        -: 1235:
        2: 1236:		if (choice1)
        -: 1237:		{
        -: 1238:			//gain coins equal to trashed card
        2: 1239:			state->coins = state->coins + getCost(handCard(choice1, state));
        -: 1240:			//trash card
        2: 1241:			discardCard(choice1, currentPlayer, state, 1);
        -: 1242:		}
        -: 1243:
        -: 1244:		//discard card
        2: 1245:		discardCard(handPos, currentPlayer, state, 0);
        2: 1246:		return 0;
        -: 1247:
        -: 1248:	case sea_hag:
    #####: 1249:		for (i = 0; i < state->numPlayers; i++){
    #####: 1250:			if (i != currentPlayer){
    #####: 1251:				state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1252:				state->discardCount[i]++;
    #####: 1253:				state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1254:			}
        -: 1255:		}
    #####: 1256:		return 0;
        -: 1257:
        -: 1258:	case treasure_map:
        -: 1259:
    #####: 1260:		return playTreasureMap(state, currentPlayer, handPos);
        -: 1261:	}
    #####: 1262:	return -1;
        -: 1263:}
        -: 1264:
       64: 1265:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1266:{
        -: 1267:
        -: 1268:	//if card is not trashed, added to Played pile 
       64: 1269:	if (trashFlag < 1)
        -: 1270:	{
        -: 1271:		//add card to played pile
       37: 1272:		state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
       37: 1273:		state->playedCardCount++;
        -: 1274:	}
        -: 1275:
        -: 1276:	//set played card to -1
       64: 1277:	state->hand[currentPlayer][handPos] = -1;
        -: 1278:
        -: 1279:	//remove card from player's hand
       64: 1280:	if (handPos == (state->handCount[currentPlayer] - 1)) 	//last card in hand array is played
        -: 1281:	{
        -: 1282:		//reduce number of cards in hand
        3: 1283:		state->handCount[currentPlayer]--;
        -: 1284:	}
       61: 1285:	else if (state->handCount[currentPlayer] == 1) //only one card in hand
        -: 1286:	{
        -: 1287:		//reduce number of cards in hand
    #####: 1288:		state->handCount[currentPlayer]--;
        -: 1289:	}
        -: 1290:	else
        -: 1291:	{
        -: 1292:		//replace discarded card with last card in hand
       61: 1293:		state->hand[currentPlayer][handPos] = state->hand[currentPlayer][(state->handCount[currentPlayer] - 1)];
        -: 1294:		//set last card to -1
       61: 1295:		state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1296:		//reduce number of cards in hand
       61: 1297:		state->handCount[currentPlayer]--;
        -: 1298:	}
        -: 1299:
       64: 1300:	return 0;
        -: 1301:}
        -: 1302:
      199: 1303:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1304:{
        -: 1305:	//Note: supplyPos is enum of choosen card
        -: 1306:
        -: 1307:	//check if supply pile is empty (0) or card is not used in game (-1)
      199: 1308:	if (supplyCount(supplyPos, state) < 1)
        -: 1309:	{
    #####: 1310:		return -1;
        -: 1311:	}
        -: 1312:
        -: 1313:	//added card for [whoseTurn] current player:
        -: 1314:	// toFlag = 0 : add to discard
        -: 1315:	// toFlag = 1 : add to deck
        -: 1316:	// toFlag = 2 : add to hand
        -: 1317:
      199: 1318:	if (toFlag == 1)
        -: 1319:	{
    #####: 1320:		state->deck[player][state->deckCount[player]] = supplyPos;
    #####: 1321:		state->deckCount[player]++;
        -: 1322:	}
      199: 1323:	else if (toFlag == 2)
        -: 1324:	{
    #####: 1325:		state->hand[player][state->handCount[player]] = supplyPos;
    #####: 1326:		state->handCount[player]++;
        -: 1327:	}
        -: 1328:	else
        -: 1329:	{
      199: 1330:		state->discard[player][state->discardCount[player]] = supplyPos;
      199: 1331:		state->discardCount[player]++;
        -: 1332:	}
        -: 1333:
        -: 1334:	//decrease number in supply pile
      199: 1335:	state->supplyCount[supplyPos]--;
        -: 1336:
      199: 1337:	return 0;
        -: 1338:}
        -: 1339:
      323: 1340:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1341:{
        -: 1342:	int i;
        -: 1343:
        -: 1344:	//reset coin count
      323: 1345:	state->coins = 0;
        -: 1346:
        -: 1347:	//add coins for each Treasure card in player's hand
     1905: 1348:	for (i = 0; i < state->handCount[player]; i++)
        -: 1349:	{
     1582: 1350:		if (state->hand[player][i] == copper)
        -: 1351:		{
      744: 1352:			state->coins += 1;
        -: 1353:		}
      838: 1354:		else if (state->hand[player][i] == silver)
        -: 1355:		{
       78: 1356:			state->coins += 2;
        -: 1357:		}
      760: 1358:		else if (state->hand[player][i] == gold)
        -: 1359:		{
    #####: 1360:			state->coins += 3;
        -: 1361:		}
        -: 1362:	}
        -: 1363:
        -: 1364:	//add bonus
      323: 1365:	state->coins += bonus;
        -: 1366:
      323: 1367:	return 0;
        -: 1368:}
        -: 1369:
        -: 1370:
        -: 1371://end of dominion.c
